SPI Master Driver
=================

:link_to_translation:`zh_CN:[中文]`

SPI Master driver is a program that controls {IDF_TARGET_NAME}'s General Purpose SPI (GP-SPI) peripheral(s) when it functions as a master.

.. only:: esp32

    .. note::

        SPI1 is not a GP-SPI. SPI Master driver also supports SPI1 but with quite a few limitations, see :ref:`spi_master_on_spi1_bus`.

For more hardware information about the GP-SPI peripheral(s), see **{IDF_TARGET_NAME} Technical Reference Manual** > **SPI Controller** [`PDF <{IDF_TARGET_TRM_EN_URL}#spi>`__].

Terminology
-----------

The terms used in relation to the SPI Master driver are given in the table below.

.. list-table::
   :widths: 30 70
   :header-rows: 1

   * - Term
     - Definition
   * - Host
     - The SPI controller peripheral inside {IDF_TARGET_NAME} initiates SPI transmissions over the bus and acts as an SPI Master.
   * - Device
     - SPI slave Device. An SPI bus may be connected to one or more Devices. Each Device shares the MOSI, MISO, and SCLK signals but is only active on the bus when the Host asserts the Device's individual CS line.
   * - Bus
     - A signal bus, common to all Devices connected to one Host. In general, a bus includes the following lines: MISO, MOSI, SCLK, one or more CS lines, and, optionally, QUADWP and QUADHD. So Devices are connected to the same lines, with the exception that each Device has its own CS line. Several Devices can also share one CS line if connected in a daisy-chain manner.
   * - MOSI
     - Master Out, Slave In, a.k.a. D. Data transmission from a Host to Device. Also data0 signal in Octal/OPI mode.
   * - MISO
     - Master In, Slave Out, a.k.a. Q. Data transmission from a Device to Host. Also data1 signal in Octal/OPI mode.
   * - SCLK
     - Serial Clock. The oscillating signal generated by a Host keeps the transmission of data bits in sync.
   * - CS
     - Chip Select. Allows a Host to select individual Device(s) connected to the bus in order to send or receive data.
   * - QUADWP
     - Write Protect signal. Used for 4-bit (qio/qout) transactions. Also for the data2 signal in Octal/OPI mode.
   * - QUADHD
     - Hold signal. Used for 4-bit (qio/qout) transactions. Also for the data3 signal in Octal/OPI mode.
   * - DATA4
     - Data4 signal in Octal/OPI mode.
   * - DATA5
     - Data5 signal in Octal/OPI mode.
   * - DATA6
     - Data6 signal in Octal/OPI mode.
   * - DATA7
     - Data7 signal in Octal/OPI mode.
   * - Assertion
     - The action of activating a line.
   * - De-assertion
     - The action of returning the line back to inactive (back to idle) status.
   * - Transaction
     - One instance of a Host asserting a CS line, transferring data to and from a Device, and de-asserting the CS line. Transactions are atomic, which means they can never be interrupted by another transaction.
   * - Launch Edge
     - Edge of the clock at which the source register **launches** the signal onto the line.
   * - Latch Edge
     - Edge of the clock at which the destination register **latches in** the signal.


Driver Features
---------------

The SPI Master driver governs the communications between Hosts and Devices. The driver supports the following features:

- Multi-threaded environments
- Transparent handling of DMA transfers while reading and writing data
- Automatic time-division multiplexing of data coming from different Devices on the same signal bus, see :ref:`spi_bus_lock`.

.. warning::

    The SPI Master driver allows multiple Devices to be connected on a same SPI bus (sharing a single {IDF_TARGET_NAME} SPI peripheral). As long as each Device is accessed by only one task, the driver is thread-safe. However, if multiple tasks try to access the same SPI Device, the driver is **not thread-safe**. In this case, it is recommended to either:

    - Refactor your application so that each SPI peripheral is only accessed by a single task at a time. You can use :cpp:member:`spi_bus_config_t::isr_cpu_id` to register the SPI ISR to the same core as SPI peripheral-related tasks to ensure thread safety.
    - Add a mutex lock around the shared Device using :c:macro:`xSemaphoreCreateMutex`.

.. toctree::
   :hidden:

   SPI Features <spi_features>

SPI Transactions
----------------

An SPI bus transaction consists of five phases which can be found in the table below. Any of these phases can be skipped.

{IDF_TARGET_ADDR_LEN:default="32", esp32="64"}

.. list-table::
   :widths: 30 70
   :header-rows: 1

   * - Phase
     - Description
   * - Command
     - In this phase, a command (0-16 bit) is written to the bus by the Host.
   * - Address
     - In this phase, an address (0-{IDF_TARGET_ADDR_LEN} bit) is transmitted over the bus by the Host.
   * - Dummy
     - This phase is configurable and is used to meet the timing requirements.
   * - Write
     - Host sends data to a Device. This data follows the optional command and address phases and is indistinguishable from them at the electrical level.
   * - Read
     - Device sends data to its Host.

.. todo::

   Add a package diagram.


The attributes of a transaction are determined by the bus configuration structure :cpp:type:`spi_bus_config_t`, Device configuration structure :cpp:type:`spi_device_interface_config_t`, and transaction configuration structure :cpp:type:`spi_transaction_t`.

An SPI Host can send full-duplex transactions, during which the Read and Write phases occur simultaneously. The total transaction length is determined by the sum of the following members:

- :cpp:member:`spi_device_interface_config_t::command_bits`
- :cpp:member:`spi_device_interface_config_t::address_bits`
- :cpp:member:`spi_transaction_t::length`

While the member :cpp:member:`spi_transaction_t::rxlength` only determines the length of data received into the buffer.

In half-duplex transactions, the Read and Write phases are not simultaneous (one direction at a time). The lengths of the Write and Read phases are determined by :cpp:member:`spi_transaction_t::length` and :cpp:member:`spi_transaction_t::rxlength` respectively.

The Command and Address phases are optional, as not every SPI Device requires a command and/or address. This is reflected in the Device's configuration: if :cpp:member:`spi_device_interface_config_t::command_bits` and/or :cpp:member:`spi_device_interface_config_t::address_bits` are set to zero, no Command or Address phase will occur.

The Read and Write phases can also be optional, as not every transaction requires both writing and reading data. If :cpp:member:`spi_transaction_t::rx_buffer` is ``NULL`` and :c:macro:`SPI_TRANS_USE_RXDATA` is not set, the Read phase is skipped. If :cpp:member:`spi_transaction_t::tx_buffer` is ``NULL`` and :c:macro:`SPI_TRANS_USE_TXDATA` is not set, the Write phase is skipped.

The driver supports two types of transactions: interrupt transactions and polling transactions. The programmer can choose to use a different transaction type per Device. If your Device requires both transaction types, see :ref:`mixed_transactions`.


.. _interrupt_transactions:

Interrupt Transactions
^^^^^^^^^^^^^^^^^^^^^^

Interrupt transactions blocks the transaction routine until the transaction completes, thus allowing the CPU to run other tasks.

An application task can queue multiple transactions, and the driver automatically handles them one by one in the interrupt service routine (ISR). It allows the task to switch to other procedures until all the transactions are complete.


.. _polling_transactions:

Polling Transactions
^^^^^^^^^^^^^^^^^^^^

Polling transactions do not use interrupts. The routine keeps polling the SPI Host's status bit until the transaction is finished.

All the tasks that use interrupt transactions can be blocked by the queue. At this point, they need to wait for the ISR to run twice before the transaction is finished. Polling transactions save time otherwise spent on queue handling and context switching, which results in smaller transaction duration. The disadvantage is that the CPU is busy while these transactions are in progress.

The :cpp:func:`spi_device_polling_end` routine needs an overhead of at least 1 µs to unblock other tasks when the transaction is finished. It is strongly recommended to wrap a series of polling transactions using the functions :cpp:func:`spi_device_acquire_bus` and :cpp:func:`spi_device_release_bus` to avoid the overhead. For more information, see :ref:`bus_acquiring`.

.. _transaction-line-mode:

Transaction Line Mode
^^^^^^^^^^^^^^^^^^^^^

Supported line modes for {IDF_TARGET_NAME} are listed as follows, to make use of these modes, set the member ``flags`` in the struct :cpp:type:`spi_transaction_t` as shown in the ``Transaction Flag`` column. If you want to check if corresponding IO pins are set or not, set the member ``flags`` in the :cpp:type:`spi_bus_config_t` as shown in the ``Bus IO setting Flag`` column.


.. only:: not SOC_SPI_SUPPORT_OCT

    .. list-table::
       :widths: 30 40 40 40 50 50
       :header-rows: 1

       * - Mode name
         - Command Line Width
         - Address Line Width
         - Data Line Width
         - Transaction Flag
         - Bus IO Setting Flag
       * - Normal SPI
         - 1
         - 1
         - 1
         - 0
         - 0
       * - Dual Output
         - 1
         - 1
         - 2
         - SPI_TRANS_MODE_DIO
         - SPICOMMON_BUSFLAG_DUAL
       * - Dual I/O
         - 1
         - 2
         - 2
         - SPI_TRANS_MODE_DIO
           SPI_TRANS_MULTILINE_ADDR
         - SPICOMMON_BUSFLAG_DUAL
       * - Quad Output
         - 1
         - 1
         - 4
         - SPI_TRANS_MODE_QIO
         - SPICOMMON_BUSFLAG_QUAD
       * - Quad I/O
         - 1
         - 4
         - 4
         - SPI_TRANS_MODE_QIO
           SPI_TRANS_MULTILINE_ADDR
         - SPICOMMON_BUSFLAG_QUAD

.. only:: SOC_SPI_SUPPORT_OCT

    .. list-table::
       :widths: 30 40 40 40 50 50
       :header-rows: 1

       * - Mode name
         - Command Line Width
         - Address Line Width
         - Data Line Width
         - Transaction Flag
         - Bus IO Setting Flag
       * - Normal SPI
         - 1
         - 1
         - 1
         - 0
         - 0
       * - Dual Output
         - 1
         - 1
         - 2
         - SPI_TRANS_MODE_DIO
         - SPICOMMON_BUSFLAG_DUAL
       * - Dual I/O
         - 1
         - 2
         - 2
         - SPI_TRANS_MODE_DIO
           SPI_TRANS_MULTILINE_ADDR
         - SPICOMMON_BUSFLAG_DUAL
       * - Quad Output
         - 1
         - 1
         - 4
         - SPI_TRANS_MODE_QIO
         - SPICOMMON_BUSFLAG_QUAD
       * - Quad I/O
         - 1
         - 4
         - 4
         - SPI_TRANS_MODE_QIO
           SPI_TRANS_MULTILINE_ADDR
         - SPICOMMON_BUSFLAG_QUAD
       * - Octal Output
         - 1
         - 1
         - 8
         - SPI_TRANS_MODE_OCT
         - SPICOMMON_BUSFLAG_OCTAL
       * - OPI
         - 8
         - 8
         - 8
         - SPI_TRANS_MODE_OCT
           SPI_TRANS_MULTILINE_ADDR
           SPI_TRANS_MULTILINE_CMD
         - SPICOMMON_BUSFLAG_OCTAL

Command and Address Phases
^^^^^^^^^^^^^^^^^^^^^^^^^^

During the Command and Address phases, the members :cpp:member:`spi_transaction_t::cmd` and :cpp:member:`spi_transaction_t::addr` are sent to the bus, nothing is read at this time. The default lengths of the Command and Address phases are set in :cpp:type:`spi_device_interface_config_t` by calling :cpp:func:`spi_bus_add_device`. If the flags :c:macro:`SPI_TRANS_VARIABLE_CMD` and :c:macro:`SPI_TRANS_VARIABLE_ADDR` in the member :cpp:member:`spi_transaction_t::flags` are not set, the driver automatically sets the length of these phases to default values during Device initialization.

If the lengths of the Command and Address phases need to be variable, declare the struct :cpp:type:`spi_transaction_ext_t`, set the flags :c:macro:`SPI_TRANS_VARIABLE_CMD` and/or :c:macro:`SPI_TRANS_VARIABLE_ADDR` in the member :cpp:member:`spi_transaction_ext_t::base` and configure the rest of base as usual. Then the length of each phase will be equal to :cpp:member:`spi_transaction_ext_t::command_bits` and :cpp:member:`spi_transaction_ext_t::address_bits` set in the struct :cpp:type:`spi_transaction_ext_t`.

If the Command and Address phase need to have the same number of lines as the data phase, you need to set ``SPI_TRANS_MULTILINE_CMD`` and/or ``SPI_TRANS_MULTILINE_ADDR`` to the ``flags`` member in the struct :cpp:type:`spi_transaction_t`. Also see :ref:`transaction-line-mode`.


Write and Read Phases
^^^^^^^^^^^^^^^^^^^^^

Normally, the data that needs to be transferred to or from a Device is read from or written to a chunk of memory indicated by the members :cpp:member:`spi_transaction_t::rx_buffer` and :cpp:member:`spi_transaction_t::tx_buffer`. If DMA is enabled for transfers, the buffers are required to be:

  1. Allocated in DMA-capable internal memory (MALLOC_CAP_DMA), see :ref:`DMA-Capable Memory <dma-capable-memory>`.
  2. 32-bit aligned (starting from a 32-bit boundary and having a length of multiples of 4 bytes).

If these requirements are not satisfied, the transaction efficiency will be affected due to the allocation and copying of temporary buffers.

If using more than one data line to transmit, please set ``SPI_DEVICE_HALFDUPLEX`` flag for the member ``flags`` in the struct :cpp:type:`spi_device_interface_config_t`. And the member ``flags`` in the struct :cpp:type:`spi_transaction_t` should be set as described in :ref:`transaction-line-mode`.

.. only:: esp32

    .. note::

        Half-duplex transactions with both Read and Write phases are not supported when using DMA. For details and workarounds, see :ref:`spi_known_issues`.

.. only:: not SOC_SPI_HD_BOTH_INOUT_SUPPORTED

    .. note::

        Half-duplex transactions with both Read and Write phases are not supported. Please use full duplex mode.

.. _bus_acquiring:

Bus Acquiring
^^^^^^^^^^^^^

Sometimes you might want to send SPI transactions exclusively and continuously so that it takes as little time as possible. For this, you can use bus acquiring, which helps to suspend transactions (both polling or interrupt) to other Devices until the bus is released. To acquire and release a bus, use the functions :cpp:func:`spi_device_acquire_bus` and :cpp:func:`spi_device_release_bus`.


Driver Usage
------------

.. todo::

   Organize the Driver Usage into subsections that will reflect the general user experience of the users, e.g.,

   Configuration

   Add stuff about the configuration API here, the various options in configuration (e.g., configure for interrupt vs. polling), and optional configuration

   Transactions

   Describe how to execute a normal transaction (i.e., where data is larger than 32 bits). Describe how to configure between big and little-endian.

   - Add a sub-sub section on how to optimize when transmitting less than 32 bits
   - Add a sub-sub section on how to transmit mixed transactions to the same Device


- Initialize an SPI bus by calling the function :cpp:func:`spi_bus_initialize`. Make sure to set the correct I/O pins in the struct :cpp:type:`spi_bus_config_t`. Set the signals that are not needed to ``-1``.

- Register a Device connected to the bus with the driver by calling the function :cpp:func:`spi_bus_add_device`. Make sure to configure any timing requirements the Device might need with the parameter ``dev_config``. You should now have obtained the Device's handle which will be used when sending a transaction to it.

- To interact with the Device, fill one or more :cpp:type:`spi_transaction_t` structs with any transaction parameters required. Then send the structs either using a polling transaction or an interrupt transaction:

    - :ref:`Interrupt <interrupt_transactions>`
        Either queue all transactions by calling the function :cpp:func:`spi_device_queue_trans` and, at a later time, query the result using the function :cpp:func:`spi_device_get_trans_result`, or handle all requests synchronously by feeding them into :cpp:func:`spi_device_transmit`.

    - :ref:`Polling <polling_transactions>`
        Call the function :cpp:func:`spi_device_polling_transmit` to send polling transactions. Alternatively, if you want to insert something in between, send the transactions by using :cpp:func:`spi_device_polling_start` and :cpp:func:`spi_device_polling_end`.

- (Optional) To perform back-to-back transactions with a Device, call the function :cpp:func:`spi_device_acquire_bus` before sending transactions and :cpp:func:`spi_device_release_bus` after the transactions have been sent.

- (Optional) To remove a certain Device from the bus, call :cpp:func:`spi_bus_remove_device` with the Device handle as an argument.

- (Optional) To remove the driver from the bus, make sure no more devices are attached and call :cpp:func:`spi_bus_free`.

The example code for the SPI Master driver can be found in the :example:`peripherals/spi_master` directory of ESP-IDF examples.


Transactions with Data Not Exceeding 32 Bits
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When the transaction data size is equal to or less than 32 bits, it will be sub-optimal to allocate a buffer for the data. The data can be directly stored in the transaction struct instead. For transmitted data, it can be achieved by using the :cpp:member:`spi_transaction_t::tx_data` member and setting the :c:macro:`SPI_TRANS_USE_TXDATA` flag on the transmission. For received data, use :cpp:member:`spi_transaction_t::rx_data` and set :c:macro:`SPI_TRANS_USE_RXDATA`. In both cases, do not touch the :cpp:member:`spi_transaction_t::tx_buffer` or :cpp:member:`spi_transaction_t::rx_buffer` members, because they use the same memory locations as :cpp:member:`spi_transaction_t::tx_data` and :cpp:member:`spi_transaction_t::rx_data`.


Transactions with Integers Other than ``uint8_t``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

An SPI Host reads and writes data into memory byte by byte. By default, data is sent with the most significant bit (MSB) first, as LSB is first used in rare cases. If a value of fewer than 8 bits needs to be sent, the bits should be written into memory in the MSB first manner.

For example, if ``0b00010`` needs to be sent, it should be written into a ``uint8_t`` variable, and the length for reading should be set to 5 bits. The Device will still receive 8 bits with 3 additional "random" bits, so the reading must be performed correctly.

On top of that, {IDF_TARGET_NAME} is a little-endian chip, which means that the least significant byte of ``uint16_t`` and ``uint32_t`` variables is stored at the smallest address. Hence, if ``uint16_t`` is stored in memory, bits [7:0] are sent first, followed by bits [15:8].

For cases when the data to be transmitted has a size differing from ``uint8_t`` arrays, the following macros can be used to transform data to the format that can be sent by the SPI driver directly:

- :c:macro:`SPI_SWAP_DATA_TX` for data to be transmitted
- :c:macro:`SPI_SWAP_DATA_RX` for data received


.. _mixed_transactions:

Notes on Sending Mixed Transactions to the Same Device
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To reduce coding complexity, send only one type of transaction (interrupt or polling) to one Device. However, you still can send both interrupt and polling transactions alternately. The notes below explain how to do this.

The polling transactions should be initiated only after all the polling and interrupt transactions are finished.

Since an unfinished polling transaction blocks other transactions, please do not forget to call the function :cpp:func:`spi_device_polling_end` after :cpp:func:`spi_device_polling_start` to allow other transactions or to allow other Devices to use the bus. Remember that if there is no need to switch to other tasks during your polling transaction, you can initiate a transaction with :cpp:func:`spi_device_polling_transmit` so that it will be ended automatically.

In-flight polling transactions are disturbed by the ISR operation to accommodate interrupt transactions. Always make sure that all the interrupt transactions sent to the ISR are finished before you call :cpp:func:`spi_device_polling_start`. To do that, you can keep calling :cpp:func:`spi_device_get_trans_result` until all the transactions are returned.

To have better control of the calling sequence of functions, send mixed transactions to the same Device only within a single task.

.. only:: esp32

    .. _spi_master_on_spi1_bus:

    Notes on Using the SPI Master Driver on SPI1 Bus
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    .. note::

        Though the :ref:`spi_bus_lock` feature makes it possible to use SPI Master driver on the SPI1 bus, it is still tricky and needs a lot of special treatment. It is a feature for advanced developers.

    To use SPI Master driver on SPI1 bus, you have to take care of two problems:

    1. The code and data should be in the internal memory when the driver is operating on SPI1 bus.

       SPI1 bus is shared among Devices and the cache for data (code) in the flash as well as the PSRAM. The cache should be disabled when other drivers are operating on the SPI1 bus. Hence the data (code) in the flash as well as the PSRAM cannot be fetched while the driver acquires the SPI1 bus by:

       - Explicit bus acquiring between :cpp:func:`spi_device_acquire_bus` and :cpp:func:`spi_device_release_bus`.
       - Implicit bus acquiring between :cpp:func:`spi_device_polling_start` and :cpp:func:`spi_device_polling_end` (or inside :cpp:func:`spi_device_polling_transmit`).

       During the time above, all other tasks and most ISRs will be disabled (see :ref:`iram-safe-interrupt-handlers`). Application code and data used by the current task should be placed in internal memory (DRAM or IRAM), or already in the ROM. Access to external memory (flash code, const data in the flash, and static/heap data in the PSRAM) will cause a ``Cache disabled but cached memory region accessed`` exception. For differences between IRAM, DRAM, and flash cache, please refer to the :ref:`application memory layout <memory-layout>` documentation.

       To place functions into the IRAM, you can either:

       1. Add ``IRAM_ATTR`` (include ``esp_attr.h``) to the function like:

              IRAM_ATTR void foo(void) { }

          Please note that when a function is inlined, it will follow its caller's segment, and the attribute will not take effect. You may need to use ``NOLINE_ATTR`` to avoid this. Please also note that the compiler may transform some code into a lookup table in the const data, so ``noflash_text`` is not safe.

       2. Use the ``noflash`` placement in the ``linker.lf``. See more in :doc:`../../api-guides/linker-script-generation`. Please note that the compiler may transform some code into a lookup table in the const data, so ``noflash_text`` is not safe.

       Please do take care that the optimization level may affect the compiler behavior of inline, or transform some code into a lookup table in the const data, etc.

       To place data into the DRAM, you can either:

       1. Add ``DRAM_ATTR`` (include ``esp_attr.h``) to the data definition like:

              DRAM_ATTR int g_foo = 3;

       2. Use the ``noflash`` placement in the linker.lf. See more in :doc:`../../api-guides/linker-script-generation`.

    Please also see the example :example:`peripherals/spi_master/hd_eeprom`.


GPIO Matrix and IO_MUX
^^^^^^^^^^^^^^^^^^^^^^

.. only:: esp32

    Most of ESP32's peripheral signals have a direct connection to their dedicated IO_MUX pins. However, the signals can also be routed to any other available pins using the less direct GPIO matrix. If at least one signal is routed through the GPIO matrix, then all signals will be routed through it.

    The GPIO matrix introduces flexibility of routing but also brings the following disadvantages:

    - Increases the input delay of the MISO signal, which makes MISO setup time violations more likely. If SPI needs to operate at high speeds, use dedicated IO_MUX pins.
    - Allows signals with clock frequencies only up to 40 MHz, as opposed to 80 MHz if IO_MUX pins are used.

    .. note::

        For more details about the influence of the MISO input delay on the maximum clock frequency, see :ref:`timing_considerations`.

    The IO_MUX pins for SPI buses are given below.

    .. list-table::
       :widths: 40 20 20
       :header-rows: 1

       * - Pin Name
         - SPI 2 (GPIO Number)
         - SPI 3 (GPIO Number)
       * - CS0 [1]_
         - 15
         - 5
       * - SCLK
         - 14
         - 18
       * - MISO
         - 12
         - 19
       * - MOSI
         - 13
         - 23
       * - QUADWP
         - 2
         - 22
       * - QUADHD
         - 4
         - 21

.. only:: not esp32

    {IDF_TARGET_SPI2_IOMUX_PIN_CS:default="N/A",   esp32s2="10", esp32s3="10", esp32c2="10", esp32c3="10", esp32c6="16", esp32h2="1", esp32p4="7",  esp32c5="12"}
    {IDF_TARGET_SPI2_IOMUX_PIN_CLK:default="N/A",  esp32s2="12", esp32s3="12", esp32c2="6",  esp32c3="6",  esp32c6="6",  esp32h2="4", esp32p4="9",  esp32c5="6"}
    {IDF_TARGET_SPI2_IOMUX_PIN_MOSI:default="N/A", esp32s2="11"  esp32s3="11", esp32c2="7"   esp32c3="7",  esp32c6="7",  esp32h2="5", esp32p4="8",  esp32c5="7"}
    {IDF_TARGET_SPI2_IOMUX_PIN_MISO:default="N/A", esp32s2="13"  esp32s3="13", esp32c2="2"   esp32c3="2",  esp32c6="2",  esp32h2="0", esp32p4="10", esp32c5="2"}
    {IDF_TARGET_SPI2_IOMUX_PIN_HD:default="N/A",   esp32s2="9"   esp32s3="9",  esp32c2="4"   esp32c3="4",  esp32c6="4",  esp32h2="3", esp32p4="6",  esp32c5="4"}
    {IDF_TARGET_SPI2_IOMUX_PIN_WP:default="N/A",   esp32s2="14"  esp32s3="14", esp32c2="5"   esp32c3="5",  esp32c6="5",  esp32h2="2", esp32p4="11", esp32c5="5"}

    Most of the chip's peripheral signals have a direct connection to their dedicated IO_MUX pins. However, the signals can also be routed to any other available pins using the less direct GPIO matrix. If at least one signal is routed through the GPIO matrix, then all signals will be routed through it.

    When an SPI Host is set to 80 MHz or lower frequencies, routing SPI pins via the GPIO matrix will behave the same compared to routing them via IOMUX.

    The IO_MUX pins for SPI buses are given below.

    .. list-table::
       :widths: 40 30
       :header-rows: 1

       * - Pin Name
         - GPIO Number (SPI2)
       * - CS0 [1]_
         - {IDF_TARGET_SPI2_IOMUX_PIN_CS}
       * - SCLK
         - {IDF_TARGET_SPI2_IOMUX_PIN_CLK}
       * - MISO
         - {IDF_TARGET_SPI2_IOMUX_PIN_MISO}
       * - MOSI
         - {IDF_TARGET_SPI2_IOMUX_PIN_MOSI}
       * - QUADWP
         - {IDF_TARGET_SPI2_IOMUX_PIN_WP}
       * - QUADHD
         - {IDF_TARGET_SPI2_IOMUX_PIN_HD}

.. [1] Only the first Device attached to the bus can use the CS0 pin.

.. _speed_considerations:

Transfer Speed Considerations
-----------------------------

There are three factors limiting the transfer speed:

- Transaction interval
- SPI clock frequency
- Cache miss of SPI functions, including callbacks

The main parameter that determines the transfer speed for large transactions is clock frequency. For multiple small transactions, the transfer speed is mostly determined by the length of transaction intervals.


Transaction Duration
^^^^^^^^^^^^^^^^^^^^

{IDF_TARGET_TRANS_TIME_INTR_DMA:default="N/A", esp32="28", esp32s2="23", esp32c3="28", esp32s3="26", esp32c2="42", esp32c6="34", esp32h2="58", esp32c5="27"}
{IDF_TARGET_TRANS_TIME_POLL_DMA:default="N/A", esp32="10", esp32s2="9",  esp32c3="10", esp32s3="11", esp32c2="17", esp32c6="17", esp32h2="28", esp32c5="16"}
{IDF_TARGET_TRANS_TIME_INTR_CPU:default="N/A", esp32="25", esp32s2="22", esp32c3="27", esp32s3="24", esp32c2="40", esp32c6="32", esp32h2="54", esp32c5="24"}
{IDF_TARGET_TRANS_TIME_POLL_CPU:default="N/A", esp32="8",  esp32s2="8",  esp32c3="9",  esp32s3="9",  esp32c2="15", esp32c6="15", esp32h2="24", esp32c5="13"}

Transaction duration includes setting up SPI peripheral registers, copying data to FIFOs or setting up DMA links, and the time for SPI transactions.

Interrupt transactions allow appending extra overhead to accommodate the cost of FreeRTOS queues and the time needed for switching between tasks and the ISR.

For **interrupt transactions**, the CPU can switch to other tasks when a transaction is in progress. This saves CPU time but increases the transaction duration. See :ref:`interrupt_transactions`. For **polling transactions**, it does not block the task but allows to do polling when the transaction is in progress. For more information, see :ref:`polling_transactions`.

If DMA is enabled, setting up the linked list requires about 2 µs per transaction. When a master is transferring data, it automatically reads the data from the linked list. If DMA is not enabled, the CPU has to write and read each byte from the FIFO by itself. Usually, this is faster than 2 µs, but the transaction length is limited to 64 bytes for both write and read.

The typical transaction duration for one byte of data is given below.

- Interrupt Transaction via DMA: {IDF_TARGET_TRANS_TIME_INTR_DMA} µs.
- Interrupt Transaction via CPU: {IDF_TARGET_TRANS_TIME_INTR_CPU} µs.
- Polling Transaction via DMA: {IDF_TARGET_TRANS_TIME_POLL_DMA} µs.
- Polling Transaction via CPU: {IDF_TARGET_TRANS_TIME_POLL_CPU} µs.

Note that these data are tested with :ref:`CONFIG_SPI_MASTER_ISR_IN_IRAM` enabled. SPI transaction related code are placed in the internal memory. If this option is turned off (for example, for internal memory optimization), the transaction duration may be affected.

SPI Clock Frequency
^^^^^^^^^^^^^^^^^^^

The clock source of the GPSPI peripherals can be selected by setting :cpp:member:`spi_device_handle_t::cfg::clock_source`. You can refer to :cpp:type:`spi_clock_source_t` to know the supported clock sources.

By default driver sets :cpp:member:`spi_device_handle_t::cfg::clock_source` to ``SPI_CLK_SRC_DEFAULT``. This usually stands for the highest frequency among GPSPI clock sources. Its value is different among chips.

The actual clock frequency of a Device may not be exactly equal to the number you set, it is re-calculated by the driver to the nearest hardware-compatible number, and not larger than the clock frequency of the clock source. You can call :cpp:func:`spi_device_get_actual_freq` to know the actual frequency computed by the driver.

The theoretical maximum transfer speed of the Write or Read phase can be calculated according to the table below:

.. only:: not SOC_SPI_SUPPORT_OCT

    .. list-table::
       :widths: 40 30
       :header-rows: 1

       * - Line Width of Write/Read phase
         - Speed (Bps)
       * - 1-Line
         - *SPI Frequency / 8*
       * - 2-Line
         - *SPI Frequency / 4*
       * - 4-Line
         - *SPI Frequency / 2*

.. only:: SOC_SPI_SUPPORT_OCT

    .. list-table::
       :widths: 40 30
       :header-rows: 1

       * - Line Width of Write/Read phase
         - Speed (Bps)
       * - 1-Line
         - *SPI Frequency / 8*
       * - 2-Line
         - *SPI Frequency / 4*
       * - 4-Line
         - *SPI Frequency / 2*
       * - 8-Line
         - *SPI Frequency*

The transfer speed calculation of other phases (Command, Address, Dummy) is similar.

.. only:: esp32

    If the clock frequency is too high, the use of some functions might be limited. See :ref:`timing_considerations`.

Cache Missing
^^^^^^^^^^^^^

The default config puts only the ISR into the IRAM. Other SPI-related functions, including the driver itself and the callback, might suffer from cache misses and need to wait until the code is read from flash. Select :ref:`CONFIG_SPI_MASTER_IN_IRAM` to put the whole SPI driver into IRAM and put the entire callback(s) and its callee functions into IRAM to prevent cache missing.

.. note::

    SPI driver implementation is based on FreeRTOS APIs, to use :ref:`CONFIG_SPI_MASTER_IN_IRAM`, you should not enable :ref:`CONFIG_FREERTOS_PLACE_FUNCTIONS_INTO_FLASH`.

For an interrupt transaction, the overall cost is **20+8n/Fspi[MHz]** [µs] for n bytes transferred in one transaction. Hence, the transferring speed is: **n/(20+8n/Fspi)**. An example of transferring speed at 8 MHz clock speed is given in the following table.

.. list-table::
   :widths: 30 45 40 30 30
   :header-rows: 1

   * - Frequency (MHz)
     - Transaction Interval (µs)
     - Transaction Length (bytes)
     - Total Time (µs)
     - Total Speed (KBps)
   * - 8
     - 25
     - 1
     - 26
     - 38.5
   * - 8
     - 25
     - 8
     - 33
     - 242.4
   * - 8
     - 25
     - 16
     - 41
     - 490.2
   * - 8
     - 25
     - 64
     - 89
     - 719.1
   * - 8
     - 25
     - 128
     - 153
     - 836.6

When a transaction length is short, the cost of the transaction interval is high. If possible, try to squash several short transactions into one transaction to achieve a higher transfer speed.

Please note that the ISR is disabled during flash operation by default. To keep sending transactions during flash operations, enable :ref:`CONFIG_SPI_MASTER_ISR_IN_IRAM` and set :c:macro:`ESP_INTR_FLAG_IRAM` in the member :cpp:member:`spi_bus_config_t::intr_flags`. In this case, all the transactions queued before starting flash operations are handled by the ISR in parallel. Also note that the callback of each Device and their ``callee`` functions should be in IRAM, or your callback will crash due to cache missing. For more details, see :ref:`iram-safe-interrupt-handlers`.


.. only:: esp32

    .. _timing_considerations:

    Timing Considerations
    ---------------------

    As shown in the figure below, there is a delay on the MISO line after the SCLK launch edge and before the signal is latched by the internal register. As a result, the MISO pin setup time is the limiting factor for the SPI clock speed. When the delay is too long, the setup slack is < 0, which means the setup timing requirement is violated and the reading might be incorrect.

    .. image:: /../_static/spi_miso.png
        :scale: 40 %
        :align: center

    .. wavedrom:: /../_static/diagrams/spi/miso_timing_waveform.json

    The maximum allowed frequency is dependent on:

    - :cpp:member:`spi_device_interface_config_t::input_delay_ns` - maximum data valid time on the MISO bus after a clock cycle on SCLK starts
    - If the IO_MUX pin or the GPIO Matrix is used

    When the GPIO matrix is used, the maximum allowed frequency is reduced to about 33 ~ 77% in comparison to the existing **input delay**. To retain a higher frequency, you have to use the IO_MUX pins or the **dummy bit workaround**. You can obtain the maximum reading frequency of the master by using the function :cpp:func:`spi_get_freq_limit`.

    .. _dummy_bit_workaround:

    **Dummy bit workaround**: Dummy clocks, during which the Host does not read data, can be inserted before the Read phase begins. The Device still sees the dummy clocks and sends out data, but the Host does not read until the Read phase comes. This compensates for the lack of the MISO setup time required by the Host and allows the Host to do reading at a higher frequency.

    In the ideal case, if the Device is so fast that the input delay is shorter than an APB clock cycle - 12.5 ns - the maximum frequency at which the Host can read (or read and write) in different conditions is as follows:

    .. list-table::
       :widths: 30 45 40 30
       :header-rows: 1

       * - Frequency Limit (MHz)
         - Frequency Limit (MHz)
         - Dummy Bits Used by Driver
         - Comments
       * - GPIO Matrix
         - IO_MUX Pins
         -
         -
       * - 26.6
         - 80
         - No
         -
       * - 40
         - --
         - Yes
         - Half-duplex, no DMA allowed

    If the Host only writes data, the **dummy bit workaround** and the frequency check can be disabled by setting the bit ``SPI_DEVICE_NO_DUMMY`` in the member :cpp:member:`spi_device_interface_config_t::flags`. When disabled, the output frequency can be 80 MHz, even if the GPIO matrix is used.

    :cpp:member:`spi_device_interface_config_t::flags`

    The SPI Master driver still works even if the :cpp:member:`spi_device_interface_config_t::input_delay_ns` in the structure :cpp:type:`spi_device_interface_config_t` is set to 0. However, setting an accurate value helps to:

    - Calculate the frequency limit for full-duplex transactions
    - Compensate the timing correctly with dummy bits for half-duplex transactions

    You can approximate the maximum data valid time after the launch edge of SPI clocks by checking the statistics in the AC characteristics chapter of your Device's specification or measure the time using an oscilloscope or logic analyzer.

    Please note that the actual PCB layout design and excessive loads may increase the input delay. It means that non-optimal wiring and/or a load capacitor on the bus will most likely lead to input delay values exceeding the values given in the Device specification or measured while the bus is floating.

    Some typical delay values are shown in the following table. These data are retrieved when the slave Device is on a different physical chip.

    .. list-table::
       :widths: 40 20
       :header-rows: 1

       * - Device
         - Input Delay (ns)
       * - Ideal Device
         - 0
       * - ESP32 slave using IO_MUX
         - 50
       * - ESP32 slave using GPIO_MATRIX
         - 75

    The MISO path delay (valid time) consists of a slave's **input delay** plus the master's **GPIO matrix delay**. The delay determines the above frequency limit for full-duplex transfers. Once exceeding, full-duplex transfers will not work as well as the half-duplex transactions that use dummy bits. The frequency limit is:

        *Freq limit [MHz] = 80 / (floor(MISO delay[ns]/12.5) + 1)*

    The figure below shows the relationship between frequency limit and input delay. Two extra APB clock cycle periods should be added to the MISO delay if the master uses the GPIO matrix.

    .. image:: /../_static/spi_master_freq_tv.png

    Corresponding frequency limits for different Devices with different **input delay** times are shown in the table below.

    When the master is IO_MUX (0 ns):

    .. list-table::
       :widths: 20 40 40
       :header-rows: 1

       * - Input Delay (ns)
         - MISO Path Delay (ns)
         - Freq. Limit (MHz)
       * - 0
         - 0
         - 80
       * - 50
         - 50
         - 16
       * - 75
         - 75
         - 11.43

    When the master is GPIO_MATRIX (25 ns):

    .. list-table::
       :widths: 20 40 40
       :header-rows: 1

       * - Input Delay (ns)
         - MISO Path Delay (ns)
         - Freq. Limit (MHz)
       * - 0
         - 25
         - 26.67
       * - 50
         - 75
         - 11.43
       * - 75
         - 100
         - 8.89


    .. _spi_known_issues:

    Known Issues
    ------------

    1. Half-duplex transactions are not compatible with DMA when both the Write and Read phases are used.

        If such transactions are required, you have to use one of the alternative solutions:

        1. Use full-duplex transactions instead.
        2. Disable DMA by setting the bus initialization function's last parameter to 0 as follows:
            ``ret=spi_bus_initialize(VSPI_HOST, &buscfg, 0);``

        This can prohibit you from transmitting and receiving data longer than 64 bytes.
        3. Try using the command and address fields to replace the Write phase.

    2. Full-duplex transactions are not compatible with the **dummy bit workaround**, hence the frequency is limited. See :ref:`dummy bit speed-up workaround <dummy_bit_workaround>`.

    3. ``dummy_bits`` in :cpp:type:`spi_device_interface_config_t` and :cpp:type:`spi_transaction_ext_t` are not available when SPI Read and Write phases are both enabled (regardless of full duplex or half duplex mode).

    4. ``cs_ena_pretrans`` is not compatible with the Command and Address phases of full-duplex transactions.


Application Example
-------------------

The code example for using the SPI master half duplex mode to read/write an AT93C46D EEPROM (8-bit mode) can be found in the :example:`peripherals/spi_master/hd_eeprom` directory of ESP-IDF examples.

The code example for using the SPI master full duplex mode to drive a SPI_LCD (e.g. ST7789V or ILI9341) can be found in the :example:`peripherals/spi_master/lcd` directory of ESP-IDF examples.

API Reference - SPI Common
--------------------------

.. include-build-file:: inc/spi_types.inc
.. include-build-file:: inc/spi_common.inc


API Reference - SPI Master
--------------------------

.. include-build-file:: inc/spi_master.inc
