Host-Based Security Workflows
=============================

{IDF_TARGET_CRYPT_CNT:default="SPI_BOOT_CRYPT_CNT",esp32="FLASH_CRYPT_CNT"}
{IDF_TARGET_CRYPT_CNT_MAX_VAL:default="7",esp32="127"}
{IDF_TARGET_SBV2_DEFAULT_SCHEME:default="RSA", esp32c2="ECDSA (V2)"}

Introduction
------------

It is recommended to have an uninterrupted power supply while enabling security features on ESP32 SoCs. Power failures during the secure manufacturing process could cause issues that are hard to debug and, in some cases, may cause permanent boot-up failures.

This guide highlights an approach where security features are enabled with the assistance of an external host machine. Security workflows are broken down into various stages and key material is generated on the host machine; thus, allowing greater recovery chances in case of power or other failures. It also offers better timings for secure manufacturing, e.g., in the case of encryption of firmware on the host machine vs. on the device.


Goals
-----

#. Simplify the traditional workflow with stepwise instructions.
#. Design a more flexible workflow as compared to the traditional firmware-based workflow.
#. Improve reliability by dividing the workflow into small operations.
#. Eliminate dependency on :ref:`second-stage-bootloader` (firmware bootloader).

Pre-requisite
-------------

* ``esptool``: Please make sure the ``esptool`` has been installed. It can be installed by running:

.. code:: bash

   pip install esptool

Scope
-----

* :ref:`enable-flash-encryption-and-secure-boot-v2-externally`
* :ref:`enable-flash-encryption-externally`
* :ref:`enable-secure-boot-v2-externally`

Security Workflows
------------------

.. _enable-flash-encryption-and-secure-boot-v2-externally:

Enable Flash Encryption and Secure Boot V2 Externally
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. important::

    It is recommended to enable both Flash Encryption and Secure Boot V2 for a production use case.

When enabling the Flash Encryption and Secure Boot V2 externally we need to enable them in the following order:

#. Enable the Flash Encryption feature by following the steps listed in :ref:`enable-flash-encryption-externally`.
#. Enable the Secure Boot V2 feature by following the steps listed in :ref:`enable-secure-boot-v2-externally`.

The reason for this order is as follows:

To enable the Secure Boot (SB) V2, it is necessary to keep the SB V2 key readable. To protect the key's readability, the write protection for RD_DIS (ESP_EFUSE_WR_DIS_RD_DIS) is applied. However, this action poses a challenge when attempting to enable Flash Encryption, as the Flash Encryption (FE) key needs to remain unreadable. This conflict arises because the RD_DIS is already write-protected, making it impossible to read protect the FE key.

.. _enable-flash-encryption-externally:

Enable Flash Encryption Externally
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In this case, all the eFuses related to flash encryption are written with help of the espefuse tool. More details about flash encryption can be found in the :doc:`Flash Encryption Guide </security/flash-encryption>`

1. Ensure that you have an {IDF_TARGET_NAME} device with default flash encryption eFuse settings as shown in :ref:`flash-encryption-efuse`.

    See how to check :ref:`flash-encryption-status`.

  In this case, the flash on the chip must be erased and flash encryption must not be enabled. The chip can be erased by running:

  .. code:: bash

     esptool.py --port PORT erase_flash

2. Generate a flash encryption key.

  A random flash encryption key can be generated by running:

  .. only:: not SOC_FLASH_ENCRYPTION_XTS_AES

      .. code-block:: bash

          espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin

  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_256

      If :ref:`Size of generated AES-XTS key <CONFIG_SECURE_FLASH_ENCRYPTION_KEYSIZE>` is AES-128 (256-bit key):

      .. code-block:: bash

          espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin

      else if :ref:`Size of generated AES-XTS key <CONFIG_SECURE_FLASH_ENCRYPTION_KEYSIZE>` is AES-256 (512-bit key):

      .. code-block:: bash

          espsecure.py generate_flash_encryption_key --keylen 512 my_flash_encryption_key.bin


  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and not SOC_FLASH_ENCRYPTION_XTS_AES_256 and not SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

      .. code-block:: bash

          espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin

  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

        If :ref:`Size of generated AES-XTS key <CONFIG_SECURE_FLASH_ENCRYPTION_KEYSIZE>` is AES-128 (256-bit key):

        .. code-block:: bash

            espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin

        else if :ref:`Size of generated AES-XTS key <CONFIG_SECURE_FLASH_ENCRYPTION_KEYSIZE>` is AES-128 key derived from 128 bits (SHA256(128 bits)):

        .. code-block:: bash

            espsecure.py generate_flash_encryption_key --keylen 128 my_flash_encryption_key.bin

3. Burn the flash encryption key into eFuse.

  This action **cannot be reverted**. It can be done by running:

  .. only:: not SOC_FLASH_ENCRYPTION_XTS_AES

    .. code-block:: bash

        espefuse.py --port PORT burn_key flash_encryption my_flash_encryption_key.bin

  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_256

    .. code-block:: bash

      espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin KEYPURPOSE

    where ``BLOCK`` is a free keyblock between ``BLOCK_KEY0`` and ``BLOCK_KEY5``. And ``KEYPURPOSE`` is either ``XTS_AES_256_KEY_1``, ``XTS_AES_256_KEY_2``, ``XTS_AES_128_KEY``. See `{IDF_TARGET_NAME} Technical Reference Manual <{IDF_TARGET_TRM_EN_URL}>`_ for a description of the key purposes.

    For AES-128 (256-bit key) - ``XTS_AES_128_KEY``:

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin XTS_AES_128_KEY

    For AES-256 (512-bit key) - ``XTS_AES_256_KEY_1`` and ``XTS_AES_256_KEY_2``. ``espefuse.py`` supports burning both these two key purposes together with a 512-bit key to two separate key blocks via the virtual key purpose ``XTS_AES_256_KEY``. When this is used ``espefuse.py`` will burn the first 256 bits of the key to the specified ``BLOCK`` and burn the corresponding block key purpose to ``XTS_AES_256_KEY_1``. The last 256 bits of the key will be burned to the first free key block after ``BLOCK`` and the corresponding block key purpose to ``XTS_AES_256_KEY_2``

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin XTS_AES_256_KEY

    If you wish to specify exactly which two blocks are used then it is possible to divide the key into two 256-bit keys, and manually burn each half with ``XTS_AES_256_KEY_1`` and ``XTS_AES_256_KEY_2`` as key purposes:

    .. code-block:: bash

      split -b 32 my_flash_encryption_key.bin my_flash_encryption_key.bin
      espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin.aa XTS_AES_256_KEY_1
      espefuse.py --port PORT burn_key BLOCK+1 my_flash_encryption_key.bin.ab XTS_AES_256_KEY_2


  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and not SOC_FLASH_ENCRYPTION_XTS_AES_256 and not SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK my_flash_encryption_key.bin XTS_AES_128_KEY

    where ``BLOCK`` is a free keyblock between ``BLOCK_KEY0`` and ``BLOCK_KEY5``.

  .. only:: SOC_FLASH_ENCRYPTION_XTS_AES_128 and SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK

    For AES-128 (256-bit key) - ``XTS_AES_128_KEY`` (the ``XTS_KEY_LENGTH_256`` eFuse will be burn to 1):

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK_KEY0 flash_encryption_key256.bin XTS_AES_128_KEY

    For AES-128 key derived from 128 bits (SHA256(128 bits)) - ``XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS``. The FE key will be written in the lower part of eFuse BLOCK_KEY0. The upper 128 bits are not used and will remain available for reading by software. Using the special mode of the espefuse tool, shown in the ``For burning both keys together`` section below, the user can write their data to it using any espefuse commands.

    .. code-block:: bash

        espefuse.py --port PORT burn_key BLOCK_KEY0 flash_encryption_key128.bin XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS

    For burning both keys together (Secure Boot and Flash Encryption):

    .. code-block:: bash

        espefuse.py --port PORT --chip esp32c2 burn_key_digest secure_boot_signing_key.pem \
                                                  burn_key BLOCK_KEY0 flash_encryption_key128.bin XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS


  .. only:: SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK

      .. warning::

          For the {IDF_TARGET_NAME} BLOCK9 (BLOCK_KEY5) can not be used by XTS_AES keys.


4. Burn the ``{IDF_TARGET_CRYPT_CNT}`` eFuse.

  If you only want to enable flash encryption in **Development** mode and want to keep the ability to disable it in the future, Update the {IDF_TARGET_CRYPT_CNT} value in the below command from {IDF_TARGET_CRYPT_CNT_MAX_VAL} to 0x1. (not recommended for production)

  .. code-block:: bash

      espefuse.py --port PORT --chip {IDF_TARGET_PATH_NAME} burn_efuse {IDF_TARGET_CRYPT_CNT} {IDF_TARGET_CRYPT_CNT_MAX_VAL}

  .. only:: esp32

      In the case of {IDF_TARGET_NAME}, you also need to burn the ``FLASH_CRYPT_CONFIG``. It can be done by running:

      .. code-block:: bash

          espefuse.py --port PORT --chip {IDF_TARGET_PATH_NAME} burn_efuse FLASH_CRYPT_CONFIG 0xF

  .. note::

     At this point, the flash encryption on the device has been enabled. You may test the flash encryption process as given in step 5. Please note that the security-related eFuses have not been burned at this point. It is recommended that they should be burned in production use cases as explained in step 6.

5. Encrypt and flash the binaries.

  The bootloader and the application binaries for the project must be built with Flash Encryption Release mode with default configurations.

  Flash encryption Release mode can be set in the menuconfig as follows:

  .. list::

      - :ref:`Enable flash encryption on boot <CONFIG_SECURE_FLASH_ENC_ENABLED>`
      :esp32: - :ref:`Select Release mode <CONFIG_SECURE_FLASH_ENCRYPTION_MODE>` (Note that once Release mode is selected, the ``DISABLE_DL_ENCRYPT`` and ``DISABLE_DL_DECRYPT`` eFuse bits will be burned to disable flash encryption hardware in ROM Download Mode.)
      :esp32: - :ref:`Select UART ROM download mode (Permanently disabled (recommended)) <CONFIG_SECURE_UART_ROM_DL_MODE>` (Note that this option is only available when :ref:`CONFIG_ESP32_REV_MIN` is set to 3 (ESP32 V3).) The default choice is to keep UART ROM download mode enabled, however it is recommended to permanently disable this mode to reduce the options available to an attacker.
      :not esp32: - :ref:`Select Release mode <CONFIG_SECURE_FLASH_ENCRYPTION_MODE>` (Note that once Release mode is selected, the ``EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT`` eFuse bit will be burned to disable flash encryption hardware in ROM Download Mode.)
      :not esp32: - :ref:`Select UART ROM download mode (Permanently switch to Secure mode (recommended)) <CONFIG_SECURE_UART_ROM_DL_MODE>`. This is the default option and is recommended. It is also possible to change this configuration setting to permanently disable UART ROM download mode, if this mode is not needed.
      - :ref:`Select the appropriate bootloader log verbosity <CONFIG_BOOTLOADER_LOG_LEVEL>`
      - Save the configuration and exit.


  The binaries can be encrypted on the host machine by running:

  .. only:: esp32

      .. code-block:: bash

         espsecure.py encrypt_flash_data --keyfile my_flash_encryption_key.bin --address 0x1000 --output bootloader-enc.bin build/bootloader/bootloader.bin

         espsecure.py encrypt_flash_data --keyfile my_flash_encryption_key.bin --address 0x8000 --output partition-table-enc.bin build/partition_table/partition-table.bin

         espsecure.py encrypt_flash_data --keyfile my_flash_encryption_key.bin --address 0x10000 --output my-app-enc.bin build/my-app.bin

  .. only:: not esp32

      .. code-block:: bash

         espsecure.py encrypt_flash_data --aes_xts --keyfile my_flash_encryption_key.bin --address 0x0 --output bootloader-enc.bin build/my-app.bin

         espsecure.py encrypt_flash_data --aes_xts --keyfile my_flash_encryption_key.bin --address 0x8000 --output partition-table-enc.bin build/partition_table/partition-table.bin

         espsecure.py encrypt_flash_data --aes_xts --keyfile my_flash_encryption_key.bin --address 0x10000 --output my-app-enc.bin build/my-app.bin

  The above files can then be flashed to their respective offset using ``esptool.py``. To see all of the command line options recommended for ``esptool.py``, see the output printed when ``idf.py build`` succeeds. In the above command the offsets are used for a sample firmware, the actual offset for your firmware can be obtained by checking the partition table entry or by running `idf.py partition-table`. When the application contains the following partition: ``otadata``, ``nvs_encryption_keys`` they need to be encrypted as well. Please refer to :ref:`encrypted-partitions` for more details about encrypted partitions.

  .. note::

     If the flashed ciphertext file is not recognized by the {IDF_TARGET_NAME} when it boots, check that the keys match and that the command line arguments match exactly, including the correct offset. It is important to provide the correct offset as the ciphertext changes when the offset changes.

     .. only:: esp32

         If your ESP32 uses non-default :ref:`FLASH_CRYPT_CONFIG value in eFuse <setting-flash-crypt-config>` then you will need to pass the ``--flash_crypt_conf`` argument to ``espsecure.py`` to set the matching value. This will not happen if the device configured flash encryption by itself but may happen when burning eFuses manually to enable flash encryption.

  The command ``espsecure.py decrypt_flash_data`` can be used with the same options (and different input/output files), to decrypt ciphertext flash contents or a previously encrypted file.

6. Burn flash encryption-related security eFuses as listed below:

  A) Burn security eFuses:

    .. important::

      For production use cases, it is highly recommended to burn all the eFuses listed below.

    .. list::

        :esp32: - ``DISABLE_DL_ENCRYPT``: Disable the UART bootloader encryption access.
        :esp32: - ``DISABLE_DL_DECRYPT``: Disable the UART bootloader decryption access.
        :esp32: - ``DISABLE_DL_CACHE``: Disable the UART bootloader flash cache access.
        :esp32: - ``JTAG_DISABLE``: Disable the JTAG
        :SOC_EFUSE_DIS_BOOT_REMAP: - ``DIS_BOOT_REMAP``: Disable capability to Remap ROM to RAM address space
        :SOC_EFUSE_DIS_DOWNLOAD_ICACHE: - ``DIS_DOWNLOAD_ICACHE``: Disable UART cache
        :SOC_EFUSE_DIS_DOWNLOAD_DCACHE: - ``DIS_DOWNLOAD_DCACHE``: Disable UART cache.
        :SOC_EFUSE_HARD_DIS_JTAG: - ``HARD_DIS_JTAG``: Hard disable JTAG peripheral
        :SOC_EFUSE_DIS_DIRECT_BOOT:- ``DIS_DIRECT_BOOT``: Disable direct boot (legacy SPI boot mode)
        :SOC_EFUSE_DIS_LEGACY_SPI_BOOT: - ``DIS_LEGACY_SPI_BOOT``: Disable legacy SPI boot mode
        :SOC_EFUSE_DIS_USB_JTAG: - ``DIS_USB_JTAG``: Disable USB switch to JTAG
        :SOC_EFUSE_DIS_PAD_JTAG: - ``DIS_PAD_JTAG``: Disable JTAG permanently
        :not esp32: - ``DIS_DOWNLOAD_MANUAL_ENCRYPT``: Disable UART bootloader encryption access
        :SOC_EFUSE_DIS_DOWNLOAD_MSPI: - ``DIS_DOWNLOAD_MSPI``: Disable the MSPI access in download mode

    The respective eFuses can be burned by running:

    .. code:: bash

        espefuse.py burn_efuse --port PORT EFUSE_NAME 0x1

    .. note::

        Please update the EFUSE_NAME with the eFuse that you need to burn. Multiple eFuses can be burned at the same time by appending them to the above command (e.g., EFUSE_NAME VAL EFUSE_NAME2 VAL2). More documentation about `espefuse.py` can be found `here <https://docs.espressif.com/projects/esptool/en/latest/esp32/espefuse/index.html>`_

  B) Write protect security eFuses:

    After burning the respective eFuses we need to write_protect the security configurations

  .. only:: esp32

      .. code:: bash

          espefuse.py --port PORT write_protect_efuse MAC

      .. note::

          The write disable bit for MAC also write disables DIS_CACHE which is required to prevent accidental burning of this bit.

    C) Disable UART ROM DL mode:

  .. only:: not esp32

      .. code:: bash

          espefuse.py --port PORT write_protect_efuse DIS_ICACHE

      .. note::

          The write protection of above eFuse also write protects multiple other eFuses, Please refer to the {IDF_TARGET_NAME} eFuse table for more details.

    C) Enable Security Download mode:

      .. warning::

          Please burn the following bit at the very end. After this bit is burned, the espefuse tool can no longer be used to burn additional eFuses.

      .. list::

          :esp32: - ``UART_DOWNLOAD_DIS`` : Disable the UART ROM Download mode.
          :not esp32: - ``ENABLE_SECURITY_DOWNLOAD``: Enable Secure ROM download mode

      .. only:: esp32

          The eFuse can be burned by running:

          .. code:: bash

              espefuse.py --port PORT burn_efuse UART_DOWNLOAD_DIS

      .. only:: not esp32

          The eFuse can be burned by running:

          .. code:: bash

              espefuse.py --port PORT burn_efuse ENABLE_SECURITY_DOWNLOAD

.. important::

    7. Delete flash encryption key on host:

        Once the flash encryption has been enabled for the device, the key **must be deleted immediately**. This ensures that the host cannot produce encrypted binaries for the same device going forward. This step is important to reduce the vulnerability of the flash encryption key.

Flash Encryption Guidelines
~~~~~~~~~~~~~~~~~~~~~~~~~~~

* It is recommended to generate a unique flash encryption key for each device for production use-cases.
* It is recommended to ensure that the RNG used by host machine to generate the flash encryption key has good entropy.
* See :ref:`flash-encryption-limitations` for more details.

.. _enable-secure-boot-v2-externally:

Enable Secure Boot V2 Externally
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In this workflow, we shall use ``espsecure`` tool to generate signing keys and use the ``espefuse`` tool to burn the relevant eFuses. The details about the Secure Boot V2 process can be found at :doc:`Secure Boot V2 Guide </security/secure-boot-v2>`

1. Generate Secure Boot V2 Signing Private Key.

  .. only:: esp32 or SOC_SECURE_BOOT_V2_RSA

     The Secure Boot V2 signing key for the RSA3072 scheme can be generated by running:

     .. code:: bash

         espsecure.py generate_signing_key --version 2 --scheme rsa3072 secure_boot_signing_key.pem

  .. only:: SOC_SECURE_BOOT_V2_ECC

     The Secure Boot V2 signing key for ECDSA scheme can be generated by running:

      .. code:: bash

          espsecure.py generate_signing_key --version 2 --scheme ecdsa256 secure_boot_signing_key.pem

     The scheme in the above command can be changed to ``ecdsa192`` to generate ecdsa192 private key.

  .. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

     A total of 3 keys can be used for Secure Boot V2 at once. These should be computed independently and stored separately. The same command with different key file names can be used to generate multiple Secure Boot V2 signing keys. It is recommended to use multiple keys in order to reduce dependency on a single key.

2. Generate Public Key Digest.

  The public key digest for the private key generated in the previous step can be generated by running:

  .. code:: bash

      espsecure.py digest_sbv2_public_key --keyfile secure_boot_signing_key.pem --output digest.bin

  .. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

      In case of multiple digests, each digest should be kept in a separate file.

3. Burn the key digest in eFuse.

  The public key digest can be burned in the eFuse by running:

  .. only:: esp32

      .. code:: bash

          espefuse.py --port PORT --chip esp32 burn_key secure_boot_v2 digest.bin

  .. only:: esp32c2

     .. code:: bash

          espefuse.py --port PORT --chip esp32c2 burn_key KEY_BLOCK0 SECURE_BOOT_DIGEST digest.bin

  .. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

      .. code:: bash

          espefuse.py --port PORT --chip {IDF_TARGET_PATH_NAME} burn_key BLOCK SECURE_BOOT_DIGEST0 digest.bin

      where ``BLOCK`` is a free keyblock between ``BLOCK_KEY0`` and ``BLOCK_KEY5``.

      In case of multiple digests, the other digests can be burned sequentially by changing the key purpose to ``SECURE_BOOT_DIGEST1`` and ``SECURE_BOOT_DIGEST2`` respectively.

4. Enable Secure Boot V2.

  Secure Boot V2 eFuse can be enabled by running:

  .. only:: esp32

     .. code:: bash

          espefuse.py --port PORT --chip esp32 burn_efuse ABS_DONE_1

  .. only:: not esp32

     .. code:: bash

          espefuse.py --port PORT --chip {IDF_TARGET_PATH_NAME} burn_efuse SECURE_BOOT_EN


  .. note::

     At this stage the secure boot V2 has been enabled for the {IDF_TARGET_NAME}. The ROM bootloader shall now verify the authenticity of the :ref:`second-stage-bootloader` on every bootup. You may test the secure boot process by executing Steps 5 & 6. Please note that security-related eFuses have not been burned at this point. For production use cases, all security-related eFuses must be burned as given in step 7.

5. Build the binaries.

  By default, the ROM bootloader would only verify the :ref:`second-stage-bootloader` (firmware bootloader). The firmware bootloader would verify the app partition only when the :ref:`CONFIG_SECURE_BOOT` option is enabled (and :ref:`CONFIG_SECURE_BOOT_VERSION` is set to ``SECURE_BOOT_V2_ENABLED``) while building the bootloader.

  a) Open the :ref:`project-configuration-menu`, in "Security features" set "Enable hardware Secure Boot in bootloader" to enable Secure Boot.

  .. only:: esp32

      For ESP32, Secure Boot V2 is available only for ESP32 ECO3 onwards. To view the "Secure Boot V2" option the chip revision should be changed to revision v3.0 (ECO3). To change the chip revision, set "Minimum Supported ESP32 Revision" to "Rev 3.0 (ECO3)" in "Component Config" -> "Hardware Settings" -> "Chip Revision".

  .. only:: SOC_SECURE_BOOT_V2_RSA or SOC_SECURE_BOOT_V2_ECC

      The "Secure Boot V2" option will be selected and the "App Signing Scheme" will be set to {IDF_TARGET_SBV2_DEFAULT_SCHEME} by default.

  b) Disable the option :ref:`CONFIG_SECURE_BOOT_BUILD_SIGNED_BINARIES` for the project in the :ref:`project-configuration-menu`. This shall make sure that all the generated binaries are secure padded and unsigned. This step is done to avoid generating signed binaries as we are going to manually sign the binaries using ``espsecure`` tool.

  After the above configurations, the bootloader and application binaries can be built with ``idf.py build`` command.

6. Sign and Flash the binaries.

  The Secure Boot V2 workflow only verifies the ``bootloader`` and ``application`` binaries, hence only those binaries need to be signed. The other binaries (e.g., ``partition-table.bin``) can be flashed as they are generated in the build stage.

  The ``bootloader.bin`` and ``app.bin`` binaries can be signed by running:

  .. code:: bash

     espsecure.py sign_data --version 2 --keyfile secure_boot_signing_key.pem --output bootloader-signed.bin build/bootloader/bootloader.bin

     espsecure.py sign_data --version 2 --keyfile secure_boot_signing_key.pem --output my-app-signed.bin build/my-app.bin

  .. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

      If multiple keys secure boot keys are to be used then the same signed binary can be appended with a signature block signed with the new key as follows:

      .. code:: bash

          espsecure.py sign_data --keyfile secure_boot_signing_key2.pem --version 2 --append_signatures -o bootloader-signed2.bin bootloader-signed.bin

          espsecure.py sign_data --keyfile secure_boot_signing_key2.pem --version 2 --append_signatures -o my-app-signed2.bin my-app-signed.bin

      The same process can be repeated for the third key. Note that the names of the input and output files must not be the same.

  The signatures attached to a binary can be checked by running:

  .. code:: bash

     espsecure.py signature_info_v2 bootloader-signed.bin

  The above files along with other binaries (e.g., partition table) can then be flashed to their respective offset using ``esptool.py``. To see all of the command line options recommended for ``esptool.py``, see the output printed when ``idf.py build`` succeeds. The flash offset for your firmware can be obtained by checking the partition table entry or by running ``idf.py partition-table``.

7. Burn relevant eFuses.

  A) Burn security eFuses:

    .. important::

        For production use cases, it is highly recommended to burn all the eFuses listed below.

    .. list::

        :esp32: - ``JTAG_DISABLE``: Disable the JTAG
        :SOC_EFUSE_DIS_BOOT_REMAP: - ``DIS_BOOT_REMAP``: Disable capability to Remap ROM to RAM address space
        :SOC_EFUSE_HARD_DIS_JTAG: - ``HARD_DIS_JTAG``: Hard disable JTAG peripheral
        :SOC_EFUSE_SOFT_DIS_JTAG: - ``SOFT_DIS_JTAG``: Disable software access to JTAG peripheral
        :SOC_EFUSE_DIS_DIRECT_BOOT:- ``DIS_DIRECT_BOOT``: Disable direct boot (legacy SPI boot mode)
        :SOC_EFUSE_DIS_LEGACY_SPI_BOOT: - ``DIS_LEGACY_SPI_BOOT``: Disable legacy SPI boot mode
        :SOC_EFUSE_DIS_USB_JTAG: - ``DIS_USB_JTAG``: Disable USB switch to JTAG
        :SOC_EFUSE_DIS_PAD_JTAG: - ``DIS_PAD_JTAG``: Disable JTAG permanently
        :SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS: - ``SECURE_BOOT_AGGRESSIVE_REVOKE``: Aggressive revocation of key digests, see :ref:`secure-boot-v2-aggressive-key-revocation` for more details.

    The respective eFuses can be burned by running:

    .. code:: bash

        espefuse.py burn_efuse --port PORT EFUSE_NAME 0x1

    .. note::

        Please update the EFUSE_NAME with the eFuse that you need to burn. Multiple eFuses can be burned at the same time by appending them to the above command (e.g., EFUSE_NAME VAL EFUSE_NAME2 VAL2). More documentation about `espefuse.py` can be found `here <https://docs.espressif.com/projects/esptool/en/latest/esp32/espefuse/index.html>`_

  B) Secure Boot V2-related eFuses:

    i) Disable the ability for read protection:

    The secure boot digest burned in the eFuse must be kept readable otherwise secure boot operation would result in a failure. To prevent the accidental enabling of read protection for this key block we need to burn the following eFuse:

    .. code:: bash

        espefuse.py -p $ESPPORT write_protect_efuse RD_DIS

    .. important::

        After this eFuse has been burned, read protection cannot be enabled for any key. E.g., if flash encryption which requires read protection for its key is not enabled at this point then it cannot be enabled afterwards. Please ensure that no eFuse keys are going to need read protection after this.


    .. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

        ii) Revoke key digests:

        The unused digest slots need to be revoked when we are burning the secure boot key. The respective slots can be revoked by running

        .. code:: bash

            espefuse.py --port PORT --chip {IDF_TARGET_PATH_NAME} burn_efuse EFUSE_REVOKE_BIT

        The ``EFUSE_REVOKE_BIT`` in the above command can be ``SECURE_BOOT_KEY_REVOKE0`` or ``SECURE_BOOT_KEY_REVOKE1`` or ``SECURE_BOOT_KEY_REVOKE2``. Please note that only the unused key digests must be revoked. Once revoked, the respective digest cannot be used again.

  .. only:: esp32

    C) Disable UART ROM DL mode:

  .. only:: not esp32

    C) Enable Security Download mode:


      .. warning::

          Please burn the following bit at the very end. After this bit is burned, the espefuse tool can no longer be used to burn additional eFuses.

      .. list::

          :esp32: - ``UART_DOWNLOAD_DIS`` : Disable the UART ROM Download mode.
          :not esp32: - ``ENABLE_SECURITY_DOWNLOAD``: Enable Secure ROM download mode

      .. only:: esp32

          The eFuse can be burned by running:

          .. code:: bash

            espefuse.py --port PORT burn_efuse UART_DOWNLOAD_DIS

      .. only:: not esp32

        The eFuse can be burned by running:

        .. code:: bash

            espefuse.py --port PORT burn_efuse ENABLE_SECURITY_DOWNLOAD

Secure Boot V2 Guidelines
~~~~~~~~~~~~~~~~~~~~~~~~~

* It is recommended to store the secure boot key in a highly secure place. A physical or a cloud HSM may be used for secure storage of the secure boot private key. Please take a look at :ref:`remote-sign-v2-image` for more details.

.. only:: SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS

    * It is recommended to use all the available digest slots to reduce dependency on a single private key.
