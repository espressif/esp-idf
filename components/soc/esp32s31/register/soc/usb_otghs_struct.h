/**
 * SPDX-FileCopyrightText: 2025 Espressif Systems (Shanghai) CO LTD
 *
 *  SPDX-License-Identifier: Apache-2.0
 */
#pragma once

#include <stdint.h>
#ifdef __cplusplus
extern "C" {
#endif

/** Group: The OTG Control and Status register controls the behavior and reflects the
 *  status of the OTG function of the controller.
 */
/** Type of gotgctl register
 *  The OTG Control and Status register controls the behavior and reflects the status
 *  of the OTG function of the controller.
 */
typedef union {
    struct {
        uint32_t reserved_0:2;
        /** gotgctl_vbvalidoven : R/W; bitpos: [2]; default: 0;
         *  Mode: Host only
         *  VBUS Valid Override Enable (VbvalidOvEn)
         *  This bit is used to enable/disable the software to override the Bvalid signal using
         *  the GOTGCTL.VbvalidOvVal.
         *  - 1'b1 : Internally Bvalid received from the PHY is overridden with
         *  GOTGCTL.VbvalidOvVal.
         *  - 1'b0 : Override is disabled and bvalid signal from the respective PHY selected is
         *  used internally by the controller.
         */
        uint32_t gotgctl_vbvalidoven:1;
        /** gotgctl_vbvalidovval : R/W; bitpos: [3]; default: 0;
         *  Mode: Host only
         *  VBUS Valid OverrideValue (VbvalidOvVal)
         *  This bit is used to set Override value for vbusvalid signal when
         *  GOTGCTL.VbvalidOvEn is set.
         *  - 1'b0 : vbusvalid value is 1'b0 when GOTGCTL.VbvalidOvEn =1
         *  - 1'b1 : vbusvalid value is 1'b1 when GOTGCTL.VbvalidOvEn =1
         */
        uint32_t gotgctl_vbvalidovval:1;
        /** gotgctl_avalidoven : R/W; bitpos: [4]; default: 0;
         *  Mode: Host only
         *  A-Peripheral Session Valid Override Enable (AvalidOvEn)
         *  This bit is used to enable/disable the software to override the Avalid signal using
         *  the GOTGCTL.AvalidOvVal.
         *  - 1'b1: Internally Avalid received from the PHY is overridden with
         *  GOTGCTL.AvalidOvVal.
         *  - 1'b0: Override is disabled and avalid signal from the respective PHY selected is
         *  used internally by the core
         */
        uint32_t gotgctl_avalidoven:1;
        /** gotgctl_avalidovval : R/W; bitpos: [5]; default: 0;
         *  Mode: Host only
         *  A-Peripheral Session Valid OverrideValue (AvalidOvVal)
         *  This bit is used to set Override value for Avalid signal when GOTGCTL.AvalidOvEn is
         *  set.
         *  - 1'b0 : Avalid value is 1'b0 when GOTGCTL.AvalidOvEn =1
         *  - 1'b1 : Avalid value is 1'b1 when GOTGCTL.AvalidOvEn =1
         */
        uint32_t gotgctl_avalidovval:1;
        /** gotgctl_bvalidoven : R/W; bitpos: [6]; default: 0;
         *  Mode: Device only
         *  B-Peripheral Session Valid Override Value (BvalidOvEn)
         *  This bit is used to enable/disable the software to override the Bvalid signal using
         *  the GOTGCTL.BvalidOvVal.
         *  - 1'b1 : Internally Bvalid received from the PHY is overridden with
         *  GOTGCTL.BvalidOvVal.
         *  - 1'b0 : Override is disabled and bvalid signal from the respective PHY selected is
         *  used internally by the force
         */
        uint32_t gotgctl_bvalidoven:1;
        /** gotgctl_bvalidovval : R/W; bitpos: [7]; default: 0;
         *  Mode: Device only
         *  B-Peripheral Session Valid OverrideValue (BvalidOvVal)
         *  This bit is used to set Override value for Bvalid signal when GOTGCTL.BvalidOvEn is
         *  set.
         *  - 1'b0 : Bvalid value is 1'b0 when GOTGCTL.BvalidOvEn =1
         *  - 1'b1 : Bvalid value is 1'b1 when GOTGCTL.BvalidOvEn =1
         */
        uint32_t gotgctl_bvalidovval:1;
        uint32_t reserved_8:7;
        /** gotgctl_dbncefltrbypass : R/W; bitpos: [15]; default: 0;
         *  Mode: Host and Device
         *  Debounce Filter Bypass
         *  Bypass Debounce filters for avalid, bvalid, vbusvalid, sessend, iddig signals when
         *  enabled.
         *  - 1'b0: Disabled
         *  - 1'b1: Enabled
         *
         *
         *  Note:  This register bit is valid only when debounce filters are present in core.
         */
        uint32_t gotgctl_dbncefltrbypass:1;
        /** gotgctl_conidsts : RO; bitpos: [16]; default: 1;
         *  Mode: Host and Device
         *  Connector ID Status (ConIDSts)
         *  Indicates the connector ID status on a connect event.
         *  - 1'b0: The core is in A-Device mode.
         *  - 1'b1: The core is in B-Device mode.
         *
         *  Note:
         *  The reset value of this register field can be read only after the PHY clock is
         *  stable, or if IDDIG_FILTER is enabled, wait for the filter timer to expire to read
         *  the correct reset value which ever event is later.
         *  Reset:
         *  - 1'b0: in host only mode (OTG_MODE = 5 or 6)
         *  - 1'b1: in all other configurations
         */
        uint32_t gotgctl_conidsts:1;
        /** gotgctl_dbnctime : RO; bitpos: [17]; default: 0;
         *  Mode: Host only
         *  Long/Short Debounce Time (DbncTime)
         *  Indicates the debounce time of a detected connection.
         *  - 1'b0: Long debounce time, used for physical connections (100 ms + 2.5 micro-sec)
         *  - 1'b1: Short debounce time, used for soft connections (2.5 micro-sec)
         */
        uint32_t gotgctl_dbnctime:1;
        /** gotgctl_asesvld : RO; bitpos: [18]; default: 1;
         *  Mode: Host only
         *  A-Session Valid (ASesVld)
         *  Indicates the Host mode transceiver status.
         *  - 1'b0: A-session is not valid
         *  - 1'b1: A-session is valid
         *  Note: If you do not enabled OTG features (such as SRP and HNP), the read reset
         *  value will be 1. The vbus assigns the values internally for non-SRP or non-HNP
         *  configurations.
         *  In case of OTG_MODE=0, the reset value of this bit is 1'b0.
         */
        uint32_t gotgctl_asesvld:1;
        /** gotgctl_bsesvld : RO; bitpos: [19]; default: 1;
         *  Mode: Device only
         *  B-Session Valid (BSesVld)
         *  Indicates the Device mode transceiver status.
         *  - 1'b0: B-session is not valid.
         *  - 1'b1: B-session is valid.
         *  In OTG mode, you can use this bit to determine if the device is connected or
         *  disconnected.
         *
         *  Note:
         *  - If you do not enable OTG features (such as SRP and HNP), the read reset value
         *  will be 1.The vbus assigns the values internally for non- SRP or non-HNP
         *  configurations.
         *  - In case of OTG_MODE=0, the reset value of this bit is 1'b0.
         *  - The reset value of this register field can be read only after the PHY clock is
         *  stable, or if IDDIG_FILTER is enabled, wait for the filter timer to expire to read
         *  the correct reset value which ever event is later.
         */
        uint32_t gotgctl_bsesvld:1;
        /** gotgctl_otgver : R/W; bitpos: [20]; default: 0;
         *  OTG Version (OTGVer)
         *  Indicates the OTG revision.
         *  - 1'b0: OTG Version 1.3. In this version the core supports Data line pulsing and
         *  VBus pulsing for SRP.
         *  - 1'b1: OTG Version 2.0. In this version the core supports only Data line pulsing
         *  for SRP.
         */
        uint32_t gotgctl_otgver:1;
        /** gotgctl_curmod : RO; bitpos: [21]; default: 0;
         *  Current Mode of Operation (CurMod)
         *  Mode: Host and Device
         *  Indicates the current mode.
         *  - 1'b0: Device mode
         *  - 1'b1: Host mode
         *  Reset:
         *  - 1'b1 in Host-only mode (OTG_MODE=5 or 6)
         *  - 1'b0 in all other configurations
         *  Note: The reset value of this register field can be read only after the PHY clock
         *  is stable, or if IDDIG_FILTER is enabled, wait for the filter timer to expire to
         *  read the correct reset value which ever event is later.
         */
        uint32_t gotgctl_curmod:1;
        /** gotgctl_multvalidbc : RO; bitpos: [26:22]; default: 0;
         *  Mode: Host and Device
         *  Multi Valued ID pin (MultValIdBC)
         *  Battery Charger ACA inputs in the following order:
         *  - Bit 26: rid_float.
         *  - Bit 25: rid_gnd
         *  - Bit 24: rid_a
         *  - Bit 23: rid_b
         *  - Bit 22: rid_c
         */
        uint32_t gotgctl_multvalidbc:5;
        /** gotgctl_chirpen : R/W; bitpos: [27]; default: 0;
         *  Mode: Device Only
         *  This bit when programmed to 1'b1 results in the core asserting chirp_on before
         *  sending an actual Chirp K signal on USB. This bit is present only if OTG_BC_SUPPORT
         *  = 1.If OTG_BC_SUPPORT!=1, this bit is a reserved bit. Do not set this bit when core
         *  is operating in HSIC mode because HSIC always operates at High Speed and High speed
         *  chirp is not used
         */
        uint32_t gotgctl_chirpen:1;
        uint32_t reserved_28:4;
    };
    uint32_t val;
} usb_otghs_gotgctl_reg_t;


/** Group: The application reads this register whenever there is an OTG interrupt and
 *  clears the bits in this register to clear the OTG interrupt.
 */
/** Type of gotgint register
 *  The application reads this register whenever there is an OTG interrupt and clears
 *  the bits in this register to clear the OTG interrupt.
 */
typedef union {
    struct {
        uint32_t reserved_0:2;
        /** gotgint_sesenddet : R/W; bitpos: [2]; default: 0;
         *  Mode: Host and Device
         *  Session End Detected (SesEndDet)
         *  The controller sets this bit when the utmiotg_bvalid signal is deasserted. This bit
         *  can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t gotgint_sesenddet:1;
        uint32_t reserved_3:5;
        /** gotgint_sesreqsucstschng : R/W; bitpos: [8]; default: 0;
         *  Mode: Host and Device
         *  Session Request Success Status Change (SesReqSucStsChng)
         *  The core sets this bit on the success or failure of a session request. The
         *  application must read the Session Request Success bit in the OTG Control and Status
         *  register (GOTGCTL.SesReqScs) to check for success or failure. This bit can be set
         *  only by the core and the application must write 1 to clear it.
         */
        uint32_t gotgint_sesreqsucstschng:1;
        /** gotgint_hstnegsucstschng : R/W; bitpos: [9]; default: 0;
         *  Mode: Host and Device
         *  Host Negotiation Success Status Change (HstNegSucStsChng)
         *  The core sets this bit on the success or failure of a USB host negotiation request.
         *  The application must read the Host Negotiation Success bit of the OTG Control and
         *  Status register (GOTGCTL.HstNegScs) to check for success or failure. This bit can
         *  be set only by the core and the application must write 1 to clear it.
         */
        uint32_t gotgint_hstnegsucstschng:1;
        uint32_t reserved_10:7;
        /** gotgint_hstnegdet : R/W; bitpos: [17]; default: 0;
         *  Mode:Host and Device
         *  Host Negotiation Detected (HstNegDet)
         *  The core sets this bit when it detects a host negotiation request on the USB. This
         *  bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t gotgint_hstnegdet:1;
        /** gotgint_adevtoutchg : R/W; bitpos: [18]; default: 0;
         *  Mode: Host and Device
         *  A-Device Timeout Change (ADevTOUTChg)
         *  The core sets this bit to indicate that the A-device has timed out while waiting
         *  for the B-device to connect.This bit can be set only by the core and the
         *  application must write 1 to clear it.
         */
        uint32_t gotgint_adevtoutchg:1;
        /** gotgint_dbncedone : R/W; bitpos: [19]; default: 0;
         *  Mode: Host only
         *  Debounce Done (DbnceDone)
         *  The core sets this bit when the debounce is completed after the device connect. The
         *  application can start driving USB reset after seeing this interrupt. This bit is
         *  only valid when the HNP Capable or SRP Capable bit is SET in the Core USB
         *  Configuration register (GUSBCFG.HNPCap or GUSBCFG.SRPCap, respectively). This bit
         *  can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t gotgint_dbncedone:1;
        /** gotgint_multvalipchng : R/W; bitpos: [20]; default: 0;
         *  This bit when set indicates that there is a change in the value of at least one ACA
         *  pin value.
         *  This bit is present only if OTG_BC_SUPPORT=1, otherwise it is reserved.
         */
        uint32_t gotgint_multvalipchng:1;
        uint32_t reserved_21:11;
    };
    uint32_t val;
} usb_otghs_gotgint_reg_t;


/** Group: This register can be used to configure the core after power-on or a change
 *  in mode. This register mainly contains AHB system-related configuration parameters.
 *  Do not change this register after the initial programming. The application must
 *  program this register before starting any transactions on either the AHB or the USB.
 */
/** Type of gahbcfg register
 *  This register can be used to configure the core after power-on or a change in mode.
 *  This register mainly contains AHB system-related configuration parameters. Do not
 *  change this register after the initial programming. The application must program
 *  this register before starting any transactions on either the AHB or the USB.
 */
typedef union {
    struct {
        /** gahbcfg_glblintrmsk : R/W; bitpos: [0]; default: 0;
         *  Mode: Host and device
         *  Global Interrupt Mask (GlblIntrMsk)
         *  The application uses this bit to mask or unmask the interrupt line assertion to
         *  itself. Irrespective of this bit's setting, the interrupt status registers are
         *  updated by the controller.
         */
        uint32_t gahbcfg_glblintrmsk:1;
        /** gahbcfg_hbstlen : R/W; bitpos: [4:1]; default: 0;
         *  Mode: Host and device
         *  Burst Length/Type (HBstLen)
         *  This field is used in both External and Internal DMA modes. In External DMA mode,
         *  these bits appear on dma_burst[3:0] ports, which can be used by an external wrapper
         *  to interface the External DMA Controller interface to Synopsis DW_ahb_dmac or ARM
         *  PrimeCell.
         *  External DMA Mode defines the DMA burst length in terms of 32-bit words:
         *  - 4'b0000: 1 word
         *  - 4'b0001: 4 words
         *  - 4'b0010: 8 words
         *  - 4'b0011: 16 words
         *  - 4'b0100: 32 words
         *  - 4'b0101: 64 words
         *  - 4'b0110: 128 words
         *  - 4'b0111: 256 words
         *  - Others: Reserved
         *  Internal DMA Mode AHB Master burst type:
         *  - 4'b0000 Single
         *  - 4'b0001 INCR
         *  - 4'b0011 INCR4
         *  - 4'b0101 INCR8
         *  - 4'b0111 INCR16
         *  - Others: Reserved
         */
        uint32_t gahbcfg_hbstlen:4;
        /** gahbcfg_dmaen : R/W; bitpos: [5]; default: 0;
         *  Mode: Host and device
         *  DMA Enable (DMAEn)
         *
         *  This bit is always 0 when Slave-Only mode has been selected.
         *
         *  Reset: 1'b0
         */
        uint32_t gahbcfg_dmaen:1;
        uint32_t reserved_6:1;
        /** gahbcfg_nptxfemplvl : R/W; bitpos: [7]; default: 0;
         *  Mode: Host and device
         *  Non-Periodic TxFIFO Empty Level (NPTxFEmpLvl)
         *  This bit is used only in Slave mode. In host mode and with Shared FIFO with device
         *  mode, this bit indicates when the Non-Periodic TxFIFO Empty Interrupt bit in the
         *  Core Interrupt register (GINTSTS.NPTxFEmp) is triggered.
         *  With dedicated FIFO in device mode, this bit indicates when IN endpoint Transmit
         *  FIFO empty interrupt (DIEPINTn.TxFEmp) is triggered.
         *  Host mode and with Shared FIFO with device mode:
         *  - 1'b0: GINTSTS.NPTxFEmp interrupt indicates that the Non-Periodic TxFIFO is half
         *  empty
         *  - 1'b1: GINTSTS.NPTxFEmp interrupt indicates that the Non-Periodic TxFIFO is
         *  completely empty
         *  Dedicated FIFO in device mode:
         *  - 1'b0: DIEPINTn.TxFEmp interrupt indicates that the IN Endpoint TxFIFO is half
         *  empty
         *  - 1'b1: DIEPINTn.TxFEmp interrupt indicates that the IN Endpoint TxFIFO is
         *  completely empty
         */
        uint32_t gahbcfg_nptxfemplvl:1;
        /** gahbcfg_ptxfemplvl : R/W; bitpos: [8]; default: 0;
         *  Mode: Host only
         *  Periodic TxFIFO Empty Level (PTxFEmpLvl)
         *  Indicates when the Periodic TxFIFO Empty Interrupt bit in the Core Interrupt
         *  register (GINTSTS.PTxFEmp) is triggered. This bit is used only in Slave mode.
         *  - 1'b0: GINTSTS.PTxFEmp interrupt indicates that the Periodic TxFIFO is half empty
         *  - 1'b1: GINTSTS.PTxFEmp interrupt indicates that the Periodic TxFIFO is completely
         *  empty
         */
        uint32_t gahbcfg_ptxfemplvl:1;
        uint32_t reserved_9:12;
        /** gahbcfg_remmemsupp : R/W; bitpos: [21]; default: 0;
         *  Mode: Host and Device
         *  Remote Memory Support (RemMemSupp)
         *  This bit is programmed to enable the functionality to wait for the system DMA Done
         *  Signal for the DMA Write Transfers.
         *  - GAHBCFG.RemMemSupp=1
         *  The int_dma_req output signal is asserted when the DMA starts write transfer to the
         *  external memory. When the core is done with the Transfers it asserts int_dma_done
         *  signal to flag the completion of DMA writes from the controller. The core then
         *  waits for sys_dma_done signal from the system to proceed further and complete the
         *  Data Transfer corresponding to a particular Channel/Endpoint.
         *  - GAHBCFG.RemMemSupp=0
         *  The int_dma_req and int_dma_done signals are not asserted and the core proceeds
         *  with the assertion of the XferComp interrupt as soon as the DMA write transfer is
         *  done at the Core Boundary and it does not wait for the sys_dma_done signal to
         *  complete the DATA transfers.
         */
        uint32_t gahbcfg_remmemsupp:1;
        /** gahbcfg_notialldmawrit : R/W; bitpos: [22]; default: 0;
         *  Mode: Host and Device
         *  Notify All DMA Write Transactions (NotiAllDmaWrit)
         *  This bit is programmed to enable the System DMA Done functionality for all the DMA
         *  write Transactions corresponding to the Channel/Endpoint. This bit is valid only
         *  when GAHBCFG.RemMemSupp is set to 1.
         *  - GAHBCFG.NotiAllDmaWrit = 1
         *  The core asserts int_dma_req for all the DMA write transactions on the AHB
         *  interface along with int_dma_done, chep_last_transact and chep_number signal
         *  information. The core waits for sys_dma_done signal for all the DMA write
         *  transactions in order to complete the transfer of a particular Channel/Endpoint.
         *  - GAHBCFG.NotiAllDmaWrit = 0
         *  The core asserts int_dma_req signal only for the last transaction of DMA write
         *  transfer corresponding to a particular Channel/Endpoint. Similarly, the core waits
         *  for sys_dma_done signal only for that transaction of DMA write to complete the
         *  transfer of a particular Channel/Endpoint.
         */
        uint32_t gahbcfg_notialldmawrit:1;
        /** gahbcfg_ahbsingle : R/W; bitpos: [23]; default: 0;
         *  Mode: Host and Device
         *  AHB Single Support (AHBSingle)
         *  This bit when programmed supports Single transfers for the remaining data in a
         *  transfer when the core is operating in DMA mode.
         *  - 1'b0: The remaining data in the transfer is sent using INCR burst size.
         *  - 1'b1: The remaining data in the transfer is sent using Single burst size.
         *  Note: If this feature is enabled, the AHB RETRY and SPLIT transfers still have INCR
         *  burst type. Enable this feature when the AHB Slave connected to the core does not
         *  support INCR burst (and when Split, and Retry transactions are not being used in
         *  the bus).
         */
        uint32_t gahbcfg_ahbsingle:1;
        /** gahbcfg_invdescendianess : R/W; bitpos: [24]; default: 0;
         *  Mode: Host and Device
         *  Invert Descriptor Endianness (InvDescEndianess)
         *  - 1'b0: Descriptor Endianness is same as AHB Master Endianness.
         *  - 1'b1:
         *  -- If the AHB Master endianness is Big Endian, the Descriptor Endianness is Little
         *  Endian.
         *  -- If the AHB Master endianness is Little Endian, the Descriptor Endianness is Big
         *  Endian.
         */
        uint32_t gahbcfg_invdescendianess:1;
        uint32_t reserved_25:7;
    };
    uint32_t val;
} usb_otghs_gahbcfg_reg_t;


/** Group: This register can be used to configure the core after power-on or when
 *  changing to Host mode or Device mode. It contains USB and USB-PHY related
 *  configuration parameters. The application must program this register before
 *  starting any transactions on either the AHB or the USB. If you are using the HSIC
 *  interface, HSIC PHY must be in reset while programming this register. Do not make
 *  changes to this register after the initial programming.
 */
/** Type of gusbcfg register
 *  This register can be used to configure the core after power-on or when changing to
 *  Host mode or Device mode. It contains USB and USB-PHY related configuration
 *  parameters. The application must program this register before starting any
 *  transactions on either the AHB or the USB. If you are using the HSIC interface,
 *  HSIC PHY must be in reset while programming this register. Do not make changes to
 *  this register after the initial programming.
 */
typedef union {
    struct {
        /** gusbcfg_toutcal : R/W; bitpos: [2:0]; default: 0;
         *  Mode: Host and Device
         *  HS/FS Timeout Calibration (TOutCal)
         *
         *  The number of PHY clocks that the application programs in this field is added to
         *  the high-speed/full-speed interpacket timeout duration in the core to account for
         *  any additional delays introduced by the PHY. This can be required, because the
         *  delay introduced by the PHY in generating the linestate condition can vary from one
         *  PHY to another.
         *
         *  The USB standard timeout value for high-speed operation is 736 to 816 (inclusive)
         *  bit times. The USB standard timeout value for full-speed operation is 16 to 18
         *  (inclusive) bit times. The application must program this field based on the speed
         *  of enumeration. The number of bit times added per PHY clock are as follows:
         *
         *  High-speed operation:
         *  - One 30-MHz PHY clock = 16 bit times
         *  - One 60-MHz PHY clock = 8 bit times
         *  Full-speed operation:
         *  - One 30-MHz PHY clock = 0.4 bit times
         *  - One 60-MHz PHY clock = 0.2 bit times
         *  - One 48-MHz PHY clock = 0.25 bit times
         */
        uint32_t gusbcfg_toutcal:3;
        /** gusbcfg_phyif : R/W; bitpos: [3]; default: 0;
         *  Mode: Host and Device
         *  PHY Interface (PHYIf)
         *  The application uses this bit to configure the core to support a UTMI+ PHY with an
         *  8- or 16-bit interface. When a ULPI PHY is chosen, this must be Set to 8-bit mode.
         *  - 1'b0: 8 bits
         *  - 1'b1: 16 bits
         *  This bit is writable only If UTMI+ and ULPI were selected. Otherwise, this bit
         *  returns the value for the power-on interface selected during configuration.
         */
        uint32_t gusbcfg_phyif:1;
        /** gusbcfg_ulpi_utmi_sel : R/W; bitpos: [4]; default: 0;
         *  Mode: Host and Device
         *  ULPI or UTMI+ Select (ULPI_UTMI_Sel)
         *
         *  The application uses this bit to select either a UTMI+ interface or ULPI Interface.
         *  - 1'b0: UTMI+ Interface
         *  - 1'b1: ULPI Interface
         */
        uint32_t gusbcfg_ulpi_utmi_sel:1;
        /** gusbcfg_fsintf : R/W; bitpos: [5]; default: 0;
         *  Mode: Host and Device
         *  Full-Speed Serial Interface Select (FSIntf)
         *
         *  The application uses this bit to select either a unidirectional or bidirectional
         *  USB 1.1 full-speed serial transceiver interface.
         *  - 1'b0: 6-pin unidirectional full-speed serial interface
         *  - 1'b1: 3-pin bidirectional full-speed serial interface
         *  If a USB 1.1 Full-Speed Serial Transceiver interface was not selected, this bit is
         *  always 0, with Write Only access. If a USB 1.1 FS interface was selected, Then the
         *  application can Set this bit to select between the 3- and 6-pin interfaces, and
         *  access is Read and Write.
         *
         *  Note: For supporting the new 4-pin bi-directional interface, you need to select
         *  6-pin unidirectional FS serial mode, and add an external control to convert it to a
         *  4-pin interface.
         */
        uint32_t gusbcfg_fsintf:1;
        /** gusbcfg_physel : R/W; bitpos: [6]; default: 0;
         *  PHYSel
         *
         *  Mode: Host and Device
         *
         *  USB 2.0 High-Speed PHY or USB 1.1 Full-Speed Serial Transceiver Select (PHYSel)
         *  The application uses this bit to select either a high-speed UTMI+ or ULPI PHY, or a
         *  full-speed transceiver.
         *  - 1'b0: USB 2.0 high-speed UTMI+ or ULPI PHY
         *  - 1'b1: USB 1.1 full-speed serial transceiver
         *  If a USB 1.1 Full-Speed Serial Transceiver interface was not selected in, this bit
         *  is always 0, with Write Only access.
         *  If a high-speed PHY interface was not selected in, this bit is always 1, with Write
         *  Only access.
         *  If both interface types were selected (parameters have non-zero values), the
         *  application uses this bit to select which interface is active, and access is Read
         *  and Write.
         */
        uint32_t gusbcfg_physel:1;
        /** gusbcfg_ddrsel : R/W; bitpos: [7]; default: 0;
         *  Mode: Host and Device
         *  ULPI DDR Select (DDRSel)
         *  The application uses this bit to select a Single Data Rate (SDR) or Double Data
         *  Rate (DDR) or ULPI interface.
         *  - 1'b0: Single Data Rate ULPI Interface, with 8-bit-wide data bus
         *  - 1'b1: Double Data Rate ULPI Interface, with 4-bit-wide data bus
         */
        uint32_t gusbcfg_ddrsel:1;
        uint32_t reserved_8:2;
        /** gusbcfg_usbtrdtim : R/W; bitpos: [13:10]; default: 5;
         *  Mode: Device only
         *  USB Turnaround Time (USBTrdTim)
         *  Sets the turnaround time in PHY clocks. Specifies the response time for a MAC
         *  request to the Packet FIFO Controller (PFC) to fetch data from the DFIFO (SPRAM).
         *  This must be programmed to
         *  - 4'h5 : When the MAC interface is 16-bit UTMI+
         *  - 4'h9 : When the MAC interface is 8-bit UTMI+
         *  Note:Refer to Programming Guide Section Choosing the Value of GUSBCFG.USBTrdTim for
         *  the turnaround time calculation. During the AHB Clock Frequency selection, it is
         *  recommended to consider mis-sampling into account for USBTrdTim. USB turnaround
         *  time is critical for certification where long cables and 5-Hubs are used. If you
         *  need the AHB to run at less than 30 MHz (or less than 42MHz when operating in
         *  16-bit UTMI mode in HS speed), and if USB turnaround time is not critical, these
         *  bits can be programmed to a larger value.
         */
        uint32_t gusbcfg_usbtrdtim:4;
        uint32_t reserved_14:1;
        /** gusbcfg_phylpwrclksel : R/W; bitpos: [15]; default: 0;
         *  PHY Low-Power Clock Select (PhyLPwrClkSel)
         *  Mode: Host and Device
         *  Selects either 480-MHz or 48-MHz (low-power) PHY mode. In FS and LS modes, the PHY
         *  can usually operate on a 48-MHz clock to save power.
         *  - 1'b0: 480-MHz Internal PLL clock
         *  - 1'b1: 48-MHz External Clock
         *  In 480 MHz mode, the UTMI interface operates at either 60 or 30-MHz, depending upon
         *  whether 8- or 16-bit data width is selected.
         *  In 48-MHz mode, the UTMI interface operates at 48 MHz in FS mode and at either 48
         *  or 6 MHz in LS mode (depending on the PHY vendor). This bit drives the
         *  utmi_fsls_low_power core output signal, and is valid only for UTMI+ PHYs.
         */
        uint32_t gusbcfg_phylpwrclksel:1;
        uint32_t reserved_16:1;
        /** gusbcfg_ulpifsls : R/W; bitpos: [17]; default: 0;
         *  Mode: Host and Device
         *  ULPI FS/LS Select (ULPIFsLs)
         *  The application uses this bit to select the FS/LS serial interface for the ULPI
         *  PHY. This bit is valid only when the FS serial transceiver is selected on the ULPI
         *  PHY.
         *  - 1'b0: ULPI interface
         *  - 1'b1: ULPI FS/LS serial interface
         *  Note: Before setting this bit, the application needs to ensure that
         *  GUSBCFG.ULPI_UTMI_SEL = 1'b1.
         */
        uint32_t gusbcfg_ulpifsls:1;
        /** gusbcfg_ulpiautores : R/W; bitpos: [18]; default: 0;
         *  Mode: Host and Device
         *  ULPI Auto Resume (ULPIAutoRes)
         *  This bit sets the AutoResume bit in the Interface Control register on the ULPI PHY.
         *  - 1'b0: PHY does not use AutoResume feature.
         *  - 1'b1: PHY uses AutoResume feature.
         */
        uint32_t gusbcfg_ulpiautores:1;
        /** gusbcfg_ulpiclksusm : R/W; bitpos: [19]; default: 0;
         *  Mode: Host and Device
         *  ULPI Clock SuspendM (ULPIClkSusM)
         *  This bit sets the ClockSuspendM bit in the Interface Control register on the ULPI
         *  PHY. This bit applies only in serial or carkit modes.
         *  - 1'b0: PHY powers down internal clock during suspend.
         *  - 1'b1: PHY does not power down internal clock.
         */
        uint32_t gusbcfg_ulpiclksusm:1;
        /** gusbcfg_ulpiextvbusdrv : R/W; bitpos: [20]; default: 0;
         *  Mode: Host only
         *  ULPI External VBUS Drive (ULPIExtVbusDrv)
         *  This bit selects between internal or external supply to drive 5V on VBUS, in ULPI
         *  PHY.
         *  - 1'b0: PHY drives VBUS using internal charge pump (Default).
         *  - 1'b1: PHY drives VBUS using external supply.
         */
        uint32_t gusbcfg_ulpiextvbusdrv:1;
        /** gusbcfg_ulpiextvbusindicator : R/W; bitpos: [21]; default: 0;
         *  Mode: Host only
         *  ULPI External VBUS Indicator (ULPIExtVbusIndicator)
         *  This bit indicates to the ULPI PHY to use an external VBUS overcurrent indicator.
         *  - 1'b0: PHY uses internal VBUS valid comparator.
         *  - 1'b1: PHY uses external VBUS valid comparator.
         */
        uint32_t gusbcfg_ulpiextvbusindicator:1;
        /** gusbcfg_termseldlpulse : R/W; bitpos: [22]; default: 0;
         *  Mode: Device only
         *  TermSel DLine Pulsing Selection (TermSelDLPulse)
         *  This bit selects utmi_termselect to drive data line pulse during SRP.
         *  - 1'b0: Data line pulsing using utmi_txvalid (Default).
         *  - 1'b1: Data line pulsing using utmi_termsel.
         */
        uint32_t gusbcfg_termseldlpulse:1;
        /** gusbcfg_complement : R/W; bitpos: [23]; default: 0;
         *  Mode: Host only
         *  Indicator Complement Controls the PHY to invert the ExternalVbusIndicator input
         *  signal, generating the Complement Output. For more information, refer to the ULPI
         *  Specification.
         *  - 1'b0: PHY does not invert ExternalVbusIndicator signal
         *  - 1'b1: PHY does invert ExternalVbusIndicator signal
         *  This bit is reserved and read-only when OTG_HSPHY_INTERFACE is set to 0 or 1.
         */
        uint32_t gusbcfg_complement:1;
        /** gusbcfg_indicator : R/W; bitpos: [24]; default: 0;
         *  Mode: Host only
         *  Indicator Pass Through
         *  Controls whether the Complement Output is qualified with the Internal Vbus Valid
         *  comparator before being used in the Vbus State in the RX CMD. For more information,
         *  refer to the ULPI Specification.
         *  - 1'b0: Complement Output signal is qualified with the Internal VbusValid
         *  comparator.
         *  - 1'b1: Complement Output signal is not qualified with the Internal VbusValid
         *  comparator.
         *  This bit is reserved and read-only when OTG_HSPHY_INTERFACE is set to 0 or 1.
         */
        uint32_t gusbcfg_indicator:1;
        /** gusbcfg_ulpi : R/W; bitpos: [25]; default: 0;
         *  Mode: Host only
         *  ULPI Interface Protect Disable
         *  Controls circuitry built into the PHY for protecting the ULPI interface when the
         *  link tri-states STP and data. Any pull-ups or pull-downs employed by this feature
         *  can be disabled. For more information, refer to the ULPI Specification.
         *  - 1'b0: Enables the interface protect circuit
         *  - 1'b1: Disables the interface protect circuit
         */
        uint32_t gusbcfg_ulpi:1;
        /** gusbcfg_ic_usbcap : RO; bitpos: [26]; default: 0;
         *  Mode: Host and Device
         *  IC_USB-Capable (IC_USBCap)
         *  The application uses this bit to control the core's IC_USB capabilities.
         *  - 1'b0: IC_USB PHY Interface is not selected.
         *  - 1'b1: IC_USB PHY Interface is selected.
         *  This bit is writable only if OTG_ENABLE_IC_USB=1 and OTG_FSPHY_INTERFACE!=0.
         *  The reset value depends on the configuration parameter OTG_SELECT_IC_USB when
         *  OTG_ENABLE_IC_USB = 1. In all other cases, this bit is set to 1'b0 and the bit is
         *  read only.
         */
        uint32_t gusbcfg_ic_usbcap:1;
        uint32_t reserved_27:1;
        /** gusbcfg_txenddelay : R/W; bitpos: [28]; default: 1;
         *  Mode: Device only
         *  Tx End Delay (TxEndDelay)
         *  Setting this bit to 1'b1 enables the controller to follow the TxEndDelay timings as
         *  per UTMI+ specification 1.05 section 4.1.5 for opmode signal during remote wakeup.
         *  - 1'b0 : Normal Mode.
         *  - 1'b1 : Tx End delay.
         *  The default value of this field is 1'b1 and it is not recommended to program it to
         *  1'b0. The option to set it to 1'b0 (Normal Mode) is present only for debug purpose.
         */
        uint32_t gusbcfg_txenddelay:1;
        /** gusbcfg_forcehstmode : R/W; bitpos: [29]; default: 0;
         *  Mode: Host and device
         *  Force Host Mode (ForceHstMode)
         *  Writing a 1 to this bit forces the core to host mode irrespective of utmiotg_iddig
         *  input pin.
         *  - 1'b0 : Normal Mode.
         *  - 1'b1 : Force Host Mode.
         *  After setting the force bit, the application must wait at least 25 ms before the
         *  change to take effect. When the simulation is in scale down mode, waiting for 500
         *  micro sec is sufficient. This bit is valid only when OTG_MODE = 0, 1 or 2. In all
         *  other cases, this bit reads 0.
         */
        uint32_t gusbcfg_forcehstmode:1;
        /** gusbcfg_forcedevmode : R/W; bitpos: [30]; default: 0;
         *  Mode:Host and device
         *  Force Device Mode (ForceDevMode)
         *  Writing a 1 to this bit forces the controller to device mode irrespective of
         *  utmiotg_iddig input pin.
         *  - 1'b0 : Normal Mode.
         *  - 1'b1 : Force Device Mode.
         *  After setting the force bit, the application must wait at least 25 ms before the
         *  change to take effect. When the simulation is in scale down mode, waiting for 500
         *  micro sec is sufficient. This bit is valid only when OTG_MODE = 0, 1 or 2. In all
         *  other cases, this bit reads 0.
         */
        uint32_t gusbcfg_forcedevmode:1;
        /** gusbcfg_corrupttxpkt : R/W; bitpos: [31]; default: 0;
         *  Mode: Host and device
         *  Corrupt Tx packet (CorruptTxPkt)
         *  This bit is for debug purposes only. Never Set this bit to 1. The application must
         *  always write 1'b0 to this bit.
         */
        uint32_t gusbcfg_corrupttxpkt:1;
    };
    uint32_t val;
} usb_otghs_gusbcfg_reg_t;


/** Group: The application uses this register to reset various hardware features inside
 *  the controller.
 */
/** Type of grstctl register
 *  The application uses this register to reset various hardware features inside the
 *  controller.
 */
typedef union {
    struct {
        /** grstctl_csftrst : R/W; bitpos: [0]; default: 0;
         *  Mode: Host and Device
         *  Core Soft Reset (CSftRst)
         *  Resets the hclk and phy_clock domains as follows:
         *  - Clears the interrupts and all the CSR registers except the following register
         *  bits:
         *  -- PCGCCTL.RstPdwnModule
         *  -- PCGCCTL.GateHclk
         *  -- PCGCCTL.PwrClmp
         *  -- PCGCCTL.StopPPhyLPwrClkSelclk
         *  -- GUSBCFG.ForceDevMode
         *  -- GUSBCFG.ForceHstMode
         *  -- GUSBCFG.PhyLPwrClkSel
         *  -- GUSBCFG.DDRSel
         *  -- GUSBCFG.PHYSel
         *  -- GUSBCFG.FSIntf
         *  -- GUSBCFG.ULPI_UTMI_Sel
         *  -- GUSBCFG.PHYIf
         *  -- GUSBCFG.TxEndDelay
         *  -- GUSBCFG.TermSelDLPulse
         *  -- GUSBCFG.ULPIClkSusM
         *  -- GUSBCFG.ULPIAutoRes
         *  -- GUSBCFG.ULPIFsLs
         *  -- GGPIO
         *  -- GPWRDN
         *  -- GADPCTL
         *  -- HCFG.FSLSPclkSel
         *  -- DCFG.DevSpd
         *  -- DCTL.SftDiscon
         *  - All module state machines
         *  - All module state machines (except the AHB Slave Unit) are reset to the IDLE
         *  state, and all the transmit FIFOs and the receive FIFO are flushed.
         *  - Any transactions on the AHB Master are terminated as soon as possible, after
         *  gracefully completing the last data phase of an AHB transfer. Any transactions on
         *  the USB are terminated immediately.
         *  - When Hibernation or ADP feature is enabled, the PMU module is not reset by the
         *  Core Soft Reset.
         *  The application can write to this bit any time it wants to reset the core. The
         *  application must clear this bit after checking the bit 29 of this register (Core
         *  Soft Reset Done). Software must also must check that bit 31 of this register is 1
         *  (AHB Master is IDLE) before starting any operation.
         *
         *  Typically software reset is used during software development and also when you
         *  dynamically change the PHY selection bits in the USB configuration registers listed
         *  above. When you change the PHY, the corresponding clock for the PHY is selected and
         *  used in the PHY domain. Once a new clock is selected, the PHY domain has to be
         *  reset for proper operation.
         */
        uint32_t grstctl_csftrst:1;
        /** grstctl_piufssftrst : R/W; bitpos: [1]; default: 0;
         *  Mode: Host and Device
         *  PIU FS Dedicated Controller Soft Reset (PIUFSSftRst)
         *
         *  Resets the PIU FS Dedicated Controller
         *  All module state machines in FS Dedicated Controller of PIU are reset to the IDLE
         *  state. Used to reset the FS Dedicated controller in PIU in case of any PHY Errors
         *  like Loss of activity or Babble Error resulting in the PHY remaining in RX state
         *  for more than one frame boundary.
         *  This is a self clearing bit and core clears this bit after all the necessary logic
         *  is reset in the core.
         */
        uint32_t grstctl_piufssftrst:1;
        /** grstctl_frmcntrrst : R/W; bitpos: [2]; default: 0;
         *  Mode: Host only
         *  Host Frame Counter Reset (FrmCntrRst)
         *  The application writes this bit to reset the (micro)Frame number counter inside the
         *  core. When the (micro)Frame counter is reset, the subsequent SOF sent out by the
         *  core has a (micro)Frame number of 0.
         *  When application writes 1 to the bit, it might not be able to read back the value
         *  as it gets cleared by the core in a few clock cycles.
         */
        uint32_t grstctl_frmcntrrst:1;
        uint32_t reserved_3:1;
        /** grstctl_rxfflsh : R/W; bitpos: [4]; default: 0;
         *  Mode: Host and Device
         *  RxFIFO Flush (RxFFlsh)
         *  The application can flush the entire RxFIFO using this bit, but must first ensure
         *  that the core is not in the middle of a transaction.
         *  The application must only write to this bit after checking that the controller is
         *  neither reading from the RxFIFO nor writing to the RxFIFO.
         *
         *  The application must wait until the bit is cleared before performing any other
         *  operations. This bit requires eight clocks (slowest of PHY or AHB clock) to clear.
         */
        uint32_t grstctl_rxfflsh:1;
        /** grstctl_txfflsh : R/W; bitpos: [5]; default: 0;
         *  Mode: Host and Device
         *  TxFIFO Flush (TxFFlsh)
         *  This bit selectively flushes a single or all transmit FIFOs, but cannot do so If
         *  the core is in the midst of a transaction.
         *  The application must write this bit only after checking that the core is neither
         *  writing to the TxFIFO nor reading from the TxFIFO.
         *  Verify using these registers:
         *  - ReadNAK Effective Interrupt ensures the core is not reading from the FIFO
         *  - WriteGRSTCTL.AHBIdle ensures the core is not writing anything to the FIFO.
         *  Flushing is normally recommended when FIFOs are reconfigured or when switching
         *  between Shared FIFO and Dedicated Transmit FIFO operation. FIFO flushing is also
         *  recommended during device endpoint disable. The application must wait until the
         *  core clears this bit before performing any operations. This bit takes eight clocks
         *  to clear, using the slower clock of phy_clk or hclk.
         */
        uint32_t grstctl_txfflsh:1;
        /** grstctl_txfnum : R/W; bitpos: [10:6]; default: 0;
         *  Mode: Host and Device
         *  TxFIFO Number (TxFNum)
         *  This is the FIFO number that must be flushed using the TxFIFO Flush bit. This field
         *  must not be changed until the core clears the TxFIFO Flush bit.
         *  - 5'h0:
         *  -- Non-periodic TxFIFO flush in Host mode
         *  -- Non-periodic TxFIFO flush in device mode when in shared FIFO operation
         *  -- Tx FIFO 0 flush in device mode when in dedicated FIFO mode
         *  - 5'h1:
         *  -- Periodic TxFIFO flush in Host mode
         *  -- Periodic TxFIFO 1 flush in Device mode when in shared FIFO operation
         *  -- TXFIFO 1 flush in device mode when in dedicated FIFO mode
         *  - 5'h2:
         *  -- Periodic TxFIFO 2 flush in Device mode when in shared FIFO operation
         *  -- TXFIFO 2 flush in device mode when in dedicated FIFO mode
         *  ...
         *  - 5'hF
         *  -- Periodic TxFIFO 15 flush in Device mode when in shared FIFO operation
         *  -- TXFIFO 15 flush in device mode when in dedicated FIFO mode
         *  - 5'h10: Flush all the transmit FIFOs in device or host mode
         */
        uint32_t grstctl_txfnum:5;
        uint32_t reserved_11:18;
        /** grstctl_csftrstdone : R/W; bitpos: [29]; default: 0;
         *  Mode: Host and Device
         *  Core Soft Reset Done (CSftRstDone)
         *  The core sets this bit when all the necessary logic is reset in the core.This bit
         *  is cleared by the application along with GRSTCTL.CSftRst (bit 0)
         */
        uint32_t grstctl_csftrstdone:1;
        /** grstctl_dmareq : RO; bitpos: [30]; default: 0;
         *  Mode: Host and Device
         *  DMA Request Signal (DMAReq)
         *  Indicates that the DMA request is in progress. Used for debug.
         */
        uint32_t grstctl_dmareq:1;
        /** grstctl_ahbidle : RO; bitpos: [31]; default: 1;
         *  Mode: Host and Device
         *  AHB Master Idle (AHBIdle)
         *  Indicates that the AHB Master State Machine is in the IDLE condition.
         */
        uint32_t grstctl_ahbidle:1;
    };
    uint32_t val;
} usb_otghs_grstctl_reg_t;


/** Group: This register interrupts the application for system-level events in the
 *  current mode (Device mode or Host mode).
 */
/** Type of gintsts register
 *  This register interrupts the application for system-level events in the current
 *  mode (Device mode or Host mode). Some of the bits in this register are valid only
 *  in Host mode, while others are valid in Device mode only. This register also
 *  indicates the current mode. To clear the interrupt status bits of type R_SS_WC, the
 *  application must write 1'b1 to the bit. The FIFO status interrupts are read only;
 *  once software reads from or writes to the FIFO while servicing these interrupts,
 *  FIFO interrupt conditions are cleared automatically. The application must clear the
 *  GINTSTS register at initialization before unmasking the interrupt bit to avoid any
 *  interrupts generated prior to initialization.  Note: Read the reset value of
 *  GINTSTS.CurMod only after the following conditions:  - If IDDIG_FILTER is disabled,
 *  read only after PHY clock is stable.  - If IDDIG_FILTER is enabled, read only after
 *  the filter timer expires.
 */
typedef union {
    struct {
        /** gintsts_curmod : RO; bitpos: [0]; default: 0;
         *  Mode: Host and Device
         *  Current Mode of Operation (CurMod)
         *  Indicates the current mode.
         *  - 1'b0: Device mode
         *  - 1'b1: Host mode
         *
         *
         *  Note: The reset value of this register field can be read only after the PHY clock
         *  is stable, or if IDDIG_FILTER is enabled, wait for the filter timer to expire to
         *  read the correct reset value which ever event is later.
         */
        uint32_t gintsts_curmod:1;
        /** gintsts_modemis : R/W; bitpos: [1]; default: 0;
         *  Mode: Host and Device
         *  Mode Mismatch Interrupt (ModeMis)
         *  The core sets this bit when the application is trying to access:
         *  - A Host mode register, when the controller is operating in Device mode
         *  - A Device mode register, when the controller is operating in Host mode
         *  The register access is completed on the AHB with an OKAY response, but is ignored
         *  by the controller internally and does not affect the operation of the controller.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t gintsts_modemis:1;
        /** gintsts_otgint : RO; bitpos: [2]; default: 0;
         *  Mode: Host and Device
         *  OTG Interrupt (OTGInt)
         *  The controller sets this bit to indicate an OTG protocol event. The application
         *  must read the OTG Interrupt Status (GOTGINT) register to determine the exact event
         *  that caused this interrupt. The application must clear the appropriate status bit
         *  in the GOTGINT register to clear this bit.
         */
        uint32_t gintsts_otgint:1;
        /** gintsts_sof : R/W; bitpos: [3]; default: 0;
         *  Mode: Host and Device
         *  Start of (micro)Frame (Sof)
         *
         *  In Host mode, the core sets this bit to indicate that an SOF (FS), micro-SOF (HS),
         *  or Keep-Alive (LS) is transmitted on the USB. The application must write a 1 to
         *  this bit to clear the interrupt.
         *
         *  In Device mode, the controller sets this bit to indicate that an SOF token has been
         *  received on the USB. The application can read the Device Status register to get the
         *  current (micro)Frame number. This interrupt is seen only when the core is operating
         *  at either HS or FS. This bit can be set only by the core and the application must
         *  write 1 to clear it.
         *
         *  Note: This register may return 1'b1 if read immediately after power-on reset.
         *  If the register bit reads 1'b1 immediately after power-on reset, it does not
         *  indicate that an SOF has been sent (in case of host mode) or SOF has been received
         *  (in case of device mode).
         *  The read value of this interrupt is valid only after a valid connection between
         *  host and device is established. If the bit is set after power on reset the
         *  application can clear the bit.
         */
        uint32_t gintsts_sof:1;
        /** gintsts_rxflvl : RO; bitpos: [4]; default: 0;
         *  Mode: Host and Device
         *  RxFIFO Non-Empty (RxFLvl)
         *
         *  Indicates that there is at least one packet pending to be read from the RxFIFO.
         */
        uint32_t gintsts_rxflvl:1;
        /** gintsts_nptxfemp : RO; bitpos: [5]; default: 1;
         *  Mode: Host and Device
         *  Non-periodic TxFIFO Empty (NPTxFEmp)
         *  This interrupt is asserted when the Non-periodic TxFIFO is either half or
         *  completely empty, and there is space for at least one Entry to be written to the
         *  Non-periodic Transmit Request Queue. The half or completely empty status is
         *  determined by the Non-periodic TxFIFO Empty Level bit in the Core AHB Configuration
         *  register (GAHBCFG.NPTxFEmpLvl).
         *  In host mode, the application can use GINTSTS.NPTxFEmp with the OTG_EN_DED_TX_FIFO
         *  parameter set to either 1 or 0.
         *  In device mode, the application uses GINTSTS.NPTxFEmp when OTG_EN_DED_TX_FIFO=0.
         *  When OTG_EN_DED_TX_FIFO=1, the application uses DIEPINTn.TxFEmp.
         */
        uint32_t gintsts_nptxfemp:1;
        /** gintsts_ginnakeff : RO; bitpos: [6]; default: 0;
         *  Mode: Device only
         *  Global IN Non-periodic NAK Effective (GINNakEff)
         *  Indicates that the Set Global Non-periodic IN NAK bit in the Device Control
         *  register (DCTL.SGNPInNak) set by the application, has taken effect in the core.
         *  That is, the core has sampled the Global IN NAK bit Set by the application. This
         *  bit can be cleared by clearing the Clear Global Non-periodic IN NAK bit in the
         *  Device Control register (DCTL.CGNPInNak). This interrupt does not necessarily mean
         *  that a NAK handshake
         *  is sent out on the USB. The STALL bit takes precedence over the NAK bit.
         */
        uint32_t gintsts_ginnakeff:1;
        /** gintsts_goutnakeff : RO; bitpos: [7]; default: 0;
         *  Mode: Device only
         *  Global OUT NAK Effective (GOUTNakEff)
         *  Indicates that the Set Global OUT NAK bit in the Device Control register
         *  (DCTL.SGOUTNak), Set by the application, has taken effect in the core. This bit can
         *  be cleared by writing the Clear Global OUT NAK bit in the Device Control register
         *  (DCTL.CGOUTNak).
         */
        uint32_t gintsts_goutnakeff:1;
        uint32_t reserved_8:2;
        /** gintsts_erlysusp : R/W; bitpos: [10]; default: 0;
         *  Mode: Device only
         *  Early Suspend (ErlySusp)
         *  The controller sets this bit to indicate that an Idle state has been detected on
         *  the USB for 3 ms.
         */
        uint32_t gintsts_erlysusp:1;
        /** gintsts_usbsusp : R/W; bitpos: [11]; default: 0;
         *  Mode: Device only
         *  USB Suspend (USBSusp)
         *  The controller sets this bit to indicate that a suspend was detected on the USB.
         *  The controller enters the Suspended state when there is no activity on the
         *  linestate signal for an extended period of time.
         */
        uint32_t gintsts_usbsusp:1;
        /** gintsts_usbrst : R/W; bitpos: [12]; default: 0;
         *  Mode: Device only
         *  USB Reset (USBRst)
         *  The controller sets this bit to indicate that a reset is detected on the USB.
         */
        uint32_t gintsts_usbrst:1;
        /** gintsts_enumdone : R/W; bitpos: [13]; default: 0;
         *  Mode: Device only
         *  Enumeration Done (EnumDone)
         *  The core sets this bit to indicate that speed enumeration is complete. The
         *  application must read the Device Status (DSTS) register to obtain the enumerated
         *  speed.
         */
        uint32_t gintsts_enumdone:1;
        /** gintsts_isooutdrop : R/W; bitpos: [14]; default: 0;
         *  Mode: Device only
         *  Isochronous OUT Packet Dropped Interrupt (ISOOutDrop)
         *  The controller sets this bit when it fails to write an isochronous OUT packet into
         *  the RxFIFO because the RxFIFO does not have enough space to accommodate a maximum
         *  packet size packet for the isochronous OUT endpoint.
         */
        uint32_t gintsts_isooutdrop:1;
        /** gintsts_eopf : R/W; bitpos: [15]; default: 0;
         *  Mode: Device only
         *  End of Periodic Frame Interrupt (EOPF)
         *  Indicates that the period specified in the Periodic Frame Interval field of the
         *  Device Configuration register (DCFG.PerFrInt) has been reached in the current
         *  microframe.
         *  In case of Non-Ignore Frame Number Scatter/Gather (Descriptor DMA) mode, the
         *  controller internally handles the following scenarios based on EOPF:
         *
         *  Read Flush: At the EOPF, the controller checks if there are any pending packets in
         *  the FIFO corresponding to the current (micro)Frame.
         *  - If there are any pending packets, then the controller initiates read flush, due
         *  to which the read pointer is updated to the starting location of the next
         *  micro-frame packet.
         *  - If there are no pending packets corresponding to the current (micro)Frame, the
         *  controller does not take any action.
         *  Write Flush: At the EOPF, if the controller is still fetching the current
         *  micro-frame data, then the controller stops pushing data into the TXFIFO but keeps
         *  fetching the complete packet from the System Memory. After completing the scheduled
         *  packet size fetch, the controller updates the Status Quadlet Fields (Transmit
         *  Status to BUFFLUSH) and closes the Descriptor.  During the descriptor close, the
         *  controller initiates write flush, due to which the write pointer is updated to the
         *  starting location of the next micro-frame packet. Because the controller stops
         *  pushing the packet to the TxFIFO after EOPF, to bring the write pointer to the
         *  starting location of the next micro-frame, write flush is done.
         */
        uint32_t gintsts_eopf:1;
        uint32_t reserved_16:1;
        /** gintsts_epmis : R/W; bitpos: [17]; default: 0;
         *  Mode: Device only
         *  Endpoint Mismatch Interrupt (EPMis)
         *  Note: This interrupt is valid only in shared FIFO operation.
         *  Indicates that an IN token has been received for a non-periodic endpoint, but the
         *  data for another endpoint is present in the top of the Non-periodic Transmit FIFO
         *  and the IN endpoint mismatch count programmed by the application has expired.
         */
        uint32_t gintsts_epmis:1;
        /** gintsts_iepint : RO; bitpos: [18]; default: 0;
         *  Mode: Device only
         *  IN Endpoints Interrupt (IEPInt)
         *  The core sets this bit to indicate that an interrupt is pending on one of the IN
         *  endpoints of the core (in Device mode). The application must read the Device All
         *  Endpoints Interrupt (DAINT) register to determine the exact number of the IN
         *  endpoint on Device IN Endpoint-n Interrupt (DIEPINTn) register to determine the
         *  exact cause of the interrupt. The application must clear the appropriate status bit
         *  in the corresponding DIEPINTn register to
         *  clear this bit.
         */
        uint32_t gintsts_iepint:1;
        /** gintsts_oepint : RO; bitpos: [19]; default: 0;
         *  Mode: Device only
         *  OUT Endpoints Interrupt (OEPInt)
         *  The controller sets this bit to indicate that an interrupt is pending on one of the
         *  OUT endpoints of the core (in Device mode). The application must read the Device
         *  All Endpoints Interrupt (DAINT) register to determine the exact number of the OUT
         *  endpoint on which the interrupt occurred, and then read the corresponding Device
         *  OUT Endpoint-n Interrupt (DOEPINTn) register to determine the exact cause of the
         *  interrupt. The application must
         *  clear the appropriate status bit in the corresponding DOEPINTn register to clear
         *  this bit.
         */
        uint32_t gintsts_oepint:1;
        /** gintsts_incompisoin : R/W; bitpos: [20]; default: 0;
         *  Mode: Device only
         *  Incomplete Isochronous IN Transfer (incompISOIN)
         *  The core sets this interrupt to indicate that there is at least one isochronous IN
         *  endpoint on which the transfer is not completed in the current microframe. This
         *  interrupt is asserted along with the End of Periodic Frame Interrupt (EOPF) bit in
         *  this register.
         *  Note: This interrupt is not asserted in Scatter/Gather DMA mode.
         */
        uint32_t gintsts_incompisoin:1;
        /** gintsts_incomplp : R/W; bitpos: [21]; default: 0;
         *  Incomplete Periodic Transfer (incomplP)
         *  Mode: Host only
         *  In Host mode, the core sets this interrupt bit when there are incomplete periodic
         *  transactions still pending which are scheduled for the current microframe.
         *  Incomplete Isochronous OUT Transfer (incompISOOUT)
         *  Mode: Device only
         *  The Device mode, the core sets this interrupt to indicate that there is at least
         *  one isochronous OUT endpoint on which the transfer is not completed in the current
         *  microframe. This interrupt is asserted along with the End of Periodic Frame
         *  Interrupt (EOPF) bit in this register.
         */
        uint32_t gintsts_incomplp:1;
        /** gintsts_fetsusp : R/W; bitpos: [22]; default: 0;
         *  Mode: Device only
         *  Data Fetch Suspended (FetSusp)
         *  This interrupt is valid only in DMA mode. This interrupt indicates that the core
         *  has stopped fetching data. For IN endpoints due to the unavailability of TxFIFO
         *  space or Request Queue space. This interrupt is used by the application for an
         *  endpoint mismatch algorithm.
         *
         *  For example, after detecting an endpoint mismatch, the application:
         *  - Sets a Global non-periodic IN NAK handshake
         *  - Disables IN endpoints
         *  - Flushes the FIFO
         *  - Determines the token sequence from the IN Token Sequence Learning Queue
         *  - Re-enables the endpoints
         *  - Clears the Global non-periodic IN NAK handshake
         *  If the Global non-periodic IN NAK is cleared, the core has not yet fetched data for
         *  the IN endpoint, and the IN token is received. The core generates an 'IN token
         *  received when FIFO empty' interrupt. It then sends the host a NAK response. To
         *  avoid this scenario, the application can check the GINTSTS.FetSusp interrupt, which
         *  ensures that the FIFO is full before clearing a Global NAK handshake.
         *
         *  Alternatively, the application can mask the IN token received when FIFO empty
         *  interrupt when clearing a Global IN NAK handshake.
         */
        uint32_t gintsts_fetsusp:1;
        /** gintsts_resetdet : R/W; bitpos: [23]; default: 0;
         *  Mode: Device only
         *  Reset detected Interrupt (ResetDet)
         *  In Device mode, this interrupt is asserted when a reset is detected on the USB in
         *  partial power-down mode when the device is in Suspend.
         *
         *  In Host mode, this interrupt is not asserted.
         */
        uint32_t gintsts_resetdet:1;
        /** gintsts_prtint : RO; bitpos: [24]; default: 0;
         *  Mode: Host only
         *  Host Port Interrupt (PrtInt)
         *  The core sets this bit to indicate a change in port status of one of the controller
         *  ports in Host mode. The application must read the Host Port Control and Status
         *  (HPRT) register to determine the exact event that caused this interrupt. The
         *  application must clear the appropriate status bit in the Host Port
         *  Control and Status register to clear this bit.
         */
        uint32_t gintsts_prtint:1;
        /** gintsts_hchint : RO; bitpos: [25]; default: 0;
         *  Mode: Host only
         *  Host Channels Interrupt (HChInt)
         *  The core sets this bit to indicate that an interrupt is pending on one of the
         *  channels of the core (in Host mode). The application must read the Host All
         *  Channels Interrupt (HAINT) register to determine the exact number of the channel on
         *  which the interrupt occurred, and Then read the corresponding Host
         *  Channel-n Interrupt (HCINTn) register to determine the exact cause of the
         *  interrupt. The application must clear the appropriate status bit in the HCINTn
         *  register to clear this bit.
         */
        uint32_t gintsts_hchint:1;
        /** gintsts_ptxfemp : RO; bitpos: [26]; default: 1;
         *  Mode: Host only
         *  Periodic TxFIFO Empty (PTxFEmp)
         *  This interrupt is asserted when the Periodic Transmit FIFO is either half or
         *  completely empty and there is space for at least one entry to be written in the
         *  Periodic Request Queue. The half or completely empty status is determined by the
         *  Periodic TxFIFO Empty Level bit in the Core AHB Configuration register
         *  (GAHBCFG.PTxFEmpLvl).
         */
        uint32_t gintsts_ptxfemp:1;
        uint32_t reserved_27:1;
        /** gintsts_conidstschng : R/W; bitpos: [28]; default: 0;
         *  Mode: Host and Device
         *  Connector ID Status Change (ConIDStsChng)
         *  The core sets this bit when there is a change in connector ID status.
         */
        uint32_t gintsts_conidstschng:1;
        /** gintsts_disconnint : R/W; bitpos: [29]; default: 0;
         *  Mode: Host only
         *  Disconnect Detected Interrupt (DisconnInt)
         *  Asserted when a device disconnect is detected.
         */
        uint32_t gintsts_disconnint:1;
        /** gintsts_sessreqint : R/W; bitpos: [30]; default: 0;
         *  Mode: Host and Device
         *  Session Request/New Session Detected Interrupt (SessReqInt)
         *  In Host mode, this interrupt is asserted when a session request is detected from
         *  the device. In Host mode, this interrupt is asserted when a session request is
         *  detected from the device.
         *  In Device mode, this interrupt is asserted when the utmisrp_bvalid signal goes high.
         *  For more information on how to use this interrupt, see 'Partial Power-Down and
         *  Clock Gating Programming Model' in the Programming Guide.
         */
        uint32_t gintsts_sessreqint:1;
        /** gintsts_wkupint : R/W; bitpos: [31]; default: 0;
         *  Mode: Host and Device
         *  Resume/Remote Wakeup Detected Interrupt (WkUpInt)
         *  Wakeup Interrupt during Suspend(L2) or LPM(L1) state.
         *  - During Suspend(L2):
         *  -- Device Mode: This interrupt is asserted only when Host Initiated Resume is
         *  detected on USB.
         *  -- Host Mode: This interrupt is asserted only when Device Initiated Remote Wakeup
         *  is detected on USB.
         *  For more information, see 'Partial Power-Down and Clock Gating Programming Model'
         *  in the Programming Guide.
         *  - During LPM(L1):
         *  -- Device Mode: This interrupt is asserted for either Host Initiated Resume or
         *  Device Initiated Remote Wakeup on USB.
         *  -- Host Mode: This interrupt is asserted for either Host Initiated Resume or Device
         *  Initiated Remote Wakeup on USB.
         *  For more information, see 'LPM Entry and Exit Programming Model' in the Programming
         *  Guide.
         */
        uint32_t gintsts_wkupint:1;
    };
    uint32_t val;
} usb_otghs_gintsts_reg_t;

/** Type of gintsts2 register
 *  This register interrupts the application for system-level events in the current
 *  mode (Device mode or Host mode). Some of the bits in this register are valid only
 *  in Host mode, while others are valid in Device mode only. This register also
 *  indicates the current mode. To clear the interrupt status bits of type R_SS_WC, the
 *  application must write 1'b1 to the bit. The application must clear the GINTSTS2
 *  register at initialization before unmasking the interrupt bit to avoid any
 *  interrupts generated prior to initialization.
 */
typedef union {
    struct {
        /** gintsts2_gintsts2 : R/W; bitpos: [31:0]; default: 0;
         *  Resvered
         */
        uint32_t gintsts2_gintsts2:32;
    };
    uint32_t val;
} usb_otghs_gintsts2_reg_t;


/** Group: This register works with the Interrupt Register (GINTSTS) to interrupt the
 *  application. When an interrupt bit is masked, the interrupt associated with that
 *  bit is not generated. However, the GINTSTS register bit corresponding to that
 *  interrupt is still set.
 */
/** Type of gintmsk register
 *  This register works with the Interrupt Register (GINTSTS) to interrupt the
 *  application. When an interrupt bit is masked, the interrupt associated with that
 *  bit is not generated. However, the GINTSTS register bit corresponding to that
 *  interrupt is still set.  Note: The fields of this register change depending on host
 *  or device mode.
 */
typedef union {
    struct {
        uint32_t reserved_0:1;
        /** gintmsk_modemismsk : R/W; bitpos: [1]; default: 0;
         *  Mode: Host and Device
         *  Mode Mismatch Interrupt Mask (ModeMisMsk)
         */
        uint32_t gintmsk_modemismsk:1;
        /** gintmsk_otgintmsk : R/W; bitpos: [2]; default: 0;
         *  Mode: Host and Device
         *  OTG Interrupt Mask (OTGIntMsk)
         */
        uint32_t gintmsk_otgintmsk:1;
        /** gintmsk_sofmsk : R/W; bitpos: [3]; default: 0;
         *  Mode: Host and Device
         *  Start of (micro)Frame Mask (SofMsk)
         */
        uint32_t gintmsk_sofmsk:1;
        /** gintmsk_rxflvlmsk : R/W; bitpos: [4]; default: 0;
         *  Mode: Host and Device
         *  Receive FIFO Non-Empty Mask (RxFLvlMsk)
         */
        uint32_t gintmsk_rxflvlmsk:1;
        /** gintmsk_nptxfempmsk : R/W; bitpos: [5]; default: 0;
         *  Mode: Host and Device
         *  Non-periodic TxFIFO Empty Mask (NPTxFEmpMsk)
         */
        uint32_t gintmsk_nptxfempmsk:1;
        /** gintmsk_ginnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  Mode: Device only,
         *  Global Non-periodic IN NAK Effective Mask (GINNakEffMsk)
         */
        uint32_t gintmsk_ginnakeffmsk:1;
        /** gintmsk_goutnakeffmsk : R/W; bitpos: [7]; default: 0;
         *  Mode: Device only
         *  Global OUT NAK Effective Mask (GOUTNakEffMsk)
         */
        uint32_t gintmsk_goutnakeffmsk:1;
        uint32_t reserved_8:2;
        /** gintmsk_erlysuspmsk : R/W; bitpos: [10]; default: 0;
         *  Mode: Device only
         *  Early Suspend Mask (ErlySuspMsk)
         */
        uint32_t gintmsk_erlysuspmsk:1;
        /** gintmsk_usbsuspmsk : R/W; bitpos: [11]; default: 0;
         *  Mode: Device only
         *  USB Suspend Mask (USBSuspMsk)
         */
        uint32_t gintmsk_usbsuspmsk:1;
        /** gintmsk_usbrstmsk : R/W; bitpos: [12]; default: 0;
         *  Mode: Device only
         *  USB Reset Mask (USBRstMsk)
         */
        uint32_t gintmsk_usbrstmsk:1;
        /** gintmsk_enumdonemsk : R/W; bitpos: [13]; default: 0;
         *  Mode: Device only
         *  Enumeration Done Mask (EnumDoneMsk)
         */
        uint32_t gintmsk_enumdonemsk:1;
        /** gintmsk_isooutdropmsk : R/W; bitpos: [14]; default: 0;
         *  Mode: Device only
         *  Isochronous OUT Packet Dropped Interrupt Mask (ISOOutDropMsk)
         */
        uint32_t gintmsk_isooutdropmsk:1;
        /** gintmsk_eopfmsk : R/W; bitpos: [15]; default: 0;
         *  Mode: Device only
         *  End of Periodic Frame Interrupt Mask (EOPFMsk)
         */
        uint32_t gintmsk_eopfmsk:1;
        uint32_t reserved_16:1;
        /** gintmsk_epmismsk : R/W; bitpos: [17]; default: 0;
         *  Mode: Device only
         *  Endpoint Mismatch Interrupt Mask (EPMisMsk)
         */
        uint32_t gintmsk_epmismsk:1;
        /** gintmsk_iepintmsk : R/W; bitpos: [18]; default: 0;
         *  Mode: Device only
         *  IN Endpoints Interrupt Mask (IEPIntMsk)
         */
        uint32_t gintmsk_iepintmsk:1;
        /** gintmsk_oepintmsk : R/W; bitpos: [19]; default: 0;
         *  Mode: Device only
         *  OUT Endpoints Interrupt Mask (OEPIntMsk)
         */
        uint32_t gintmsk_oepintmsk:1;
        uint32_t reserved_20:1;
        /** gintmsk_incomplpmsk : R/W; bitpos: [21]; default: 0;
         *  Incomplete Periodic Transfer Mask (incomplPMsk)
         *  Mode: Host only
         *  Incomplete Isochronous OUT Transfer Interrupt Mask (incompISOOUTMsk)
         *  Mode: Device only
         */
        uint32_t gintmsk_incomplpmsk:1;
        /** gintmsk_fetsuspmsk : R/W; bitpos: [22]; default: 0;
         *  Mode: Device only
         *  Data Fetch Suspended Mask (FetSuspMsk)
         */
        uint32_t gintmsk_fetsuspmsk:1;
        /** gintmsk_resetdetmsk : R/W; bitpos: [23]; default: 0;
         *  Mode: Device only
         *  Reset detected Interrupt Mask (ResetDetMsk)
         */
        uint32_t gintmsk_resetdetmsk:1;
        /** gintmsk_prtintmsk : R/W; bitpos: [24]; default: 0;
         *  Mode: Host only
         *  Host Port Interrupt Mask (PrtIntMsk)
         */
        uint32_t gintmsk_prtintmsk:1;
        /** gintmsk_hchintmsk : R/W; bitpos: [25]; default: 0;
         *  Mode: Host only
         *  Host Channels Interrupt Mask (HChIntMsk)
         */
        uint32_t gintmsk_hchintmsk:1;
        /** gintmsk_ptxfempmsk : R/W; bitpos: [26]; default: 0;
         *  Mode: Host only
         *  Periodic TxFIFO Empty Mask (PTxFEmpMsk)
         */
        uint32_t gintmsk_ptxfempmsk:1;
        uint32_t reserved_27:1;
        /** gintmsk_conidstschngmsk : R/W; bitpos: [28]; default: 0;
         *  Mode: Host and Device
         *  Connector ID Status Change Mask (ConIDStsChngMsk)
         */
        uint32_t gintmsk_conidstschngmsk:1;
        /** gintmsk_disconnintmsk : R/W; bitpos: [29]; default: 0;
         *  Mode: Host and Device
         *  Disconnect Detected Interrupt Mask (DisconnIntMsk)
         */
        uint32_t gintmsk_disconnintmsk:1;
        /** gintmsk_sessreqintmsk : R/W; bitpos: [30]; default: 0;
         *  Mode: Host and Device
         *  Session Request/New Session Detected Interrupt Mask (SessReqIntMsk)
         */
        uint32_t gintmsk_sessreqintmsk:1;
        /** gintmsk_wkupintmsk : R/W; bitpos: [31]; default: 0;
         *  Mode: Host and Device
         *  Resume/Remote Wakeup Detected Interrupt Mask (WkUpIntMsk)
         *  The WakeUp bit is used for LPM state wake up in a way similar to that of wake up in
         *  suspend state.
         */
        uint32_t gintmsk_wkupintmsk:1;
    };
    uint32_t val;
} usb_otghs_gintmsk_reg_t;


/** Group: A read to the Receive Status Debug Read register returns the contents of the
 *  top of the Receive FIFO.
 */
/** Type of grxstsr register
 *  A read to the Receive Status Debug Read register returns the contents of the top of
 *  the Receive FIFO.  The receive status contents must be interpreted differently in
 *  Host and Device modes. The core ignores the receive status read when the receive
 *  FIFO is empty and returns a value of 32'h0000_0000.  Note:  - Use of these fields
 *  vary based on whether the core is functioning as a host or a device.  - Do not read
 *  this register's reset value before configuring the core because the read value is
 *  'X' in the simulation.
 */
typedef union {
    struct {
        /** grxstsr_chnum : RO; bitpos: [3:0]; default: 0;
         *  Channel Number (ChNum)
         *  Mode: Host only
         *  Indicates the channel number to which the current received packet belongs.
         *  Endpoint Number (EPNum)
         *  Mode: Device only
         *  Indicates the endpoint number to which the current received packet belongs.
         */
        uint32_t grxstsr_chnum:4;
        /** grxstsr_bcnt : RO; bitpos: [14:4]; default: 0;
         *  Byte Count (BCnt)
         *
         *  In host mode, indicates the byte count of the received IN data packet.
         *
         *  In device mode, indicates the byte count of the received data packet.
         */
        uint32_t grxstsr_bcnt:11;
        /** grxstsr_dpid : RO; bitpos: [16:15]; default: 0;
         *  Data PID (DPID)
         *
         *  In host mode, indicates the Data PID of the received packet. In device mode,
         *  indicates the Data PID of the received OUT data packet.
         *  - 2'b00: DATA0
         *  - 2'b10: DATA1
         *  - 2'b01: DATA2
         *  - 2'b11: MDATA
         *  Reset: 2'h0
         */
        uint32_t grxstsr_dpid:2;
        /** grxstsr_pktsts : RO; bitpos: [20:17]; default: 0;
         *  Packet Status (PktSts) indicates the status of the received packet.
         *  In host mode,
         *  - 4'b0010: IN data packet received
         *  - 4'b0011: IN transfer completed (triggers an interrupt)
         *  - 4'b0101: Data toggle error (triggers an interrupt)
         *  - 4'b0111: Channel halted (triggers an interrupt)
         *  - Others: Reserved
         *  Reset:4'b0
         *
         *  In device mode,
         *  - 4'b0001: Global OUT NAK (triggers an interrupt)
         *  - 4'b0010: OUT data packet received
         *  - 4'b0011: OUT transfer completed (triggers an interrupt)
         *  - 4'b0100: SETUP transaction completed (triggers an interrupt)
         *  - 4'b0110: SETUP data packet received
         *  - Others: Reserved
         *  Reset:4'h0
         */
        uint32_t grxstsr_pktsts:4;
        /** grxstsr_fn : RO; bitpos: [24:21]; default: 0;
         *  Mode: Device only
         *  Frame Number (FN)
         *  This is the least significant 4 bits of the (micro)Frame number in which the packet
         *  is received on the USB. This field is supported only when isochronous OUT endpoints
         *  are supported.
         */
        uint32_t grxstsr_fn:4;
        uint32_t reserved_25:7;
    };
    uint32_t val;
} usb_otghs_grxstsr_reg_t;


/** Group: A read to the Receive Status Read and Pop register returns the contents of
 *  the top of the Receive FIFO and additionally pops the top data entry out of the
 *  RxFIFO.
 */
/** Type of grxstsp register
 *  A read to the Receive Status Read and Pop register returns the contents of the top
 *  of the Receive FIFO and additionally pops the top data entry out of the RxFIFO. The
 *  receive status contents must be interpreted differently in Host and Device modes.
 *  The core ignores the receive status pop/read when the receive FIFO is empty and
 *  returns a value of 32'h0000_0000. The application must only pop the Receive Status
 *  FIFO when the Receive FIFO Non-Empty bit of the Core Interrupt register
 *  (GINTSTS.RxFLvl) is asserted.  Note:  - Use of these fields vary based on whether
 *  the core is functioning as a host or a device.  - Do not read this register's reset
 *  value before configuring the core because the read value is 'X' in the simulation.
 */
typedef union {
    struct {
        /** grxstsp_chnum : RO; bitpos: [3:0]; default: 0;
         *  Channel Number (ChNum)
         *  Mode: Host only
         *  Indicates the channel number to which the current received packet belongs.
         *  Endpoint Number (EPNum)
         *  Mode: Device only
         *  Indicates the endpoint number to which the current received packet belongs.
         */
        uint32_t grxstsp_chnum:4;
        /** grxstsp_bcnt : RO; bitpos: [14:4]; default: 0;
         *  Byte Count (BCnt)
         *
         *  In host mode, indicates the byte count of the received IN data packet.
         *
         *  In device mode, indicates the byte count of the received data packet.
         */
        uint32_t grxstsp_bcnt:11;
        /** grxstsp_dpid : RO; bitpos: [16:15]; default: 0;
         *  Data PID (DPID)
         *
         *  In host mode, indicates the Data PID of the received packet. In device mode,
         *  indicates the Data PID of the received OUT data packet.
         *  - 2'b00: DATA0
         *  - 2'b10: DATA1
         *  - 2'b01: DATA2
         *  - 2'b11: MDATA
         *  Reset: 2'h0
         */
        uint32_t grxstsp_dpid:2;
        /** grxstsp_pktsts : RO; bitpos: [20:17]; default: 0;
         *  Packet Status (PktSts) indicates the status of the received packet.
         *  In host mode,
         *  - 4'b0010: IN data packet received
         *  - 4'b0011: IN transfer completed (triggers an interrupt)
         *  - 4'b0101: Data toggle error (triggers an interrupt)
         *  - 4'b0111: Channel halted (triggers an interrupt)
         *  - Others: Reserved
         *  Reset:4'b0
         *
         *  In device mode,
         *  - 4'b0001: Global OUT NAK (triggers an interrupt)
         *  - 4'b0010: OUT data packet received
         *  - 4'b0011: OUT transfer completed (triggers an interrupt)
         *  - 4'b0100: SETUP transaction completed (triggers an interrupt)
         *  - 4'b0110: SETUP data packet received
         *  - Others: Reserved
         *  Reset:4'h0
         */
        uint32_t grxstsp_pktsts:4;
        /** grxstsp_fn : RO; bitpos: [24:21]; default: 0;
         *  Mode: Device only
         *  Frame Number (FN)
         *  This is the least significant 4 bits of the (micro)Frame number in which the packet
         *  is received on the USB. This field is supported only when isochronous OUT endpoints
         *  are supported.
         */
        uint32_t grxstsp_fn:4;
        uint32_t reserved_25:7;
    };
    uint32_t val;
} usb_otghs_grxstsp_reg_t;


/** Group: The application can program the RAM size that must be allocated to the
 *  RxFIFO.
 */
/** Type of grxfsiz register
 *  The application can program the RAM size that must be allocated to the RxFIFO.
 */
typedef union {
    struct {
        /** grxfsiz_rxfdep : R/W; bitpos: [10:0]; default: 1024;
         *  Mode: Host and Device
         *  RxFIFO Depth (RxFDep)
         *  This value is in terms of 32-bit words.
         *  - Minimum value is 16
         *  - Maximum value is 32,768
         *  The power-on reset value of this register is specified as the Largest Rx Data FIFO
         *  Depth during configuration.
         *  If Enable Dynamic FIFO Sizing is selected in coreConsultant, these flops are
         *  optimized, and reads return the power-on value.
         *  If Enable Dynamic FIFO Sizing is selected in coreConsultant, you can write a new
         *  value in this field. Programmed values must not exceed the power-on value.
         */
        uint32_t grxfsiz_rxfdep:11;
        uint32_t reserved_11:21;
    };
    uint32_t val;
} usb_otghs_grxfsiz_reg_t;


/** Group: The application can program the RAM size and the memory start address for
 *  the Non-periodic TxFIFO
 */
/** Type of gnptxfsiz register
 *  The application can program the RAM size and the memory start address for the
 *  Non-periodic TxFIFO  Note: The fields of this register change depending on host or
 *  device mode.
 */
typedef union {
    struct {
        /** gnptxfsiz_nptxfstaddr : R/W; bitpos: [10:0]; default: 1024;
         *  Non-periodic Transmit RAM Start Address (NPTxFStAddr)
         *  For host mode, this field is always valid.
         *  This field contains the memory start address for Non-periodic Transmit FIFO RAM.
         *  - This field is determined during coreConsultant configuration by Enable Dynamic
         *  FIFO Sizing? (OTG_DFIFO_DYNAMIC):OTG_DFIFO_DYNAMIC = 0
         *  These flops are optimized, and reads return the power-on value.
         *  - OTG_DFIFO_DYNAMIC = 1 The application can write a new value in this field.
         *  Programmed values must not exceed the power-on value set in coreConsultant.
         *  Programmed values must not exceed the power-on value set in coreConsultant.
         *  The power-on reset value of this field is specified during coreConsultant
         *  configuration by Largest Rx Data FIFO Depth (parameter OTG_RX_DFIFO_DEPTH).
         */
        uint32_t gnptxfsiz_nptxfstaddr:11;
        uint32_t reserved_11:5;
        /** gnptxfsiz_nptxfdep : R/W; bitpos: [26:16]; default: 1024;
         *  Mode: Host only
         *  Non-periodic TxFIFO Depth (NPTxFDep)
         *  For host mode, this field is always valid.
         *  For device mode, this field is valid only when OTG_EN_DED_TX_FIFO=0.
         *  This value is in terms of 32-bit words.
         *  - Minimum value is 16
         *  - Maximum value is 32,768
         *  This attribute of field is determined during coreConsultant configuration by Enable
         *  Dynamic FIFO Sizing? (OTG_DFIFO_DYNAMIC):
         *  - OTG_DFIFO_DYNAMIC = 0: These flops are optimized, and reads return the power-on
         *  value.
         *  - OTG_DFIFO_DYNAMIC = 1: The application can write a new value in this field.
         *  Programmed values must not exceed the power-on value set in coreConsultant.
         *  The power-on reset value of this field is specified during coreConsultant
         *  configuration as Largest IN Endpoint FIFO 0 Depth (parameter
         *  OTG_TX_DINEP_DFIFO_DEPTH_0).
         */
        uint32_t gnptxfsiz_nptxfdep:11;
        uint32_t reserved_27:5;
    };
    uint32_t val;
} usb_otghs_gnptxfsiz_reg_t;


/** Group: In Device mode, this register is valid only in Shared FIFO operation. */
/** Type of gnptxsts register
 *  In Device mode, this register is valid only in Shared FIFO operation. This
 *  read-only register contains the free space information for the Non-periodic TxFIFO
 *  and the Non-periodic Transmit Request Queue.
 */
typedef union {
    struct {
        /** gnptxsts_nptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  Non-periodic TxFIFO Space Avail (NPTxFSpcAvail)
         *  Indicates the amount of free space available in the Non-periodic TxFIFO.
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Non-periodic TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0 <= n <= 32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  Reset: Configurable
         */
        uint32_t gnptxsts_nptxfspcavail:16;
        /** gnptxsts_nptxqspcavail : RO; bitpos: [23:16]; default: 8;
         *  Non-periodic Transmit Request Queue Space Available (NPTxQSpcAvail)
         *  Indicates the amount of free space available in the Non-periodic Transmit Request
         *  Queue. This queue holds both IN and OUT requests in Host mode. Device mode has only
         *  IN requests.
         *  - 8'h0: Non-periodic Transmit Request Queue is full
         *  - 8'h1: 1 location available
         *  - 8'h2: 2 locations available
         *  - n: n locations available (0 <= n <= 8)
         *  - Others: Reserved
         *  Reset: Configurable
         */
        uint32_t gnptxsts_nptxqspcavail:8;
        /** gnptxsts_nptxqtop : RO; bitpos: [30:24]; default: 0;
         *  Top of the Non-periodic Transmit Request Queue (NPTxQTop)
         *  Entry in the Non-periodic Tx Request Queue that is currently being processed by the
         *  MAC.
         *
         *  - Bits [30:27]: Channel/endpoint number
         *  - Bits [26:25]:
         *  - 2'b00: IN/OUT token
         *  -- 2'b01: Zero-length transmit packet (device IN/host OUT)
         *  -- 2'b10: PING/CSPLIT token
         *  -- 2'b11: Channel halt command
         *  - Bit [24]: Terminate (last Entry for selected channel/endpoint)
         *  Reset: 7'h0
         */
        uint32_t gnptxsts_nptxqtop:7;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_gnptxsts_reg_t;


/** Group: The application can use this register to access PHY registers. It is
 *  implemented only if Enable PHY Vendor Control Interface was selected during
 *  coreConsultant configuration (parameter OTG_VENDOR_CTL_INTERFACE = 1). For a UTMI+
 *  PHY, the DWC_otg core uses the UTMI+ Vendor Control interface for PHY register
 *  access. For a ULPI PHY, the core uses the ULPI interface for PHY register access.
 *  The application sets Vendor Control register for PHY register access and times the
 *  PHY register access. The application polls the VStatus Done bit in this register
 *  for the completion of the PHY register access.
 */
/** Type of gpvndctl register
 *  The application can use this register to access PHY registers. It is implemented
 *  only if Enable PHY Vendor Control Interface was selected during coreConsultant
 *  configuration (parameter OTG_VENDOR_CTL_INTERFACE = 1). For a UTMI+ PHY, the
 *  DWC_otg core uses the UTMI+ Vendor Control interface for PHY register access. For a
 *  ULPI PHY, the core uses the ULPI interface for PHY register access. The application
 *  sets Vendor Control register for PHY register access and times the PHY register
 *  access. The application polls the VStatus Done bit in this register for the
 *  completion of the PHY register access.
 */
typedef union {
    struct {
        /** gpvndctl_regdata : R/W; bitpos: [7:0]; default: 0;
         *  Register Data (RegData)
         *
         *  Contains the write data for register write.
         *
         *  Read data for register read, valid when VStatus Done is set.
         */
        uint32_t gpvndctl_regdata:8;
        /** gpvndctl_vctrl : R/W; bitpos: [15:8]; default: 0;
         *
         *  UTMI+ Vendor Control Register Address (VCtrl)
         *  The 4-bit register address a vendor defined 4-bit parallel
         *  output bus. Bits 11:8 of this field are placed on
         *  utmi_vcontrol[3:0].
         *  ULPI Extended Register Address (ExtRegAddr)
         *  The 6-bit PHY extended register address.
         */
        uint32_t gpvndctl_vctrl:8;
        /** gpvndctl_regaddr : R/W; bitpos: [21:16]; default: 0;
         *  Register Address (RegAddr)
         *
         *  The 6-bit PHY register address for immediate PHY Register set access. Set to 6'h2F
         *  for Extended PHY Register set access.
         */
        uint32_t gpvndctl_regaddr:6;
        /** gpvndctl_regwr : R/W; bitpos: [22]; default: 0;
         *
         *  Register Write (RegWr)
         *  Set this bit for register writes, and clear it for register reads.
         */
        uint32_t gpvndctl_regwr:1;
        uint32_t reserved_23:2;
        /** gpvndctl_newregreq : R/W; bitpos: [25]; default: 0;
         *
         *  New Register Request (NewRegReq)
         *
         *  The application sets this bit for a new vendor control
         *  access.
         */
        uint32_t gpvndctl_newregreq:1;
        /** gpvndctl_vstsbsy : RO; bitpos: [26]; default: 0;
         *
         *  VStatus Busy (VStsBsy)
         *
         *  The core sets this bit when the vendor control access is in
         *  progress and clears this bit when done.
         */
        uint32_t gpvndctl_vstsbsy:1;
        /** gpvndctl_vstsdone : R/W; bitpos: [27]; default: 0;
         *
         *  VStatus Done (VStsDone)
         *
         *  The core sets this bit when the vendor control access is
         *  done.
         *  This bit is cleared by the core when the application sets the
         *  New Register Request bit (bit 25).
         */
        uint32_t gpvndctl_vstsdone:1;
        uint32_t reserved_28:3;
        /** gpvndctl_disulpidrvr : R/W; bitpos: [31]; default: 0;
         *
         *  Disable ULPI Drivers (DisUlpiDrvr)
         *
         *  The application sets this bit when it has finished processing
         *  the ULPI Carkit Interrupt (GINTSTS.ULPICKINT). When
         *  set, the controller disables drivers for output signals
         *  and masks input signal for the ULPI interface. The controller clears this bit
         *  before enabling the ULPI interface.
         */
        uint32_t gpvndctl_disulpidrvr:1;
    };
    uint32_t val;
} usb_otghs_gpvndctl_reg_t;


/** Group: This read-only register contains the release number of the core being used. */
/** Type of gsnpsid register
 *  This read-only register contains the release number of the core being used.
 */
typedef union {
    struct {
        /** gsnpsid_synopsysid : RO; bitpos: [31:0]; default: 1330922250;
         *  Release number of the controller being used currently.
         *
         *  Bits [31:16]:
         *  - 0x4f54: ASCII Value for OT
         *  Bits [15:0]: Current Release Number. For example, 0x400a corresponds to v4.00a
         *  Release number.
         */
        uint32_t gsnpsid_synopsysid:32;
    };
    uint32_t val;
} usb_otghs_gsnpsid_reg_t;


/** Group: This register contains the logical endpoint direction(s) selected using
 *  coreConsultant.
 */
/** Type of ghwcfg1 register
 *  This register contains the logical endpoint direction(s) selected using
 *  coreConsultant.
 */
typedef union {
    struct {
        /** ghwcfg1_epdir : RO; bitpos: [31:0]; default: 0;
         *  This 32-bit field uses two bits per
         *  endpoint to determine the endpoint direction.
         *
         *  Endpoint
         *  - Bits [31:30]: Endpoint 15 direction
         *  - Bits [29:28]: Endpoint 14 direction
         *  ...
         *  - Bits [3:2]: Endpoint 1 direction
         *  - Bits[1:0]: Endpoint 0 direction (always BIDIR)
         *  Direction
         *  - 2'b00: BIDIR (IN and OUT) endpoint
         *  - 2'b01: IN endpoint
         *  - 2'b10: OUT endpoint
         *  - 2'b11: Reserved
         *  Note: This field is configured using the OTG_EP_DIR_1(n) parameter.
         */
        uint32_t ghwcfg1_epdir:32;
    };
    uint32_t val;
} usb_otghs_ghwcfg1_reg_t;


/** Group: This register contains configuration options selected using coreConsultant. */
/** Type of ghwcfg2 register
 *  This register contains configuration options selected using coreConsultant.
 */
typedef union {
    struct {
        /** ghwcfg2_otgmode : RO; bitpos: [2:0]; default: 2;
         *  Mode of Operation (OtgMode)
         *  - 3'b000: HNP- and SRP-Capable OTG (Host & Device)
         *  - 3'b001: SRP-Capable OTG (Host & Device)
         *  - 3'b010: Non-HNP and Non-SRP Capable OTG (Host and Device)
         *  - 3'b011: SRP-Capable Device
         *  - 3'b100: Non-OTG Device
         *  - 3'b101: SRP-Capable Host
         *  - 3'b110: Non-OTG Host
         *  - Others: Reserved
         *  Note: This field is configured using the OTG_MODE parameter.
         */
        uint32_t ghwcfg2_otgmode:3;
        /** ghwcfg2_otgarch : RO; bitpos: [4:3]; default: 2;
         *  Architecture (OtgArch)
         *  - 2'b00: Slave-Only
         *  - 2'b01: External DMA
         *  - 2'b10: Internal DMA
         *  - Others: Reserved
         *  Note: This field is configured using the OTG_ARCHITECTURE parameter.
         */
        uint32_t ghwcfg2_otgarch:2;
        /** ghwcfg2_singpnt : RO; bitpos: [5]; default: 0;
         *  Point-to-Point (SingPnt)
         *  - 1'b0: Multi-point application  (hub and split support)
         *  - 1'b1: Single-point application (no hub and split support)
         *  Note: This field is configured using the OTG_SINGLE_POINT parameter.
         */
        uint32_t ghwcfg2_singpnt:1;
        /** ghwcfg2_hsphytype : RO; bitpos: [7:6]; default: 3;
         *  High-Speed PHY Interface Type (HSPhyType)
         *  - 2'b00: High-Speed interface not supported
         *  - 2'b01: UTMI+
         *  - 2'b10: ULPI
         *  - 2'b11: UTMI+ and ULPI
         *  Note: This field is configured using the OTG_HSPHY_INTERFACE parameter.
         */
        uint32_t ghwcfg2_hsphytype:2;
        /** ghwcfg2_fsphytype : RO; bitpos: [9:8]; default: 2;
         *  Full-Speed PHY Interface Type (FSPhyType)
         *  - 2'b00: Full-speed interface not supported
         *  - 2'b01: Dedicated full-speed interface
         *  - 2'b10: FS pins shared with UTMI+ pins
         *  - 2'b11: FS pins shared with ULPI pins
         *  Note: This field is configured using the OTG_FSPHY_INTERFACE parameter.
         */
        uint32_t ghwcfg2_fsphytype:2;
        /** ghwcfg2_numdeveps : RO; bitpos: [13:10]; default: 15;
         *  Number of Device Endpoints (NumDevEps)
         *
         *  Indicates the number of device endpoints supported by the core in Device mode.
         *
         *  The range of this field is 0-15.
         *
         *  Note: This field is configured using the OTG_NUM_EPS parameter.
         */
        uint32_t ghwcfg2_numdeveps:4;
        /** ghwcfg2_numhstchnl : RO; bitpos: [17:14]; default: 15;
         *  Number of Host Channels (NumHstChnl)
         *  Indicates the number of host channels supported by the core in Host mode. The range
         *  of this field is 0-15: 0 specifies 1 channel, 15 specifies 16 channels.
         *
         *  Note: This field is configured using the OTG_NUM_HOST_CHAN parameter.
         */
        uint32_t ghwcfg2_numhstchnl:4;
        /** ghwcfg2_periosupport : RO; bitpos: [18]; default: 1;
         *  Periodic OUT Channels Supported in Host Mode (PerioSupport)
         *  - 1'b0: No
         *  - 1'b1: Yes
         *  Note: This field is configured using the OTG_EN_PERIO_HOST parameter.
         */
        uint32_t ghwcfg2_periosupport:1;
        /** ghwcfg2_dynfifosizing : RO; bitpos: [19]; default: 1;
         *  Dynamic FIFO Sizing Enabled (DynFifoSizing)
         *  - 1'b0: No
         *  - 1'b1: Yes
         *  Note: This field is configured using the OTG_DFIFO_DYNAMIC parameter.
         */
        uint32_t ghwcfg2_dynfifosizing:1;
        /** ghwcfg2_multiprocintrpt : RO; bitpos: [20]; default: 1;
         *  Multi Processor Interrupt Enabled (MultiProcIntrpt)
         *  - 1'b0: No
         *  - 1'b1: Yes
         *  Note: This field is configured using the OTG_MULTI_PROC_INTRPT parameter.
         */
        uint32_t ghwcfg2_multiprocintrpt:1;
        uint32_t reserved_21:1;
        /** ghwcfg2_nptxqdepth : RO; bitpos: [23:22]; default: 2;
         *  Non-periodic Request Queue Depth (NPTxQDepth)
         *  - 2'b00: 2
         *  - 2'b01: 4
         *  - 2'b10: 8
         *  - Others: Reserved
         *  Note: This field is configured using the OTG_NPERIO_TX_QUEUE_DEPTH parameter.
         */
        uint32_t ghwcfg2_nptxqdepth:2;
        /** ghwcfg2_ptxqdepth : RO; bitpos: [25:24]; default: 3;
         *  Host Mode Periodic Request Queue Depth (PTxQDepth)
         *  - 2'b00: 2
         *  - 2'b01: 4
         *  - 2'b10: 8
         *  - 2'b11:16
         *  Note: This field is configured using the OTG_PERIO_TX_QUEUE_DEPTH parameter.
         */
        uint32_t ghwcfg2_ptxqdepth:2;
        /** ghwcfg2_tknqdepth : RO; bitpos: [30:26]; default: 8;
         *  Device Mode IN Token Sequence Learning Queue Depth (TknQDepth)
         *  Range: 0-30
         *
         *  Note: This field is configured using the OTG_TOKEN_QUEUE_DEPTH parameter.
         */
        uint32_t ghwcfg2_tknqdepth:5;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_ghwcfg2_reg_t;

/** Type of ghwcfg3 register
 *  This register contains configuration options selected using coreConsultant.
 */
typedef union {
    struct {
        /** ghwcfg3_xfersizewidth : RO; bitpos: [3:0]; default: 8;
         *  Width of Transfer Size Counters (XferSizeWidth)
         *  - 4'b0000: 11 bits
         *  - 4'b0001: 12 bits
         *  ...
         *  - 4'b1000: 19 bits
         *  - Others: Reserved
         *  Note: This field is configured using the OTG_PACKET_COUNT_WIDTH parameter.
         */
        uint32_t ghwcfg3_xfersizewidth:4;
        /** ghwcfg3_pktsizewidth : RO; bitpos: [6:4]; default: 6;
         *  Width of Packet Size Counters (PktSizeWidth)
         *  - 3'b000: 4 bits
         *  - 3'b001: 5 bits
         *  - 3'b010: 6 bits
         *  - 3'b011: 7 bits
         *  - 3'b100: 8 bits
         *  - 3'b101: 9 bits
         *  - 3'b110: 10 bits
         *  - Others: Reserved
         *  Note: This field is configured using the OTG_PACKET_COUNT_WIDTH parameter.
         */
        uint32_t ghwcfg3_pktsizewidth:3;
        /** ghwcfg3_otgen : RO; bitpos: [7]; default: 1;
         *  OTG Function Enabled (OtgEn)
         *
         *  The application uses this bit to indicate the OTG capabilities of the controller .
         *  - 1'b0: Not OTG capable
         *  - 1'b1: OTG Capable
         *  Note: This field is configured using the OTG_MODE parameter.
         */
        uint32_t ghwcfg3_otgen:1;
        /** ghwcfg3_i2cintsel : RO; bitpos: [8]; default: 0;
         *  I2C Selection (I2CIntSel)
         *  - 1'b0: I2C Interface is not available on the controller.
         *  - 1'b1: I2C Interface is available on the controller.
         *  Note: This field is configured using the OTG_I2C_INTERFACE parameter.
         */
        uint32_t ghwcfg3_i2cintsel:1;
        /** ghwcfg3_vndctlsupt : RO; bitpos: [9]; default: 1;
         *  Vendor Control Interface Support (VndctlSupt)
         *  - 1'b0: Vendor Control Interface is not available on the core.
         *  - 1'b1: Vendor Control Interface is available.
         *  Note: This field is configured using the OTG_VENDOR_CTL_INTERFACE parameter.
         */
        uint32_t ghwcfg3_vndctlsupt:1;
        /** ghwcfg3_optfeature : RO; bitpos: [10]; default: 1;
         *  Optional Features Removed (OptFeature)
         *  Indicates whether the User ID register, GPIO interface ports, and SOF toggle and
         *  counter ports were removed for gate count optimization by enabling Remove Optional
         *  Features.
         *  - 1'b0: No
         *  - 1'b1: Yes
         *  Note: This field is configured using the OTG_RM_OPT_FEATURES parameter.
         */
        uint32_t ghwcfg3_optfeature:1;
        /** ghwcfg3_rsttype : RO; bitpos: [11]; default: 0;
         *  Reset Style for Clocked always Blocks in RTL (RstType)
         *  - 1'b0: Asynchronous reset is used in the controller
         *  - 1'b1: Synchronous reset is used in the controller
         *  Note: This field is configured using the OTG_SYNC_RESET_TYPE parameter.
         */
        uint32_t ghwcfg3_rsttype:1;
        /** ghwcfg3_adpsupport : RO; bitpos: [12]; default: 0;
         *  This bit indicates whether ADP logic is present within or external to the controller
         *  - 0: No ADP logic present with the controller
         *  - 1: ADP logic is present along with the controller.
         */
        uint32_t ghwcfg3_adpsupport:1;
        /** ghwcfg3_hsicmode : RO; bitpos: [13]; default: 0;
         *  HSIC mode specified for Mode of Operation
         *  Value Range: 0 - 1
         *  - 1: HSIC-capable with shared UTMI PHY interface
         *  - 0: Non-HSIC-capable
         */
        uint32_t ghwcfg3_hsicmode:1;
        /** ghwcfg3_bcsupport : RO; bitpos: [14]; default: 1;
         *  This bit indicates the controller support for Battery Charger.
         *  - 0 - No Battery Charger Support
         *  - 1 - Battery Charger support present
         */
        uint32_t ghwcfg3_bcsupport:1;
        /** ghwcfg3_lpmmode : RO; bitpos: [15]; default: 0;
         *  LPM mode specified for Mode of Operation.
         */
        uint32_t ghwcfg3_lpmmode:1;
        /** ghwcfg3_dfifodepth : RO; bitpos: [31:16]; default: 896;
         *  DFIFO Depth (DfifoDepth - EP_LOC_CNT)
         *
         *  This value is in terms of 32-bit words.
         *  - Minimum value is 32
         *  - Maximum value is 32,768
         *  Note: This field is configured using the OTG_DFIFO_DEPTH parameter. For more
         *  information on EP_LOC_CNT, see the Endpoint Information Controller (EPINFO_CTL)
         *  section.
         */
        uint32_t ghwcfg3_dfifodepth:16;
    };
    uint32_t val;
} usb_otghs_ghwcfg3_reg_t;

/** Type of ghwcfg4 register
 *  This register contains configuration options selected using coreConsultant. Note:
 *  Bit [31] is available only when Scatter/Gather DMA mode is enabled. When
 *  Scatter/Gather DMA mode is disabled, this field is reserved.
 */
typedef union {
    struct {
        /** ghwcfg4_numdevperioeps : RO; bitpos: [3:0]; default: 0;
         *  Number of Device Mode Periodic IN Endpoints (NumDevPerioEps)
         *
         *  Range: 0-15
         */
        uint32_t ghwcfg4_numdevperioeps:4;
        /** ghwcfg4_partialpwrdn : RO; bitpos: [4]; default: 1;
         *  Enable Partial Power Down (PartialPwrDn)
         *  - 1'b0: Partial Power Down Not Enabled
         *  - 1'b1: Partial Power Down Enabled
         */
        uint32_t ghwcfg4_partialpwrdn:1;
        /** ghwcfg4_ahbfreq : RO; bitpos: [5]; default: 1;
         *  Minimum AHB Frequency Less Than 60 MHz (AhbFreq)
         *  - 1'b0: No
         *  - 1'b1: Yes
         */
        uint32_t ghwcfg4_ahbfreq:1;
        /** ghwcfg4_hibernation : RO; bitpos: [6]; default: 0;
         *  Enable Hibernation (Hibernation)
         *  - 1'b0: Hibernation feature not enabled
         *  - 1'b1: Hibernation feature enabled
         */
        uint32_t ghwcfg4_hibernation:1;
        /** ghwcfg4_extendedhibernation : RO; bitpos: [7]; default: 0;
         *  Enable Hibernation
         *  - 1'b0: Extended Hibernation feature not enabled
         *  - 1'b1: Extended Hibernation feature enabled
         */
        uint32_t ghwcfg4_extendedhibernation:1;
        uint32_t reserved_8:1;
        /** ghwcfg4_enhancedlpmsupt1 : RO; bitpos: [9]; default: 1;
         *  Enhanced LPM Support1 (EnhancedLPMSupt1)
         *  - This bit indicates that the controller supports L1 entry based on FIFO status.
         *  - Accept L1 Request even if Bulk/Interrupt TxFIFO is not empty.
         */
        uint32_t ghwcfg4_enhancedlpmsupt1:1;
        /** ghwcfg4_servintflow : RO; bitpos: [10]; default: 0;
         *  Service Interval Flow
         *
         *  This bit indicates that the controller supports Service-Interval based scheduling
         *  flow for ISOC IN EPs.
         */
        uint32_t ghwcfg4_servintflow:1;
        /** ghwcfg4_ipgisocsupt : RO; bitpos: [11]; default: 1;
         *  Interpacket Gap ISOC OUT Worst-case Support (ipgisocSupt)
         *
         *  This bit indicates that the controller supports the worst-case scenario of Rx
         *  followed by Rx Inter Packet Gap (IPG) (32-bit times) as per the UTMI Specification
         *  for any token following an ISOC OUT token. Without this support, when any token
         *  follows an ISOC OUT token with the worst-case IPG, the controller does not detect
         *  the followed token. The worst-case IPG of the controller without this support
         *  depends on the AHB and PHY clock frequency.By default IPG Support is enabled.
         */
        uint32_t ghwcfg4_ipgisocsupt:1;
        /** ghwcfg4_acgsupt : RO; bitpos: [12]; default: 0;
         *  Active Clock Gating Support
         *
         *  This bit indicates that the controller supports the Dynamic (Switching) Power
         *  Reduction during periods
         *  when there is no USB and AHB Traffic.
         *  - 1'b0:  Active Clock Gating is not enabled.
         *  - 1'b1:  Active Clock Gating Enabled.
         */
        uint32_t ghwcfg4_acgsupt:1;
        /** ghwcfg4_enhancedlpmsupt : RO; bitpos: [13]; default: 1;
         *  Enhanced LPM Support (EnhancedLPMSupt)
         *
         *  This bit indicates that the controller supports the following behavior:
         *  L1 Entry Behavior based on FIFO Status
         *  - TX FIFO
         *  - Accept L1 Request even if ISOC IN TX FIFO is not empty.
         *  - Reject L1 Request if Non-Periodic TX FIFO is not empty.
         *  - Ensure application can flush the TX FIFO while the Controller is in L1.
         *  - RX FIFO
         *  - Accept L1 Request even if RX FIFO (common to Periodic and Non-Periodic) is not
         *  empty.
         *  - Accept L1 Request but delay SLEEPM assertion until RX SINK Buffer is empty.
         *
         *  Prevent L1 Entry if a Control Transfer is in progress on any Control Endpoint.
         *  Ability to Flush TxFIFO even if PHY Clock is gated.
         *
         */
        uint32_t ghwcfg4_enhancedlpmsupt:1;
        /** ghwcfg4_phydatawidth : RO; bitpos: [15:14]; default: 2;
         *  UTMI+ PHY/ULPI-to-Internal UTMI+ Wrapper Data Width
         *  (PhyDataWidth)<vr>When a ULPI PHY is used, an internal wrapper converts ULPI to
         *  UTMI+.
         *  - 2'b00: 8 bits
         *  - 2'b01: 16 bits
         *  - 2'b10: 8/16 bits, software selectable
         *  - Others: Reserved
         */
        uint32_t ghwcfg4_phydatawidth:2;
        /** ghwcfg4_numctleps : RO; bitpos: [19:16]; default: 1;
         *  Number of Device Mode Control Endpoints in Addition to
         *  Endpoint 0 (NumCtlEps)
         *  Range: 0-15
         */
        uint32_t ghwcfg4_numctleps:4;
        /** ghwcfg4_iddgfltr : RO; bitpos: [20]; default: 1;
         *  IDDIG Filter Enable (IddgFltr)
         *  - 1'b0: No filter
         *  - 1'b1: Filter
         */
        uint32_t ghwcfg4_iddgfltr:1;
        /** ghwcfg4_vbusvalidfltr : RO; bitpos: [21]; default: 0;
         *  VBUS Valid Filter Enabled (VBusValidFltr)
         *  - 1'b0: No filter
         *  - 1'b1: Filter
         */
        uint32_t ghwcfg4_vbusvalidfltr:1;
        /** ghwcfg4_avalidfltr : RO; bitpos: [22]; default: 0;
         *  a_valid Filter Enabled (AValidFltr)
         *  - 1'b0: No filter
         *  - 1'b1: Filter
         */
        uint32_t ghwcfg4_avalidfltr:1;
        /** ghwcfg4_bvalidfltr : RO; bitpos: [23]; default: 0;
         *  b_valid Filter Enabled (BValidFltr)
         *  - 1'b0: No filter
         *  - 1'b1: Filter
         */
        uint32_t ghwcfg4_bvalidfltr:1;
        /** ghwcfg4_sessendfltr : RO; bitpos: [24]; default: 0;
         *  session_end Filter Enabled (SessEndFltr)
         *  - 1'b0: No filter
         *  - 1'b1: Filter
         */
        uint32_t ghwcfg4_sessendfltr:1;
        /** ghwcfg4_dedfifomode : RO; bitpos: [25]; default: 1;
         *  Enable Dedicated Transmit FIFO for device IN Endpoints
         *  (DedFifoMode)
         *  - 1'b0 : Dedicated Transmit FIFO Operation not enabled.
         *  - 1'b1 : Dedicated Transmit FIFO Operation enabled.
         */
        uint32_t ghwcfg4_dedfifomode:1;
        /** ghwcfg4_ineps : RO; bitpos: [29:26]; default: 7;
         *  Number of Device Mode IN Endpoints Including Control Endpoints (INEps)
         *  - 0: 1 IN Endpoint
         *  - 1: 2 IN Endpoints
         *  ....
         *  - 15: 16 IN Endpoints
         */
        uint32_t ghwcfg4_ineps:4;
        /** ghwcfg4_descdmaenabled : RO; bitpos: [30]; default: 1;
         *  Scatter/Gather DMA configuration
         *  - 1'b0: Non-Scatter/Gather DMA configuration
         *  - 1'b1: Scatter/Gather DMA configuration
         */
        uint32_t ghwcfg4_descdmaenabled:1;
        /** ghwcfg4_descdma : RO; bitpos: [31]; default: 1;
         *  Scatter/Gather DMA configuration
         *  - 1'b0: Non Dynamic configuration
         *  - 1'b1: Dynamic configuration
         *  Note: This field is configured using the OTG_EN_DESC_DMA parameter.
         */
        uint32_t ghwcfg4_descdma:1;
    };
    uint32_t val;
} usb_otghs_ghwcfg4_reg_t;


/** Group: Register to configure the DFIFOs for the controller. */
/** Type of gdfifocfg register
 *  Register to configure the DFIFOs for the controller.
 */
typedef union {
    struct {
        /** gdfifocfg_gdfifocfg : R/W; bitpos: [15:0]; default: 1024;
         *  GDFIFOCfg
         *
         *  This field is for dynamic programming of the DFIFO Size. This value takes effect
         *  only when the application programs a non zero value to this register. The value
         *  programmed must conform to the guidelines described in 'FIFO RAM Allocation'. The
         *  core does not have any corrective logic if the FIFO sizes are programmed
         *  incorrectly.
         */
        uint32_t gdfifocfg_gdfifocfg:16;
        /** gdfifocfg_epinfobaseaddr : R/W; bitpos: [31:16]; default: 896;
         *  This field provides the start address of the EP info controller.
         *  The EP info controller manages the stored values in the last few locations of the
         *  SPRAM as listed below.
         *
         *  - Host Buffer DMA mode: One location per channel is used in SPRAM to store the
         *  HCDMAn value.
         *  - Host Scatter/Gather DMA mode: Four locations per channel are used in SPRAM to
         *  store the Base Descriptor address, Current Descriptor address, Current Buffer
         *  Pointer, and the Status Quadlet.
         *  - Device Buffer DMA mode: One location per endpoint direction is used in SPRAM to
         *  store the DIEPDMA and DOEPDMA value.
         *  - Device Scatter/Gather DMA mode: Four locations per endpoint direction are used in
         *  SPRAM to store the Base Descriptor address, Current Descriptor address, Current
         *  Buffer Pointer and the Status Quadlet.
         */
        uint32_t gdfifocfg_epinfobaseaddr:16;
    };
    uint32_t val;
} usb_otghs_gdfifocfg_reg_t;


/** Group: This register works with the Interrupt Register (GINTSTS2) to interrupt the
 *  application. When an interrupt bit is masked, the interrupt associated with that
 *  bit is not generated. However, the GINTSTS2 register bit corresponding to that
 *  interrupt is still set.
 */
/** Type of gintmsk2 register
 *  This register works with the Interrupt Register (GINTSTS2) to interrupt the
 *  application. When an interrupt bit is masked, the interrupt associated with that
 *  bit is not generated. However, the GINTSTS2 register bit corresponding to that
 *  interrupt is still set.  Note: The fields of this register change depending on host
 *  or device mode.
 */
typedef union {
    struct {
        /** gintmsk2_gintmsk2 : R/W; bitpos: [31:0]; default: 0;
         *  Resvered
         */
        uint32_t gintmsk2_gintmsk2:32;
    };
    uint32_t val;
} usb_otghs_gintmsk2_reg_t;


/** Group: This register holds the size and the memory start address of the Periodic
 *  TxFIFO.
 */
/** Type of hptxfsiz register
 *  This register holds the size and the memory start address of the Periodic TxFIFO.
 *  Note: Read the reset value of this register only after the following conditions:  -
 *  If IDDIG_FILTER is disabled, read only after PHY clock is stable.  - If
 *  IDDIG_FILTER is enabled, read only after the filter timer expires.
 */
typedef union {
    struct {
        /** hptxfsiz_ptxfstaddr : R/W; bitpos: [11:0]; default: 2048;
         *  Host Periodic TxFIFO Start Address (PTxFStAddr)
         *
         *  The power-on reset value of this register is the sum of the Largest Rx Data FIFO
         *  Depth and Largest Non-periodic Tx Data FIFO Depth.These parameters are:
         *
         *  In shared FIFO operation:
         *  - OTG_RX_DFIFO_DEPTH + OTG_TX_NPERIO_DFIFO_DEPTH
         *
         *  In dedicated FIFO mode:
         *  - OTG_RX_DFIFO_DEPTH + OTG_TX_HNPERIO_DFIFO_DEPTH If Enable Dynamic FIFO Sizing?
         *  was deselected in coreConsultant (parameter OTG_DFIFO_DYNAMIC = 0), these flops are
         *  optimized, and reads return the power-on value. If Enable Dynamic FIFO Sizing? was
         *  selected in coreConsultant (parameter OTG_DFIFO_DYNAMIC = 1), you can write a new
         *  value in this field.
         *
         *  Programmed values must not exceed the power-on value set in coreConsultant.
         */
        uint32_t hptxfsiz_ptxfstaddr:12;
        uint32_t reserved_12:4;
        /** hptxfsiz_ptxfsize : R/W; bitpos: [26:16]; default: 1024;
         *  Host Periodic TxFIFO Depth (PTxFSize)
         *
         *  This value is in terms of 32-bit words.
         *  - Minimum value is 16
         *  - Maximum value is 32,768
         *  The power-on reset value of this register is specified as the Largest Host Mode
         *  Periodic Tx Data FIFO Depth.
         *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
         *  value.
         *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
         *  Programmed values must not exceed the power-on value set in coreConsultant.
         */
        uint32_t hptxfsiz_ptxfsize:11;
        uint32_t reserved_27:5;
    };
    uint32_t val;
} usb_otghs_hptxfsiz_reg_t;


/** Group: This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1).
 *  It holds the size and memory start address of IN endpoint TxFIFOs implemented in
 *  Device mode. Each FIFO holds the data for one IN endpoint. This register is
 *  repeated for instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use
 *  GNPTXFSIZ register for programming the size and memory start address.
 */
/** Type of dieptxf1 register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
typedef union {
    struct {
        /** dieptxf1_inepntxfstaddr : R/W; bitpos: [10:0]; default: 1536;
         *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
         *
         *  This field contains the memory start address for the IN endpoint Transmit FIFO that
         *  this register corresponds to.
         *  The power-on reset value of this register is calculated according to the following
         *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
         *  (FIFO number-1).
         *  For example,
         *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
         *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
         *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
         *  so on.
         *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
         *  Reset Value(A) = (C-65536).
         *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
         *  = 0), this field is read-only and read value is the power-on reset value.
         *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
         *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
         *  depths, you can program their values according to the above formula. Programmed
         *  values must not exceed the power-on value set in coreConsultant.
         */
        uint32_t dieptxf1_inepntxfstaddr:11;
        uint32_t reserved_11:5;
        /** dieptxf1_inepntxfdep : R/W; bitpos: [25:16]; default: 512;
         *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
         *
         *  This value is in terms of 32-bit words.
         *  - Minimum value is 16
         *  - Maximum value is 32,768
         *  The power-on reset value of this register is specified as the Largest IN Endpoint
         *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
         *  configuration, where i is the FIFO number this register corresponds to.
         *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
         *  value.
         *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
         *  Programmed values must not exceed the power-on value.
         */
        uint32_t dieptxf1_inepntxfdep:10;
        uint32_t reserved_26:6;
    };
    uint32_t val;
} usb_otghs_dieptxf1_reg_t;

/** Type of dieptxf2 register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
typedef union {
    struct {
        /** dieptxf2_inepntxfstaddr : R/W; bitpos: [11:0]; default: 2048;
         *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
         *
         *  This field contains the memory start address for the IN endpoint Transmit FIFO that
         *  this register corresponds to.
         *  The power-on reset value of this register is calculated according to the following
         *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
         *  (FIFO number-1).
         *  For example,
         *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
         *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
         *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
         *  so on.
         *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
         *  Reset Value(A) = (C-65536).
         *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
         *  = 0), this field is read-only and read value is the power-on reset value.
         *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
         *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
         *  depths, you can program their values according to the above formula. Programmed
         *  values must not exceed the power-on value set in coreConsultant.
         */
        uint32_t dieptxf2_inepntxfstaddr:12;
        uint32_t reserved_12:4;
        /** dieptxf2_inepntxfdep : R/W; bitpos: [25:16]; default: 512;
         *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
         *
         *  This value is in terms of 32-bit words.
         *  - Minimum value is 16
         *  - Maximum value is 32,768
         *  The power-on reset value of this register is specified as the Largest IN Endpoint
         *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
         *  configuration, where i is the FIFO number this register corresponds to.
         *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
         *  value.
         *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
         *  Programmed values must not exceed the power-on value.
         */
        uint32_t dieptxf2_inepntxfdep:10;
        uint32_t reserved_26:6;
    };
    uint32_t val;
} usb_otghs_dieptxf2_reg_t;

/** Type of dieptxf3 register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
typedef union {
    struct {
        /** dieptxf3_inepntxfstaddr : R/W; bitpos: [11:0]; default: 2560;
         *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
         *
         *  This field contains the memory start address for the IN endpoint Transmit FIFO that
         *  this register corresponds to.
         *  The power-on reset value of this register is calculated according to the following
         *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
         *  (FIFO number-1).
         *  For example,
         *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
         *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
         *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
         *  so on.
         *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
         *  Reset Value(A) = (C-65536).
         *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
         *  = 0), this field is read-only and read value is the power-on reset value.
         *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
         *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
         *  depths, you can program their values according to the above formula. Programmed
         *  values must not exceed the power-on value set in coreConsultant.
         */
        uint32_t dieptxf3_inepntxfstaddr:12;
        uint32_t reserved_12:4;
        /** dieptxf3_inepntxfdep : R/W; bitpos: [25:16]; default: 512;
         *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
         *
         *  This value is in terms of 32-bit words.
         *  - Minimum value is 16
         *  - Maximum value is 32,768
         *  The power-on reset value of this register is specified as the Largest IN Endpoint
         *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
         *  configuration, where i is the FIFO number this register corresponds to.
         *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
         *  value.
         *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
         *  Programmed values must not exceed the power-on value.
         */
        uint32_t dieptxf3_inepntxfdep:10;
        uint32_t reserved_26:6;
    };
    uint32_t val;
} usb_otghs_dieptxf3_reg_t;

/** Type of dieptxf4 register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
typedef union {
    struct {
        /** dieptxf4_inepntxfstaddr : R/W; bitpos: [11:0]; default: 3072;
         *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
         *
         *  This field contains the memory start address for the IN endpoint Transmit FIFO that
         *  this register corresponds to.
         *  The power-on reset value of this register is calculated according to the following
         *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
         *  (FIFO number-1).
         *  For example,
         *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
         *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
         *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
         *  so on.
         *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
         *  Reset Value(A) = (C-65536).
         *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
         *  = 0), this field is read-only and read value is the power-on reset value.
         *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
         *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
         *  depths, you can program their values according to the above formula. Programmed
         *  values must not exceed the power-on value set in coreConsultant.
         */
        uint32_t dieptxf4_inepntxfstaddr:12;
        uint32_t reserved_12:4;
        /** dieptxf4_inepntxfdep : R/W; bitpos: [25:16]; default: 512;
         *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
         *
         *  This value is in terms of 32-bit words.
         *  - Minimum value is 16
         *  - Maximum value is 32,768
         *  The power-on reset value of this register is specified as the Largest IN Endpoint
         *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
         *  configuration, where i is the FIFO number this register corresponds to.
         *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
         *  value.
         *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
         *  Programmed values must not exceed the power-on value.
         */
        uint32_t dieptxf4_inepntxfdep:10;
        uint32_t reserved_26:6;
    };
    uint32_t val;
} usb_otghs_dieptxf4_reg_t;

/** Type of dieptxf5 register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
typedef union {
    struct {
        /** dieptxf5_inepntxfstaddr : R/W; bitpos: [11:0]; default: 3584;
         *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
         *
         *  This field contains the memory start address for the IN endpoint Transmit FIFO that
         *  this register corresponds to.
         *  The power-on reset value of this register is calculated according to the following
         *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
         *  (FIFO number-1).
         *  For example,
         *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
         *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
         *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
         *  so on.
         *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
         *  Reset Value(A) = (C-65536).
         *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
         *  = 0), this field is read-only and read value is the power-on reset value.
         *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
         *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
         *  depths, you can program their values according to the above formula. Programmed
         *  values must not exceed the power-on value set in coreConsultant.
         */
        uint32_t dieptxf5_inepntxfstaddr:12;
        uint32_t reserved_12:4;
        /** dieptxf5_inepntxfdep : R/W; bitpos: [25:16]; default: 512;
         *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
         *
         *  This value is in terms of 32-bit words.
         *  - Minimum value is 16
         *  - Maximum value is 32,768
         *  The power-on reset value of this register is specified as the Largest IN Endpoint
         *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
         *  configuration, where i is the FIFO number this register corresponds to.
         *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
         *  value.
         *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
         *  Programmed values must not exceed the power-on value.
         */
        uint32_t dieptxf5_inepntxfdep:10;
        uint32_t reserved_26:6;
    };
    uint32_t val;
} usb_otghs_dieptxf5_reg_t;

/** Type of dieptxf6 register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
typedef union {
    struct {
        /** dieptxf6_inepntxfstaddr : R/W; bitpos: [12:0]; default: 4096;
         *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
         *
         *  This field contains the memory start address for the IN endpoint Transmit FIFO that
         *  this register corresponds to.
         *  The power-on reset value of this register is calculated according to the following
         *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
         *  (FIFO number-1).
         *  For example,
         *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
         *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
         *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
         *  so on.
         *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
         *  Reset Value(A) = (C-65536).
         *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
         *  = 0), this field is read-only and read value is the power-on reset value.
         *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
         *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
         *  depths, you can program their values according to the above formula. Programmed
         *  values must not exceed the power-on value set in coreConsultant.
         */
        uint32_t dieptxf6_inepntxfstaddr:13;
        uint32_t reserved_13:3;
        /** dieptxf6_inepntxfdep : R/W; bitpos: [25:16]; default: 512;
         *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
         *
         *  This value is in terms of 32-bit words.
         *  - Minimum value is 16
         *  - Maximum value is 32,768
         *  The power-on reset value of this register is specified as the Largest IN Endpoint
         *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
         *  configuration, where i is the FIFO number this register corresponds to.
         *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
         *  value.
         *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
         *  Programmed values must not exceed the power-on value.
         */
        uint32_t dieptxf6_inepntxfdep:10;
        uint32_t reserved_26:6;
    };
    uint32_t val;
} usb_otghs_dieptxf6_reg_t;

/** Type of dieptxf7 register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
typedef union {
    struct {
        /** dieptxf7_inepntxfstaddr : R/W; bitpos: [12:0]; default: 4608;
         *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
         *
         *  This field contains the memory start address for the IN endpoint Transmit FIFO that
         *  this register corresponds to.
         *  The power-on reset value of this register is calculated according to the following
         *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
         *  (FIFO number-1).
         *  For example,
         *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
         *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
         *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
         *  so on.
         *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
         *  Reset Value(A) = (C-65536).
         *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
         *  = 0), this field is read-only and read value is the power-on reset value.
         *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
         *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
         *  depths, you can program their values according to the above formula. Programmed
         *  values must not exceed the power-on value set in coreConsultant.
         */
        uint32_t dieptxf7_inepntxfstaddr:13;
        uint32_t reserved_13:3;
        /** dieptxf7_inepntxfdep : R/W; bitpos: [25:16]; default: 512;
         *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
         *
         *  This value is in terms of 32-bit words.
         *  - Minimum value is 16
         *  - Maximum value is 32,768
         *  The power-on reset value of this register is specified as the Largest IN Endpoint
         *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
         *  configuration, where i is the FIFO number this register corresponds to.
         *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
         *  value.
         *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
         *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
         *  Programmed values must not exceed the power-on value.
         */
        uint32_t dieptxf7_inepntxfdep:10;
        uint32_t reserved_26:6;
    };
    uint32_t val;
} usb_otghs_dieptxf7_reg_t;


/** Group: This register is used to configure the controller in Host mode. */
/** Type of hcfg register
 *  This register is used to configure the controller in Host mode.
 */
typedef union {
    struct {
        /** hcfg_fslspclksel : R/W; bitpos: [1:0]; default: 0;
         *  FS/LS PHY Clock Select (FSLSPclkSel)
         *
         *  When the core is in FS Host mode
         *  - 2'b00: PHY clock is running at 30/60 MHz
         *  - 2'b01: PHY clock is running at 48 MHz
         *  - Others: Reserved
         *  When the core is in LS Host mode
         *  - 2'b00: PHY clock is running at 30/60 MHz. When the UTMI+/ULPI PHY Low Power mode
         *  is not selected, use 30/60 MHz.
         *  - 2'b01: PHY clock is running at 48 MHz. When the UTMI+ PHY Low Power mode is
         *  selected, use 48MHz If the PHY supplies a 48 MHz clock during LS mode.
         *  - 2'b10: PHY clock is running at 6 MHz. In USB 1.1 FS mode, use 6 MHz when the
         *  UTMI+ PHY Low Power mode is selected and the PHY supplies a 6 MHz clock during LS
         *  mode. If you select a 6 MHz clock during LS mode, you must do a soft reset.
         *  - 2'b11: Reserved
         *  Notes:
         *  - When Core in FS mode, the internal and external clocks have the same frequency.
         *  - When Core in LS mode,
         *  -- If FSLSPclkSel = 2'b00: Internal and external clocks have the same frequency
         *  -- If FSLSPclkSel = 2'b10: Internal clock is the divided by eight version of
         *  external 48 MHz clock
         */
        uint32_t hcfg_fslspclksel:2;
        /** hcfg_fslssupp : R/W; bitpos: [2]; default: 0;
         *  FS- and LS-Only Support (FSLSSupp)
         *
         *  The application uses this bit to control the core's enumeration speed. Using this
         *  bit, the application can make the core
         *  enumerate as a FS host, even If the connected device supports HS traffic. Do not
         *  make changes to this field after initial
         *  programming.
         *  - 1'b0: HS/FS/LS, based on the maximum speed supported by the connected device
         *  - 1'b1: FS/LS-only, even If the connected device can support HS
         */
        uint32_t hcfg_fslssupp:1;
        uint32_t reserved_3:4;
        /** hcfg_ena32khzs : R/W; bitpos: [7]; default: 0;
         *  Enable 32 KHz Suspend mode (Ena32KHzS)
         *
         *  This bit can be set only in FS PHY interface is selected.
         *  Else, this bit needs to be set to zero.
         *  When FS PHY interface is chosen and this bit is set,
         *  the core expects that the PHY clock during Suspend is switched
         *  from 48 MHz to 32 KHz.
         */
        uint32_t hcfg_ena32khzs:1;
        /** hcfg_resvalid : R/W; bitpos: [15:8]; default: 2;
         *  Resume Validation Period  (ResValid)
         *
         *  This field is effective only when HCFG.Ena32KHzS is set.
         *  It controls the resume period when the core resumes from suspend.
         *  The core counts for 'ResValid' number of clock cycles to detect a
         *  valid resume when this is set.
         */
        uint32_t hcfg_resvalid:8;
        uint32_t reserved_16:7;
        /** hcfg_descdma : R/W; bitpos: [23]; default: 0;
         *  Enable Scatter/gather DMA in Host mode (DescDMA)
         *
         *  When the Scatter/Gather DMA option selected during configuration of the RTL, the
         *  application can set this bit during initialization
         *  to enable the Scatter/Gather DMA operation.
         *
         *  Note: This bit must be modified only once after a reset.
         *
         *  The following combinations are available for programming:
         *  - GAHBCFG.DMAEn=0,HCFG.DescDMA=0 => Slave mode
         *  - GAHBCFG.DMAEn=0,HCFG.DescDMA=1 => Invalid
         *  - GAHBCFG.DMAEn=1,HCFG.DescDMA=0 => Buffered DMA mode
         *  - GAHBCFG.DMAEn=1,HCFG.DescDMA=1 => Scatter/Gather DMA mode
         */
        uint32_t hcfg_descdma:1;
        /** hcfg_frlisten : R/W; bitpos: [25:24]; default: 0;
         *  Frame List Entries(FrListEn)
         *
         *  The value in the register specifies the number of entries in the Frame list.
         *  This field is valid only in Scatter/Gather DMA mode.
         *  - 2'b00: 8 Entries
         *  - 2'b01: 16 Entries
         *  - 2'b10: 32 Entries
         *  - 2'b11: 64 Entries
         */
        uint32_t hcfg_frlisten:2;
        /** hcfg_perschedena : R/W; bitpos: [26]; default: 0;
         *  Enable Periodic Scheduling (PerSchedEna):
         *
         *  Applicable in host DDMA mode only.
         *  Enables periodic scheduling within the core. Initially, the bit is reset.
         *  The core does not process any periodic channels.
         *
         *  As soon as this bit is set,
         *  the core gets ready to start scheduling periodic channels and
         *  sets HCFG.PerSchedStat. The setting of HCFG.PerSchedStat indicates the core
         *  has enabled periodic scheduling. Once HCFG.PerSchedEna is set,
         *  the application is not supposed to again reset the bit unless HCFG.PerSchedStat
         *  is set.
         *
         *  As soon as this bit is reset, the core gets ready to
         *  stop scheduling periodic channels and resets HCFG.PerSchedStat.
         */
        uint32_t hcfg_perschedena:1;
        uint32_t reserved_27:4;
        /** hcfg_modechtimen : R/W; bitpos: [31]; default: 0;
         *  Mode Change Ready Timer Enable (ModeChTimEn)
         *
         *  This bit is used to enable/disable the Host core to wait  200 PHY clock cycles at
         *  the end of Resume to change the opmode signal to the PHY to 00
         *  after Suspend or LPM.
         *  - 1'b0 : The Host core waits for either 200 PHY clock cycles or a linestate of SE0
         *  at the end of resume to the change the opmode from 2'b10 to 2'b00
         *  - 1'b1 : The Host core waits only for a linestate of SE0 at the end of resume to
         *  change the opmode from 2'b10 to 2'b00.
         */
        uint32_t hcfg_modechtimen:1;
    };
    uint32_t val;
} usb_otghs_hcfg_reg_t;


/** Group: This register is used to control the interval between two consecutive SOFs. */
/** Type of hfir register
 *  This register is used to control the interval between two consecutive SOFs.
 */
typedef union {
    struct {
        /** hfir_frint : R/W; bitpos: [15:0]; default: 60000;
         *  Frame Interval (FrInt)
         *
         *  The value that the application programs to this field specifies
         *  the interval between two consecutive SOFs (FS) or micro-
         *  SOFs (HS) or Keep-Alive tokens (HS). This field contains the
         *  number of PHY clocks that constitute the required frame
         *  interval. The Default value set in this field  is for FS operation
         *  when the PHY clock frequency is 60 MHz. The application can
         *  write a value to this register only after the Port Enable bit of the
         *  Host Port Control and Status register (HPRT.PrtEnaPort) has
         *  been Set. If no value is programmed, the core calculates the
         *  value based on the PHY clock specified in the FS/LS PHY
         *  Clock Select field of the Host Configuration register
         *  (HCFG.FSLSPclkSel). Do not change the value of this field
         *  after the initial configuration.
         *  - 125 us * (PHY clock frequency for HS)
         *  - 1 ms * (PHY clock frequency for FS/LS)
         */
        uint32_t hfir_frint:16;
        /** hfir_hfirrldctrl : R/W; bitpos: [16]; default: 0;
         *  Reload Control (HFIRRldCtrl)
         *
         *  This bit allows dynamic reloading of the HFIR register during run time.
         *  - 1'b0 : The HFIR cannot be reloaded dynamically
         *  - 1'b1: the HFIR can be dynamically reloaded during runtime.
         *  This bit needs to be programmed during initial configuration and its value must not
         *  be changed during runtime.
         */
        uint32_t hfir_hfirrldctrl:1;
        uint32_t reserved_17:15;
    };
    uint32_t val;
} usb_otghs_hfir_reg_t;


/** Group: This register indicates the current frame number. It also indicates the time
 *  remaining (in terms of the number of PHY clocks) in the current (micro)frame.
 */
/** Type of hfnum register
 *  This register indicates the current frame number. It also indicates the time
 *  remaining (in terms of the number of PHY clocks) in the current (micro)frame.
 *  Note: Read the reset value of this register only after the following conditions:  -
 *  If IDDIG_FILTER is disabled, read only when the PHY clock is stable.  - If
 *  IDDIG_FILTER is enabled, read only after the filter timer expires.
 */
typedef union {
    struct {
        /** hfnum_frnum : RO; bitpos: [15:0]; default: 16383;
         *  Frame Number (FrNum)
         *
         *  This field increments when a new SOF is transmitted on the
         *  USB, and is reset to 0 when it reaches 16'h3FFF.
         */
        uint32_t hfnum_frnum:16;
        /** hfnum_frrem : RO; bitpos: [31:16]; default: 0;
         *  Frame Time Remaining (FrRem)
         *
         *  Indicates the amount of time remaining in the current
         *  microframe (HS) or Frame (FS/LS), in terms of PHY clocks. This
         *  field decrements on each PHY clock. When it reaches zero, this
         *  field is reloaded with the value in the Frame Interval register and
         *  a new SOF is transmitted on the USB.
         */
        uint32_t hfnum_frrem:16;
    };
    uint32_t val;
} usb_otghs_hfnum_reg_t;


/** Group: This register contains information about the Periodic Transmit Queue in the
 *  Host controller.
 */
/** Type of hptxsts register
 *  This register contains information about the Periodic Transmit Queue in the Host
 *  controller.
 */
typedef union {
    struct {
        /** hptxsts_ptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  Periodic Transmit Data FIFO Space Available (PTxFSpcAvail)
         *
         *  Indicates the number of free locations available to be written to in the Periodic
         *  TxFIFO.
         *
         *  Values are in terms of 32-bit words
         *  - 16'h0    : Periodic TxFIFO is full
         *  - 16'h1    : 1 word available
         *  - 16'h2    : 2 words available
         *  - 16'hn    : n words available (where 0  n  32,768)
         *  - 16'h8000 : 32,768 words
         *  - Others   : Reserved
         */
        uint32_t hptxsts_ptxfspcavail:16;
        /** hptxsts_ptxqspcavail : RO; bitpos: [22:16]; default: 16;
         *  Periodic Transmit Request Queue Space Available (PTxQSpcAvail)
         *
         *  Indicates the number of free locations available to be written in the Periodic
         *  Transmit Request Queue. This queue holds both IN and OUT requests.
         *  - 7'h0: Periodic Transmit Request Queue is full
         *  - 7'h1: 1 location available
         *  - 7'h2: 2 locations available
         *  - n: n locations available (0 <= n <= 16)
         *  - Others: Reserved
         */
        uint32_t hptxsts_ptxqspcavail:7;
        /** hptxsts_ptxqtop : RO; bitpos: [31:23]; default: 0;
         *  Top of the Periodic Transmit Request Queue (PTxQTop)
         *
         *  This indicates the Entry in the Periodic Tx Request Queue that is
         *  currently being processed by the MAC.
         *
         *  This register is used for debugging.
         *  - Bit [31]: Odd/Even (micro)Frame
         *  -- 1'b0: send in even (micro)Frame
         *  -- 1'b1: send in odd (micro)Frame
         *  - Bits [30:27]: Channel/endpoint number
         *  - Bits [26:25]: Type
         *  -- 2'b00: IN/OUT
         *  -- 2'b01: Zero-length packet
         *  -- 2'b10: CSPLIT
         *  -- 2'b11: Disable channel command
         *  - Bit [24]: Last Periodic Entry for the selected periodic channel/endpoint
         *  - Bit [23]: Terminate (last Entry for the selected channel/endpoint)
         */
        uint32_t hptxsts_ptxqtop:9;
    };
    uint32_t val;
} usb_otghs_hptxsts_reg_t;


/** Group: When a significant event occurs on a channel, the Host All Channels
 *  Interrupt register interrupts the application using the Host Channels Interrupt bit
 *  of the Core Interrupt register (GINTSTS.HChInt). This is shown in the "Interrupt
 *  Hierarchy" figure in the databook. There is one interrupt bit per channel, up to a
 *  maximum of 16 bits. Bits in this register are set and cleared when the application
 *  sets and clears bits in the corresponding Host Channel-n Interrupt register.
 */
/** Type of haint register
 *  When a significant event occurs on a channel, the Host All Channels Interrupt
 *  register interrupts the application using the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt). This is shown in the Interrupt Hierarchy
 *  figure in the databook. There is one interrupt bit per channel, up to a maximum of
 *  16 bits. Bits in this register are set and cleared when the application sets and
 *  clears bits in the corresponding Host Channel-n Interrupt register.
 */
typedef union {
    struct {
        /** haint_haint : RO; bitpos: [15:0]; default: 0;
         *
         *  Channel Interrupt for channel no.
         */
        uint32_t haint_haint:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_haint_reg_t;


/** Group: The Host All Channel Interrupt Mask register works with the Host All Channel
 *  Interrupt register to interrupt the application when an event occurs on a channel.
 *  There is one interrupt mask bit per channel, up to a maximum of 16 bits.
 */
/** Type of haintmsk register
 *  The Host All Channel Interrupt Mask register works with the Host All Channel
 *  Interrupt register to interrupt the application when an event occurs on a channel.
 *  There is one interrupt mask bit per channel, up to a maximum of 16 bits.
 */
typedef union {
    struct {
        /** haintmsk_haintmsk : R/W; bitpos: [15:0]; default: 0;
         *  Channel Interrupt Mask (HAINTMsk)
         *  One bit per channel: Bit 0 for channel 0, bit 15 for channel 15
         */
        uint32_t haintmsk_haintmsk:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_haintmsk_reg_t;


/** Group: This register is present only in case of Scatter/Gather DMA. It is
 *  implemented as flops. This register holds the starting address of the Frame list
 *  information.
 */
/** Type of hflbaddr register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented as
 *  flops. This register holds the starting address of the Frame list information.
 */
typedef union {
    struct {
        /** hflbaddr_hflbaddr : R/W; bitpos: [31:0]; default: 0;
         *  The starting address of the Frame list.
         *  This register is used only for Isochronous and Interrupt Channels.
         */
        uint32_t hflbaddr_hflbaddr:32;
    };
    uint32_t val;
} usb_otghs_hflbaddr_reg_t;


/** Group: This register is available only in Host mode. Currently, the OTG Host
 *  supports only one port. A single register holds USB port-related information such
 *  as USB reset, enable, suspend, resume, connect status, and test mode for each port.
 *  It is shown in the "Interrupt Hierarchy" figure in the databook. The R_SS_WC bits
 *  in this register can trigger an interrupt to the application through the Host Port
 *  Interrupt bit of the Core Interrupt register (GINTSTS.PrtInt). On a Port Interrupt,
 *  the application must read this register and clear the bit that caused the
 *  interrupt. For the R_SS_WC bits, the application must write a 1 to the bit to clear
 *  the interrupt.
 */
/** Type of hprt register
 *  This register is available only in Host mode. Currently, the OTG Host supports only
 *  one port. A single register holds USB port-related information such as USB reset,
 *  enable, suspend, resume, connect status, and test mode for each port. It is shown
 *  in the Interrupt Hierarchy figure in the databook. The R_SS_WC bits in this
 *  register can trigger an interrupt to the application through the Host Port
 *  Interrupt bit of the Core Interrupt register (GINTSTS.PrtInt). On a Port Interrupt,
 *  the application must read this register and clear the bit that caused the
 *  interrupt. For the R_SS_WC bits, the application must write a 1 to the bit to clear
 *  the interrupt.
 */
typedef union {
    struct {
        /** hprt_prtconnsts : RO; bitpos: [0]; default: 0;
         *  Port Connect Status (PrtConnSts)
         *  - 0: No device is attached to the port.
         *  - 1: A device is attached to the port.
         */
        uint32_t hprt_prtconnsts:1;
        /** hprt_prtconndet : R/W; bitpos: [1]; default: 0;
         *  Port Connect Detected (PrtConnDet)
         *
         *  The core sets this bit when a device connection is detected
         *  to trigger an interrupt to the application using the Host Port
         *  Interrupt bit of the Core Interrupt register (GINTSTS.PrtInt).This bit can be set
         *  only by the core and the application must write 1 to clear it.The application must
         *  write a 1 to this bit to clear the
         *  interrupt.
         */
        uint32_t hprt_prtconndet:1;
        /** hprt_prtena : R/W; bitpos: [2]; default: 0;
         *  Port Enable (PrtEna)
         *
         *  A port is enabled only by the core after a reset sequence,
         *  and is disabled by an overcurrent condition, a disconnect
         *  condition, or by the application clearing this bit. The
         *  application cannot Set this bit by a register write. It can only
         *  clear it to disable the port by writing 1. This bit does not trigger any
         *  interrupt to the application.
         *  - 1'b0: Port disabled
         *  - 1'b1: Port enabled
         */
        uint32_t hprt_prtena:1;
        /** hprt_prtenchng : R/W; bitpos: [3]; default: 0;
         *  Port Enable/Disable Change (PrtEnChng)
         *
         *  The core sets this bit when the status of the Port Enable bit [2] of this register
         *  changes.This bit can be set only by the core and the application must write 1 to
         *  clear it.
         */
        uint32_t hprt_prtenchng:1;
        /** hprt_prtovrcurract : RO; bitpos: [4]; default: 0;
         *  Port Overcurrent Active (PrtOvrCurrAct)
         *
         *  Indicates the overcurrent condition of the port.
         *  - 1'b0: No overcurrent condition
         *  - 1'b1: Overcurrent condition
         */
        uint32_t hprt_prtovrcurract:1;
        /** hprt_prtovrcurrchng : R/W; bitpos: [5]; default: 0;
         *  Port Overcurrent Change (PrtOvrCurrChng)
         *
         *  The core sets this bit when the status of the Port Overcurrent Active bit (bit 4)
         *  in this register changes.This bit can be set only by the core and the application
         *  must write 1 to clear it
         */
        uint32_t hprt_prtovrcurrchng:1;
        /** hprt_prtres : R/W; bitpos: [6]; default: 0;
         *  Port Resume (PrtRes)
         *
         *  The application sets this bit to drive resume signaling on the
         *  port. The core continues to drive the resume signal until the
         *  application clears this bit.
         *
         *  If the core detects a USB remote wakeup sequence, as
         *  indicated by the Port Resume/Remote Wakeup Detected
         *  Interrupt bit of the Core Interrupt register
         *  (GINTSTS.WkUpInt), the core starts driving resume
         *  signaling without application intervention and clears this bit
         *  when it detects a disconnect condition. The read value of
         *  this bit indicates whether the core is currently driving
         *  resume signaling.
         *  - 1'b0: No resume driven
         *  - 1'b1: Resume driven
         *  When LPM is enabled, In L1 state the behavior of this bit is as follows:
         *  The application sets this bit to drive resume signaling on the port.
         *  The core continues to drive the resume signal until a pre-determined time
         *  specified in GLPMCFG.HIRD_Thres[3:0] field. If the core detects a USB remote
         *  wakeup sequence, as indicated by the Port L1Resume/Remote L1Wakeup Detected
         *  Interrupt bit of the Core Interrupt register (GINTSTS.L1WkUpInt),
         *  the core starts driving resume signaling without application intervention
         *  and clears this bit at the end of resume.This bit can be set by both core or
         *  application
         *  and also cleared by core or application. This bit is cleared by the core even if
         *  there is
         *  no device connected to the Host.
         */
        uint32_t hprt_prtres:1;
        /** hprt_prtsusp : R/W; bitpos: [7]; default: 0;
         *  Port Suspend (PrtSusp)
         *
         *  The application sets this bit to put this port in Suspend
         *  mode. The core only stops sending SOFs when this is Set.
         *  To stop the PHY clock, the application must Set the Port
         *  Clock Stop bit, which asserts the suspend input pin of the
         *  PHY.
         *
         *  The read value of this bit reflects the current suspend status
         *  of the port. This bit is cleared by the core after a remote
         *  wakeup signal is detected or the application sets the Port
         *  Reset bit or Port Resume bit in this register or the
         *  Resume/Remote Wakeup Detected Interrupt bit or
         *  Disconnect Detected Interrupt bit in the Core Interrupt
         *  register (GINTSTS.WkUpInt or GINTSTS.DisconnInt,
         *  respectively).This bit is cleared by the core even if there is
         *  no device connected to the Host.
         *  - 1'b0: Port not in Suspend mode
         *  - 1'b1: Port in Suspend mode
         */
        uint32_t hprt_prtsusp:1;
        /** hprt_prtrst : R/W; bitpos: [8]; default: 0;
         *  Port Reset (PrtRst)
         *
         *  When the application sets this bit, a reset sequence is
         *  started on this port. The application must time the reset
         *  period and clear this bit after the reset sequence is
         *  complete.
         *  - 1'b0: Port not in reset
         *  - 1'b1: Port in reset
         *  The application must leave this bit set for at least a
         *  minimum duration mentioned below to start a reset on the
         *  port. The application can leave it set for another 10 ms in
         *  addition to the required minimum duration, before clearing
         *  the bit, even though there is no maximum limit Set by the
         *  USB standard.This bit is cleared by the core even if there is
         *  no device connected to the Host.
         *  - High speed: 50 ms
         *  - Full speed/Low speed: 10 ms
         */
        uint32_t hprt_prtrst:1;
        uint32_t reserved_9:1;
        /** hprt_prtlnsts : RO; bitpos: [11:10]; default: 0;
         *  Port Line Status (PrtLnSts)
         *
         *  Indicates the current logic level USB data lines
         *  - Bit [10]: Logic level of D+
         *  - Bit [11]: Logic level of D-
         */
        uint32_t hprt_prtlnsts:2;
        /** hprt_prtpwr : R/W; bitpos: [12]; default: 0;
         *  Port Power (PrtPwr)
         *
         *  The application uses this field to control power to this port (write 1'b1 to set to
         *  1'b1
         *  and write 1'b0 to set to 1'b0), and the core can clear this bit on an over current
         *  condition.
         *  - 1'b0: Power off
         *  - 1'b1: Power on
         *
         *  Note: This bit is interface independent. The application needs to program this bit
         *  for all interfaces as described in the host programming flow in the Programming
         *  Guide.
         */
        uint32_t hprt_prtpwr:1;
        /** hprt_prttstctl : R/W; bitpos: [16:13]; default: 0;
         *  Port Test Control (PrtTstCtl)
         *
         *  The application writes a nonzero value to this field to put the port into a Test
         *  mode, and the corresponding pattern is signaled on the port.
         *  - 4'b0000: Test mode disabled
         *  - 4'b0001: Test_J mode
         *  - 4'b0010: Test_K mode
         *  - 4'b0011: Test_SE0_NAK mode
         *  - 4'b0100: Test_Packet mode
         *  - 4'b0101: Test_Force_Enable
         *  - Others: Reserved
         *
         *  To move the DWC_otg controller to test mode, you must set this field. Complete the
         *  following steps to move the DWC_otg core to test mode:
         *  - 1. Power on the core.
         *  - 2. Load the DWC_otg driver.
         *  - 3. Connect an HS device and enumerate to HS mode.
         *  - 4. Access the HPRT register to send test packets.
         *  - 5. Remove the device and connect to fixture (OPT) port. The DWC_otg host core
         *  continues sending out test packets.
         *  - 6. Test the eye diagram.
         */
        uint32_t hprt_prttstctl:4;
        /** hprt_prtspd : RO; bitpos: [18:17]; default: 0;
         *  Port Speed (PrtSpd)
         *
         *  Indicates the speed of the device attached to this port.
         *  - 2'b00: High speed
         *  - 2'b01: Full speed
         *  - 2'b10: Low speed
         *  - 2'b11: Reserved
         */
        uint32_t hprt_prtspd:2;
        uint32_t reserved_19:13;
    };
    uint32_t val;
} usb_otghs_hprt_reg_t;


/** Group: This register contains the characteristics of the Host Channel. */
/** Type of hcchar0 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar0_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar0_mps:11;
        /** hcchar0_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar0_epnum:4;
        /** hcchar0_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar0_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar0_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar0_lspddev:1;
        /** hcchar0_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar0_eptype:2;
        /** hcchar0_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar0_ec:2;
        /** hcchar0_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar0_devaddr:7;
        /** hcchar0_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar0_oddfrm:1;
        /** hcchar0_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar0_chdis:1;
        /** hcchar0_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar0_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar0_reg_t;

/** Type of hcchar1 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar1_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar1_mps:11;
        /** hcchar1_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar1_epnum:4;
        /** hcchar1_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar1_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar1_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar1_lspddev:1;
        /** hcchar1_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar1_eptype:2;
        /** hcchar1_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar1_ec:2;
        /** hcchar1_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar1_devaddr:7;
        /** hcchar1_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar1_oddfrm:1;
        /** hcchar1_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar1_chdis:1;
        /** hcchar1_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar1_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar1_reg_t;

/** Type of hcchar2 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar2_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar2_mps:11;
        /** hcchar2_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar2_epnum:4;
        /** hcchar2_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar2_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar2_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar2_lspddev:1;
        /** hcchar2_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar2_eptype:2;
        /** hcchar2_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar2_ec:2;
        /** hcchar2_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar2_devaddr:7;
        /** hcchar2_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar2_oddfrm:1;
        /** hcchar2_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar2_chdis:1;
        /** hcchar2_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar2_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar2_reg_t;

/** Type of hcchar3 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar3_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar3_mps:11;
        /** hcchar3_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar3_epnum:4;
        /** hcchar3_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar3_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar3_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar3_lspddev:1;
        /** hcchar3_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar3_eptype:2;
        /** hcchar3_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar3_ec:2;
        /** hcchar3_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar3_devaddr:7;
        /** hcchar3_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar3_oddfrm:1;
        /** hcchar3_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar3_chdis:1;
        /** hcchar3_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar3_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar3_reg_t;

/** Type of hcchar4 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar4_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar4_mps:11;
        /** hcchar4_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar4_epnum:4;
        /** hcchar4_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar4_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar4_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar4_lspddev:1;
        /** hcchar4_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar4_eptype:2;
        /** hcchar4_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar4_ec:2;
        /** hcchar4_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar4_devaddr:7;
        /** hcchar4_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar4_oddfrm:1;
        /** hcchar4_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar4_chdis:1;
        /** hcchar4_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar4_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar4_reg_t;

/** Type of hcchar5 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar5_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar5_mps:11;
        /** hcchar5_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar5_epnum:4;
        /** hcchar5_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar5_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar5_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar5_lspddev:1;
        /** hcchar5_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar5_eptype:2;
        /** hcchar5_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar5_ec:2;
        /** hcchar5_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar5_devaddr:7;
        /** hcchar5_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar5_oddfrm:1;
        /** hcchar5_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar5_chdis:1;
        /** hcchar5_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar5_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar5_reg_t;

/** Type of hcchar6 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar6_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar6_mps:11;
        /** hcchar6_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar6_epnum:4;
        /** hcchar6_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar6_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar6_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar6_lspddev:1;
        /** hcchar6_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar6_eptype:2;
        /** hcchar6_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar6_ec:2;
        /** hcchar6_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar6_devaddr:7;
        /** hcchar6_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar6_oddfrm:1;
        /** hcchar6_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar6_chdis:1;
        /** hcchar6_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar6_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar6_reg_t;

/** Type of hcchar7 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar7_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar7_mps:11;
        /** hcchar7_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar7_epnum:4;
        /** hcchar7_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar7_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar7_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar7_lspddev:1;
        /** hcchar7_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar7_eptype:2;
        /** hcchar7_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar7_ec:2;
        /** hcchar7_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar7_devaddr:7;
        /** hcchar7_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar7_oddfrm:1;
        /** hcchar7_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar7_chdis:1;
        /** hcchar7_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar7_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar7_reg_t;

/** Type of hcchar8 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar8_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar8_mps:11;
        /** hcchar8_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar8_epnum:4;
        /** hcchar8_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar8_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar8_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar8_lspddev:1;
        /** hcchar8_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar8_eptype:2;
        /** hcchar8_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar8_ec:2;
        /** hcchar8_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar8_devaddr:7;
        /** hcchar8_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar8_oddfrm:1;
        /** hcchar8_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar8_chdis:1;
        /** hcchar8_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar8_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar8_reg_t;

/** Type of hcchar9 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar9_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar9_mps:11;
        /** hcchar9_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar9_epnum:4;
        /** hcchar9_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar9_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar9_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar9_lspddev:1;
        /** hcchar9_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar9_eptype:2;
        /** hcchar9_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar9_ec:2;
        /** hcchar9_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar9_devaddr:7;
        /** hcchar9_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar9_oddfrm:1;
        /** hcchar9_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar9_chdis:1;
        /** hcchar9_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar9_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar9_reg_t;

/** Type of hcchar10 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar10_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar10_mps:11;
        /** hcchar10_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar10_epnum:4;
        /** hcchar10_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar10_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar10_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar10_lspddev:1;
        /** hcchar10_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar10_eptype:2;
        /** hcchar10_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar10_ec:2;
        /** hcchar10_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar10_devaddr:7;
        /** hcchar10_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar10_oddfrm:1;
        /** hcchar10_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar10_chdis:1;
        /** hcchar10_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar10_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar10_reg_t;

/** Type of hcchar11 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar11_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar11_mps:11;
        /** hcchar11_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar11_epnum:4;
        /** hcchar11_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar11_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar11_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar11_lspddev:1;
        /** hcchar11_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar11_eptype:2;
        /** hcchar11_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar11_ec:2;
        /** hcchar11_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar11_devaddr:7;
        /** hcchar11_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar11_oddfrm:1;
        /** hcchar11_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar11_chdis:1;
        /** hcchar11_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar11_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar11_reg_t;

/** Type of hcchar12 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar12_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar12_mps:11;
        /** hcchar12_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar12_epnum:4;
        /** hcchar12_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar12_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar12_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar12_lspddev:1;
        /** hcchar12_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar12_eptype:2;
        /** hcchar12_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar12_ec:2;
        /** hcchar12_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar12_devaddr:7;
        /** hcchar12_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar12_oddfrm:1;
        /** hcchar12_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar12_chdis:1;
        /** hcchar12_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar12_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar12_reg_t;

/** Type of hcchar13 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar13_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar13_mps:11;
        /** hcchar13_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar13_epnum:4;
        /** hcchar13_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar13_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar13_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar13_lspddev:1;
        /** hcchar13_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar13_eptype:2;
        /** hcchar13_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar13_ec:2;
        /** hcchar13_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar13_devaddr:7;
        /** hcchar13_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar13_oddfrm:1;
        /** hcchar13_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar13_chdis:1;
        /** hcchar13_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar13_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar13_reg_t;

/** Type of hcchar14 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar14_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar14_mps:11;
        /** hcchar14_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar14_epnum:4;
        /** hcchar14_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar14_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar14_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar14_lspddev:1;
        /** hcchar14_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar14_eptype:2;
        /** hcchar14_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar14_ec:2;
        /** hcchar14_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar14_devaddr:7;
        /** hcchar14_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar14_oddfrm:1;
        /** hcchar14_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar14_chdis:1;
        /** hcchar14_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar14_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar14_reg_t;

/** Type of hcchar15 register
 *  This register contains the characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcchar15_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Indicates the maximum packet size of the associated endpoint.
         */
        uint32_t hcchar15_mps:11;
        /** hcchar15_epnum : R/W; bitpos: [14:11]; default: 0;
         *  Endpoint Number (EPNum)
         *
         *  Indicates the endpoint number on the device serving as the data source or sink.
         */
        uint32_t hcchar15_epnum:4;
        /** hcchar15_epdir : R/W; bitpos: [15]; default: 0;
         *  Endpoint Direction (EPDir)
         *
         *  Indicates whether the transaction is IN or OUT.
         *  - 1'b0: OUT
         *  - 1'b1: IN
         */
        uint32_t hcchar15_epdir:1;
        uint32_t reserved_16:1;
        /** hcchar15_lspddev : R/W; bitpos: [17]; default: 0;
         *  Low-Speed Device (LSpdDev)
         *
         *  This field is Set by the application to indicate that this channel is communicating
         *  to a low-speed device.
         *
         *  The application must program this bit when a low speed device is connected to the
         *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
         *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
         *
         *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
         *  set by the application software.
         */
        uint32_t hcchar15_lspddev:1;
        /** hcchar15_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Indicates the transfer type selected.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t hcchar15_eptype:2;
        /** hcchar15_ec : R/W; bitpos: [21:20]; default: 0;
         *  Multi Count (MC) / Error Count (EC)
         *
         *  When the Split Enable bit of the Host Channel-n Split Control
         *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
         *  the host the number of transactions that must be executed per
         *  microframe for this periodic endpoint. For non periodic transfers,
         *  this field is used only in DMA mode, and specifies the number
         *  packets to be fetched for this channel before the internal DMA
         *  engine changes arbitration.
         *  - 2'b00: Reserved This field yields undefined results.
         *  - 2'b01: 1 transaction
         *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
         *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
         *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
         *  number of immediate retries to be performed for a periodic split
         *  transactions on transaction errors. This field must be Set to at
         *  least 2'b01.
         */
        uint32_t hcchar15_ec:2;
        /** hcchar15_devaddr : R/W; bitpos: [28:22]; default: 0;
         *  Device Address (DevAddr)
         *
         *  This field selects the specific device serving as the data source
         *  or sink.
         */
        uint32_t hcchar15_devaddr:7;
        /** hcchar15_oddfrm : R/W; bitpos: [29]; default: 0;
         *  Odd Frame (OddFrm)
         *
         *  This field is set (reset) by the application to indicate that the OTG host must
         *  perform
         *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
         *  (isochronous and interrupt) transactions.
         *  - 1'b0: Even (micro)Frame
         *  - 1'b1: Odd (micro)Frame
         */
        uint32_t hcchar15_oddfrm:1;
        /** hcchar15_chdis : R/W; bitpos: [30]; default: 0;
         *  Channel Disable (ChDis)
         *
         *  The application sets this bit to stop transmitting/receiving data
         *  on a channel, even before the transfer for that channel is
         *  complete. The application must wait for the Channel Disabled
         *  interrupt before treating the channel as disabled.
         */
        uint32_t hcchar15_chdis:1;
        /** hcchar15_chena : R/W; bitpos: [31]; default: 0;
         *  Channel Enable (ChEna)
         *
         *  When Scatter/Gather mode is enabled
         *  - 1'b0: Indicates that the descriptor structure is not yet ready.
         *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
         *  is setup and this channel can access the descriptor.
         *  When Scatter/Gather mode is disabled
         *
         *  This field is set by the application and cleared by the OTG host.
         *  - 1'b0: Channel disabled
         *  - 1'b1: Channel enabled
         */
        uint32_t hcchar15_chena:1;
    };
    uint32_t val;
} usb_otghs_hcchar15_reg_t;


/** Group: This register contains the Split characteristics of the Host Channel. */
/** Type of hcsplt0 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt0_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt0_prtaddr:7;
        /** hcsplt0_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt0_hubaddr:7;
        /** hcsplt0_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt0_xactpos:2;
        /** hcsplt0_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt0_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt0_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt0_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt0_reg_t;

/** Type of hcsplt1 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt1_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt1_prtaddr:7;
        /** hcsplt1_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt1_hubaddr:7;
        /** hcsplt1_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt1_xactpos:2;
        /** hcsplt1_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt1_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt1_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt1_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt1_reg_t;

/** Type of hcsplt2 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt2_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt2_prtaddr:7;
        /** hcsplt2_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt2_hubaddr:7;
        /** hcsplt2_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt2_xactpos:2;
        /** hcsplt2_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt2_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt2_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt2_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt2_reg_t;

/** Type of hcsplt3 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt3_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt3_prtaddr:7;
        /** hcsplt3_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt3_hubaddr:7;
        /** hcsplt3_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt3_xactpos:2;
        /** hcsplt3_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt3_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt3_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt3_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt3_reg_t;

/** Type of hcsplt4 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt4_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt4_prtaddr:7;
        /** hcsplt4_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt4_hubaddr:7;
        /** hcsplt4_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt4_xactpos:2;
        /** hcsplt4_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt4_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt4_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt4_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt4_reg_t;

/** Type of hcsplt5 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt5_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt5_prtaddr:7;
        /** hcsplt5_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt5_hubaddr:7;
        /** hcsplt5_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt5_xactpos:2;
        /** hcsplt5_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt5_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt5_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt5_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt5_reg_t;

/** Type of hcsplt6 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt6_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt6_prtaddr:7;
        /** hcsplt6_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt6_hubaddr:7;
        /** hcsplt6_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt6_xactpos:2;
        /** hcsplt6_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt6_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt6_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt6_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt6_reg_t;

/** Type of hcsplt7 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt7_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt7_prtaddr:7;
        /** hcsplt7_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt7_hubaddr:7;
        /** hcsplt7_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt7_xactpos:2;
        /** hcsplt7_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt7_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt7_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt7_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt7_reg_t;

/** Type of hcsplt8 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt8_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt8_prtaddr:7;
        /** hcsplt8_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt8_hubaddr:7;
        /** hcsplt8_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt8_xactpos:2;
        /** hcsplt8_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt8_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt8_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt8_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt8_reg_t;

/** Type of hcsplt9 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt9_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt9_prtaddr:7;
        /** hcsplt9_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt9_hubaddr:7;
        /** hcsplt9_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt9_xactpos:2;
        /** hcsplt9_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt9_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt9_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt9_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt9_reg_t;

/** Type of hcsplt10 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt10_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt10_prtaddr:7;
        /** hcsplt10_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt10_hubaddr:7;
        /** hcsplt10_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt10_xactpos:2;
        /** hcsplt10_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt10_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt10_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt10_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt10_reg_t;

/** Type of hcsplt11 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt11_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt11_prtaddr:7;
        /** hcsplt11_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt11_hubaddr:7;
        /** hcsplt11_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt11_xactpos:2;
        /** hcsplt11_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt11_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt11_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt11_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt11_reg_t;

/** Type of hcsplt12 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt12_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt12_prtaddr:7;
        /** hcsplt12_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt12_hubaddr:7;
        /** hcsplt12_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt12_xactpos:2;
        /** hcsplt12_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt12_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt12_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt12_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt12_reg_t;

/** Type of hcsplt13 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt13_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt13_prtaddr:7;
        /** hcsplt13_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt13_hubaddr:7;
        /** hcsplt13_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt13_xactpos:2;
        /** hcsplt13_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt13_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt13_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt13_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt13_reg_t;

/** Type of hcsplt14 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt14_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt14_prtaddr:7;
        /** hcsplt14_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt14_hubaddr:7;
        /** hcsplt14_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt14_xactpos:2;
        /** hcsplt14_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt14_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt14_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt14_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt14_reg_t;

/** Type of hcsplt15 register
 *  This register contains the Split characteristics of the Host Channel.
 */
typedef union {
    struct {
        /** hcsplt15_prtaddr : R/W; bitpos: [6:0]; default: 0;
         *  Port Address (PrtAddr)
         *
         *  This field is the port number of the recipient transaction translator.
         */
        uint32_t hcsplt15_prtaddr:7;
        /** hcsplt15_hubaddr : R/W; bitpos: [13:7]; default: 0;
         *  Hub Address (HubAddr)
         *
         *  This field holds the device address of the transaction translator's hub.
         */
        uint32_t hcsplt15_hubaddr:7;
        /** hcsplt15_xactpos : R/W; bitpos: [15:14]; default: 0;
         *  Transaction Position (XactPos)
         *
         *  This field is used to determine whether to send all, first, middle, or last
         *  payloads with each OUT transaction.
         *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
         *  than or equal to 188 bytes).
         *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
         *  than 188 bytes).
         *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
         *  188 bytes).
         *  - 2'b01: End. This is the last payload of this transaction (which is larger than
         *  188 bytes).
         */
        uint32_t hcsplt15_xactpos:2;
        /** hcsplt15_compsplt : R/W; bitpos: [16]; default: 0;
         *  Do Complete Split (CompSplt)
         *
         *  The application sets this field to request the OTG host to perform a complete split
         *  transaction.
         */
        uint32_t hcsplt15_compsplt:1;
        uint32_t reserved_17:14;
        /** hcsplt15_spltena : R/W; bitpos: [31]; default: 0;
         *  Split Enable (SpltEna)
         *
         *  The application sets this field to indicate that this channel is enabled to perform
         *  split transactions.
         */
        uint32_t hcsplt15_spltena:1;
    };
    uint32_t val;
} usb_otghs_hcsplt15_reg_t;


/** Group: This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the "Interrupt Hierarchy" figure in the
 *  databook. The application must read this register when the Host Channels Interrupt
 *  bit of the Core Interrupt register (GINTSTS.HChInt) is set. Before the application
 *  can read this register, it must first read the Host All Channels Interrupt (HAINT)
 *  register to get the exact channel number for the Host Channel-n Interrupt register.
 *  The application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
/** Type of hcint0 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint0_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint0_xfercompl:1;
        /** hcint0_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint0_chhltd:1;
        /** hcint0_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint0_ahberr:1;
        /** hcint0_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint0_stall:1;
        /** hcint0_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint0_nak:1;
        /** hcint0_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint0_ack:1;
        /** hcint0_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint0_nyet:1;
        /** hcint0_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint0_xacterr:1;
        /** hcint0_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint0_bblerr:1;
        /** hcint0_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint0_frmovrun:1;
        /** hcint0_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint0_datatglerr:1;
        /** hcint0_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint0_bnaintr:1;
        /** hcint0_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint0_xcs_xact_err:1;
        /** hcint0_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint0_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint0_reg_t;

/** Type of hcint1 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint1_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint1_xfercompl:1;
        /** hcint1_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint1_chhltd:1;
        /** hcint1_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint1_ahberr:1;
        /** hcint1_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint1_stall:1;
        /** hcint1_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint1_nak:1;
        /** hcint1_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint1_ack:1;
        /** hcint1_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint1_nyet:1;
        /** hcint1_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint1_xacterr:1;
        /** hcint1_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint1_bblerr:1;
        /** hcint1_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint1_frmovrun:1;
        /** hcint1_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint1_datatglerr:1;
        /** hcint1_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint1_bnaintr:1;
        /** hcint1_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint1_xcs_xact_err:1;
        /** hcint1_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint1_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint1_reg_t;

/** Type of hcint2 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint2_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint2_xfercompl:1;
        /** hcint2_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint2_chhltd:1;
        /** hcint2_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint2_ahberr:1;
        /** hcint2_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint2_stall:1;
        /** hcint2_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint2_nak:1;
        /** hcint2_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint2_ack:1;
        /** hcint2_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint2_nyet:1;
        /** hcint2_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint2_xacterr:1;
        /** hcint2_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint2_bblerr:1;
        /** hcint2_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint2_frmovrun:1;
        /** hcint2_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint2_datatglerr:1;
        /** hcint2_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint2_bnaintr:1;
        /** hcint2_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint2_xcs_xact_err:1;
        /** hcint2_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint2_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint2_reg_t;

/** Type of hcint3 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint3_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint3_xfercompl:1;
        /** hcint3_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint3_chhltd:1;
        /** hcint3_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint3_ahberr:1;
        /** hcint3_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint3_stall:1;
        /** hcint3_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint3_nak:1;
        /** hcint3_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint3_ack:1;
        /** hcint3_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint3_nyet:1;
        /** hcint3_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint3_xacterr:1;
        /** hcint3_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint3_bblerr:1;
        /** hcint3_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint3_frmovrun:1;
        /** hcint3_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint3_datatglerr:1;
        /** hcint3_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint3_bnaintr:1;
        /** hcint3_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint3_xcs_xact_err:1;
        /** hcint3_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint3_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint3_reg_t;

/** Type of hcint4 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint4_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint4_xfercompl:1;
        /** hcint4_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint4_chhltd:1;
        /** hcint4_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint4_ahberr:1;
        /** hcint4_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint4_stall:1;
        /** hcint4_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint4_nak:1;
        /** hcint4_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint4_ack:1;
        /** hcint4_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint4_nyet:1;
        /** hcint4_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint4_xacterr:1;
        /** hcint4_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint4_bblerr:1;
        /** hcint4_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint4_frmovrun:1;
        /** hcint4_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint4_datatglerr:1;
        /** hcint4_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint4_bnaintr:1;
        /** hcint4_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint4_xcs_xact_err:1;
        /** hcint4_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint4_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint4_reg_t;

/** Type of hcint5 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint5_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint5_xfercompl:1;
        /** hcint5_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint5_chhltd:1;
        /** hcint5_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint5_ahberr:1;
        /** hcint5_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint5_stall:1;
        /** hcint5_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint5_nak:1;
        /** hcint5_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint5_ack:1;
        /** hcint5_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint5_nyet:1;
        /** hcint5_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint5_xacterr:1;
        /** hcint5_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint5_bblerr:1;
        /** hcint5_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint5_frmovrun:1;
        /** hcint5_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint5_datatglerr:1;
        /** hcint5_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint5_bnaintr:1;
        /** hcint5_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint5_xcs_xact_err:1;
        /** hcint5_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint5_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint5_reg_t;

/** Type of hcint6 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint6_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint6_xfercompl:1;
        /** hcint6_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint6_chhltd:1;
        /** hcint6_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint6_ahberr:1;
        /** hcint6_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint6_stall:1;
        /** hcint6_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint6_nak:1;
        /** hcint6_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint6_ack:1;
        /** hcint6_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint6_nyet:1;
        /** hcint6_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint6_xacterr:1;
        /** hcint6_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint6_bblerr:1;
        /** hcint6_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint6_frmovrun:1;
        /** hcint6_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint6_datatglerr:1;
        /** hcint6_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint6_bnaintr:1;
        /** hcint6_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint6_xcs_xact_err:1;
        /** hcint6_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint6_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint6_reg_t;

/** Type of hcint7 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint7_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint7_xfercompl:1;
        /** hcint7_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint7_chhltd:1;
        /** hcint7_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint7_ahberr:1;
        /** hcint7_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint7_stall:1;
        /** hcint7_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint7_nak:1;
        /** hcint7_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint7_ack:1;
        /** hcint7_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint7_nyet:1;
        /** hcint7_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint7_xacterr:1;
        /** hcint7_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint7_bblerr:1;
        /** hcint7_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint7_frmovrun:1;
        /** hcint7_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint7_datatglerr:1;
        /** hcint7_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint7_bnaintr:1;
        /** hcint7_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint7_xcs_xact_err:1;
        /** hcint7_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint7_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint7_reg_t;

/** Type of hcint8 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint8_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint8_xfercompl:1;
        /** hcint8_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint8_chhltd:1;
        /** hcint8_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint8_ahberr:1;
        /** hcint8_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint8_stall:1;
        /** hcint8_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint8_nak:1;
        /** hcint8_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint8_ack:1;
        /** hcint8_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint8_nyet:1;
        /** hcint8_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint8_xacterr:1;
        /** hcint8_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint8_bblerr:1;
        /** hcint8_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint8_frmovrun:1;
        /** hcint8_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint8_datatglerr:1;
        /** hcint8_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint8_bnaintr:1;
        /** hcint8_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint8_xcs_xact_err:1;
        /** hcint8_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint8_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint8_reg_t;

/** Type of hcint9 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint9_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint9_xfercompl:1;
        /** hcint9_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint9_chhltd:1;
        /** hcint9_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint9_ahberr:1;
        /** hcint9_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint9_stall:1;
        /** hcint9_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint9_nak:1;
        /** hcint9_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint9_ack:1;
        /** hcint9_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint9_nyet:1;
        /** hcint9_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint9_xacterr:1;
        /** hcint9_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint9_bblerr:1;
        /** hcint9_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint9_frmovrun:1;
        /** hcint9_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint9_datatglerr:1;
        /** hcint9_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint9_bnaintr:1;
        /** hcint9_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint9_xcs_xact_err:1;
        /** hcint9_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint9_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint9_reg_t;

/** Type of hcint10 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint10_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint10_xfercompl:1;
        /** hcint10_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint10_chhltd:1;
        /** hcint10_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint10_ahberr:1;
        /** hcint10_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint10_stall:1;
        /** hcint10_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint10_nak:1;
        /** hcint10_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint10_ack:1;
        /** hcint10_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint10_nyet:1;
        /** hcint10_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint10_xacterr:1;
        /** hcint10_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint10_bblerr:1;
        /** hcint10_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint10_frmovrun:1;
        /** hcint10_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint10_datatglerr:1;
        /** hcint10_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint10_bnaintr:1;
        /** hcint10_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint10_xcs_xact_err:1;
        /** hcint10_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint10_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint10_reg_t;

/** Type of hcint11 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint11_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint11_xfercompl:1;
        /** hcint11_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint11_chhltd:1;
        /** hcint11_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint11_ahberr:1;
        /** hcint11_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint11_stall:1;
        /** hcint11_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint11_nak:1;
        /** hcint11_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint11_ack:1;
        /** hcint11_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint11_nyet:1;
        /** hcint11_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint11_xacterr:1;
        /** hcint11_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint11_bblerr:1;
        /** hcint11_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint11_frmovrun:1;
        /** hcint11_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint11_datatglerr:1;
        /** hcint11_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint11_bnaintr:1;
        /** hcint11_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint11_xcs_xact_err:1;
        /** hcint11_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint11_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint11_reg_t;

/** Type of hcint12 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint12_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint12_xfercompl:1;
        /** hcint12_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint12_chhltd:1;
        /** hcint12_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint12_ahberr:1;
        /** hcint12_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint12_stall:1;
        /** hcint12_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint12_nak:1;
        /** hcint12_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint12_ack:1;
        /** hcint12_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint12_nyet:1;
        /** hcint12_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint12_xacterr:1;
        /** hcint12_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint12_bblerr:1;
        /** hcint12_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint12_frmovrun:1;
        /** hcint12_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint12_datatglerr:1;
        /** hcint12_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint12_bnaintr:1;
        /** hcint12_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint12_xcs_xact_err:1;
        /** hcint12_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint12_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint12_reg_t;

/** Type of hcint13 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint13_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint13_xfercompl:1;
        /** hcint13_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint13_chhltd:1;
        /** hcint13_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint13_ahberr:1;
        /** hcint13_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint13_stall:1;
        /** hcint13_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint13_nak:1;
        /** hcint13_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint13_ack:1;
        /** hcint13_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint13_nyet:1;
        /** hcint13_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint13_xacterr:1;
        /** hcint13_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint13_bblerr:1;
        /** hcint13_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint13_frmovrun:1;
        /** hcint13_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint13_datatglerr:1;
        /** hcint13_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint13_bnaintr:1;
        /** hcint13_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint13_xcs_xact_err:1;
        /** hcint13_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint13_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint13_reg_t;

/** Type of hcint14 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint14_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint14_xfercompl:1;
        /** hcint14_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint14_chhltd:1;
        /** hcint14_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint14_ahberr:1;
        /** hcint14_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint14_stall:1;
        /** hcint14_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint14_nak:1;
        /** hcint14_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint14_ack:1;
        /** hcint14_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint14_nyet:1;
        /** hcint14_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint14_xacterr:1;
        /** hcint14_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint14_bblerr:1;
        /** hcint14_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint14_frmovrun:1;
        /** hcint14_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint14_datatglerr:1;
        /** hcint14_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint14_bnaintr:1;
        /** hcint14_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint14_xcs_xact_err:1;
        /** hcint14_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint14_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint14_reg_t;

/** Type of hcint15 register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
typedef union {
    struct {
        /** hcint15_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed (XferCompl)
         *
         *  Transfer completed normally without any errors.This bit can be set only by the core
         *  and the application must write 1 to clear it.
         *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
         *  completed with IOC bit set in its descriptor.
         *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
         *  without any errors.
         */
        uint32_t hcint15_xfercompl:1;
        /** hcint15_chhltd : R/W; bitpos: [1]; default: 0;
         *  Channel Halted (ChHltd)
         *
         *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
         *  either because of any USB transaction error or in response to disable request by
         *  the application or because of a completed transfer.
         *
         *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
         *  the following
         *  - EOL being set in descriptor
         *  - AHB error
         *  - Excessive transaction errors
         *  - Babble
         *  - Stall
         */
        uint32_t hcint15_chhltd:1;
        /** hcint15_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during AHB
         *  read/write. The application can read the corresponding channel's DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t hcint15_ahberr:1;
        /** hcint15_stall : R/W; bitpos: [3]; default: 0;
         *  STALL Response Received Interrupt (STALL)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint15_stall:1;
        /** hcint15_nak : R/W; bitpos: [4]; default: 0;
         *  NAK Response Received Interrupt (NAK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint15_nak:1;
        /** hcint15_ack : R/W; bitpos: [5]; default: 0;
         *  ACK Response Received/Transmitted Interrupt (ACK)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint15_ack:1;
        /** hcint15_nyet : R/W; bitpos: [6]; default: 0;
         *  NYET Response Received Interrupt (NYET)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint15_nyet:1;
        /** hcint15_xacterr : R/W; bitpos: [7]; default: 0;
         *  Transaction Error (XactErr)
         *
         *  Indicates one of the following errors occurred on the USB.
         *  - CRC check failure
         *  - Timeout
         *  - Bit stuff error
         *  - False EOP
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
         *  core.This bit can be set only by the core and the application must write 1 to clear
         *  it.
         */
        uint32_t hcint15_xacterr:1;
        /** hcint15_bblerr : R/W; bitpos: [8]; default: 0;
         *  Babble Error (BblErr)
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
         *  This bit can be set only by the core and the application must write 1 to clear it.
         */
        uint32_t hcint15_bblerr:1;
        /** hcint15_frmovrun : R/W; bitpos: [9]; default: 0;
         *  Frame Overrun (FrmOvrun).
         *
         *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core. This bit can be set only by the core and the application must write 1
         *  to clear
         *  it.
         */
        uint32_t hcint15_frmovrun:1;
        /** hcint15_datatglerr : R/W; bitpos: [10]; default: 0;
         *
         *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
         *  application must write 1 to clear
         *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
         *  in the core.
         */
        uint32_t hcint15_datatglerr:1;
        /** hcint15_bnaintr : R/W; bitpos: [11]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process. BNA is not generated
         *  for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint15_bnaintr:1;
        /** hcint15_xcs_xact_err : R/W; bitpos: [12]; default: 0;
         *  Excessive Transaction Error (XCS_XACT_ERR)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
         *  is not generated for Isochronous channels.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint15_xcs_xact_err:1;
        /** hcint15_desc_lst_rollintr : R/W; bitpos: [13]; default: 0;
         *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
         *  bit
         *  when the corresponding channel's descriptor list rolls over.
         *  For non Scatter/Gather DMA mode, this bit is reserved.
         */
        uint32_t hcint15_desc_lst_rollintr:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcint15_reg_t;


/** Group: This register reflects the mask for each channel status described in the
 *  previous section.
 */
/** Type of hcintmsk0 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk0_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk0_xfercomplmsk:1;
        /** hcintmsk0_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk0_chhltdmsk:1;
        /** hcintmsk0_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk0_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk0_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk0_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk0_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk0_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk0_reg_t;

/** Type of hcintmsk1 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk1_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk1_xfercomplmsk:1;
        /** hcintmsk1_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk1_chhltdmsk:1;
        /** hcintmsk1_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk1_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk1_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk1_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk1_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk1_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk1_reg_t;

/** Type of hcintmsk2 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk2_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk2_xfercomplmsk:1;
        /** hcintmsk2_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk2_chhltdmsk:1;
        /** hcintmsk2_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk2_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk2_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk2_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk2_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk2_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk2_reg_t;

/** Type of hcintmsk3 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk3_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk3_xfercomplmsk:1;
        /** hcintmsk3_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk3_chhltdmsk:1;
        /** hcintmsk3_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk3_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk3_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk3_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk3_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk3_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk3_reg_t;

/** Type of hcintmsk4 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk4_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk4_xfercomplmsk:1;
        /** hcintmsk4_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk4_chhltdmsk:1;
        /** hcintmsk4_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk4_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk4_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk4_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk4_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk4_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk4_reg_t;

/** Type of hcintmsk5 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk5_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk5_xfercomplmsk:1;
        /** hcintmsk5_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk5_chhltdmsk:1;
        /** hcintmsk5_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk5_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk5_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk5_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk5_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk5_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk5_reg_t;

/** Type of hcintmsk6 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk6_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk6_xfercomplmsk:1;
        /** hcintmsk6_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk6_chhltdmsk:1;
        /** hcintmsk6_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk6_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk6_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk6_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk6_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk6_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk6_reg_t;

/** Type of hcintmsk7 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk7_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk7_xfercomplmsk:1;
        /** hcintmsk7_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk7_chhltdmsk:1;
        /** hcintmsk7_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk7_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk7_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk7_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk7_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk7_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk7_reg_t;

/** Type of hcintmsk8 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk8_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk8_xfercomplmsk:1;
        /** hcintmsk8_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk8_chhltdmsk:1;
        /** hcintmsk8_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk8_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk8_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk8_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk8_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk8_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk8_reg_t;

/** Type of hcintmsk9 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk9_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk9_xfercomplmsk:1;
        /** hcintmsk9_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk9_chhltdmsk:1;
        /** hcintmsk9_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk9_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk9_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk9_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk9_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk9_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk9_reg_t;

/** Type of hcintmsk10 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk10_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk10_xfercomplmsk:1;
        /** hcintmsk10_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk10_chhltdmsk:1;
        /** hcintmsk10_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk10_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk10_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk10_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk10_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk10_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk10_reg_t;

/** Type of hcintmsk11 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk11_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk11_xfercomplmsk:1;
        /** hcintmsk11_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk11_chhltdmsk:1;
        /** hcintmsk11_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk11_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk11_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk11_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk11_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk11_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk11_reg_t;

/** Type of hcintmsk12 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk12_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk12_xfercomplmsk:1;
        /** hcintmsk12_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk12_chhltdmsk:1;
        /** hcintmsk12_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk12_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk12_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk12_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk12_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk12_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk12_reg_t;

/** Type of hcintmsk13 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk13_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk13_xfercomplmsk:1;
        /** hcintmsk13_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk13_chhltdmsk:1;
        /** hcintmsk13_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk13_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk13_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk13_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk13_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk13_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk13_reg_t;

/** Type of hcintmsk14 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk14_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk14_xfercomplmsk:1;
        /** hcintmsk14_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk14_chhltdmsk:1;
        /** hcintmsk14_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk14_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk14_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk14_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk14_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk14_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk14_reg_t;

/** Type of hcintmsk15 register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
typedef union {
    struct {
        /** hcintmsk15_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *
         *  Transfer Completed Mask (XferComplMsk)
         */
        uint32_t hcintmsk15_xfercomplmsk:1;
        /** hcintmsk15_chhltdmsk : R/W; bitpos: [1]; default: 0;
         *
         *  Channel Halted Mask (ChHltdMsk)
         */
        uint32_t hcintmsk15_chhltdmsk:1;
        /** hcintmsk15_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *
         *  AHB Error Mask (AHBErrMsk)
         *  In  scatter/gather  DMA  mode  for  host,
         *  interrupts are not generated due to the corresponding bits set in
         *  HCINTn.
         */
        uint32_t hcintmsk15_ahberrmsk:1;
        uint32_t reserved_3:8;
        /** hcintmsk15_bnaintrmsk : R/W; bitpos: [11]; default: 0;
         *
         *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk15_bnaintrmsk:1;
        uint32_t reserved_12:1;
        /** hcintmsk15_desc_lst_rollintrmsk : R/W; bitpos: [13]; default: 0;
         *
         *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         */
        uint32_t hcintmsk15_desc_lst_rollintrmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_hcintmsk15_reg_t;


/** Group: This register reflects the transfer size for the Host Channel. */
/** Type of hctsiz0 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz0_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz0_xfersize:19;
        /** hctsiz0_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz0_pktcnt:10;
        /** hctsiz0_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz0_pid:2;
        /** hctsiz0_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz0_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz0_reg_t;

/** Type of hctsiz1 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz1_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz1_xfersize:19;
        /** hctsiz1_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz1_pktcnt:10;
        /** hctsiz1_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz1_pid:2;
        /** hctsiz1_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz1_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz1_reg_t;

/** Type of hctsiz2 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz2_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz2_xfersize:19;
        /** hctsiz2_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz2_pktcnt:10;
        /** hctsiz2_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz2_pid:2;
        /** hctsiz2_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz2_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz2_reg_t;

/** Type of hctsiz3 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz3_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz3_xfersize:19;
        /** hctsiz3_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz3_pktcnt:10;
        /** hctsiz3_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz3_pid:2;
        /** hctsiz3_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz3_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz3_reg_t;

/** Type of hctsiz4 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz4_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz4_xfersize:19;
        /** hctsiz4_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz4_pktcnt:10;
        /** hctsiz4_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz4_pid:2;
        /** hctsiz4_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz4_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz4_reg_t;

/** Type of hctsiz5 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz5_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz5_xfersize:19;
        /** hctsiz5_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz5_pktcnt:10;
        /** hctsiz5_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz5_pid:2;
        /** hctsiz5_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz5_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz5_reg_t;

/** Type of hctsiz6 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz6_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz6_xfersize:19;
        /** hctsiz6_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz6_pktcnt:10;
        /** hctsiz6_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz6_pid:2;
        /** hctsiz6_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz6_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz6_reg_t;

/** Type of hctsiz7 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz7_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz7_xfersize:19;
        /** hctsiz7_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz7_pktcnt:10;
        /** hctsiz7_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz7_pid:2;
        /** hctsiz7_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz7_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz7_reg_t;

/** Type of hctsiz8 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz8_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz8_xfersize:19;
        /** hctsiz8_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz8_pktcnt:10;
        /** hctsiz8_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz8_pid:2;
        /** hctsiz8_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz8_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz8_reg_t;

/** Type of hctsiz9 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz9_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz9_xfersize:19;
        /** hctsiz9_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz9_pktcnt:10;
        /** hctsiz9_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz9_pid:2;
        /** hctsiz9_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz9_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz9_reg_t;

/** Type of hctsiz10 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz10_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz10_xfersize:19;
        /** hctsiz10_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz10_pktcnt:10;
        /** hctsiz10_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz10_pid:2;
        /** hctsiz10_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz10_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz10_reg_t;

/** Type of hctsiz11 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz11_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz11_xfersize:19;
        /** hctsiz11_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz11_pktcnt:10;
        /** hctsiz11_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz11_pid:2;
        /** hctsiz11_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz11_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz11_reg_t;

/** Type of hctsiz12 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz12_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz12_xfersize:19;
        /** hctsiz12_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz12_pktcnt:10;
        /** hctsiz12_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz12_pid:2;
        /** hctsiz12_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz12_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz12_reg_t;

/** Type of hctsiz13 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz13_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz13_xfersize:19;
        /** hctsiz13_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz13_pktcnt:10;
        /** hctsiz13_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz13_pid:2;
        /** hctsiz13_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz13_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz13_reg_t;

/** Type of hctsiz14 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz14_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz14_xfersize:19;
        /** hctsiz14_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz14_pktcnt:10;
        /** hctsiz14_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz14_pid:2;
        /** hctsiz14_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz14_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz14_reg_t;

/** Type of hctsiz15 register
 *  This register reflects the transfer size for the Host Channel.
 */
typedef union {
    struct {
        /** hctsiz15_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Transfer Size (XferSize)
         *
         *  For an OUT, this field is the number of data bytes the host sends during the
         *  transfer.
         *
         *  For an IN, this field is the buffer size that the application has Reserved for the
         *  transfer. The application is expected to program this field as an integer multiple
         *  of the maximum packet size for IN transactions (periodic and non-periodic).
         *
         *  The width of this counter is specified as Width of Transfer Size Counters during
         *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [18:16]: Reserved
         *
         *  [15:8]: NTD (Number of Transfer Descriptors)
         *
         *  (Non Isochronous)
         *
         *  This value is in terms of number of descriptors. Maximum number of descriptor that
         *  can be present in the list is 64. The values can be from 0 to 63.
         *  - 0: 1 descriptor
         *  - 63: 64 descriptors
         *  This field indicates the total number of descriptors present in that list. The core
         *  wraps around after servicing NTD number of descriptors for that list.
         *
         *  (Isochronous)
         *
         *  This field indicates the number of descriptors present in that list microframe.
         *
         *  The possible values for FS are
         *  - 1: 2 descriptors
         *  - 3: 4 descriptors
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  The possible values for HS are
         *  - 7: 8 descriptors
         *  - 15: 16 descriptors
         *  - 31: 32 descriptors
         *  - 63: 64 descriptors
         *  - 127: 128 descriptors
         *  - 255: 256 descriptors
         *  [7:0]: SCHED_INFO (Schedule information)
         *
         *  Every bit in this 8 bit register indicates scheduling for that microframe.
         *
         *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
         *  8th microframe in that frame.
         *
         *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
         *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
         *  indicates that the corresponding interrupt channel is scheduled to issue a token
         *  every alternate microframe starting with second microframe. Note that this field is
         *  applicable only for periodic (Isochronous and Interrupt) channels.
         */
        uint32_t hctsiz15_xfersize:19;
        /** hctsiz15_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Non-Scatter/Gather DMA Mode:
         *
         *  Packet Count (PktCnt)
         *
         *  This field is programmed by the application with the expected number of packets to
         *  be transmitted (OUT) or received (IN).
         *
         *  The host decrements this count on every successful transmission or reception of an
         *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
         *  indicate normal completion.
         *
         *  The width of this counter is specified as Width of Packet Counters during
         *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
         *
         *  Scatter/Gather DMA Mode:
         *
         *  [28:19]: Reserved
         */
        uint32_t hctsiz15_pktcnt:10;
        /** hctsiz15_pid : R/W; bitpos: [30:29]; default: 0;
         *  PID (Pid)
         *
         *  The application programs this field with the type of PID to use for the initial
         *  transaction. The host maintains this field for the rest of the transfer.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA (non-control)/SETUP (control)
         */
        uint32_t hctsiz15_pid:2;
        /** hctsiz15_dopng : R/W; bitpos: [31]; default: 0;
         *  Do Ping (DoPng)
         *
         *  This bit is used only for OUT transfers.
         *  Setting this field to 1 directs the host to do PING protocol.
         *
         *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
         *  disables the channel.
         */
        uint32_t hctsiz15_dopng:1;
    };
    uint32_t val;
} usb_otghs_hctsiz15_reg_t;


/** Group: This register is used by the OTG host in the internal DMA mode to maintain
 *  the current buffer pointer for IN/OUT transactions. The starting DMA address must
 *  be DWORD-aligned.
 */
/** Type of hcdma0 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma0_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma0_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma0_reg_t;

/** Type of hcdma1 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma1_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma1_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma1_reg_t;

/** Type of hcdma2 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma2_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma2_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma2_reg_t;

/** Type of hcdma3 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma3_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma3_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma3_reg_t;

/** Type of hcdma4 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma4_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma4_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma4_reg_t;

/** Type of hcdma5 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma5_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma5_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma5_reg_t;

/** Type of hcdma6 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma6_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma6_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma6_reg_t;

/** Type of hcdma7 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma7_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma7_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma7_reg_t;

/** Type of hcdma8 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma8_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma8_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma8_reg_t;

/** Type of hcdma9 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma9_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma9_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma9_reg_t;

/** Type of hcdma10 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma10_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma10_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma10_reg_t;

/** Type of hcdma11 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma11_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma11_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma11_reg_t;

/** Type of hcdma12 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma12_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma12_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma12_reg_t;

/** Type of hcdma13 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma13_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma13_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma13_reg_t;

/** Type of hcdma14 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma14_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma14_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma14_reg_t;

/** Type of hcdma15 register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
typedef union {
    struct {
        /** hcdma15_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  In Buffer DMA Mode:
         *
         *  [31:0]: DMA Address (DMAAddr)
         *
         *  This field holds the start address in the external memory from which the data for
         *  the endpoint must be fetched or to which it must be stored. This register is
         *  incremented on every AHB transaction.
         *
         *  Reset: X if not programmed as the register is in SPRAM.
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
         *
         *  [31:9]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the start address of the 512 bytes page. The first descriptor in
         *  the list must be located in this address. The first descriptor may be or may not be
         *  ready. The core starts processing the list from the CTD value.
         *
         *  [8:3]: Current Transfer Desc(CTD)
         *
         *  This value is in terms of number of descriptors. The values can be from 0 to 63.
         *  - 0 -  1 descriptor.
         *  - 63 - 64 descriptors.
         *  This field indicates the current descriptor processed in the list. This field is
         *  updated both by application and the core. For example, if the application enables
         *  the channel after programming CTD=5, then the core starts processing the sixth
         *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
         *  DMAAddr.
         *
         *  Reset: 6'h0
         *
         *  [2:0]: Reserved
         *
         *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
         *
         *  [31:N]: DMA Address (DMAAddr)
         *
         *  The start address must be 512-bytes aligned.
         *
         *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
         *  isochronous descriptors are present where N is based on nTD as follows:
         *  - [31:N]: Base Address
         *  - [N-1:3]: Offset
         *  - [2:0]: 000
         *  For HS ISOC, if nTD is,
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  - 127, N=10
         *  - 255, N=11
         *  For FS ISOC, if nTD is,
         *  - 1, N=4
         *  - 3, N=5
         *  - 7, N=6
         *  - 15, N=7
         *  - 31, N=8
         *  - 63, N=9
         *  [N-1:3]: Current Transfer Desc(CTD)
         *
         *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
         *  set to zero by application.
         *
         *  Reset: (N+1:3)'h0
         *
         *  [2:0]: Reserved
         */
        uint32_t hcdma15_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_hcdma15_reg_t;


/** Group: This register is present only in case of Scatter/Gather DMA. It is
 *  implemented in RAM instead of flop-based implementation. This register holds the
 *  current buffer address.
 */
/** Type of hcdmab0 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab0_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab0_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab0_reg_t;

/** Type of hcdmab1 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab1_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab1_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab1_reg_t;

/** Type of hcdmab2 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab2_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab2_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab2_reg_t;

/** Type of hcdmab3 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab3_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab3_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab3_reg_t;

/** Type of hcdmab4 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab4_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab4_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab4_reg_t;

/** Type of hcdmab5 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab5_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab5_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab5_reg_t;

/** Type of hcdmab6 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab6_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab6_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab6_reg_t;

/** Type of hcdmab7 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab7_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab7_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab7_reg_t;

/** Type of hcdmab8 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab8_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab8_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab8_reg_t;

/** Type of hcdmab9 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab9_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab9_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab9_reg_t;

/** Type of hcdmab10 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab10_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab10_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab10_reg_t;

/** Type of hcdmab11 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab11_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab11_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab11_reg_t;

/** Type of hcdmab12 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab12_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab12_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab12_reg_t;

/** Type of hcdmab13 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab13_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab13_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab13_reg_t;

/** Type of hcdmab14 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab14_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab14_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab14_reg_t;

/** Type of hcdmab15 register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
typedef union {
    struct {
        /** hcdmab15_hcdmab : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.
         *  This register is updated as and when the data transfer for the corresponding end
         *  point
         *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
         *  this
         *  field is reserved.
         */
        uint32_t hcdmab15_hcdmab:32;
    };
    uint32_t val;
} usb_otghs_hcdmab15_reg_t;


/** Group: This register configures the core in Device mode after power-on or after
 *  certain control commands or enumeration. Do not make changes to this register after
 *  initial programming.
 */
/** Type of dcfg register
 *  This register configures the core in Device mode after power-on or after certain
 *  control commands or enumeration. Do not make changes to this register after initial
 *  programming.
 */
typedef union {
    struct {
        /** dcfg_devspd : R/W; bitpos: [1:0]; default: 0;
         *  Device Speed (DevSpd)
         *
         *  Indicates the speed at which the application requires the core to
         *  enumerate, or the maximum speed the application can support.
         *  However, the actual bus speed is determined only after the connect
         *  sequence is completed, and is based on the speed of the USB
         *  host to which the core is connected.
         */
        uint32_t dcfg_devspd:2;
        /** dcfg_nzstsouthshk : R/W; bitpos: [2]; default: 0;
         *  Non-Zero-Length Status OUT Handshake (NZStsOUTHShk)
         *
         *  The application can use this field to select the handshake the core sends on
         *  receiving a nonzero-length data packet during the OUT transaction of a control
         *  transfer's Status stage.
         *  - 1'b1: Send a STALL handshake on a nonzero-length status OUT transaction and do
         *  not send the received OUT packet to the application.
         *  - 1'b0: Send the received OUT packet to the application (zerolength or
         *  nonzero-length) and send a handshake based on the NAK and STALL bits for the
         *  endpoint in the Device Endpoint Control register.
         */
        uint32_t dcfg_nzstsouthshk:1;
        /** dcfg_ena32khzsusp : R/W; bitpos: [3]; default: 0;
         *  Enable 32 KHz Suspend mode (Ena32KHzSusp)
         *
         *  This bit can be set only if FS PHY interface is selected. Otherwise, this bit needs
         *  to be set to zero. If FS PHY interface is chosen and this bit is set, the PHY clock
         *  during Suspend must be switched from 48 MHz to 32 KHz.
         */
        uint32_t dcfg_ena32khzsusp:1;
        /** dcfg_devaddr : R/W; bitpos: [10:4]; default: 0;
         *  Device Address (DevAddr)
         *
         *  The application must program this field after every SetAddress control command.
         */
        uint32_t dcfg_devaddr:7;
        /** dcfg_perfrint : R/W; bitpos: [12:11]; default: 0;
         *  Periodic Frame Interval (PerFrInt)
         *
         *  Indicates the time within a (micro)Frame at which the application
         *  must be notified using the End Of Periodic Frame Interrupt. This
         *  can be used to determine If all the isochronous traffic for that
         *  (micro)Frame is complete.
         *  - 2'b00: 80% of the (micro)Frame interval
         *  - 2'b01: 85% of the (micro)Frame interval
         *  - 2'b10: 90% of the (micro)Frame interval
         *  - 2'b11: 95% of the (micro)Frame interval
         */
        uint32_t dcfg_perfrint:2;
        /** dcfg_endevoutnak : R/W; bitpos: [13]; default: 0;
         *  Enable Device OUT NAK (EnDevOutNak)
         *
         *  This bit enables setting NAK for Bulk OUT endpoints after the transfer is completed
         *  for Device mode Descriptor DMA
         *  - 1'b0 : The core does not set NAK after Bulk OUT transfer complete
         *  - 1'b1  :  The core sets NAK after Bulk OUT transfer complete
         *  This bit is one time programmable after reset like any other DCFG register bits.
         */
        uint32_t dcfg_endevoutnak:1;
        /** dcfg_xcvrdly : R/W; bitpos: [14]; default: 0;
         *  XCVRDLY
         *
         *  Enables or disables delay between xcvr_sel and txvalid during device chirp
         */
        uint32_t dcfg_xcvrdly:1;
        /** dcfg_erraticintmsk : R/W; bitpos: [15]; default: 0;
         *  Erratic Error Interrupt Mask
         */
        uint32_t dcfg_erraticintmsk:1;
        uint32_t reserved_16:1;
        /** dcfg_ipgisocsupt : R/W; bitpos: [17]; default: 1;
         *  Worst-Case Inter-Packet Gap ISOC OUT Support (ipgisocSupt)
         *
         *  This bit indicates that the controller supports the worst-case scenario of Rx
         *  followed by Rx Inter-Packet Gap (IPG) (32 bit times) as per the UTMI Specification
         *  for any token following an ISOC OUT token. Without this support, when any token
         *  follows an ISOC OUT token with the worst-case IPG, the controller does not detect
         *  the followed token. The worst-case IPG of the controller without this support
         *  depends on the AHB and PHY clock frequency.
         */
        uint32_t dcfg_ipgisocsupt:1;
        uint32_t reserved_18:5;
        /** dcfg_descdma : R/W; bitpos: [23]; default: 0;
         *  Enable Scatter/gather DMA in device mode (DescDMA).
         *
         *  When the Scatter/Gather DMA option selected during configuration of the RTL, the
         *  application can Set this bit during initialization to enable the Scatter/Gather DMA
         *  operation.
         *
         *  Note: This bit must be modified only once after a reset. The following combinations
         *  are available for programming:
         *  - GAHBCFG.DMAEn=0,DCFG.DescDMA=0 => Slave mode
         *  - GAHBCFG.DMAEn=0,DCFG.DescDMA=1 => Invalid
         *  - GAHBCFG.DMAEn=1,DCFG.DescDMA=0 => Buffered DMA mode
         *  - GAHBCFG.DMAEn=1,DCFG.DescDMA=1 => Scatter/Gather DMA mode
         */
        uint32_t dcfg_descdma:1;
        /** dcfg_perschintvl : R/W; bitpos: [25:24]; default: 0;
         *  Periodic Scheduling Interval (PerSchIntvl)
         *
         *  PerSchIntvl must be programmed for Scatter/Gather DMA mode.
         *
         *  This field specifies the amount of time the Internal
         *  DMA engine must allocate for fetching periodic IN endpoint data.
         *  Based on the number of periodic endpoints, this value must be
         *  specified as 25,50 or 75% of (micro)Frame.
         *  - When any periodic endpoints are active, the internal DMA engine allocates the
         *  specified amount of time in fetching periodic IN endpoint data .
         *  - When no periodic endpoints are active, Then the internal DMA engine services
         *  non-periodic endpoints, ignoring this field.
         *  - After the specified time within a (micro)Frame, the DMA switches to fetching for
         *  non-periodic endpoints.
         *  -- 2'b00: 25% of (micro)Frame.
         *  -- 2'b01: 50% of (micro)Frame.
         *  -- 2'b10: 75% of (micro)Frame.
         *  -- 2'b11: Reserved.
         *  Reset: 2'b00
         */
        uint32_t dcfg_perschintvl:2;
        /** dcfg_resvalid : R/W; bitpos: [31:26]; default: 2;
         *  Resume Validation Period (ResValid)
         *
         *  This field is effective only when DCFG.Ena32KHzSusp is set.
         *  It controls the resume period when the core resumes from
         *  suspend. The core counts for ResValid number of clock cycles
         *  to detect a valid resume when this bit is set
         */
        uint32_t dcfg_resvalid:6;
    };
    uint32_t val;
} usb_otghs_dcfg_reg_t;


/** Group: This register is used to control the characteristics of the Device
 *  controller.
 */
/** Type of dctl register
 *  This register is used to control the characteristics of the Device controller.
 */
typedef union {
    struct {
        /** dctl_rmtwkupsig : R/W; bitpos: [0]; default: 0;
         *  Remote Wakeup Signaling (RmtWkUpSig)
         *
         *  When the application sets this bit, the core initiates remote
         *  signaling to wake up the USB host. The application must Set this
         *  bit to instruct the core to exit the Suspend state. As specified in
         *  the USB 2.0 specification, the application must clear this bit
         *  1-15 ms after setting it.
         *
         *
         *  If LPM is enabled and the core is in the L1 (Sleep) state, when the application
         *  sets this bit, the core initiates L1 remote signaling to wake up the USB host. The
         *  application must set this bit to instruct the core to exit the Sleep state. As
         *  specified in the LPM specification, the hardware automatically clears this bit 50
         *  microseconds (TL1DevDrvResume) after being set by the application. The application
         *  must not set this bit when GLPMCFG bRemoteWake from the previous LPM transaction is
         *  zero.
         */
        uint32_t dctl_rmtwkupsig:1;
        /** dctl_sftdiscon : R/W; bitpos: [1]; default: 1;
         *  Soft Disconnect (SftDiscon)
         *
         *  The application uses this bit to signal the controller to do a soft disconnect. As
         *  long as this bit is set, the host does not see that the device is connected, and
         *  the device does not receive
         *  signals on the USB. The core stays in the disconnected state until the application
         *  clears this bit.
         *  - 1'b0: Normal operation. When this bit is cleared after a soft disconnect, the
         *  core drives the phy_opmode_o signal on the
         *  UTMI+ to 2'b00, which generates a device connect event to the USB host. When the
         *  device is reconnected, the USB host restarts device enumeration.
         *  - 1'b1: The core drives the phy_opmode_o signal on the UTMI+ to 2'b01, which
         *  generates a device disconnect event to the USB host.
         *  The following is the minimum duration under various conditions for which this bit
         *  must be set for the USB host to detect a device disconnect. To accommodate clock
         *  jitter, it is
         *  recommended that the application adds some extra delay to the specified minimum
         *  duration.
         *
         *  For high speed, if the device state is,
         *  - Suspended, the minimum duration is 1ms + 2.5us
         *  - Idle, the minimum duration is 3ms + 2.5us
         *  - Not Idle or Suspended (performing transactions), the minimum duration 125 us
         *  For full speed/low speed, if the device state is,
         *  - Suspended, the minimum duration is 1ms + 2.5us
         *  - Idle, the minimum duration is 2.5us
         *  - Not Idle or Suspended (performing transactions), the minimum duration 125 us
         *  Note:
         *  - This bit can be also used for ULPI/FS Serial interfaces.
         *  - This bit is not impacted by a soft reset.
         */
        uint32_t dctl_sftdiscon:1;
        /** dctl_gnpinnaksts : RO; bitpos: [2]; default: 0;
         *  Global Non-periodic IN NAK Status (GNPINNakSts)
         *  - 1'b0: A handshake is sent out based on the data availability in the transmit FIFO.
         *  - 1'b1: A NAK handshake is sent out on all non-periodic IN endpoints, irrespective
         *  of the data availability in the transmit FIFO.
         */
        uint32_t dctl_gnpinnaksts:1;
        /** dctl_goutnaksts : RO; bitpos: [3]; default: 0;
         *  Global OUT NAK Status (GOUTNakSts)
         *  - 1'b0: A handshake is sent based on the FIFO Status and the NAK and STALL bit
         *  settings.
         *  - 1'b1: No data is written to the RxFIFO, irrespective of space availability. Sends
         *  a NAK handshake on all packets, except on SETUP transactions. All isochronous OUT
         *  packets are dropped.
         */
        uint32_t dctl_goutnaksts:1;
        /** dctl_tstctl : R/W; bitpos: [6:4]; default: 0;
         *  Test Control (TstCtl)
         *  - 3'b000: Test mode disabled
         *  - 3'b001: Test_J mode
         *  - 3'b010: Test_K mode
         *  - 3'b011: Test_SE0_NAK mode
         *  - 3'b100: Test_Packet mode
         *  - 3'b101: Test_Force_Enable
         *  - Others: Reserved
         */
        uint32_t dctl_tstctl:3;
        /** dctl_sgnpinnak : R/W; bitpos: [7]; default: 0;
         *  Set Global Non-periodic IN NAK (SGNPInNak)
         *
         *  A write to this field sets the Global Non-periodic IN NAK.The application uses this
         *  bit to send a NAK handshake on all non-periodic IN endpoints.
         *  The core can also Set this bit when a timeout condition is detected on a
         *  non-periodic endpoint in shared FIFO operation.
         *  The application must Set this bit only after making sure that the Global IN NAK
         *  Effective bit in the Core Interrupt Register (GINTSTS.GINNakEff) is cleared
         */
        uint32_t dctl_sgnpinnak:1;
        /** dctl_cgnpinnak : R/W; bitpos: [8]; default: 0;
         *  Clear Global Non-periodic IN NAK (CGNPInNak)
         *
         *  A write to this field clears the Global Non-periodic IN NAK.
         */
        uint32_t dctl_cgnpinnak:1;
        /** dctl_sgoutnak : R/W; bitpos: [9]; default: 0;
         *  Set Global OUT NAK (SGOUTNak)
         *
         *  A write to this field sets the Global OUT NAK. The application uses this bit to
         *  send a NAK handshake on all OUT endpoints.
         *  The application must set the this bit only after making sure that the Global OUT
         *  NAK Effective bit in the Core Interrupt Register (GINTSTS.GOUTNakEff) is cleared.
         */
        uint32_t dctl_sgoutnak:1;
        /** dctl_cgoutnak : R/W; bitpos: [10]; default: 0;
         *  Clear Global OUT NAK (CGOUTNak)
         *
         *  A write to this field clears the Global OUT NAK.
         */
        uint32_t dctl_cgoutnak:1;
        /** dctl_pwronprgdone : R/W; bitpos: [11]; default: 0;
         *  Power-On Programming Done (PWROnPrgDone)
         *
         *  The application uses this bit to indicate that register programming is completed
         *  after a wake-up from Power Down mode.
         */
        uint32_t dctl_pwronprgdone:1;
        uint32_t reserved_12:1;
        /** dctl_gmc : R/W; bitpos: [14:13]; default: 0;
         *  Global Multi Count (GMC)
         *
         *  GMC must be programmed only once after initialization.
         *  Applicable only for Scatter/Gather DMA mode. This indicates the number of packets
         *  to be serviced for that end point before moving to the next end point. It is only
         *  for non-periodic endpoints.
         *  - 2'b00: Invalid.
         *  - 2'b01: 1 packet.
         *  - 2'b10: 2 packets.
         *  - 2'b11: 3 packets.
         *  The value of this field automatically changes to 2'h1 when DCFG.DescDMA is set to
         *  1. When Scatter/Gather DMA mode is disabled, this field is reserved. and reads
         *  2'b00.
         */
        uint32_t dctl_gmc:2;
        /** dctl_ignrfrmnum : R/W; bitpos: [15]; default: 0;
         *  Ignore Frame Number Feature for Isochronous Endpoints (IgnrFrmNum)
         *
         *  This field is also used to control the Periodic Transfer Interrupt (PTI) feature.
         *
         *  Note: Do not program IgnrFrmNum bit to 1'b1 when the core is operating in threshold
         *  mode.
         *
         *  Slave Mode (GAHBCFG.DMAEn=0):
         *
         *  This bit is not valid in Slave mode and must not be programmed to 1.
         *
         *  Scatter/Gather DMA Mode (GAHBCFG.DMAEn=1,DCFG.DescDMA=1):
         *
         *  Note: When Scatter/Gather DMA mode is enabled this feature is not applicable to
         *  High Speed, High bandwidth transfers.
         *
         *  When this bit is enabled, there must be only one packet per descriptor.
         *  - 0: The core transmits the packets only in the frame number in which they are
         *  intended to be transmitted.
         *  - 1: The core ignores the frame number, sending packets immediately as the packets
         *  are ready.
         *  In Scatter/Gather DMA mode, if this bit is enabled, the packets are not flushed
         *  when a ISOC IN token is received for an elapsed frame.
         *
         *  Non-Scatter/Gather DMA Mode, that is, Buffer DMA Mode
         *  (GAHBCFG.DMAEn=1,DCFG.DescDMA=0):
         *
         *  When Scatter/Gather DMA mode is disabled, this field is used by the application to
         *  enable Periodic Transfer Interrupt (PTI) Mode.
         *
         *  The application can program Periodic Endpoint transfers for multiple (micro)Frames.
         *  - 0: Periodic Transfer Interrupt feature is disabled, application needs to program
         *  transfers for periodic endpoints every (micro)Frame
         *  - 1: Periodic Transfer Interrupt feature is enabled, application can program
         *  transfers for multiple (micro)Frames for periodic endpoints.
         *  In the PTI mode, the application receives Transfer Complete Interrupt after
         *  transfers for multiple (micro)Frames are completed.
         */
        uint32_t dctl_ignrfrmnum:1;
        /** dctl_nakonbble : R/W; bitpos: [16]; default: 0;
         *  NAK on Babble Error (NakOnBble)
         *
         *  Set NAK automatically on babble (NakOnBble). The core sets NAK automatically for
         *  the endpoint on which babble is received.
         */
        uint32_t dctl_nakonbble:1;
        /** dctl_encontonbna : R/W; bitpos: [17]; default: 0;
         *  Enable Continue on BNA (EnContOnBNA)
         *
         *  This bit enables the core to continue on BNA for Bulk OUT endpoints.
         *  With this feature enabled, when a Bulk OUT or INTR OUT endpoint receives a BNA
         *  interrupt
         *  the core starts processing the descriptor that caused the BNA interrupt after
         *  the endpoint re-enables the endpoint.
         *  - 1'b0: After receiving BNA interrupt,the core disables the endpoint. When the
         *  endpoint is re-enabled by the application, the core starts processing from the
         *  DOEPDMA descriptor.
         *  - 1'b1: After receiving BNA interrupt, the core disables the endpoint. When the
         *  endpoint is re-enabled by the application, the core starts processing from the
         *  descriptor that received the BNA interrupt.
         *  This bit is valid only when OTG_EN_DESC_DMA == 1'b1. It is a one-time programmable
         *  after reset bit like any other DCTL register bits.
         */
        uint32_t dctl_encontonbna:1;
        uint32_t reserved_18:1;
        /** dctl_servint : R/W; bitpos: [19]; default: 0;
         *  Service Interval based scheduling for Isochronous IN Endpoints
         *
         *  This field is used to enable service interval based scheduling feature for ISOC IN
         *  EPs.
         *
         *  Note: This bit is applicable only in device mode and when Scatter/Gather DMA mode
         *  is used. This feature must not be enabled along with DCTL.IgnrFrmNum.
         *
         *  Scatter/Gather DMA Mode (GAHBCFG.DMAEn=1,DCFG.DescDMA=1):
         *
         *  When this bit is enabled, the frame number field in the ISOC IN descriptor
         *  structure is interpreted as the last frame of the service interval.
         *  In Scatter/Gather DMA mode, if this bit is enabled, the pending packets are flushed
         *  by the controller at the last frame of the service interval.
         */
        uint32_t dctl_servint:1;
        uint32_t reserved_20:10;
        /** dctl_utmi_txvld_corr_dis : R/W; bitpos: [30]; default: 0;
         *  Disable the correction to OpMode/XcvrSel/TermSel on UTMI Interface.
         *
         *  When Soft disconnect (DCTL.SftDiscon=1'b1) is set by the application, the Device
         *  controller immediately changes the Opmode to Non-Driving (2'b01), XcvrSel to
         *  FS_XCVR (2'b01) and TermSel to HS_TERM (1'b1). If the Device controller is
         *  disconnected (DCTL.SftDiscon=1'b1) while transmitting a packet or a chirp, then the
         *  Device controller immediately changes the Opmode to Non-Driving (2'b01) while
         *  TxValid being High (1'b1). Certain PHYs may not respond to the TxValid by
         *  interpreting the change in OpMode to Non-Driving. The behavior of OpMode, XcvrSel
         *  and TermSel have been corrected to handle Soft disconnect during transmission. The
         *  application can set this register bit to 1'b1 to fall back to the original behavior
         *  of OpMode, XcvrSel, TermSel when Soft disconnect is set during transmission.
         *
         *  - 1'b0: Opmode, XcvrSel, TermSel are changed by the Device Controller after TxValid
         *  goes LOW (1'b0). When this bit is set to 1'b0, the Device controller changes
         *  Opmode, XcvrSel and TermSel when TxVlaid is low after assertion of Soft Disconnect.
         *  - 1'b1: Opmode, XcvrSel, TermSel are changed by the Device Controller immediately.
         *  When this bit is set to 1'b1, the Device controller changes Opmode, XcvrSel and
         *  TermSel immediately after assertion of Soft Disconnect.
         *
         *  Note: The application must program this register during Device Initialization
         *  before USB Reset and this value cannot be changed afterwards.
         */
        uint32_t dctl_utmi_txvld_corr_dis:1;
        /** dctl_utmi_termsel_corr_dis : R/W; bitpos: [31]; default: 0;
         *  Disable the correction of TermSel on UTMI Interface.
         *
         *  When the application sets Soft disconnect (DCTL.SftDiscon=1'b1), the behavior of
         *  TermSel has been corrected to drive the valid combination of XcvrSel (FS_XCVR) and
         *  TermSel (FS_TERM). The application can set this register bit to 1'b1 to fall back
         *  to the original behavior of the Device controller driving XcvrSel (FS_XCVR) and
         *  TermSel (HS_TERM) when Soft disconnect is set (DCTL.SftDiscon=1'b1).
         *
         *  - 1'b0: Valid Combination of XcvrSel and TermSel is driven by the Device
         *  Controller. When this bit is set to 1'b0, the Device controller drives TermSel to 1
         *  upon assertion of Soft Disconnect which enables FS Termination.
         *  - 1'b1: Invalid Combination of XcvrSel and TermSel is driven by the Device
         *  Controller. When this bit is set to 1'b1, the Device controller drives TermSel to 0
         *  upon assertion of Soft Disconnect which enables HS Termination.
         *
         *  Note: The application must program this register during Device Initialization
         *  before USB Reset and this value cannot be changed afterwards.
         */
        uint32_t dctl_utmi_termsel_corr_dis:1;
    };
    uint32_t val;
} usb_otghs_dctl_reg_t;


/** Group: This register indicates the status of the core with respect to USB-related
 *  events. It must be read on interrupts from Device All Interrupts (DAINT) register.
 */
/** Type of dsts register
 *  This register indicates the status of the core with respect to USB-related events.
 *  It must be read on interrupts from Device All Interrupts (DAINT) register.
 */
typedef union {
    struct {
        /** dsts_suspsts : RO; bitpos: [0]; default: 0;
         *  Suspend Status (SuspSts)
         *
         *  In Device mode, this bit is set as long as a Suspend condition is
         *  detected on the USB. The core enters the Suspend state
         *  when there is no activity on the phy_line_state_i signal for an
         *  extended period of time. The core comes out of the suspend under the following
         *  conditions :
         *  - If there is any activity on the phy_line_state_i signal, or
         *  - If the application writes to the Remote Wakeup Signaling bit in the Device
         *  Control register (DCTL.RmtWkUpSig).
         *  When the core comes out of the suspend, this bit is set to 1'b0.
         */
        uint32_t dsts_suspsts:1;
        /** dsts_enumspd : RO; bitpos: [2:1]; default: 1;
         *  Enumerated Speed (EnumSpd)
         *
         *  Indicates the speed at which the controller has come up
         *  after speed detection through a connect or reset sequence.
         *  - 2'b00: High speed (PHY clock is running at 30 or 60 MHz)
         *  - 2'b01: Full speed (PHY clock is running at 30 or 60 MHz)
         *  - 2'b10: Low speed (PHY clock is running at 6 MHz)
         *  - 2'b11: Full speed (PHY clock is running at 48 MHz)
         *  Low speed is not supported for devices using a UTMI+ PHY.
         */
        uint32_t dsts_enumspd:2;
        /** dsts_errticerr : RO; bitpos: [3]; default: 0;
         *  Erratic Error (ErrticErr)
         *
         *  The core sets this bit to report any erratic errors
         *  (phy_rxvalid_i/phy_rxvldh_i or phy_rxactive_i is asserted for at least 2 ms, due to
         *  PHY error) seen on the UTMI+.
         *  Due to erratic errors, the core goes into Suspended state and an interrupt is
         *  generated to the application with Early Suspend bit of the Core Interrupt register
         *  (GINTSTS.ErlySusp).
         *  If the early suspend is asserted due to an erratic error, the application must
         *  perform a PHY reset followed by a soft reset to controller.
         */
        uint32_t dsts_errticerr:1;
        uint32_t reserved_4:4;
        /** dsts_soffn : RO; bitpos: [21:8]; default: 0;
         *  Frame or Microframe Number of the Received SOF  (SOFFN)
         *
         *  When the core is operating at high speed, this field contains a microframe number.
         *  When the core is operating at full or low speed, this field contains a Frame number.
         *
         *  Note: This register may return a non-zero value if read immediately after power-on
         *  reset.
         *  In case the register bit reads non-zero immediately after power-on reset, it does
         *  not
         *  indicate that SOF has been received from the host. The read value of this interrupt
         *  is
         *  valid only after a valid connection between host and device is established.
         */
        uint32_t dsts_soffn:14;
        /** dsts_devlnsts : RO; bitpos: [23:22]; default: 0;
         *  Device Line Status (DevLnSts)
         *
         *  Indicates the current logic level USB data lines
         *  - DevLnSts[1]: Logic level of D+
         *  - DevLnSts[0]: Logic level of D-
         */
        uint32_t dsts_devlnsts:2;
        uint32_t reserved_24:8;
    };
    uint32_t val;
} usb_otghs_dsts_reg_t;


/** Group: This register works with each of the Device IN Endpoint Interrupt (DIEPINTn)
 *  registers for all endpoints to generate an interrupt per IN endpoint. The IN
 *  endpoint interrupt for a specific status in the DIEPINTn register can be masked by
 *  writing to the corresponding bit in this register. Status bits are masked by
 *  default.
 */
/** Type of diepmsk register
 *  This register works with each of the Device IN Endpoint Interrupt (DIEPINTn)
 *  registers for all endpoints to generate an interrupt per IN endpoint. The IN
 *  endpoint interrupt for a specific status in the DIEPINTn register can be masked by
 *  writing to the corresponding bit in this register. Status bits are masked by
 *  default.
 */
typedef union {
    struct {
        /** diepmsk_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepmsk_xfercomplmsk:1;
        /** diepmsk_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepmsk_epdisbldmsk:1;
        /** diepmsk_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepmsk_ahberrmsk:1;
        /** diepmsk_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk) (Non-isochronous endpoints)
         */
        uint32_t diepmsk_timeoutmsk:1;
        /** diepmsk_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask (INTknTXFEmpMsk)
         */
        uint32_t diepmsk_intkntxfempmsk:1;
        /** diepmsk_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepmsk_intknepmismsk:1;
        /** diepmsk_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepmsk_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepmsk_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepmsk_txfifoundrnmsk:1;
        /** diepmsk_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepmsk_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepmsk_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepmsk_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepmsk_reg_t;


/** Group: This register works with each of the Device OUT Endpoint Interrupt
 *  (DOEPINTn) registers for all endpoints to generate an interrupt per OUT endpoint.
 *  The OUT endpoint interrupt for a specific status in the DOEPINTn register can be
 *  masked by writing into the corresponding bit in this register. Status bits are
 *  masked by default.
 */
/** Type of doepmsk register
 *  This register works with each of the Device OUT Endpoint Interrupt (DOEPINTn)
 *  registers for all endpoints to generate an interrupt per OUT endpoint. The OUT
 *  endpoint interrupt for a specific status in the DOEPINTn register can be masked by
 *  writing into the corresponding bit in this register. Status bits are masked by
 *  default.
 */
typedef union {
    struct {
        /** doepmsk_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepmsk_xfercomplmsk:1;
        /** doepmsk_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepmsk_epdisbldmsk:1;
        /** doepmsk_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepmsk_ahberrmsk:1;
        /** doepmsk_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepmsk_setupmsk:1;
        /** doepmsk_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepmsk_outtknepdismsk:1;
        /** doepmsk_stsphsercvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhseRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepmsk_stsphsercvdmsk:1;
        /** doepmsk_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepmsk_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepmsk_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepmsk_outpkterrmsk:1;
        /** doepmsk_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepmsk_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepmsk_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepmsk_bbleerrmsk:1;
        /** doepmsk_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepmsk_nakmsk:1;
        /** doepmsk_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepmsk_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepmsk_reg_t;


/** Group: When a significant event occurs on an endpoint, a Device All Endpoints
 *  Interrupt register interrupts the
 */
/** Type of daint register
 *  When a significant event occurs on an endpoint, a Device All Endpoints Interrupt
 *  register interrupts the application using the Device OUT Endpoints Interrupt bit or
 *  Device IN Endpoints Interrupt bit of the Core Interrupt register (GINTSTS.OEPInt or
 *  GINTSTS.IEPInt, respectively). This is shown in Figure 5-2. There is one interrupt
 *  bit per endpoint, up to a maximum of 16 bits for OUT endpoints and 16 bits for IN
 *  endpoints. For a bidirectional endpoint, the corresponding IN and OUT interrupt
 *  bits are used. Bits in this register are set and cleared when the application sets
 *  and clears bits in the corresponding Device Endpoint-n Interrupt register
 *  (DIEPINTn/DOEPINTn).
 */
typedef union {
    struct {
        /** daint_inepint0 : RO; bitpos: [0]; default: 0;
         *  IN Endpoint 0 Interrupt Bit
         */
        uint32_t daint_inepint0:1;
        /** daint_inepint1 : RO; bitpos: [1]; default: 0;
         *  IN Endpoint 1 Interrupt Bit
         */
        uint32_t daint_inepint1:1;
        /** daint_inepint2 : RO; bitpos: [2]; default: 0;
         *  IN Endpoint 2 Interrupt Bit
         */
        uint32_t daint_inepint2:1;
        /** daint_inepint3 : RO; bitpos: [3]; default: 0;
         *  IN Endpoint 3 Interrupt Bit
         */
        uint32_t daint_inepint3:1;
        /** daint_inepint4 : RO; bitpos: [4]; default: 0;
         *  IN Endpoint 4 Interrupt Bit
         */
        uint32_t daint_inepint4:1;
        /** daint_inepint5 : RO; bitpos: [5]; default: 0;
         *  IN Endpoint 5 Interrupt Bit
         */
        uint32_t daint_inepint5:1;
        /** daint_inepint6 : RO; bitpos: [6]; default: 0;
         *  IN Endpoint 6 Interrupt Bit
         */
        uint32_t daint_inepint6:1;
        /** daint_inepint7 : RO; bitpos: [7]; default: 0;
         *  IN Endpoint 7 Interrupt Bit
         */
        uint32_t daint_inepint7:1;
        /** daint_inepint8 : RO; bitpos: [8]; default: 0;
         *  IN Endpoint 8 Interrupt Bit
         */
        uint32_t daint_inepint8:1;
        /** daint_inepint9 : RO; bitpos: [9]; default: 0;
         *  IN Endpoint 9 Interrupt Bit
         */
        uint32_t daint_inepint9:1;
        /** daint_inepint10 : RO; bitpos: [10]; default: 0;
         *  IN Endpoint 10 Interrupt Bit
         */
        uint32_t daint_inepint10:1;
        /** daint_inepint11 : RO; bitpos: [11]; default: 0;
         *  IN Endpoint 11 Interrupt Bit
         */
        uint32_t daint_inepint11:1;
        /** daint_inepint12 : RO; bitpos: [12]; default: 0;
         *  IN Endpoint 12 Interrupt Bit
         */
        uint32_t daint_inepint12:1;
        /** daint_inepint13 : RO; bitpos: [13]; default: 0;
         *  IN Endpoint 13 Interrupt Bit
         */
        uint32_t daint_inepint13:1;
        /** daint_inepint14 : RO; bitpos: [14]; default: 0;
         *  IN Endpoint 14 Interrupt Bit
         */
        uint32_t daint_inepint14:1;
        /** daint_inepint15 : RO; bitpos: [15]; default: 0;
         *  IN Endpoint 15 Interrupt Bit
         */
        uint32_t daint_inepint15:1;
        /** daint_outepint0 : RO; bitpos: [16]; default: 0;
         *  OUT Endpoint 0 Interrupt Bit
         */
        uint32_t daint_outepint0:1;
        /** daint_outepint1 : RO; bitpos: [17]; default: 0;
         *  OUT Endpoint 1 Interrupt Bit
         */
        uint32_t daint_outepint1:1;
        /** daint_outepint2 : RO; bitpos: [18]; default: 0;
         *  OUT Endpoint 2 Interrupt Bit
         */
        uint32_t daint_outepint2:1;
        /** daint_outepint3 : RO; bitpos: [19]; default: 0;
         *  OUT Endpoint 3 Interrupt Bit
         */
        uint32_t daint_outepint3:1;
        /** daint_outepint4 : RO; bitpos: [20]; default: 0;
         *  OUT Endpoint 4 Interrupt Bit
         */
        uint32_t daint_outepint4:1;
        /** daint_outepint5 : RO; bitpos: [21]; default: 0;
         *  OUT Endpoint 5 Interrupt Bit
         */
        uint32_t daint_outepint5:1;
        /** daint_outepint6 : RO; bitpos: [22]; default: 0;
         *  OUT Endpoint 6 Interrupt Bit
         */
        uint32_t daint_outepint6:1;
        /** daint_outepint7 : RO; bitpos: [23]; default: 0;
         *  OUT Endpoint 7 Interrupt Bit
         */
        uint32_t daint_outepint7:1;
        /** daint_outepint8 : RO; bitpos: [24]; default: 0;
         *  OUT Endpoint 8 Interrupt Bit
         */
        uint32_t daint_outepint8:1;
        /** daint_outepint9 : RO; bitpos: [25]; default: 0;
         *  OUT Endpoint 9 Interrupt Bit
         */
        uint32_t daint_outepint9:1;
        /** daint_outepint10 : RO; bitpos: [26]; default: 0;
         *  OUT Endpoint 10 Interrupt Bit
         */
        uint32_t daint_outepint10:1;
        /** daint_outepint11 : RO; bitpos: [27]; default: 0;
         *  OUT Endpoint 11 Interrupt Bit
         */
        uint32_t daint_outepint11:1;
        /** daint_outepint12 : RO; bitpos: [28]; default: 0;
         *  OUT Endpoint 12 Interrupt Bit
         */
        uint32_t daint_outepint12:1;
        /** daint_outepint13 : RO; bitpos: [29]; default: 0;
         *  OUT Endpoint 13 Interrupt Bit
         */
        uint32_t daint_outepint13:1;
        /** daint_outepint14 : RO; bitpos: [30]; default: 0;
         *  OUT Endpoint 14 Interrupt Bit
         */
        uint32_t daint_outepint14:1;
        /** daint_outepint15 : RO; bitpos: [31]; default: 0;
         *  OUT Endpoint 15 Interrupt Bit
         */
        uint32_t daint_outepint15:1;
    };
    uint32_t val;
} usb_otghs_daint_reg_t;


/** Group: The Device Endpoint Interrupt Mask register works with the Device Endpoint
 *  Interrupt register to interrupt the application when an event occurs on a device
 *  endpoint. However, the Device All Endpoints Interrupt (DAINT) register bit
 *  corresponding to that interrupt is still set.
 */
/** Type of daintmsk register
 *  The Device Endpoint Interrupt Mask register works with the Device Endpoint
 *  Interrupt register to interrupt the application when an event occurs on a device
 *  endpoint. However, the Device All Endpoints Interrupt (DAINT) register bit
 *  corresponding to that interrupt is still set.
 */
typedef union {
    struct {
        /** daintmsk_inepmsk0 : R/W; bitpos: [0]; default: 0;
         *  IN Endpoint 0 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk0:1;
        /** daintmsk_inepmsk1 : R/W; bitpos: [1]; default: 0;
         *  IN Endpoint 1 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk1:1;
        /** daintmsk_inepmsk2 : R/W; bitpos: [2]; default: 0;
         *  IN Endpoint 2 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk2:1;
        /** daintmsk_inepmsk3 : R/W; bitpos: [3]; default: 0;
         *  IN Endpoint 3 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk3:1;
        /** daintmsk_inepmsk4 : R/W; bitpos: [4]; default: 0;
         *  IN Endpoint 4 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk4:1;
        /** daintmsk_inepmsk5 : R/W; bitpos: [5]; default: 0;
         *  IN Endpoint 5 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk5:1;
        /** daintmsk_inepmsk6 : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint 6 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk6:1;
        /** daintmsk_inepmsk7 : R/W; bitpos: [7]; default: 0;
         *  IN Endpoint 7 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk7:1;
        /** daintmsk_inepmsk8 : R/W; bitpos: [8]; default: 0;
         *  IN Endpoint 8 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk8:1;
        /** daintmsk_inepmsk9 : R/W; bitpos: [9]; default: 0;
         *  IN Endpoint 9 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk9:1;
        /** daintmsk_inepmsk10 : R/W; bitpos: [10]; default: 0;
         *  IN Endpoint 10 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk10:1;
        /** daintmsk_inepmsk11 : R/W; bitpos: [11]; default: 0;
         *  IN Endpoint 11 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk11:1;
        /** daintmsk_inepmsk12 : R/W; bitpos: [12]; default: 0;
         *  IN Endpoint 12 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk12:1;
        /** daintmsk_inepmsk13 : R/W; bitpos: [13]; default: 0;
         *  IN Endpoint 13 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk13:1;
        /** daintmsk_inepmsk14 : R/W; bitpos: [14]; default: 0;
         *  IN Endpoint 14 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk14:1;
        /** daintmsk_inepmsk15 : R/W; bitpos: [15]; default: 0;
         *  IN Endpoint 15 Interrupt mask Bit
         */
        uint32_t daintmsk_inepmsk15:1;
        /** daintmsk_outepmsk0 : R/W; bitpos: [16]; default: 0;
         *  OUT Endpoint 0 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk0:1;
        /** daintmsk_outepmsk1 : R/W; bitpos: [17]; default: 0;
         *  OUT Endpoint 1 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk1:1;
        /** daintmsk_outepmsk2 : R/W; bitpos: [18]; default: 0;
         *  OUT Endpoint 2 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk2:1;
        /** daintmsk_outepmsk3 : R/W; bitpos: [19]; default: 0;
         *  OUT Endpoint 3 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk3:1;
        /** daintmsk_outepmsk4 : R/W; bitpos: [20]; default: 0;
         *  OUT Endpoint 4 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk4:1;
        /** daintmsk_outepmsk5 : R/W; bitpos: [21]; default: 0;
         *  OUT Endpoint 5 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk5:1;
        /** daintmsk_outepmsk6 : R/W; bitpos: [22]; default: 0;
         *  OUT Endpoint 6 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk6:1;
        /** daintmsk_outepmsk7 : R/W; bitpos: [23]; default: 0;
         *  OUT Endpoint 7 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk7:1;
        /** daintmsk_outepmsk8 : R/W; bitpos: [24]; default: 0;
         *  OUT Endpoint 8 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk8:1;
        /** daintmsk_outepmsk9 : R/W; bitpos: [25]; default: 0;
         *  OUT Endpoint 9 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk9:1;
        /** daintmsk_outepmsk10 : R/W; bitpos: [26]; default: 0;
         *  OUT Endpoint 10 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk10:1;
        /** daintmsk_outepmsk11 : R/W; bitpos: [27]; default: 0;
         *  OUT Endpoint 11 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk11:1;
        /** daintmsk_outepmsk12 : R/W; bitpos: [28]; default: 0;
         *  OUT Endpoint 12 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk12:1;
        /** daintmsk_outepmsk13 : R/W; bitpos: [29]; default: 0;
         *  OUT Endpoint 13 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk13:1;
        /** daintmsk_outepmsk14 : R/W; bitpos: [30]; default: 0;
         *  OUT Endpoint 14 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk14:1;
        /** daintmsk_outepmsk15 : R/W; bitpos: [31]; default: 0;
         *  OUT Endpoint 15 Interrupt mask Bit
         */
        uint32_t daintmsk_outepmsk15:1;
    };
    uint32_t val;
} usb_otghs_daintmsk_reg_t;


/** Group: This register specifies the VBUS discharge time after VBUS pulsing during
 *  SRP.
 */
/** Type of dvbusdis register
 *  This register specifies the VBUS discharge time after VBUS pulsing during SRP.
 */
typedef union {
    struct {
        /** dvbusdis_dvbusdis : R/W; bitpos: [15:0]; default: 6103;
         *  Device VBUS Discharge Time (DVBUSDis)
         *
         *  Specifies the VBUS discharge time after VBUS pulsing during SRP. This value equals
         *  (VBUS discharge time in PHY clocks) / 1, 024.
         *
         *  The value you use depends whether the PHY is operating at 30MHz (16-bit data width)
         *  or 60 MHz (8-bit data width).
         *
         *  Depending on your VBUS load, this value can need adjustment.
         */
        uint32_t dvbusdis_dvbusdis:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dvbusdis_reg_t;


/** Group: This register contains the VBUS pulsing time during SRP. */
/** Type of dvbuspulse register
 *  This register contains the VBUS pulsing time during SRP.
 */
typedef union {
    struct {
        /** dvbuspulse_dvbuspulse : R/W; bitpos: [11:0]; default: 1464;
         *  Device VBUS Pulsing Time (DVBUSPulse)
         *
         *  Specifies the VBUS pulsing time during SRP. This value equals (VBUS pulsing time in
         *  PHY clocks) / 1, 024
         *
         *  The value you use depends whether the PHY is operating at 30MHz (16-bit data width)
         *  or 60 MHz (8-bit data width).
         */
        uint32_t dvbuspulse_dvbuspulse:12;
        uint32_t reserved_12:20;
    };
    uint32_t val;
} usb_otghs_dvbuspulse_reg_t;


/** Group: This register contains the Receive and Transmit Threshold characteristics of
 *  the Device controller.
 */
/** Type of dthrctl register
 *  This register contains the Receive and Transmit Threshold characteristics of the
 *  Device controller.
 */
typedef union {
    struct {
        /** dthrctl_nonisothren : R/W; bitpos: [0]; default: 0;
         *  Non-ISO IN Endpoints Threshold Enable. (NonISOThrEn)
         *
         *  When this bit is Set, the core enables thresholding for Non Isochronous IN
         *  endpoints.
         */
        uint32_t dthrctl_nonisothren:1;
        /** dthrctl_isothren : R/W; bitpos: [1]; default: 0;
         *
         *  ISO IN Endpoints Threshold Enable. (ISOThrEn)
         *
         *  When this bit is Set, the core enables thresholding for isochronous IN
         *  endpoints.
         */
        uint32_t dthrctl_isothren:1;
        /** dthrctl_txthrlen : R/W; bitpos: [10:2]; default: 8;
         *  Transmit Threshold Length (TxThrLen)
         *
         *  This field specifies Transmit thresholding size in DWORDS. This also forms
         *  the MAC threshold and specifies the amount of data in bytes to be in the
         *  corresponding endpoint transmit FIFO, before the core can start transmit
         *  on the USB. The threshold length has to be at least eight DWORDS when the
         *  value of AHBThrRatio is 2'h00. In case the AHBThrRatio is non zero the
         *  application needs to ensure that the AHB Threshold value does not go below
         *  the recommended eight DWORD.  This field controls both isochronous and
         *  non-isochronous IN endpoint thresholds. The recommended value for ThrLen
         *  is to be the same as the programmed AHB Burst Length (GAHBCFG.HBstLen).
         *
         *  Note:
         *  - When OTG_ARCHITECTURE=0, the reset value of this register field is 0.
         *  - When OTG_ARCHITECTURE=2, the reset value of this register field is 8.
         */
        uint32_t dthrctl_txthrlen:9;
        /** dthrctl_ahbthrratio : R/W; bitpos: [12:11]; default: 0;
         *  AHB Threshold Ratio (AHBThrRatio)
         *
         *  These bits define the ratio between the AHB threshold and the MAC threshold for the
         *  transmit path only. The AHB threshold always remains less than or equal to the USB
         *  threshold, because this does not increase overhead. Both the AHB and the MAC
         *  threshold must be DWORD-aligned. The application needs to program TxThrLen and the
         *  AHBThrRatio to make the AHB Threshold value DWORD aligned. If the AHB threshold
         *  value is not DWORD aligned, the core might not behave correctly. When programming
         *  the TxThrLen and AHBThrRatio, the application must ensure that the minimum AHB
         *  threshold value does not go below 8 DWORDS to meet the USB turnaround time
         *  requirements.
         *  - 2'b00: AHB threshold = MAC threshold
         *  - 2'b01: AHB threshold = MAC threshold / 2
         *  - 2'b10: AHB threshold = MAC threshold / 4
         *  - 2'b11: AHB threshold = MAC threshold / 8
         */
        uint32_t dthrctl_ahbthrratio:2;
        uint32_t reserved_13:3;
        /** dthrctl_rxthren : R/W; bitpos: [16]; default: 0;
         *  Receive Threshold Enable (RxThrEn)
         *
         *  When this bit is set, the core enables thresholding in the receive direction.
         *
         *  Note: We recommends that you do not enable RxThrEn, because it may cause issues in
         *  the RxFIFO especially during error conditions such as RxError and Babble.
         */
        uint32_t dthrctl_rxthren:1;
        /** dthrctl_rxthrlen : R/W; bitpos: [25:17]; default: 8;
         *  Receive Threshold Length (RxThrLen)
         *
         *  This field specifies Receive thresholding size in DWORDS.
         *  This field also specifies the amount of data received on the USB before the core
         *  can start transmitting on the AHB.
         *  The threshold length has to be at least eight DWORDS.
         *  The recommended value for ThrLen is to be the same as the programmed
         *  AHB Burst Length (GAHBCFG.HBstLen).
         */
        uint32_t dthrctl_rxthrlen:9;
        uint32_t reserved_26:1;
        /** dthrctl_arbprken : R/W; bitpos: [27]; default: 1;
         *  Arbiter Parking Enable (ArbPrkEn)
         *
         *  This bit controls internal DMA arbiter parking for IN endpoints. If thresholding is
         *  enabled and this bit is set to one, then the arbiter parks on the IN endpoint for
         *  which there is a token received on the USB. This is done to avoid getting into
         *  underrun conditions. By default, arbiter parking is enabled.
         */
        uint32_t dthrctl_arbprken:1;
        uint32_t reserved_28:4;
    };
    uint32_t val;
} usb_otghs_dthrctl_reg_t;


/** Group: This register is valid only in Dedicated FIFO operation (OTG_EN_DED_TX_FIFO
 *  = 1). This register is used to control the IN endpoint FIFO empty interrupt
 *  generation (DIEPINTn.TxfEmp).
 */
/** Type of diepempmsk register
 *  This register is valid only in Dedicated FIFO operation (OTG_EN_DED_TX_FIFO = 1).
 *  This register is used to control the IN endpoint FIFO empty interrupt generation
 *  (DIEPINTn.TxfEmp).
 */
typedef union {
    struct {
        /** diepempmsk_ineptxfempmsk : R/W; bitpos: [15:0]; default: 0;
         *  IN EP Tx FIFO Empty Interrupt Mask Bits (InEpTxfEmpMsk)
         *
         *  These bits acts as mask bits for DIEPINTn.TxFEmp interrupt, one bit per IN Endpoint:
         *
         *  Bit 0 for IN EP 0, bit 15 for IN EP 15
         */
        uint32_t diepempmsk_ineptxfempmsk:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_diepempmsk_reg_t;


/** Group: This register is available in device mode and only when parameter
 *  "OTG_MULTI_PROC_INTRPT" on page 121=1. There is one interrupt bit per endpoint, up
 *  to a maximum of 16 bits for OUT endpoints and 16 bits for IN endpoints. For a
 *  bidirectional endpoint, the corresponding IN and OUT interrupt bits are used. Bits
 *  in this register are set and cleared when the application sets and clears bits in
 *  the corresponding Device Endpoint-n Interrupt register (DIEPINTn/DOEPINTn). The
 *  interrupt is automatically cleared once the DOEPINTn/DIEPINTn interrupt is cleared
 *  by the application.
 */
/** Type of deachint register
 *  This register is available in device mode and only when parameter
 *  OTG_MULTI_PROC_INTRPT on page 121=1. There is one interrupt bit per endpoint, up to
 *  a maximum of 16 bits for OUT endpoints and 16 bits for IN endpoints. For a
 *  bidirectional endpoint, the corresponding IN and OUT interrupt bits are used. Bits
 *  in this register are set and cleared when the application sets and clears bits in
 *  the corresponding Device Endpoint-n Interrupt register (DIEPINTn/DOEPINTn). The
 *  interrupt is automatically cleared once the DOEPINTn/DIEPINTn interrupt is cleared
 *  by the application.
 */
typedef union {
    struct {
        /** deachint_echinepint : RO; bitpos: [15:0]; default: 0;
         *  Each IN Endpoint Interrupt Bits (EchInEpInt)
         *
         *  One bit per IN Endpoint:
         *
         *  Bit 0 for IN endpoint 0, bit 15 for endpoint 15
         */
        uint32_t deachint_echinepint:16;
        /** deachint_echoutepint : RO; bitpos: [31:16]; default: 0;
         *  Each OUT Endpoint Interrupt Bits (EchOutEPInt)
         *
         *  One bit per OUT endpoint:
         *
         *  Bit 16 for OUT endpoint 0, bit 31 for OUT endpoint 15
         */
        uint32_t deachint_echoutepint:16;
    };
    uint32_t val;
} usb_otghs_deachint_reg_t;


/** Group: This register is available only when parameter OTG_MULTI_PROC_INTRPT=1. The
 *  Device Each Endpoint Interrupt Mask register works with the Device Each Endpoint
 *  Interrupt register to interrupt the application when an event occurs on a device
 *  endpoint. However, the Device Each Endpoints Interrupt (DEACHINT) register bit
 *  corresponding to that interrupt remains set.
 */
/** Type of deachintmsk register
 *  This register is available only when parameter OTG_MULTI_PROC_INTRPT=1. The Device
 *  Each Endpoint Interrupt Mask register works with the Device Each Endpoint Interrupt
 *  register to interrupt the application when an event occurs on a device endpoint.
 *  However, the Device Each Endpoints Interrupt (DEACHINT) register bit corresponding
 *  to that interrupt remains set.
 */
typedef union {
    struct {
        /** deachintmsk_echinepmsk0 : R/W; bitpos: [0]; default: 0;
         *  IN EP0 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk0:1;
        /** deachintmsk_echinepmsk1 : R/W; bitpos: [1]; default: 0;
         *  IN EP1 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk1:1;
        /** deachintmsk_echinepmsk2 : R/W; bitpos: [2]; default: 0;
         *  IN EP2 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk2:1;
        /** deachintmsk_echinepmsk3 : R/W; bitpos: [3]; default: 0;
         *  IN EP3 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk3:1;
        /** deachintmsk_echinepmsk4 : R/W; bitpos: [4]; default: 0;
         *  IN EP4 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk4:1;
        /** deachintmsk_echinepmsk5 : R/W; bitpos: [5]; default: 0;
         *  IN EP5 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk5:1;
        /** deachintmsk_echinepmsk6 : R/W; bitpos: [6]; default: 0;
         *  IN EP6 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk6:1;
        /** deachintmsk_echinepmsk7 : R/W; bitpos: [7]; default: 0;
         *  IN EP7 Interrupt Mask Bits
         */
        uint32_t deachintmsk_echinepmsk7:1;
        /** deachintmsk_echinepmsk8 : R/W; bitpos: [8]; default: 0;
         *  IN EP8 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk8:1;
        /** deachintmsk_echinepmsk9 : R/W; bitpos: [9]; default: 0;
         *  IN EP9 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk9:1;
        /** deachintmsk_echinepmsk10 : R/W; bitpos: [10]; default: 0;
         *  IN EP10 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk10:1;
        /** deachintmsk_echinepmsk11 : R/W; bitpos: [11]; default: 0;
         *  IN EP11 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk11:1;
        /** deachintmsk_echinepmsk12 : R/W; bitpos: [12]; default: 0;
         *  IN EP12 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk12:1;
        /** deachintmsk_echinepmsk13 : R/W; bitpos: [13]; default: 0;
         *  IN EP13 Interrupt Mask Bits
         */
        uint32_t deachintmsk_echinepmsk13:1;
        /** deachintmsk_echinepmsk14 : R/W; bitpos: [14]; default: 0;
         *  IN EP14 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk14:1;
        /** deachintmsk_echinepmsk15 : R/W; bitpos: [15]; default: 0;
         *  IN EP15 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echinepmsk15:1;
        /** deachintmsk_echoutepmsk0 : R/W; bitpos: [16]; default: 0;
         *  OUT EP0 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk0:1;
        /** deachintmsk_echoutepmsk1 : R/W; bitpos: [17]; default: 0;
         *  OUT EP1 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk1:1;
        /** deachintmsk_echoutepmsk2 : R/W; bitpos: [18]; default: 0;
         *  OUT EP2 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk2:1;
        /** deachintmsk_echoutepmsk3 : R/W; bitpos: [19]; default: 0;
         *  OUT EP3 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk3:1;
        /** deachintmsk_echoutepmsk4 : R/W; bitpos: [20]; default: 0;
         *  OUT EP4 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk4:1;
        /** deachintmsk_echoutepmsk5 : R/W; bitpos: [21]; default: 0;
         *  OUT EP5 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk5:1;
        /** deachintmsk_echoutepmsk6 : R/W; bitpos: [22]; default: 0;
         *  OUT EP6 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk6:1;
        /** deachintmsk_echoutepmsk7 : R/W; bitpos: [23]; default: 0;
         *  OUT EP7 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk7:1;
        /** deachintmsk_echoutepmsk8 : R/W; bitpos: [24]; default: 0;
         *  OUT EP8 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk8:1;
        /** deachintmsk_echoutepmsk9 : R/W; bitpos: [25]; default: 0;
         *  OUT EP9 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk9:1;
        /** deachintmsk_echoutepmsk10 : R/W; bitpos: [26]; default: 0;
         *  OUT EP10 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk10:1;
        /** deachintmsk_echoutepmsk11 : R/W; bitpos: [27]; default: 0;
         *  OUT EP11 Interrupt Mask Bits
         */
        uint32_t deachintmsk_echoutepmsk11:1;
        /** deachintmsk_echoutepmsk12 : R/W; bitpos: [28]; default: 0;
         *  OUT EP12 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk12:1;
        /** deachintmsk_echoutepmsk13 : R/W; bitpos: [29]; default: 0;
         *  OUT EP13 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk13:1;
        /** deachintmsk_echoutepmsk14 : R/W; bitpos: [30]; default: 0;
         *  OUT EP14 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk14:1;
        /** deachintmsk_echoutepmsk15 : R/W; bitpos: [31]; default: 0;
         *  OUT EP15 Interrupt Mask Bit
         */
        uint32_t deachintmsk_echoutepmsk15:1;
    };
    uint32_t val;
} usb_otghs_deachintmsk_reg_t;


/** Group: This register is available in device mode and only when parameter
 *  "OTG_MULTI_PROC_INTRPT" on page 121=1. These registers are endpoint-specific mask
 *  registers for (DIEPINTn). The IN endpoint interrupt for a specific status in the
 *  DIEPINTn register can be masked by writing 0 to the corresponding bit in this
 *  register. Status bits are masked by default.
 */
/** Type of diepeachmsk0 register
 *  This register is available in device mode and only when parameter
 *  OTG_MULTI_PROC_INTRPT on page 121=1. These registers are endpoint-specific mask
 *  registers for (DIEPINTn). The IN endpoint interrupt for a specific status in the
 *  DIEPINTn register can be masked by writing 0 to the corresponding bit in this
 *  register. Status bits are masked by default.  - Mask interrupt: 1'b0  - Unmask
 *  interrupt: 1'b1
 */
typedef union {
    struct {
        /** diepeachmsk0_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk0_xfercomplmsk:1;
        /** diepeachmsk0_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk0_epdisbldmsk:1;
        /** diepeachmsk0_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk0_ahberrmsk:1;
        /** diepeachmsk0_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk) (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk0_timeoutmsk:1;
        /** diepeachmsk0_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask (INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk0_intkntxfempmsk:1;
        /** diepeachmsk0_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk0_intknepmismsk:1;
        /** diepeachmsk0_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk0_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk0_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk0_txfifoundrnmsk:1;
        /** diepeachmsk0_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk0_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk0_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk0_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk0_reg_t;


/** Group: This register contains the interrupts for the IN Endpoints of the Device
 *  controller.
 */
/** Type of diepeachmsk1 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk1_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk1_xfercomplmsk:1;
        /** diepeachmsk1_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk1_epdisbldmsk:1;
        /** diepeachmsk1_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk1_ahberrmsk:1;
        /** diepeachmsk1_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk1_timeoutmsk:1;
        /** diepeachmsk1_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk1_intkntxfempmsk:1;
        /** diepeachmsk1_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk1_intknepmismsk:1;
        /** diepeachmsk1_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk1_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk1_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk1_txfifoundrnmsk:1;
        /** diepeachmsk1_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk1_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk1_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk1_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk1_reg_t;

/** Type of diepeachmsk2 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk2_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk2_xfercomplmsk:1;
        /** diepeachmsk2_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk2_epdisbldmsk:1;
        /** diepeachmsk2_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk2_ahberrmsk:1;
        /** diepeachmsk2_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk2_timeoutmsk:1;
        /** diepeachmsk2_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk2_intkntxfempmsk:1;
        /** diepeachmsk2_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk2_intknepmismsk:1;
        /** diepeachmsk2_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk2_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk2_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk2_txfifoundrnmsk:1;
        /** diepeachmsk2_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk2_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk2_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk2_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk2_reg_t;

/** Type of diepeachmsk3 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk3_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk3_xfercomplmsk:1;
        /** diepeachmsk3_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk3_epdisbldmsk:1;
        /** diepeachmsk3_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk3_ahberrmsk:1;
        /** diepeachmsk3_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk3_timeoutmsk:1;
        /** diepeachmsk3_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk3_intkntxfempmsk:1;
        /** diepeachmsk3_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk3_intknepmismsk:1;
        /** diepeachmsk3_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk3_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk3_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk3_txfifoundrnmsk:1;
        /** diepeachmsk3_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk3_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk3_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk3_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk3_reg_t;

/** Type of diepeachmsk4 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk4_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk4_xfercomplmsk:1;
        /** diepeachmsk4_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk4_epdisbldmsk:1;
        /** diepeachmsk4_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk4_ahberrmsk:1;
        /** diepeachmsk4_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk4_timeoutmsk:1;
        /** diepeachmsk4_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk4_intkntxfempmsk:1;
        /** diepeachmsk4_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk4_intknepmismsk:1;
        /** diepeachmsk4_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk4_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk4_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk4_txfifoundrnmsk:1;
        /** diepeachmsk4_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk4_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk4_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk4_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk4_reg_t;

/** Type of diepeachmsk5 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk5_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk5_xfercomplmsk:1;
        /** diepeachmsk5_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk5_epdisbldmsk:1;
        /** diepeachmsk5_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk5_ahberrmsk:1;
        /** diepeachmsk5_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk5_timeoutmsk:1;
        /** diepeachmsk5_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk5_intkntxfempmsk:1;
        /** diepeachmsk5_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk5_intknepmismsk:1;
        /** diepeachmsk5_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk5_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk5_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk5_txfifoundrnmsk:1;
        /** diepeachmsk5_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk5_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk5_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk5_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk5_reg_t;

/** Type of diepeachmsk6 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk6_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk6_xfercomplmsk:1;
        /** diepeachmsk6_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk6_epdisbldmsk:1;
        /** diepeachmsk6_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk6_ahberrmsk:1;
        /** diepeachmsk6_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk6_timeoutmsk:1;
        /** diepeachmsk6_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk6_intkntxfempmsk:1;
        /** diepeachmsk6_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk6_intknepmismsk:1;
        /** diepeachmsk6_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk6_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk6_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk6_txfifoundrnmsk:1;
        /** diepeachmsk6_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk6_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk6_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk6_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk6_reg_t;

/** Type of diepeachmsk7 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk7_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk7_xfercomplmsk:1;
        /** diepeachmsk7_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk7_epdisbldmsk:1;
        /** diepeachmsk7_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk7_ahberrmsk:1;
        /** diepeachmsk7_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk7_timeoutmsk:1;
        /** diepeachmsk7_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk7_intkntxfempmsk:1;
        /** diepeachmsk7_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk7_intknepmismsk:1;
        /** diepeachmsk7_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk7_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk7_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk7_txfifoundrnmsk:1;
        /** diepeachmsk7_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk7_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk7_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk7_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk7_reg_t;

/** Type of diepeachmsk8 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk8_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk8_xfercomplmsk:1;
        /** diepeachmsk8_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk8_epdisbldmsk:1;
        /** diepeachmsk8_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk8_ahberrmsk:1;
        /** diepeachmsk8_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk8_timeoutmsk:1;
        /** diepeachmsk8_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk8_intkntxfempmsk:1;
        /** diepeachmsk8_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk8_intknepmismsk:1;
        /** diepeachmsk8_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk8_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk8_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk8_txfifoundrnmsk:1;
        /** diepeachmsk8_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk8_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk8_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk8_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk8_reg_t;

/** Type of diepeachmsk9 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk9_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk9_xfercomplmsk:1;
        /** diepeachmsk9_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk9_epdisbldmsk:1;
        /** diepeachmsk9_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk9_ahberrmsk:1;
        /** diepeachmsk9_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk9_timeoutmsk:1;
        /** diepeachmsk9_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk9_intkntxfempmsk:1;
        /** diepeachmsk9_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk9_intknepmismsk:1;
        /** diepeachmsk9_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk9_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk9_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk9_txfifoundrnmsk:1;
        /** diepeachmsk9_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk9_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk9_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk9_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk9_reg_t;

/** Type of diepeachmsk10 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk10_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk10_xfercomplmsk:1;
        /** diepeachmsk10_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk10_epdisbldmsk:1;
        /** diepeachmsk10_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk10_ahberrmsk:1;
        /** diepeachmsk10_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk10_timeoutmsk:1;
        /** diepeachmsk10_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk10_intkntxfempmsk:1;
        /** diepeachmsk10_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk10_intknepmismsk:1;
        /** diepeachmsk10_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk10_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk10_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk10_txfifoundrnmsk:1;
        /** diepeachmsk10_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk10_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk10_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk10_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk10_reg_t;

/** Type of diepeachmsk11 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk11_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk11_xfercomplmsk:1;
        /** diepeachmsk11_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk11_epdisbldmsk:1;
        /** diepeachmsk11_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk11_ahberrmsk:1;
        /** diepeachmsk11_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk11_timeoutmsk:1;
        /** diepeachmsk11_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk11_intkntxfempmsk:1;
        /** diepeachmsk11_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk11_intknepmismsk:1;
        /** diepeachmsk11_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk11_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk11_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk11_txfifoundrnmsk:1;
        /** diepeachmsk11_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk11_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk11_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk11_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk11_reg_t;

/** Type of diepeachmsk12 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk12_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk12_xfercomplmsk:1;
        /** diepeachmsk12_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk12_epdisbldmsk:1;
        /** diepeachmsk12_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk12_ahberrmsk:1;
        /** diepeachmsk12_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk12_timeoutmsk:1;
        /** diepeachmsk12_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk12_intkntxfempmsk:1;
        /** diepeachmsk12_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk12_intknepmismsk:1;
        /** diepeachmsk12_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk12_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk12_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk12_txfifoundrnmsk:1;
        /** diepeachmsk12_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk12_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk12_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk12_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk12_reg_t;

/** Type of diepeachmsk13 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk13_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk13_xfercomplmsk:1;
        /** diepeachmsk13_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk13_epdisbldmsk:1;
        /** diepeachmsk13_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk13_ahberrmsk:1;
        /** diepeachmsk13_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk13_timeoutmsk:1;
        /** diepeachmsk13_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk13_intkntxfempmsk:1;
        /** diepeachmsk13_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk13_intknepmismsk:1;
        /** diepeachmsk13_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk13_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk13_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk13_txfifoundrnmsk:1;
        /** diepeachmsk13_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk13_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk13_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk13_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk13_reg_t;

/** Type of diepeachmsk14 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk14_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk14_xfercomplmsk:1;
        /** diepeachmsk14_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk14_epdisbldmsk:1;
        /** diepeachmsk14_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk14_ahberrmsk:1;
        /** diepeachmsk14_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk14_timeoutmsk:1;
        /** diepeachmsk14_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk14_intkntxfempmsk:1;
        /** diepeachmsk14_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk14_intknepmismsk:1;
        /** diepeachmsk14_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk14_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk14_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk14_txfifoundrnmsk:1;
        /** diepeachmsk14_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk14_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk14_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk14_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk14_reg_t;

/** Type of diepeachmsk15 register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepeachmsk15_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t diepeachmsk15_xfercomplmsk:1;
        /** diepeachmsk15_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t diepeachmsk15_epdisbldmsk:1;
        /** diepeachmsk15_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error Mask (AHBErrMsk)
         */
        uint32_t diepeachmsk15_ahberrmsk:1;
        /** diepeachmsk15_timeoutmsk : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition Mask (TimeOUTMsk)
         *  (Non-isochronous endpoints)
         */
        uint32_t diepeachmsk15_timeoutmsk:1;
        /** diepeachmsk15_intkntxfempmsk : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
         */
        uint32_t diepeachmsk15_intkntxfempmsk:1;
        /** diepeachmsk15_intknepmismsk : R/W; bitpos: [5]; default: 0;
         *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
         */
        uint32_t diepeachmsk15_intknepmismsk:1;
        /** diepeachmsk15_inepnakeffmsk : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
         */
        uint32_t diepeachmsk15_inepnakeffmsk:1;
        uint32_t reserved_7:1;
        /** diepeachmsk15_txfifoundrnmsk : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun Mask (TxfifoUndrnMsk)
         */
        uint32_t diepeachmsk15_txfifoundrnmsk:1;
        /** diepeachmsk15_bnainintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BNAInIntrMsk)
         */
        uint32_t diepeachmsk15_bnainintrmsk:1;
        uint32_t reserved_10:3;
        /** diepeachmsk15_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t diepeachmsk15_nakmsk:1;
        uint32_t reserved_14:18;
    };
    uint32_t val;
} usb_otghs_diepeachmsk15_reg_t;


/** Group: This register is available in device mode and only when parameter
 *  OTG_MULTI_PROC_INTRPT=1. These registers are endpoint specific mask registers for
 *  (DOEPINTn). The OUT endpoint interrupt for a specific status in the DOEPINTn
 *  register can be masked by writing 0 to the corresponding bit in this register.
 *  Status bits are masked by default.
 */
/** Type of doepeachmsk0 register
 *  This register is available in device mode and only when parameter
 *  OTG_MULTI_PROC_INTRPT=1. These registers are endpoint specific mask registers for
 *  (DOEPINTn). The OUT endpoint interrupt for a specific status in the DOEPINTn
 *  register can be masked by writing 0 to the corresponding bit in this register.
 *  Status bits are masked by default.
 */
typedef union {
    struct {
        /** doepeachmsk0_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk0_xfercomplmsk:1;
        /** doepeachmsk0_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk0_epdisbldmsk:1;
        /** doepeachmsk0_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk0_ahberrmsk:1;
        /** doepeachmsk0_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk0_setupmsk:1;
        /** doepeachmsk0_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk0_outtknepdismsk:1;
        /** doepeachmsk0_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk0_stsphsrcvdmsk:1;
        /** doepeachmsk0_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk0_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk0_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk0_outpkterrmsk:1;
        /** doepeachmsk0_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk0_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk0_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk0_bbleerrmsk:1;
        /** doepeachmsk0_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk0_nakmsk:1;
        /** doepeachmsk0_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk0_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk0_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoints of the Device
 *  controller.
 */
/** Type of doepeachmsk1 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk1_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk1_xfercomplmsk:1;
        /** doepeachmsk1_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk1_epdisbldmsk:1;
        /** doepeachmsk1_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk1_ahberrmsk:1;
        /** doepeachmsk1_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk1_setupmsk:1;
        /** doepeachmsk1_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk1_outtknepdismsk:1;
        /** doepeachmsk1_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk1_stsphsrcvdmsk:1;
        /** doepeachmsk1_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk1_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk1_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk1_outpkterrmsk:1;
        /** doepeachmsk1_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk1_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk1_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk1_bbleerrmsk:1;
        /** doepeachmsk1_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk1_nakmsk:1;
        /** doepeachmsk1_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk1_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk1_reg_t;

/** Type of doepeachmsk2 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk2_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk2_xfercomplmsk:1;
        /** doepeachmsk2_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk2_epdisbldmsk:1;
        /** doepeachmsk2_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk2_ahberrmsk:1;
        /** doepeachmsk2_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk2_setupmsk:1;
        /** doepeachmsk2_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk2_outtknepdismsk:1;
        /** doepeachmsk2_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk2_stsphsrcvdmsk:1;
        /** doepeachmsk2_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk2_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk2_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk2_outpkterrmsk:1;
        /** doepeachmsk2_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk2_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk2_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk2_bbleerrmsk:1;
        /** doepeachmsk2_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk2_nakmsk:1;
        /** doepeachmsk2_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk2_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk2_reg_t;

/** Type of doepeachmsk3 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk3_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk3_xfercomplmsk:1;
        /** doepeachmsk3_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk3_epdisbldmsk:1;
        /** doepeachmsk3_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk3_ahberrmsk:1;
        /** doepeachmsk3_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk3_setupmsk:1;
        /** doepeachmsk3_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk3_outtknepdismsk:1;
        /** doepeachmsk3_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk3_stsphsrcvdmsk:1;
        /** doepeachmsk3_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk3_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk3_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk3_outpkterrmsk:1;
        /** doepeachmsk3_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk3_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk3_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk3_bbleerrmsk:1;
        /** doepeachmsk3_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk3_nakmsk:1;
        /** doepeachmsk3_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk3_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk3_reg_t;

/** Type of doepeachmsk4 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk4_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk4_xfercomplmsk:1;
        /** doepeachmsk4_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk4_epdisbldmsk:1;
        /** doepeachmsk4_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk4_ahberrmsk:1;
        /** doepeachmsk4_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk4_setupmsk:1;
        /** doepeachmsk4_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk4_outtknepdismsk:1;
        /** doepeachmsk4_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk4_stsphsrcvdmsk:1;
        /** doepeachmsk4_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk4_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk4_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk4_outpkterrmsk:1;
        /** doepeachmsk4_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk4_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk4_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk4_bbleerrmsk:1;
        /** doepeachmsk4_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk4_nakmsk:1;
        /** doepeachmsk4_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk4_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk4_reg_t;

/** Type of doepeachmsk5 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk5_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk5_xfercomplmsk:1;
        /** doepeachmsk5_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk5_epdisbldmsk:1;
        /** doepeachmsk5_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk5_ahberrmsk:1;
        /** doepeachmsk5_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk5_setupmsk:1;
        /** doepeachmsk5_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk5_outtknepdismsk:1;
        /** doepeachmsk5_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk5_stsphsrcvdmsk:1;
        /** doepeachmsk5_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk5_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk5_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk5_outpkterrmsk:1;
        /** doepeachmsk5_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk5_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk5_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk5_bbleerrmsk:1;
        /** doepeachmsk5_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk5_nakmsk:1;
        /** doepeachmsk5_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk5_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk5_reg_t;

/** Type of doepeachmsk6 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk6_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk6_xfercomplmsk:1;
        /** doepeachmsk6_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk6_epdisbldmsk:1;
        /** doepeachmsk6_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk6_ahberrmsk:1;
        /** doepeachmsk6_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk6_setupmsk:1;
        /** doepeachmsk6_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk6_outtknepdismsk:1;
        /** doepeachmsk6_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk6_stsphsrcvdmsk:1;
        /** doepeachmsk6_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk6_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk6_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk6_outpkterrmsk:1;
        /** doepeachmsk6_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk6_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk6_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk6_bbleerrmsk:1;
        /** doepeachmsk6_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk6_nakmsk:1;
        /** doepeachmsk6_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk6_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk6_reg_t;

/** Type of doepeachmsk7 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk7_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk7_xfercomplmsk:1;
        /** doepeachmsk7_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk7_epdisbldmsk:1;
        /** doepeachmsk7_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk7_ahberrmsk:1;
        /** doepeachmsk7_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk7_setupmsk:1;
        /** doepeachmsk7_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk7_outtknepdismsk:1;
        /** doepeachmsk7_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk7_stsphsrcvdmsk:1;
        /** doepeachmsk7_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk7_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk7_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk7_outpkterrmsk:1;
        /** doepeachmsk7_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk7_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk7_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk7_bbleerrmsk:1;
        /** doepeachmsk7_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk7_nakmsk:1;
        /** doepeachmsk7_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk7_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk7_reg_t;

/** Type of doepeachmsk8 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk8_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk8_xfercomplmsk:1;
        /** doepeachmsk8_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk8_epdisbldmsk:1;
        /** doepeachmsk8_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk8_ahberrmsk:1;
        /** doepeachmsk8_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk8_setupmsk:1;
        /** doepeachmsk8_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk8_outtknepdismsk:1;
        /** doepeachmsk8_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk8_stsphsrcvdmsk:1;
        /** doepeachmsk8_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk8_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk8_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk8_outpkterrmsk:1;
        /** doepeachmsk8_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk8_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk8_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk8_bbleerrmsk:1;
        /** doepeachmsk8_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk8_nakmsk:1;
        /** doepeachmsk8_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk8_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk8_reg_t;

/** Type of doepeachmsk9 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk9_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk9_xfercomplmsk:1;
        /** doepeachmsk9_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk9_epdisbldmsk:1;
        /** doepeachmsk9_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk9_ahberrmsk:1;
        /** doepeachmsk9_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk9_setupmsk:1;
        /** doepeachmsk9_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk9_outtknepdismsk:1;
        /** doepeachmsk9_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk9_stsphsrcvdmsk:1;
        /** doepeachmsk9_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk9_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk9_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk9_outpkterrmsk:1;
        /** doepeachmsk9_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk9_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk9_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk9_bbleerrmsk:1;
        /** doepeachmsk9_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk9_nakmsk:1;
        /** doepeachmsk9_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk9_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk9_reg_t;

/** Type of doepeachmsk10 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk10_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk10_xfercomplmsk:1;
        /** doepeachmsk10_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk10_epdisbldmsk:1;
        /** doepeachmsk10_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk10_ahberrmsk:1;
        /** doepeachmsk10_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk10_setupmsk:1;
        /** doepeachmsk10_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk10_outtknepdismsk:1;
        /** doepeachmsk10_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk10_stsphsrcvdmsk:1;
        /** doepeachmsk10_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk10_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk10_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk10_outpkterrmsk:1;
        /** doepeachmsk10_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk10_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk10_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk10_bbleerrmsk:1;
        /** doepeachmsk10_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk10_nakmsk:1;
        /** doepeachmsk10_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk10_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk10_reg_t;

/** Type of doepeachmsk11 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk11_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk11_xfercomplmsk:1;
        /** doepeachmsk11_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk11_epdisbldmsk:1;
        /** doepeachmsk11_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk11_ahberrmsk:1;
        /** doepeachmsk11_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk11_setupmsk:1;
        /** doepeachmsk11_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk11_outtknepdismsk:1;
        /** doepeachmsk11_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk11_stsphsrcvdmsk:1;
        /** doepeachmsk11_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk11_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk11_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk11_outpkterrmsk:1;
        /** doepeachmsk11_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk11_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk11_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk11_bbleerrmsk:1;
        /** doepeachmsk11_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk11_nakmsk:1;
        /** doepeachmsk11_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk11_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk11_reg_t;

/** Type of doepeachmsk12 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk12_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk12_xfercomplmsk:1;
        /** doepeachmsk12_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk12_epdisbldmsk:1;
        /** doepeachmsk12_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk12_ahberrmsk:1;
        /** doepeachmsk12_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk12_setupmsk:1;
        /** doepeachmsk12_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk12_outtknepdismsk:1;
        /** doepeachmsk12_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk12_stsphsrcvdmsk:1;
        /** doepeachmsk12_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk12_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk12_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk12_outpkterrmsk:1;
        /** doepeachmsk12_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk12_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk12_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk12_bbleerrmsk:1;
        /** doepeachmsk12_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk12_nakmsk:1;
        /** doepeachmsk12_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk12_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk12_reg_t;

/** Type of doepeachmsk13 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk13_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk13_xfercomplmsk:1;
        /** doepeachmsk13_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk13_epdisbldmsk:1;
        /** doepeachmsk13_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk13_ahberrmsk:1;
        /** doepeachmsk13_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk13_setupmsk:1;
        /** doepeachmsk13_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk13_outtknepdismsk:1;
        /** doepeachmsk13_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk13_stsphsrcvdmsk:1;
        /** doepeachmsk13_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk13_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk13_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk13_outpkterrmsk:1;
        /** doepeachmsk13_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk13_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk13_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk13_bbleerrmsk:1;
        /** doepeachmsk13_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk13_nakmsk:1;
        /** doepeachmsk13_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk13_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk13_reg_t;

/** Type of doepeachmsk14 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk14_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk14_xfercomplmsk:1;
        /** doepeachmsk14_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk14_epdisbldmsk:1;
        /** doepeachmsk14_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk14_ahberrmsk:1;
        /** doepeachmsk14_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk14_setupmsk:1;
        /** doepeachmsk14_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk14_outtknepdismsk:1;
        /** doepeachmsk14_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk14_stsphsrcvdmsk:1;
        /** doepeachmsk14_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk14_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk14_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk14_outpkterrmsk:1;
        /** doepeachmsk14_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk14_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk14_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk14_bbleerrmsk:1;
        /** doepeachmsk14_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk14_nakmsk:1;
        /** doepeachmsk14_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk14_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk14_reg_t;

/** Type of doepeachmsk15 register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** doepeachmsk15_xfercomplmsk : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt Mask (XferComplMsk)
         */
        uint32_t doepeachmsk15_xfercomplmsk:1;
        /** doepeachmsk15_epdisbldmsk : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
         */
        uint32_t doepeachmsk15_epdisbldmsk:1;
        /** doepeachmsk15_ahberrmsk : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErrMsk)
         */
        uint32_t doepeachmsk15_ahberrmsk:1;
        /** doepeachmsk15_setupmsk : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done Mask (SetUPMsk)
         *
         *  Applies to control endpoints only.
         */
        uint32_t doepeachmsk15_setupmsk:1;
        /** doepeachmsk15_outtknepdismsk : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk15_outtknepdismsk:1;
        /** doepeachmsk15_stsphsrcvdmsk : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received Mask (StsPhsRcvdMsk)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk15_stsphsrcvdmsk:1;
        /** doepeachmsk15_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
         *
         *  Applies to control OUT endpoints only.
         */
        uint32_t doepeachmsk15_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepeachmsk15_outpkterrmsk : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error Mask (OutPktErrMsk)
         */
        uint32_t doepeachmsk15_outpkterrmsk:1;
        /** doepeachmsk15_bnaoutintrmsk : R/W; bitpos: [9]; default: 0;
         *  BNA interrupt Mask (BnaOutIntrMsk)
         */
        uint32_t doepeachmsk15_bnaoutintrmsk:1;
        uint32_t reserved_10:2;
        /** doepeachmsk15_bbleerrmsk : R/W; bitpos: [12]; default: 0;
         *  Babble Error interrupt Mask (BbleErrMsk)
         */
        uint32_t doepeachmsk15_bbleerrmsk:1;
        /** doepeachmsk15_nakmsk : R/W; bitpos: [13]; default: 0;
         *  NAK interrupt Mask (NAKMsk)
         */
        uint32_t doepeachmsk15_nakmsk:1;
        /** doepeachmsk15_nyetmsk : R/W; bitpos: [14]; default: 0;
         *  NYET interrupt Mask (NYETMsk)
         */
        uint32_t doepeachmsk15_nyetmsk:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_doepeachmsk15_reg_t;


/** Group: This register is used to control the characteristics of the IN Endpoint 0 of
 *  the Device controller.
 */
/** Type of diepctl0 register
 *  This register is used to control the characteristics of the IN Endpoint 0 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** diepctl0_mps : R/W; bitpos: [1:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint.
         *  - 2'b00: 64 bytes
         *  - 2'b01: 32 bytes
         *  - 2'b10: 16 bytes
         *  - 2'b11: 8 bytes
         */
        uint32_t diepctl0_mps:2;
        uint32_t reserved_2:13;
        /** diepctl0_usbactep : RO; bitpos: [15]; default: 1;
         *  USB Active Endpoint (USBActEP)
         *
         *  This bit is always SET to 1, indicating that control endpoint 0 is always active in
         *  all configurations and interfaces.
         */
        uint32_t diepctl0_usbactep:1;
        uint32_t reserved_16:1;
        /** diepctl0_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When this bit is set, either by the application or core, the core stops
         *  transmitting data, even If there is data available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data
         *  packets with an ACK handshake.
         */
        uint32_t diepctl0_naksts:1;
        /** diepctl0_eptype : RO; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Hardcoded to 00 for control.
         */
        uint32_t diepctl0_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl0_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  The application can only set this bit, and the core clears it, when a
         *  SETUP token is received for this endpoint. If a NAK bit, Global Nonperiodic
         *  IN NAK, or Global OUT NAK is set along with this bit, the STALL
         *  bit takes priority.
         */
        uint32_t diepctl0_stall:1;
        /** diepctl0_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *  - For Shared FIFO operation, this value is always set to 0, indicating that control
         *  IN endpoint 0 data is always written in the Non-Periodic Transmit FIFO.
         *  - For Dedicated FIFO operation, this value is set to the FIFO number that is
         *  assigned to IN Endpoint.
         */
        uint32_t diepctl0_txfnum:4;
        /** diepctl0_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl0_cnak:1;
        /** diepctl0_snak : R/W; bitpos: [27]; default: 0;
         *
         *  Set NAK (SNAK)
         *  A write to this bit sets the NAK bit for the endpoint.
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t diepctl0_snak:1;
        uint32_t reserved_28:2;
        /** diepctl0_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  The application sets this bit to stop transmitting data on an endpoint,
         *  even before the transfer for that endpoint is complete. The application
         *  must wait for the Endpoint Disabled interrupt before treating the endpoint
         *  as disabled. The core clears this bit before setting the Endpoint Disabled
         *  Interrupt. The application must Set this bit only if Endpoint Enable is
         *  already set for this endpoint.
         */
        uint32_t diepctl0_epdis:1;
        /** diepctl0_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  When Scatter/Gather DMA mode is enabled for IN endpoints, this bit indicates that
         *  the descriptor structure and data buffer with data ready to transmit is setup.
         *
         *  When Scatter/Gather DMA mode is disabled (such as in buffer pointer based DMA mode)
         *  this bit indicates that data is ready to be transmitted on the endpoint.
         *  The core clears this bit before setting the following interrupts on this endpoint:
         *  - Endpoint Disabled
         *  - Transfer Completed
         */
        uint32_t diepctl0_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl0_reg_t;


/** Group: This register indicates the status of an endpoint with respect to USB- and
 *  AHB-related events. It is shown in the "Interrupt Hierarchy" figure in the
 *  databook. The application must read this register when the OUT Endpoints Interrupt
 *  bit or IN Endpoints Interrupt bit of the Core Interrupt register (GINTSTS.OEPInt or
 *  GINTSTS.IEPInt, respectively) is set. Before the application can read this
 *  register, it must first read the Device All Endpoints Interrupt (DAINT) register to
 *  get the exact endpoint number for the Device Endpoint-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the DAINT and GINTSTS registers
 */
/** Type of diepint0 register
 *  This register indicates the status of an endpoint with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the OUT Endpoints Interrupt bit or IN
 *  Endpoints Interrupt bit of the Core Interrupt register (GINTSTS.OEPInt or
 *  GINTSTS.IEPInt, respectively) is set. Before the application can read this
 *  register, it must first read the Device All Endpoints Interrupt (DAINT) register to
 *  get the exact endpoint number for the Device Endpoint-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the DAINT and GINTSTS registers
 */
typedef union {
    struct {
        /** diepint0_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint0_xfercompl:1;
        /** diepint0_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint0_epdisbld:1;
        /** diepint0_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint0_ahberr:1;
        /** diepint0_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint0_timeout:1;
        /** diepint0_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint0_intkntxfemp:1;
        /** diepint0_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint0_intknepmis:1;
        /** diepint0_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core).
         *
         *  The interrupt indicates that the IN endpoint NAK bit Set by the application has
         *  taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint0_inepnakeff:1;
        /** diepint0_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN Endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is either half or
         *  completely empty. The half or completely empty status is determined by the TxFIFO
         *  Empty Level bit in the Core AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint0_txfemp:1;
        /** diepint0_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints only.
         *
         *  The core generates this interrupt when it detects a transmit FIFO underrun
         *  condition in threshold mode for this endpoint.
         */
        uint32_t diepint0_txfifoundrn:1;
        /** diepint0_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core generates
         *  this interrupt when the descriptor accessed is not ready for the Core to process,
         *  such as Host busy or DMA done.
         */
        uint32_t diepint0_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint0_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped.
         *  This bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint0_pktdrpsts:1;
        /** diepint0_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint0_bbleerr:1;
        /** diepint0_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  <bring case of isochronous IN endpoints the interrupt gets generated when a zero
         *  length packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint0_nakintrpt:1;
        /** diepint0_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint0_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint0_reg_t;


/** Group: The application must modify this register before enabling endpoint 0. Once
 *  endpoint 0 is enabled using Endpoint Enable bit of the Device Control Endpoint 0
 *  Control registers (DIEPCTL0.EPEna/DOEPCTL0.EPEna), the core modifies this register.
 *  The application can only read this register once the core has cleared the Endpoint
 *  Enable bit. Nonzero endpoints use the registers for endpoints 115. When
 *  Scatter/Gather DMA mode is enabled, this register must not be programmed by the
 *  application. If the application reads this register when Scatter/Gather DMA mode is
 *  enabled, the core returns all zeros.
 */
/** Type of dieptsiz0 register
 *  The application must modify this register before enabling endpoint 0. Once endpoint
 *  0 is enabled using Endpoint Enable bit of the Device Control Endpoint 0 Control
 *  registers (DIEPCTL0.EPEna/DOEPCTL0.EPEna), the core modifies this register. The
 *  application can only read this register once the core has cleared the Endpoint
 *  Enable bit. Nonzero endpoints use the registers for endpoints 115. When
 *  Scatter/Gather DMA mode is enabled, this register must not be programmed by the
 *  application. If the application reads this register when Scatter/Gather DMA mode is
 *  enabled, the core returns all zeros.
 */
typedef union {
    struct {
        /** dieptsiz0_xfersize : R/W; bitpos: [6:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  This field contains the transfer size in bytes for the current endpoint. The
         *  transfer size (XferSize) = Sum of buffer sizes across all descriptors in the list
         *  for the endpoint.
         *  In Buffer DMA, the core only interrupts the application after it has exhausted the
         *  transfer size amount of data. The transfer size can be set to the maximum packet
         *  size of the endpoint, to be interrupted at the end of each packet.
         *  - IN Endpoints: The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         *  - OUT Endpoints: The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t dieptsiz0_xfersize:7;
        uint32_t reserved_7:12;
        /** dieptsiz0_pktcnt : R/W; bitpos: [20:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the
         *
         *  Transfer Size amount of data for endpoint 0.
         *  - IN Endpoints : This field is decremented every time a packet (maximum size or
         *  short packet) is read from the TxFIFO.
         *  - OUT Endpoints: This field is decremented every time a packet (maximum size or
         *  short packet) is written to the RxFIFO.
         */
        uint32_t dieptsiz0_pktcnt:2;
        uint32_t reserved_21:11;
    };
    uint32_t val;
} usb_otghs_dieptsiz0_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 0 of the Device
 *  controller.
 */
/** Type of diepdma0 register
 *  This register contains the DMA Address for the IN Endpoint 0 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** diepdma0_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  DMAAddr
         *
         *  This field holds the start address of the external memory for storing or fetching
         *  endpoint data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *
         *  When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *
         *  When Scatter/Gather DMA mode is enabled, this field indicates the base pointer for
         *  the descriptor list.
         */
        uint32_t diepdma0_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma0_reg_t;


/** Group: This register contains information about the IN Endpoint Transmit FIFO of
 *  the Device controller.
 */
/** Type of dtxfsts0 register
 *  This register contains information about the IN Endpoint Transmit FIFO of the
 *  Device controller.
 */
typedef union {
    struct {
        /** dtxfsts0_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic FIFO sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC = 1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts0_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts0_reg_t;


/** Group: This register contains the DMA Buffer Address for the IN Endpoint 0 of the
 *  Device controller.
 */
/** Type of diepdmab0 register
 *  This register contains the DMA Buffer Address for the IN Endpoint 0 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** diepdmab0_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab0_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab0_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 1. */
/** Type of diepctl1 register
 *  This register is used to control the characteristics of Endpoint 1.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl1_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl1_mps:11;
        uint32_t reserved_11:4;
        /** diepctl1_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl1_usbactep:1;
        /** diepctl1_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl1_dpid:1;
        /** diepctl1_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl1_naksts:1;
        /** diepctl1_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl1_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl1_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl1_stall:1;
        /** diepctl1_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl1_txfnum:4;
        /** diepctl1_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl1_cnak:1;
        /** diepctl1_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl1_snak:1;
        /** diepctl1_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl1_setd0pid:1;
        /** diepctl1_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl1_setd1pid:1;
        /** diepctl1_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl1_epdis:1;
        /** diepctl1_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl1_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl1_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 1 of the Device
 *  controller.
 */
/** Type of diepint1 register
 *  This register contains the interrupts for the IN Endpoint 1 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint1_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint1_xfercompl:1;
        /** diepint1_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint1_epdisbld:1;
        /** diepint1_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint1_ahberr:1;
        /** diepint1_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint1_timeout:1;
        /** diepint1_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint1_intkntxfemp:1;
        /** diepint1_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint1_intknepmis:1;
        /** diepint1_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint1_inepnakeff:1;
        /** diepint1_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint1_txfemp:1;
        /** diepint1_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint1_txfifoundrn:1;
        /** diepint1_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint1_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint1_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint1_pktdrpsts:1;
        /** diepint1_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint1_bbleerr:1;
        /** diepint1_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint1_nakintrpt:1;
        /** diepint1_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint1_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint1_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 1 of the Device
 *  controller.
 */
/** Type of dieptsiz1 register
 *  This register reflects the Transfer Size of the IN Endpoint 1 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz1_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz1_xfersize:19;
        /** dieptsiz1_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz1_pktcnt:10;
        /** dieptsiz1_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz1_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz1_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 1 of the Device
 *  controller.
 */
/** Type of diepdma1 register
 *  This register contains the DMA Address for the IN Endpoint 1 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma1_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma1_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma1_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 1 of the Device controller.
 */
/** Type of dtxfsts1 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  1 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts1_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts1_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts1_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 1 of the
 *  Device controller.
 */
/** Type of diepdmab1 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 1 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab1_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab1_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab1_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 2. */
/** Type of diepctl2 register
 *  This register is used to control the characteristics of Endpoint 2.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl2_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl2_mps:11;
        uint32_t reserved_11:4;
        /** diepctl2_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl2_usbactep:1;
        /** diepctl2_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl2_dpid:1;
        /** diepctl2_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl2_naksts:1;
        /** diepctl2_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl2_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl2_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl2_stall:1;
        /** diepctl2_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl2_txfnum:4;
        /** diepctl2_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl2_cnak:1;
        /** diepctl2_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl2_snak:1;
        /** diepctl2_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl2_setd0pid:1;
        /** diepctl2_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl2_setd1pid:1;
        /** diepctl2_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl2_epdis:1;
        /** diepctl2_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl2_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl2_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 2 of the Device
 *  controller.
 */
/** Type of diepint2 register
 *  This register contains the interrupts for the IN Endpoint 2 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint2_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint2_xfercompl:1;
        /** diepint2_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint2_epdisbld:1;
        /** diepint2_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint2_ahberr:1;
        /** diepint2_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint2_timeout:1;
        /** diepint2_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint2_intkntxfemp:1;
        /** diepint2_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint2_intknepmis:1;
        /** diepint2_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint2_inepnakeff:1;
        /** diepint2_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint2_txfemp:1;
        /** diepint2_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint2_txfifoundrn:1;
        /** diepint2_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint2_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint2_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint2_pktdrpsts:1;
        /** diepint2_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint2_bbleerr:1;
        /** diepint2_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint2_nakintrpt:1;
        /** diepint2_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint2_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint2_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 2 of the Device
 *  controller.
 */
/** Type of dieptsiz2 register
 *  This register reflects the Transfer Size of the IN Endpoint 2 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz2_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz2_xfersize:19;
        /** dieptsiz2_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz2_pktcnt:10;
        /** dieptsiz2_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz2_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz2_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 2 of the Device
 *  controller.
 */
/** Type of diepdma2 register
 *  This register contains the DMA Address for the IN Endpoint 2 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma2_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma2_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma2_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 2 of the Device controller.
 */
/** Type of dtxfsts2 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  2 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts2_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts2_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts2_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 2 of the
 *  Device controller.
 */
/** Type of diepdmab2 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 2 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab2_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab2_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab2_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 3. */
/** Type of diepctl3 register
 *  This register is used to control the characteristics of Endpoint 3.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl3_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl3_mps:11;
        uint32_t reserved_11:4;
        /** diepctl3_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl3_usbactep:1;
        /** diepctl3_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl3_dpid:1;
        /** diepctl3_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl3_naksts:1;
        /** diepctl3_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl3_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl3_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl3_stall:1;
        /** diepctl3_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl3_txfnum:4;
        /** diepctl3_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl3_cnak:1;
        /** diepctl3_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl3_snak:1;
        /** diepctl3_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl3_setd0pid:1;
        /** diepctl3_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl3_setd1pid:1;
        /** diepctl3_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl3_epdis:1;
        /** diepctl3_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl3_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl3_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 3 of the Device
 *  controller.
 */
/** Type of diepint3 register
 *  This register contains the interrupts for the IN Endpoint 3 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint3_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint3_xfercompl:1;
        /** diepint3_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint3_epdisbld:1;
        /** diepint3_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint3_ahberr:1;
        /** diepint3_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint3_timeout:1;
        /** diepint3_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint3_intkntxfemp:1;
        /** diepint3_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint3_intknepmis:1;
        /** diepint3_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint3_inepnakeff:1;
        /** diepint3_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint3_txfemp:1;
        /** diepint3_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint3_txfifoundrn:1;
        /** diepint3_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint3_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint3_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint3_pktdrpsts:1;
        /** diepint3_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint3_bbleerr:1;
        /** diepint3_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint3_nakintrpt:1;
        /** diepint3_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint3_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint3_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 3 of the Device
 *  controller.
 */
/** Type of dieptsiz3 register
 *  This register reflects the Transfer Size of the IN Endpoint 3 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz3_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz3_xfersize:19;
        /** dieptsiz3_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz3_pktcnt:10;
        /** dieptsiz3_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz3_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz3_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 3 of the Device
 *  controller.
 */
/** Type of diepdma3 register
 *  This register contains the DMA Address for the IN Endpoint 3 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma3_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma3_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma3_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 3 of the Device controller.
 */
/** Type of dtxfsts3 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  3 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts3_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts3_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts3_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 3 of the
 *  Device controller.
 */
/** Type of diepdmab3 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 3 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab3_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab3_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab3_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 4. */
/** Type of diepctl4 register
 *  This register is used to control the characteristics of Endpoint 4.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl4_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl4_mps:11;
        uint32_t reserved_11:4;
        /** diepctl4_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl4_usbactep:1;
        /** diepctl4_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl4_dpid:1;
        /** diepctl4_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl4_naksts:1;
        /** diepctl4_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl4_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl4_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl4_stall:1;
        /** diepctl4_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl4_txfnum:4;
        /** diepctl4_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl4_cnak:1;
        /** diepctl4_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl4_snak:1;
        /** diepctl4_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl4_setd0pid:1;
        /** diepctl4_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl4_setd1pid:1;
        /** diepctl4_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl4_epdis:1;
        /** diepctl4_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl4_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl4_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 4 of the Device
 *  controller.
 */
/** Type of diepint4 register
 *  This register contains the interrupts for the IN Endpoint 4 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint4_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint4_xfercompl:1;
        /** diepint4_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint4_epdisbld:1;
        /** diepint4_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint4_ahberr:1;
        /** diepint4_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint4_timeout:1;
        /** diepint4_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint4_intkntxfemp:1;
        /** diepint4_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint4_intknepmis:1;
        /** diepint4_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint4_inepnakeff:1;
        /** diepint4_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint4_txfemp:1;
        /** diepint4_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint4_txfifoundrn:1;
        /** diepint4_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint4_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint4_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint4_pktdrpsts:1;
        /** diepint4_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint4_bbleerr:1;
        /** diepint4_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint4_nakintrpt:1;
        /** diepint4_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint4_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint4_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 4 of the Device
 *  controller.
 */
/** Type of dieptsiz4 register
 *  This register reflects the Transfer Size of the IN Endpoint 4 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz4_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz4_xfersize:19;
        /** dieptsiz4_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz4_pktcnt:10;
        /** dieptsiz4_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz4_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz4_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 4 of the Device
 *  controller.
 */
/** Type of diepdma4 register
 *  This register contains the DMA Address for the IN Endpoint 4 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma4_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma4_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma4_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 4 of the Device controller.
 */
/** Type of dtxfsts4 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  4 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts4_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts4_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts4_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 4 of the
 *  Device controller.
 */
/** Type of diepdmab4 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 4 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab4_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab4_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab4_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 5. */
/** Type of diepctl5 register
 *  This register is used to control the characteristics of Endpoint 5.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl5_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl5_mps:11;
        uint32_t reserved_11:4;
        /** diepctl5_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl5_usbactep:1;
        /** diepctl5_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl5_dpid:1;
        /** diepctl5_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl5_naksts:1;
        /** diepctl5_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl5_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl5_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl5_stall:1;
        /** diepctl5_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl5_txfnum:4;
        /** diepctl5_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl5_cnak:1;
        /** diepctl5_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl5_snak:1;
        /** diepctl5_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl5_setd0pid:1;
        /** diepctl5_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl5_setd1pid:1;
        /** diepctl5_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl5_epdis:1;
        /** diepctl5_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl5_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl5_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 5 of the Device
 *  controller.
 */
/** Type of diepint5 register
 *  This register contains the interrupts for the IN Endpoint 5 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint5_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint5_xfercompl:1;
        /** diepint5_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint5_epdisbld:1;
        /** diepint5_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint5_ahberr:1;
        /** diepint5_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint5_timeout:1;
        /** diepint5_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint5_intkntxfemp:1;
        /** diepint5_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint5_intknepmis:1;
        /** diepint5_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint5_inepnakeff:1;
        /** diepint5_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint5_txfemp:1;
        /** diepint5_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint5_txfifoundrn:1;
        /** diepint5_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint5_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint5_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint5_pktdrpsts:1;
        /** diepint5_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint5_bbleerr:1;
        /** diepint5_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint5_nakintrpt:1;
        /** diepint5_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint5_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint5_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 5 of the Device
 *  controller.
 */
/** Type of dieptsiz5 register
 *  This register reflects the Transfer Size of the IN Endpoint 5 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz5_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz5_xfersize:19;
        /** dieptsiz5_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz5_pktcnt:10;
        /** dieptsiz5_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz5_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz5_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 5 of the Device
 *  controller.
 */
/** Type of diepdma5 register
 *  This register contains the DMA Address for the IN Endpoint 5 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma5_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma5_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma5_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 5 of the Device controller.
 */
/** Type of dtxfsts5 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  5 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts5_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts5_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts5_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 5 of the
 *  Device controller.
 */
/** Type of diepdmab5 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 5 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab5_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab5_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab5_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 6. */
/** Type of diepctl6 register
 *  This register is used to control the characteristics of Endpoint 6.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl6_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl6_mps:11;
        uint32_t reserved_11:4;
        /** diepctl6_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl6_usbactep:1;
        /** diepctl6_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl6_dpid:1;
        /** diepctl6_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl6_naksts:1;
        /** diepctl6_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl6_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl6_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl6_stall:1;
        /** diepctl6_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl6_txfnum:4;
        /** diepctl6_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl6_cnak:1;
        /** diepctl6_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl6_snak:1;
        /** diepctl6_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl6_setd0pid:1;
        /** diepctl6_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl6_setd1pid:1;
        /** diepctl6_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl6_epdis:1;
        /** diepctl6_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl6_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl6_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 6 of the Device
 *  controller.
 */
/** Type of diepint6 register
 *  This register contains the interrupts for the IN Endpoint 6 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint6_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint6_xfercompl:1;
        /** diepint6_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint6_epdisbld:1;
        /** diepint6_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint6_ahberr:1;
        /** diepint6_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint6_timeout:1;
        /** diepint6_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint6_intkntxfemp:1;
        /** diepint6_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint6_intknepmis:1;
        /** diepint6_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint6_inepnakeff:1;
        /** diepint6_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint6_txfemp:1;
        /** diepint6_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint6_txfifoundrn:1;
        /** diepint6_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint6_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint6_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint6_pktdrpsts:1;
        /** diepint6_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint6_bbleerr:1;
        /** diepint6_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint6_nakintrpt:1;
        /** diepint6_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint6_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint6_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 6 of the Device
 *  controller.
 */
/** Type of dieptsiz6 register
 *  This register reflects the Transfer Size of the IN Endpoint 6 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz6_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz6_xfersize:19;
        /** dieptsiz6_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz6_pktcnt:10;
        /** dieptsiz6_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz6_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz6_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 6 of the Device
 *  controller.
 */
/** Type of diepdma6 register
 *  This register contains the DMA Address for the IN Endpoint 6 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma6_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma6_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma6_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 6 of the Device controller.
 */
/** Type of dtxfsts6 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  6 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts6_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts6_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts6_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 6 of the
 *  Device controller.
 */
/** Type of diepdmab6 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 6 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab6_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab6_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab6_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 7. */
/** Type of diepctl7 register
 *  This register is used to control the characteristics of Endpoint 7.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl7_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl7_mps:11;
        uint32_t reserved_11:4;
        /** diepctl7_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl7_usbactep:1;
        /** diepctl7_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl7_dpid:1;
        /** diepctl7_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl7_naksts:1;
        /** diepctl7_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl7_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl7_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl7_stall:1;
        /** diepctl7_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl7_txfnum:4;
        /** diepctl7_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl7_cnak:1;
        /** diepctl7_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl7_snak:1;
        /** diepctl7_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl7_setd0pid:1;
        /** diepctl7_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl7_setd1pid:1;
        /** diepctl7_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl7_epdis:1;
        /** diepctl7_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl7_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl7_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 7 of the Device
 *  controller.
 */
/** Type of diepint7 register
 *  This register contains the interrupts for the IN Endpoint 7 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint7_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint7_xfercompl:1;
        /** diepint7_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint7_epdisbld:1;
        /** diepint7_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint7_ahberr:1;
        /** diepint7_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint7_timeout:1;
        /** diepint7_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint7_intkntxfemp:1;
        /** diepint7_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint7_intknepmis:1;
        /** diepint7_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint7_inepnakeff:1;
        /** diepint7_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint7_txfemp:1;
        /** diepint7_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint7_txfifoundrn:1;
        /** diepint7_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint7_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint7_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint7_pktdrpsts:1;
        /** diepint7_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint7_bbleerr:1;
        /** diepint7_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint7_nakintrpt:1;
        /** diepint7_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint7_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint7_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 7 of the Device
 *  controller.
 */
/** Type of dieptsiz7 register
 *  This register reflects the Transfer Size of the IN Endpoint 7 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz7_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz7_xfersize:19;
        /** dieptsiz7_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz7_pktcnt:10;
        /** dieptsiz7_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz7_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz7_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 7 of the Device
 *  controller.
 */
/** Type of diepdma7 register
 *  This register contains the DMA Address for the IN Endpoint 7 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma7_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma7_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma7_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 7 of the Device controller.
 */
/** Type of dtxfsts7 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  7 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts7_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts7_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts7_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 7 of the
 *  Device controller.
 */
/** Type of diepdmab7 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 7 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab7_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab7_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab7_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 8. */
/** Type of diepctl8 register
 *  This register is used to control the characteristics of Endpoint 8.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl8_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl8_mps:11;
        uint32_t reserved_11:4;
        /** diepctl8_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl8_usbactep:1;
        /** diepctl8_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl8_dpid:1;
        /** diepctl8_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl8_naksts:1;
        /** diepctl8_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl8_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl8_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl8_stall:1;
        /** diepctl8_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl8_txfnum:4;
        /** diepctl8_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl8_cnak:1;
        /** diepctl8_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl8_snak:1;
        /** diepctl8_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl8_setd0pid:1;
        /** diepctl8_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl8_setd1pid:1;
        /** diepctl8_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl8_epdis:1;
        /** diepctl8_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl8_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl8_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 8 of the Device
 *  controller.
 */
/** Type of diepint8 register
 *  This register contains the interrupts for the IN Endpoint 8 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint8_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint8_xfercompl:1;
        /** diepint8_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint8_epdisbld:1;
        /** diepint8_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint8_ahberr:1;
        /** diepint8_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint8_timeout:1;
        /** diepint8_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint8_intkntxfemp:1;
        /** diepint8_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint8_intknepmis:1;
        /** diepint8_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint8_inepnakeff:1;
        /** diepint8_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint8_txfemp:1;
        /** diepint8_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint8_txfifoundrn:1;
        /** diepint8_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint8_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint8_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint8_pktdrpsts:1;
        /** diepint8_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint8_bbleerr:1;
        /** diepint8_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint8_nakintrpt:1;
        /** diepint8_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint8_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint8_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 8 of the Device
 *  controller.
 */
/** Type of dieptsiz8 register
 *  This register reflects the Transfer Size of the IN Endpoint 8 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz8_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz8_xfersize:19;
        /** dieptsiz8_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz8_pktcnt:10;
        /** dieptsiz8_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz8_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz8_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 8 of the Device
 *  controller.
 */
/** Type of diepdma8 register
 *  This register contains the DMA Address for the IN Endpoint 8 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma8_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma8_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma8_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 8 of the Device controller.
 */
/** Type of dtxfsts8 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  8 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts8_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts8_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts8_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 8 of the
 *  Device controller.
 */
/** Type of diepdmab8 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 8 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab8_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab8_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab8_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 9. */
/** Type of diepctl9 register
 *  This register is used to control the characteristics of Endpoint 9.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl9_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl9_mps:11;
        uint32_t reserved_11:4;
        /** diepctl9_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl9_usbactep:1;
        /** diepctl9_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl9_dpid:1;
        /** diepctl9_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl9_naksts:1;
        /** diepctl9_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl9_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl9_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl9_stall:1;
        /** diepctl9_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl9_txfnum:4;
        /** diepctl9_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl9_cnak:1;
        /** diepctl9_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl9_snak:1;
        /** diepctl9_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl9_setd0pid:1;
        /** diepctl9_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl9_setd1pid:1;
        /** diepctl9_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl9_epdis:1;
        /** diepctl9_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl9_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl9_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 9 of the Device
 *  controller.
 */
/** Type of diepint9 register
 *  This register contains the interrupts for the IN Endpoint 9 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint9_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint9_xfercompl:1;
        /** diepint9_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint9_epdisbld:1;
        /** diepint9_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint9_ahberr:1;
        /** diepint9_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint9_timeout:1;
        /** diepint9_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint9_intkntxfemp:1;
        /** diepint9_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint9_intknepmis:1;
        /** diepint9_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint9_inepnakeff:1;
        /** diepint9_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint9_txfemp:1;
        /** diepint9_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint9_txfifoundrn:1;
        /** diepint9_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint9_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint9_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint9_pktdrpsts:1;
        /** diepint9_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint9_bbleerr:1;
        /** diepint9_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint9_nakintrpt:1;
        /** diepint9_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint9_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint9_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 9 of the Device
 *  controller.
 */
/** Type of dieptsiz9 register
 *  This register reflects the Transfer Size of the IN Endpoint 9 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz9_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz9_xfersize:19;
        /** dieptsiz9_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz9_pktcnt:10;
        /** dieptsiz9_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz9_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz9_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 9 of the Device
 *  controller.
 */
/** Type of diepdma9 register
 *  This register contains the DMA Address for the IN Endpoint 9 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma9_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma9_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma9_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 9 of the Device controller.
 */
/** Type of dtxfsts9 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  9 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts9_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts9_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts9_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 9 of the
 *  Device controller.
 */
/** Type of diepdmab9 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 9 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab9_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab9_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab9_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 10. */
/** Type of diepctl10 register
 *  This register is used to control the characteristics of Endpoint 10.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl10_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl10_mps:11;
        uint32_t reserved_11:4;
        /** diepctl10_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl10_usbactep:1;
        /** diepctl10_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl10_dpid:1;
        /** diepctl10_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl10_naksts:1;
        /** diepctl10_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl10_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl10_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl10_stall:1;
        /** diepctl10_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl10_txfnum:4;
        /** diepctl10_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl10_cnak:1;
        /** diepctl10_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl10_snak:1;
        /** diepctl10_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl10_setd0pid:1;
        /** diepctl10_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl10_setd1pid:1;
        /** diepctl10_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl10_epdis:1;
        /** diepctl10_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl10_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl10_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 10 of the Device
 *  controller.
 */
/** Type of diepint10 register
 *  This register contains the interrupts for the IN Endpoint 10 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint10_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint10_xfercompl:1;
        /** diepint10_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint10_epdisbld:1;
        /** diepint10_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint10_ahberr:1;
        /** diepint10_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint10_timeout:1;
        /** diepint10_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint10_intkntxfemp:1;
        /** diepint10_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint10_intknepmis:1;
        /** diepint10_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint10_inepnakeff:1;
        /** diepint10_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint10_txfemp:1;
        /** diepint10_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint10_txfifoundrn:1;
        /** diepint10_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint10_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint10_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint10_pktdrpsts:1;
        /** diepint10_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint10_bbleerr:1;
        /** diepint10_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint10_nakintrpt:1;
        /** diepint10_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint10_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint10_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 10 of the Device
 *  controller.
 */
/** Type of dieptsiz10 register
 *  This register reflects the Transfer Size of the IN Endpoint 10 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz10_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz10_xfersize:19;
        /** dieptsiz10_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz10_pktcnt:10;
        /** dieptsiz10_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz10_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz10_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 10 of the Device
 *  controller.
 */
/** Type of diepdma10 register
 *  This register contains the DMA Address for the IN Endpoint 10 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma10_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma10_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma10_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 10 of the Device controller.
 */
/** Type of dtxfsts10 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  10 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts10_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts10_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts10_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 10 of the
 *  Device controller.
 */
/** Type of diepdmab10 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 10 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab10_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab10_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab10_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 11. */
/** Type of diepctl11 register
 *  This register is used to control the characteristics of Endpoint 11.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl11_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl11_mps:11;
        uint32_t reserved_11:4;
        /** diepctl11_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl11_usbactep:1;
        /** diepctl11_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl11_dpid:1;
        /** diepctl11_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl11_naksts:1;
        /** diepctl11_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl11_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl11_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl11_stall:1;
        /** diepctl11_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl11_txfnum:4;
        /** diepctl11_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl11_cnak:1;
        /** diepctl11_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl11_snak:1;
        /** diepctl11_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl11_setd0pid:1;
        /** diepctl11_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl11_setd1pid:1;
        /** diepctl11_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl11_epdis:1;
        /** diepctl11_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl11_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl11_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 11 of the Device
 *  controller.
 */
/** Type of diepint11 register
 *  This register contains the interrupts for the IN Endpoint 11 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint11_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint11_xfercompl:1;
        /** diepint11_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint11_epdisbld:1;
        /** diepint11_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint11_ahberr:1;
        /** diepint11_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint11_timeout:1;
        /** diepint11_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint11_intkntxfemp:1;
        /** diepint11_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint11_intknepmis:1;
        /** diepint11_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint11_inepnakeff:1;
        /** diepint11_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint11_txfemp:1;
        /** diepint11_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint11_txfifoundrn:1;
        /** diepint11_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint11_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint11_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint11_pktdrpsts:1;
        /** diepint11_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint11_bbleerr:1;
        /** diepint11_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint11_nakintrpt:1;
        /** diepint11_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint11_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint11_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 11 of the Device
 *  controller.
 */
/** Type of dieptsiz11 register
 *  This register reflects the Transfer Size of the IN Endpoint 11 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz11_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz11_xfersize:19;
        /** dieptsiz11_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz11_pktcnt:10;
        /** dieptsiz11_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz11_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz11_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 11 of the Device
 *  controller.
 */
/** Type of diepdma11 register
 *  This register contains the DMA Address for the IN Endpoint 11 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma11_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma11_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma11_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 11 of the Device controller.
 */
/** Type of dtxfsts11 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  11 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts11_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts11_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts11_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 11 of the
 *  Device controller.
 */
/** Type of diepdmab11 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 11 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab11_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab11_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab11_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 12. */
/** Type of diepctl12 register
 *  This register is used to control the characteristics of Endpoint 12.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl12_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl12_mps:11;
        uint32_t reserved_11:4;
        /** diepctl12_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl12_usbactep:1;
        /** diepctl12_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl12_dpid:1;
        /** diepctl12_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl12_naksts:1;
        /** diepctl12_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl12_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl12_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl12_stall:1;
        /** diepctl12_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl12_txfnum:4;
        /** diepctl12_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl12_cnak:1;
        /** diepctl12_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl12_snak:1;
        /** diepctl12_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl12_setd0pid:1;
        /** diepctl12_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl12_setd1pid:1;
        /** diepctl12_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl12_epdis:1;
        /** diepctl12_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl12_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl12_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 12 of the Device
 *  controller.
 */
/** Type of diepint12 register
 *  This register contains the interrupts for the IN Endpoint 12 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint12_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint12_xfercompl:1;
        /** diepint12_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint12_epdisbld:1;
        /** diepint12_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint12_ahberr:1;
        /** diepint12_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint12_timeout:1;
        /** diepint12_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint12_intkntxfemp:1;
        /** diepint12_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint12_intknepmis:1;
        /** diepint12_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint12_inepnakeff:1;
        /** diepint12_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint12_txfemp:1;
        /** diepint12_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint12_txfifoundrn:1;
        /** diepint12_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint12_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint12_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint12_pktdrpsts:1;
        /** diepint12_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint12_bbleerr:1;
        /** diepint12_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint12_nakintrpt:1;
        /** diepint12_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint12_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint12_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 12 of the Device
 *  controller.
 */
/** Type of dieptsiz12 register
 *  This register reflects the Transfer Size of the IN Endpoint 12 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz12_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz12_xfersize:19;
        /** dieptsiz12_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz12_pktcnt:10;
        /** dieptsiz12_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz12_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz12_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 12 of the Device
 *  controller.
 */
/** Type of diepdma12 register
 *  This register contains the DMA Address for the IN Endpoint 12 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma12_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma12_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma12_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 12 of the Device controller.
 */
/** Type of dtxfsts12 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  12 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts12_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts12_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts12_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 12 of the
 *  Device controller.
 */
/** Type of diepdmab12 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 12 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab12_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab12_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab12_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 13. */
/** Type of diepctl13 register
 *  This register is used to control the characteristics of Endpoint 13.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl13_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl13_mps:11;
        uint32_t reserved_11:4;
        /** diepctl13_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl13_usbactep:1;
        /** diepctl13_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl13_dpid:1;
        /** diepctl13_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl13_naksts:1;
        /** diepctl13_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl13_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl13_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl13_stall:1;
        /** diepctl13_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl13_txfnum:4;
        /** diepctl13_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl13_cnak:1;
        /** diepctl13_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl13_snak:1;
        /** diepctl13_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl13_setd0pid:1;
        /** diepctl13_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl13_setd1pid:1;
        /** diepctl13_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl13_epdis:1;
        /** diepctl13_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl13_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl13_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 13 of the Device
 *  controller.
 */
/** Type of diepint13 register
 *  This register contains the interrupts for the IN Endpoint 13 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint13_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint13_xfercompl:1;
        /** diepint13_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint13_epdisbld:1;
        /** diepint13_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint13_ahberr:1;
        /** diepint13_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint13_timeout:1;
        /** diepint13_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint13_intkntxfemp:1;
        /** diepint13_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint13_intknepmis:1;
        /** diepint13_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint13_inepnakeff:1;
        /** diepint13_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint13_txfemp:1;
        /** diepint13_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint13_txfifoundrn:1;
        /** diepint13_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint13_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint13_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint13_pktdrpsts:1;
        /** diepint13_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint13_bbleerr:1;
        /** diepint13_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint13_nakintrpt:1;
        /** diepint13_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint13_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint13_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 13 of the Device
 *  controller.
 */
/** Type of dieptsiz13 register
 *  This register reflects the Transfer Size of the IN Endpoint 13 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz13_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz13_xfersize:19;
        /** dieptsiz13_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz13_pktcnt:10;
        /** dieptsiz13_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz13_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz13_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 13 of the Device
 *  controller.
 */
/** Type of diepdma13 register
 *  This register contains the DMA Address for the IN Endpoint 13 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma13_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma13_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma13_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 13 of the Device controller.
 */
/** Type of dtxfsts13 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  13 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts13_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts13_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts13_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 13 of the
 *  Device controller.
 */
/** Type of diepdmab13 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 13 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab13_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab13_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab13_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 14. */
/** Type of diepctl14 register
 *  This register is used to control the characteristics of Endpoint 14.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl14_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl14_mps:11;
        uint32_t reserved_11:4;
        /** diepctl14_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl14_usbactep:1;
        /** diepctl14_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl14_dpid:1;
        /** diepctl14_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl14_naksts:1;
        /** diepctl14_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl14_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl14_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl14_stall:1;
        /** diepctl14_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl14_txfnum:4;
        /** diepctl14_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl14_cnak:1;
        /** diepctl14_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl14_snak:1;
        /** diepctl14_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl14_setd0pid:1;
        /** diepctl14_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl14_setd1pid:1;
        /** diepctl14_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl14_epdis:1;
        /** diepctl14_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl14_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl14_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 14 of the Device
 *  controller.
 */
/** Type of diepint14 register
 *  This register contains the interrupts for the IN Endpoint 14 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint14_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint14_xfercompl:1;
        /** diepint14_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint14_epdisbld:1;
        /** diepint14_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint14_ahberr:1;
        /** diepint14_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint14_timeout:1;
        /** diepint14_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint14_intkntxfemp:1;
        /** diepint14_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint14_intknepmis:1;
        /** diepint14_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint14_inepnakeff:1;
        /** diepint14_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint14_txfemp:1;
        /** diepint14_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint14_txfifoundrn:1;
        /** diepint14_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint14_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint14_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint14_pktdrpsts:1;
        /** diepint14_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint14_bbleerr:1;
        /** diepint14_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint14_nakintrpt:1;
        /** diepint14_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint14_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint14_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 14 of the Device
 *  controller.
 */
/** Type of dieptsiz14 register
 *  This register reflects the Transfer Size of the IN Endpoint 14 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz14_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz14_xfersize:19;
        /** dieptsiz14_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz14_pktcnt:10;
        /** dieptsiz14_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz14_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz14_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 14 of the Device
 *  controller.
 */
/** Type of diepdma14 register
 *  This register contains the DMA Address for the IN Endpoint 14 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma14_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma14_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma14_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 14 of the Device controller.
 */
/** Type of dtxfsts14 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  14 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts14_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts14_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts14_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 14 of the
 *  Device controller.
 */
/** Type of diepdmab14 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 14 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab14_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab14_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab14_reg_t;


/** Group: This register is used to control the characteristics of Endpoint 15. */
/** Type of diepctl15 register
 *  This register is used to control the characteristics of Endpoint 15.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
typedef union {
    struct {
        /** diepctl15_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the
         *  current logical endpoint. This value is in bytes.
         */
        uint32_t diepctl15_mps:11;
        uint32_t reserved_11:4;
        /** diepctl15_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t diepctl15_usbactep:1;
        /** diepctl15_dpid : RO; bitpos: [16]; default: 0;
         *
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *
         *  Applies to isochronous IN and OUT endpoints only.
         *
         *  Indicates the (micro)frame number in which the core transmits/receives isochronous
         *  data for this endpoint. The application must program the even/odd (micro)frame
         *  number in which it intends to transmit/receive isochronous data for this endpoint
         *  using
         *  the SetEvnFr and SetOddFr fields in this register.
         *  - 1'b0: Even (micro)frame
         *  - 1'b1: Odd (micro)frame
         *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame in
         *  which data is received is updated in receive descriptor structure.
         */
        uint32_t diepctl15_dpid:1;
        /** diepctl15_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t diepctl15_naksts:1;
        /** diepctl15_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t diepctl15_eptype:2;
        uint32_t reserved_20:1;
        /** diepctl15_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t diepctl15_stall:1;
        /** diepctl15_txfnum : R/W; bitpos: [25:22]; default: 0;
         *  TxFIFO Number (TxFNum)
         *
         *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
         *  endpoints must map this to the corresponding Periodic TxFIFO number.
         *  - 4'h0: Non-Periodic TxFIFO
         *  - Others: Specified Periodic TxFIFO.number
         *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
         *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
         *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
         *  be
         *  allocated for an interrupt IN endpoint, and the number of this
         *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
         *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
         *
         *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
         *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
         *  This field is valid only for IN endpoints.
         */
        uint32_t diepctl15_txfnum:4;
        /** diepctl15_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t diepctl15_cnak:1;
        /** diepctl15_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
         *  received on that endpoint.
         */
        uint32_t diepctl15_snak:1;
        /** diepctl15_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t diepctl15_setd0pid:1;
        /** diepctl15_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t diepctl15_setd1pid:1;
        /** diepctl15_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t diepctl15_epdis:1;
        /** diepctl15_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled,
         *  -- For IN endpoints this bit indicates that the descriptor structure and data
         *  buffer with data ready to transmit is setup.
         *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  -- For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set to be able to
         *  transfer SETUP data packets in memory.
         */
        uint32_t diepctl15_epena:1;
    };
    uint32_t val;
} usb_otghs_diepctl15_reg_t;


/** Group: This register contains the interrupts for the IN Endpoint 15 of the Device
 *  controller.
 */
/** Type of diepint15 register
 *  This register contains the interrupts for the IN Endpoint 15 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepint15_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t diepint15_xfercompl:1;
        /** diepint15_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t diepint15_epdisbld:1;
        /** diepint15_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling in the
         *  Programming Guide.
         */
        uint32_t diepint15_ahberr:1;
        /** diepint15_timeout : R/W; bitpos: [3]; default: 0;
         *  Timeout Condition (TimeOUT)
         *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
         *  - In dedicated FIFO mode, applies only to Control IN endpoints.
         *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
         *  Indicates that the core has detected a timeout condition on the USB for the last IN
         *  token on this endpoint.
         */
        uint32_t diepint15_timeout:1;
        /** diepint15_intkntxfemp : R/W; bitpos: [4]; default: 0;
         *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that an IN token was received when the associated TxFIFO
         *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
         *  which the IN token was received.
         */
        uint32_t diepint15_intkntxfemp:1;
        /** diepint15_intknepmis : R/W; bitpos: [5]; default: 0;
         *  IN Token Received with EP Mismatch (INTknEPMis)
         *
         *  Applies to non-periodic IN endpoints only.
         *
         *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
         *  endpoint other than the one for which the IN token was received. This interrupt is
         *  asserted on the endpoint for which the IN token was received.
         */
        uint32_t diepint15_intknepmis:1;
        /** diepint15_inepnakeff : R/W; bitpos: [6]; default: 0;
         *  IN Endpoint NAK Effective (INEPNakEff)
         *
         *  Applies to periodic IN endpoints only.
         *
         *  This bit can be cleared when the application clears the IN endpoint NAK by writing
         *  to DIEPCTLn.CNAK.
         *
         *  This interrupt indicates that the core has sampled the NAK bit
         *
         *  Set (either by the application or by the core). The interrupt indicates that the IN
         *  endpoint NAK bit Set by the application has taken effect in the core.
         *
         *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
         *  bit takes priority over a NAK bit.
         */
        uint32_t diepint15_inepnakeff:1;
        /** diepint15_txfemp : RO; bitpos: [7]; default: 1;
         *  Transmit FIFO Empty (TxFEmp)
         *
         *  This bit is valid only for IN endpoints
         *
         *  This interrupt is asserted when the TxFIFO for this endpoint is
         *  either half or completely empty. The half or completely empty
         *  status is determined by the TxFIFO Empty Level bit in the Core
         *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
         */
        uint32_t diepint15_txfemp:1;
        /** diepint15_txfifoundrn : R/W; bitpos: [8]; default: 0;
         *  Fifo Underrun (TxfifoUndrn)
         *
         *  Applies to IN endpoints Only
         *
         *  This bit is valid only If thresholding is enabled. The core generates this
         *  interrupt when
         *  it detects a transmit FIFO underrun condition for this endpoint.
         */
        uint32_t diepint15_txfifoundrn:1;
        /** diepint15_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed is not ready for the
         *  Core to process, such as Host busy or DMA done.
         */
        uint32_t diepint15_bnaintr:1;
        uint32_t reserved_10:1;
        /** diepint15_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t diepint15_pktdrpsts:1;
        /** diepint15_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t diepint15_bbleerr:1;
        /** diepint15_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t diepint15_nakintrpt:1;
        /** diepint15_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t diepint15_nyetintrpt:1;
        uint32_t reserved_15:17;
    };
    uint32_t val;
} usb_otghs_diepint15_reg_t;


/** Group: This register reflects the Transfer Size of the IN Endpoint 15 of the Device
 *  controller.
 */
/** Type of dieptsiz15 register
 *  This register reflects the Transfer Size of the IN Endpoint 15 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dieptsiz15_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet from the
         *  external memory is written to the TxFIFO.
         */
        uint32_t dieptsiz15_xfersize:19;
        /** dieptsiz15_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  Indicates the total number of USB packets that constitute the Transfer Size amount
         *  of data for endpoint 0.
         *
         *  This field is decremented every time a packet (maximum size or short packet) is
         *  read from the TxFIFO.
         */
        uint32_t dieptsiz15_pktcnt:10;
        /** dieptsiz15_mc : R/W; bitpos: [30:29]; default: 0;
         *  MC
         *
         *  Applies to IN endpoints only.
         *
         *  For periodic IN endpoints, this field indicates the number of packets that must be
         *  transmitted per microframe on the USB. The core uses this field to calculate the
         *  data PID for isochronous IN endpoints.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
         *  specifies the number of packets the core must fetchfor an IN endpoint before it
         *  switches to the endpoint pointed to by the Next Endpoint field of the Device
         *  Endpoint-n Control register (DIEPCTLn.NextEp)
         */
        uint32_t dieptsiz15_mc:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_dieptsiz15_reg_t;


/** Group: This register contains the DMA Address for the IN Endpoint 15 of the Device
 *  controller.
 */
/** Type of diepdma15 register
 *  This register contains the DMA Address for the IN Endpoint 15 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdma15_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t diepdma15_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdma15_reg_t;


/** Group: This register reflects the status of the IN Endpoint Transmit FIFO Status
 *  Register 15 of the Device controller.
 */
/** Type of dtxfsts15 register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  15 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** dtxfsts15_ineptxfspcavail : RO; bitpos: [15:0]; default: 1024;
         *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
         *
         *  Indicates the amount of free space available in the Endpoint TxFIFO.
         *
         *  Values are in terms of 32-bit words.
         *  - 16'h0: Endpoint TxFIFO is full
         *  - 16'h1: 1 word available
         *  - 16'h2: 2 words available
         *  - 16'hn: n words available (where 0  n  32,768)
         *  - 16'h8000: 32,768 words available
         *  - Others: Reserved
         *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
         *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
         *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
         *  during reset, and
         *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
         */
        uint32_t dtxfsts15_ineptxfspcavail:16;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_dtxfsts15_reg_t;


/** Group: This register contains the DMA Buffer Address of the IN Endpoint 15 of the
 *  Device controller.
 */
/** Type of diepdmab15 register
 *  This register contains the DMA Buffer Address of the IN Endpoint 15 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
typedef union {
    struct {
        /** diepdmab15_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t diepdmab15_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_diepdmab15_reg_t;


/** Group: This register is used to control the characteristics of the OUT Endpoint 0
 *  of the Device controller.
 */
/** Type of doepctl0 register
 *  This register is used to control the characteristics of the OUT Endpoint 0 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl0_mps : RO; bitpos: [1:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The maximum packet size for control OUT endpoint 0 is the same as what is
         *  programmed in control IN Endpoint 0.
         *  - 2'b00: 64 bytes
         *  - 2'b01: 32 bytes
         *  - 2'b10: 16 bytes
         *  - 2'b11: 8 bytes
         */
        uint32_t doepctl0_mps:2;
        uint32_t reserved_2:13;
        /** doepctl0_usbactep : RO; bitpos: [15]; default: 1;
         *  USB Active Endpoint (USBActEP)
         *
         *  This bit is always set to 1, indicating that a control endpoint 0 is always active
         *  in all configurations and interfaces.
         */
        uint32_t doepctl0_usbactep:1;
        uint32_t reserved_16:1;
        /** doepctl0_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit, the core
         *  stops receiving data, even If there is space in the RxFIFO to
         *  accommodate the incoming packet. Irrespective of this bit's
         *  setting, the core always responds to SETUP data packets with
         *  an ACK handshake.
         */
        uint32_t doepctl0_naksts:1;
        /** doepctl0_eptype : RO; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  Hardcoded to 2'b00 for control.
         */
        uint32_t doepctl0_eptype:2;
        /** doepctl0_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl0_snp:1;
        /** doepctl0_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  The application can only set this bit, and the core clears it, when
         *  a SETUP token is received for this endpoint. If a NAK bit or
         *  Global OUT NAK is Set along with this bit, the STALL bit takes
         *  priority. Irrespective of this bit's setting, the core always
         *  responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl0_stall:1;
        uint32_t reserved_22:4;
        /** doepctl0_cnak : R/W; bitpos: [26]; default: 0;
         *  Clear NAK (CNAK)
         *
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl0_cnak:1;
        /** doepctl0_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *  Using this bit, the application can control the transmission of NAK handshakes on
         *  an endpoint.
         *  The core can also set bit on a Transfer Completed interrupt, or after a SETUP is
         *  received on the endpoint.
         */
        uint32_t doepctl0_snak:1;
        uint32_t reserved_28:2;
        /** doepctl0_epdis : RO; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  The application cannot disable control OUT endpoint 0.
         */
        uint32_t doepctl0_epdis:1;
        /** doepctl0_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *  - When Scatter/Gather DMA mode is enabled, for OUT endpoints this bit indicates
         *  that the descriptor structure and data buffer to receive data is setup.
         *  - When Scatter/Gather DMA mode is disabled (such as for buffer-pointer based DMA
         *  mode)this bit indicates that the application has allocated the memory to start
         *  receiving data from the USB.
         *  - The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  -- SETUP Phase Done
         *  -- Endpoint Disabled
         *  -- Transfer Completed
         *  Note: In DMA mode, this bit must be set for the core to transfer SETUP data packets
         *  into memory and it is not cleared on Transfer Completed interrupt of SETUP packet.
         */
        uint32_t doepctl0_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl0_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 0 of the Device
 *  controller.
 */
/** Type of doepint0 register
 *  This register contains the interrupts for the OUT Endpoint 0 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint0_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled
         *  - For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  - For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  Note: In DMA mode, this bit must be set for the core to transfer SETUP data packets
         *  into memory. When Scatter/Gather DMA mode is disabled, this field indicates that
         *  the programmed transfer is complete on the AHB as well as on the USB, for this
         *  endpoint.
         */
        uint32_t doepint0_xfercompl:1;
        /** doepint0_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint0_epdisbld:1;
        /** doepint0_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint0_ahberr:1;
        /** doepint0_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint0_setup:1;
        /** doepint0_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint
         *  was not yet enabled. This interrupt is asserted on the endpoint for which the OUT
         *  token was received.
         */
        uint32_t doepint0_outtknepdis:1;
        /** doepint0_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint0_stsphsercvd:1;
        /** doepint0_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint0_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint0_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled.
         *
         *  This interrupt is asserted when the core detects an overflow or a CRC error for
         *  non-Isochronous OUT packet.
         */
        uint32_t doepint0_outpkterr:1;
        /** doepint0_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the core to process, such as Host busy or DMA
         *  done.
         */
        uint32_t doepint0_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint0_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint0_pktdrpsts:1;
        /** doepint0_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint0_bbleerr:1;
        /** doepint0_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint0_nakintrpt:1;
        /** doepint0_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint0_nyetintrpt:1;
        /** doepint0_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint0_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint0_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 0 of the
 *  Device controller.
 */
/** Type of doeptsiz0 register
 *  This register contains the Transfer Size for the OUT Endpoint 0 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz0_xfersize : R/W; bitpos: [6:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for endpoint 0. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz0_xfersize:7;
        uint32_t reserved_7:12;
        /** doeptsiz0_pktcnt : R/W; bitpos: [19]; default: 0;
         *  Packet Count (PktCnt)
         *
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz0_pktcnt:1;
        uint32_t reserved_20:9;
        /** doeptsiz0_supcnt : R/W; bitpos: [30:29]; default: 0;
         *  SETUP Packet Count (SUPCnt)
         *
         *  This field specifies the number of back-to-back SETUP data packets the endpoint can
         *  receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz0_supcnt:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz0_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 0 of the Device
 *  controller.
 */
/** Type of doepdma0 register
 *  This register contains the DMA Address for the OUT Endpoint 0 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma0_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma0_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma0_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 0 of the
 *  Device controller.
 */
/** Type of doepdmab0 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 0 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab0_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab0_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab0_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 1 of
 *  the Device controller.
 */
/** Type of doepctl1 register
 *  This register is used to control the characteristics of OUT Endpoint 1 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl1_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl1_mps:11;
        uint32_t reserved_11:4;
        /** doepctl1_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl1_usbactep:1;
        /** doepctl1_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl1_dpid:1;
        /** doepctl1_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl1_naksts:1;
        /** doepctl1_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl1_eptype:2;
        /** doepctl1_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl1_snp:1;
        /** doepctl1_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl1_stall:1;
        uint32_t reserved_22:4;
        /** doepctl1_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl1_cnak:1;
        /** doepctl1_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl1_snak:1;
        /** doepctl1_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl1_setd0pid:1;
        /** doepctl1_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl1_setd1pid:1;
        /** doepctl1_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl1_epdis:1;
        /** doepctl1_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl1_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl1_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 1 of the Device
 *  controller.
 */
/** Type of doepint1 register
 *  This register contains the interrupts for the OUT Endpoint 1 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint1_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint1_xfercompl:1;
        /** doepint1_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint1_epdisbld:1;
        /** doepint1_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint1_ahberr:1;
        /** doepint1_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint1_setup:1;
        /** doepint1_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint1_outtknepdis:1;
        /** doepint1_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint1_stsphsercvd:1;
        /** doepint1_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint1_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint1_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint1_outpkterr:1;
        /** doepint1_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint1_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint1_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint1_pktdrpsts:1;
        /** doepint1_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint1_bbleerr:1;
        /** doepint1_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint1_nakintrpt:1;
        /** doepint1_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint1_nyetintrpt:1;
        /** doepint1_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint1_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint1_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 1 of the
 *  Device controller.
 */
/** Type of doeptsiz1 register
 *  This register contains the Transfer Size for the OUT Endpoint 1 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz1_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz1_xfersize:19;
        /** doeptsiz1_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz1_pktcnt:10;
        /** doeptsiz1_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz1_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz1_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 1 of the Device
 *  controller.
 */
/** Type of doepdma1 register
 *  This register contains the DMA Address for the OUT Endpoint 1 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma1_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma1_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma1_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 1 of the
 *  Device controller.
 */
/** Type of doepdmab1 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 1 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab1_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab1_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab1_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 2 of
 *  the Device controller.
 */
/** Type of doepctl2 register
 *  This register is used to control the characteristics of OUT Endpoint 2 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl2_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl2_mps:11;
        uint32_t reserved_11:4;
        /** doepctl2_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl2_usbactep:1;
        /** doepctl2_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl2_dpid:1;
        /** doepctl2_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl2_naksts:1;
        /** doepctl2_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl2_eptype:2;
        /** doepctl2_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl2_snp:1;
        /** doepctl2_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl2_stall:1;
        uint32_t reserved_22:4;
        /** doepctl2_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl2_cnak:1;
        /** doepctl2_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl2_snak:1;
        /** doepctl2_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl2_setd0pid:1;
        /** doepctl2_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl2_setd1pid:1;
        /** doepctl2_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl2_epdis:1;
        /** doepctl2_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl2_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl2_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 2 of the Device
 *  controller.
 */
/** Type of doepint2 register
 *  This register contains the interrupts for the OUT Endpoint 2 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint2_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint2_xfercompl:1;
        /** doepint2_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint2_epdisbld:1;
        /** doepint2_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint2_ahberr:1;
        /** doepint2_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint2_setup:1;
        /** doepint2_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint2_outtknepdis:1;
        /** doepint2_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint2_stsphsercvd:1;
        /** doepint2_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint2_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint2_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint2_outpkterr:1;
        /** doepint2_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint2_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint2_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint2_pktdrpsts:1;
        /** doepint2_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint2_bbleerr:1;
        /** doepint2_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint2_nakintrpt:1;
        /** doepint2_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint2_nyetintrpt:1;
        /** doepint2_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint2_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint2_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 2 of the
 *  Device controller.
 */
/** Type of doeptsiz2 register
 *  This register contains the Transfer Size for the OUT Endpoint 2 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz2_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz2_xfersize:19;
        /** doeptsiz2_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz2_pktcnt:10;
        /** doeptsiz2_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz2_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz2_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 2 of the Device
 *  controller.
 */
/** Type of doepdma2 register
 *  This register contains the DMA Address for the OUT Endpoint 2 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma2_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma2_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma2_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 2 of the
 *  Device controller.
 */
/** Type of doepdmab2 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 2 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab2_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab2_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab2_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 3 of
 *  the Device controller.
 */
/** Type of doepctl3 register
 *  This register is used to control the characteristics of OUT Endpoint 3 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl3_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl3_mps:11;
        uint32_t reserved_11:4;
        /** doepctl3_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl3_usbactep:1;
        /** doepctl3_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl3_dpid:1;
        /** doepctl3_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl3_naksts:1;
        /** doepctl3_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl3_eptype:2;
        /** doepctl3_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl3_snp:1;
        /** doepctl3_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl3_stall:1;
        uint32_t reserved_22:4;
        /** doepctl3_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl3_cnak:1;
        /** doepctl3_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl3_snak:1;
        /** doepctl3_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl3_setd0pid:1;
        /** doepctl3_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl3_setd1pid:1;
        /** doepctl3_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl3_epdis:1;
        /** doepctl3_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl3_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl3_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 3 of the Device
 *  controller.
 */
/** Type of doepint3 register
 *  This register contains the interrupts for the OUT Endpoint 3 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint3_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint3_xfercompl:1;
        /** doepint3_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint3_epdisbld:1;
        /** doepint3_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint3_ahberr:1;
        /** doepint3_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint3_setup:1;
        /** doepint3_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint3_outtknepdis:1;
        /** doepint3_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint3_stsphsercvd:1;
        /** doepint3_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint3_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint3_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint3_outpkterr:1;
        /** doepint3_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint3_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint3_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint3_pktdrpsts:1;
        /** doepint3_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint3_bbleerr:1;
        /** doepint3_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint3_nakintrpt:1;
        /** doepint3_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint3_nyetintrpt:1;
        /** doepint3_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint3_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint3_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 3 of the
 *  Device controller.
 */
/** Type of doeptsiz3 register
 *  This register contains the Transfer Size for the OUT Endpoint 3 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz3_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz3_xfersize:19;
        /** doeptsiz3_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz3_pktcnt:10;
        /** doeptsiz3_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz3_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz3_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 3 of the Device
 *  controller.
 */
/** Type of doepdma3 register
 *  This register contains the DMA Address for the OUT Endpoint 3 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma3_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma3_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma3_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 3 of the
 *  Device controller.
 */
/** Type of doepdmab3 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 3 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab3_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab3_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab3_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 4 of
 *  the Device controller.
 */
/** Type of doepctl4 register
 *  This register is used to control the characteristics of OUT Endpoint 4 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl4_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl4_mps:11;
        uint32_t reserved_11:4;
        /** doepctl4_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl4_usbactep:1;
        /** doepctl4_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl4_dpid:1;
        /** doepctl4_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl4_naksts:1;
        /** doepctl4_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl4_eptype:2;
        /** doepctl4_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl4_snp:1;
        /** doepctl4_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl4_stall:1;
        uint32_t reserved_22:4;
        /** doepctl4_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl4_cnak:1;
        /** doepctl4_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl4_snak:1;
        /** doepctl4_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl4_setd0pid:1;
        /** doepctl4_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl4_setd1pid:1;
        /** doepctl4_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl4_epdis:1;
        /** doepctl4_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl4_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl4_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 4 of the Device
 *  controller.
 */
/** Type of doepint4 register
 *  This register contains the interrupts for the OUT Endpoint 4 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint4_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint4_xfercompl:1;
        /** doepint4_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint4_epdisbld:1;
        /** doepint4_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint4_ahberr:1;
        /** doepint4_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint4_setup:1;
        /** doepint4_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint4_outtknepdis:1;
        /** doepint4_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint4_stsphsercvd:1;
        /** doepint4_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint4_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint4_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint4_outpkterr:1;
        /** doepint4_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint4_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint4_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint4_pktdrpsts:1;
        /** doepint4_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint4_bbleerr:1;
        /** doepint4_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint4_nakintrpt:1;
        /** doepint4_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint4_nyetintrpt:1;
        /** doepint4_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint4_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint4_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 4 of the
 *  Device controller.
 */
/** Type of doeptsiz4 register
 *  This register contains the Transfer Size for the OUT Endpoint 4 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz4_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz4_xfersize:19;
        /** doeptsiz4_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz4_pktcnt:10;
        /** doeptsiz4_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz4_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz4_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 4 of the Device
 *  controller.
 */
/** Type of doepdma4 register
 *  This register contains the DMA Address for the OUT Endpoint 4 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma4_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma4_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma4_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 4 of the
 *  Device controller.
 */
/** Type of doepdmab4 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 4 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab4_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab4_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab4_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 5 of
 *  the Device controller.
 */
/** Type of doepctl5 register
 *  This register is used to control the characteristics of OUT Endpoint 5 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl5_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl5_mps:11;
        uint32_t reserved_11:4;
        /** doepctl5_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl5_usbactep:1;
        /** doepctl5_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl5_dpid:1;
        /** doepctl5_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl5_naksts:1;
        /** doepctl5_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl5_eptype:2;
        /** doepctl5_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl5_snp:1;
        /** doepctl5_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl5_stall:1;
        uint32_t reserved_22:4;
        /** doepctl5_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl5_cnak:1;
        /** doepctl5_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl5_snak:1;
        /** doepctl5_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl5_setd0pid:1;
        /** doepctl5_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl5_setd1pid:1;
        /** doepctl5_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl5_epdis:1;
        /** doepctl5_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl5_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl5_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 5 of the Device
 *  controller.
 */
/** Type of doepint5 register
 *  This register contains the interrupts for the OUT Endpoint 5 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint5_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint5_xfercompl:1;
        /** doepint5_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint5_epdisbld:1;
        /** doepint5_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint5_ahberr:1;
        /** doepint5_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint5_setup:1;
        /** doepint5_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint5_outtknepdis:1;
        /** doepint5_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint5_stsphsercvd:1;
        /** doepint5_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint5_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint5_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint5_outpkterr:1;
        /** doepint5_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint5_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint5_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint5_pktdrpsts:1;
        /** doepint5_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint5_bbleerr:1;
        /** doepint5_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint5_nakintrpt:1;
        /** doepint5_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint5_nyetintrpt:1;
        /** doepint5_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint5_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint5_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 5 of the
 *  Device controller.
 */
/** Type of doeptsiz5 register
 *  This register contains the Transfer Size for the OUT Endpoint 5 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz5_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz5_xfersize:19;
        /** doeptsiz5_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz5_pktcnt:10;
        /** doeptsiz5_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz5_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz5_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 5 of the Device
 *  controller.
 */
/** Type of doepdma5 register
 *  This register contains the DMA Address for the OUT Endpoint 5 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma5_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma5_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma5_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 5 of the
 *  Device controller.
 */
/** Type of doepdmab5 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 5 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab5_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab5_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab5_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 6 of
 *  the Device controller.
 */
/** Type of doepctl6 register
 *  This register is used to control the characteristics of OUT Endpoint 6 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl6_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl6_mps:11;
        uint32_t reserved_11:4;
        /** doepctl6_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl6_usbactep:1;
        /** doepctl6_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl6_dpid:1;
        /** doepctl6_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl6_naksts:1;
        /** doepctl6_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl6_eptype:2;
        /** doepctl6_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl6_snp:1;
        /** doepctl6_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl6_stall:1;
        uint32_t reserved_22:4;
        /** doepctl6_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl6_cnak:1;
        /** doepctl6_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl6_snak:1;
        /** doepctl6_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl6_setd0pid:1;
        /** doepctl6_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl6_setd1pid:1;
        /** doepctl6_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl6_epdis:1;
        /** doepctl6_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl6_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl6_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 6 of the Device
 *  controller.
 */
/** Type of doepint6 register
 *  This register contains the interrupts for the OUT Endpoint 6 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint6_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint6_xfercompl:1;
        /** doepint6_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint6_epdisbld:1;
        /** doepint6_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint6_ahberr:1;
        /** doepint6_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint6_setup:1;
        /** doepint6_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint6_outtknepdis:1;
        /** doepint6_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint6_stsphsercvd:1;
        /** doepint6_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint6_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint6_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint6_outpkterr:1;
        /** doepint6_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint6_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint6_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint6_pktdrpsts:1;
        /** doepint6_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint6_bbleerr:1;
        /** doepint6_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint6_nakintrpt:1;
        /** doepint6_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint6_nyetintrpt:1;
        /** doepint6_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint6_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint6_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 6 of the
 *  Device controller.
 */
/** Type of doeptsiz6 register
 *  This register contains the Transfer Size for the OUT Endpoint 6 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz6_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz6_xfersize:19;
        /** doeptsiz6_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz6_pktcnt:10;
        /** doeptsiz6_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz6_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz6_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 6 of the Device
 *  controller.
 */
/** Type of doepdma6 register
 *  This register contains the DMA Address for the OUT Endpoint 6 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma6_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma6_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma6_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 6 of the
 *  Device controller.
 */
/** Type of doepdmab6 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 6 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab6_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab6_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab6_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 7 of
 *  the Device controller.
 */
/** Type of doepctl7 register
 *  This register is used to control the characteristics of OUT Endpoint 7 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl7_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl7_mps:11;
        uint32_t reserved_11:4;
        /** doepctl7_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl7_usbactep:1;
        /** doepctl7_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl7_dpid:1;
        /** doepctl7_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl7_naksts:1;
        /** doepctl7_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl7_eptype:2;
        /** doepctl7_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl7_snp:1;
        /** doepctl7_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl7_stall:1;
        uint32_t reserved_22:4;
        /** doepctl7_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl7_cnak:1;
        /** doepctl7_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl7_snak:1;
        /** doepctl7_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl7_setd0pid:1;
        /** doepctl7_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl7_setd1pid:1;
        /** doepctl7_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl7_epdis:1;
        /** doepctl7_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl7_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl7_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 7 of the Device
 *  controller.
 */
/** Type of doepint7 register
 *  This register contains the interrupts for the OUT Endpoint 7 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint7_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint7_xfercompl:1;
        /** doepint7_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint7_epdisbld:1;
        /** doepint7_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint7_ahberr:1;
        /** doepint7_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint7_setup:1;
        /** doepint7_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint7_outtknepdis:1;
        /** doepint7_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint7_stsphsercvd:1;
        /** doepint7_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint7_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint7_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint7_outpkterr:1;
        /** doepint7_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint7_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint7_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint7_pktdrpsts:1;
        /** doepint7_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint7_bbleerr:1;
        /** doepint7_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint7_nakintrpt:1;
        /** doepint7_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint7_nyetintrpt:1;
        /** doepint7_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint7_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint7_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 7 of the
 *  Device controller.
 */
/** Type of doeptsiz7 register
 *  This register contains the Transfer Size for the OUT Endpoint 7 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz7_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz7_xfersize:19;
        /** doeptsiz7_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz7_pktcnt:10;
        /** doeptsiz7_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz7_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz7_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 7 of the Device
 *  controller.
 */
/** Type of doepdma7 register
 *  This register contains the DMA Address for the OUT Endpoint 7 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma7_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma7_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma7_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 7 of the
 *  Device controller.
 */
/** Type of doepdmab7 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 7 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab7_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab7_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab7_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 8 of
 *  the Device controller.
 */
/** Type of doepctl8 register
 *  This register is used to control the characteristics of OUT Endpoint 8 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl8_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl8_mps:11;
        uint32_t reserved_11:4;
        /** doepctl8_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl8_usbactep:1;
        /** doepctl8_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl8_dpid:1;
        /** doepctl8_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl8_naksts:1;
        /** doepctl8_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl8_eptype:2;
        /** doepctl8_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl8_snp:1;
        /** doepctl8_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl8_stall:1;
        uint32_t reserved_22:4;
        /** doepctl8_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl8_cnak:1;
        /** doepctl8_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl8_snak:1;
        /** doepctl8_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl8_setd0pid:1;
        /** doepctl8_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl8_setd1pid:1;
        /** doepctl8_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl8_epdis:1;
        /** doepctl8_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl8_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl8_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 8 of the Device
 *  controller.
 */
/** Type of doepint8 register
 *  This register contains the interrupts for the OUT Endpoint 8 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint8_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint8_xfercompl:1;
        /** doepint8_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint8_epdisbld:1;
        /** doepint8_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint8_ahberr:1;
        /** doepint8_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint8_setup:1;
        /** doepint8_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint8_outtknepdis:1;
        /** doepint8_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint8_stsphsercvd:1;
        /** doepint8_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint8_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint8_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint8_outpkterr:1;
        /** doepint8_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint8_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint8_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint8_pktdrpsts:1;
        /** doepint8_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint8_bbleerr:1;
        /** doepint8_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint8_nakintrpt:1;
        /** doepint8_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint8_nyetintrpt:1;
        /** doepint8_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint8_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint8_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 8 of the
 *  Device controller.
 */
/** Type of doeptsiz8 register
 *  This register contains the Transfer Size for the OUT Endpoint 8 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz8_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz8_xfersize:19;
        /** doeptsiz8_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz8_pktcnt:10;
        /** doeptsiz8_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz8_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz8_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 8 of the Device
 *  controller.
 */
/** Type of doepdma8 register
 *  This register contains the DMA Address for the OUT Endpoint 8 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma8_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma8_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma8_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 8 of the
 *  Device controller.
 */
/** Type of doepdmab8 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 8 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab8_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab8_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab8_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 9 of
 *  the Device controller.
 */
/** Type of doepctl9 register
 *  This register is used to control the characteristics of OUT Endpoint 9 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl9_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl9_mps:11;
        uint32_t reserved_11:4;
        /** doepctl9_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl9_usbactep:1;
        /** doepctl9_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl9_dpid:1;
        /** doepctl9_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl9_naksts:1;
        /** doepctl9_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl9_eptype:2;
        /** doepctl9_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl9_snp:1;
        /** doepctl9_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl9_stall:1;
        uint32_t reserved_22:4;
        /** doepctl9_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl9_cnak:1;
        /** doepctl9_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl9_snak:1;
        /** doepctl9_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl9_setd0pid:1;
        /** doepctl9_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl9_setd1pid:1;
        /** doepctl9_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl9_epdis:1;
        /** doepctl9_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl9_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl9_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 9 of the Device
 *  controller.
 */
/** Type of doepint9 register
 *  This register contains the interrupts for the OUT Endpoint 9 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint9_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint9_xfercompl:1;
        /** doepint9_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint9_epdisbld:1;
        /** doepint9_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint9_ahberr:1;
        /** doepint9_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint9_setup:1;
        /** doepint9_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint9_outtknepdis:1;
        /** doepint9_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint9_stsphsercvd:1;
        /** doepint9_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint9_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint9_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint9_outpkterr:1;
        /** doepint9_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint9_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint9_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint9_pktdrpsts:1;
        /** doepint9_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint9_bbleerr:1;
        /** doepint9_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint9_nakintrpt:1;
        /** doepint9_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint9_nyetintrpt:1;
        /** doepint9_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint9_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint9_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 9 of the
 *  Device controller.
 */
/** Type of doeptsiz9 register
 *  This register contains the Transfer Size for the OUT Endpoint 9 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz9_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz9_xfersize:19;
        /** doeptsiz9_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz9_pktcnt:10;
        /** doeptsiz9_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz9_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz9_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 9 of the Device
 *  controller.
 */
/** Type of doepdma9 register
 *  This register contains the DMA Address for the OUT Endpoint 9 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma9_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma9_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma9_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 9 of the
 *  Device controller.
 */
/** Type of doepdmab9 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 9 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab9_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab9_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab9_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 10 of
 *  the Device controller.
 */
/** Type of doepctl10 register
 *  This register is used to control the characteristics of OUT Endpoint 10 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl10_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl10_mps:11;
        uint32_t reserved_11:4;
        /** doepctl10_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl10_usbactep:1;
        /** doepctl10_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl10_dpid:1;
        /** doepctl10_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl10_naksts:1;
        /** doepctl10_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl10_eptype:2;
        /** doepctl10_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl10_snp:1;
        /** doepctl10_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl10_stall:1;
        uint32_t reserved_22:4;
        /** doepctl10_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl10_cnak:1;
        /** doepctl10_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl10_snak:1;
        /** doepctl10_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl10_setd0pid:1;
        /** doepctl10_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl10_setd1pid:1;
        /** doepctl10_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl10_epdis:1;
        /** doepctl10_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl10_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl10_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 10 of the Device
 *  controller.
 */
/** Type of doepint10 register
 *  This register contains the interrupts for the OUT Endpoint 10 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint10_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint10_xfercompl:1;
        /** doepint10_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint10_epdisbld:1;
        /** doepint10_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint10_ahberr:1;
        /** doepint10_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint10_setup:1;
        /** doepint10_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint10_outtknepdis:1;
        /** doepint10_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint10_stsphsercvd:1;
        /** doepint10_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint10_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint10_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint10_outpkterr:1;
        /** doepint10_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint10_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint10_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint10_pktdrpsts:1;
        /** doepint10_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint10_bbleerr:1;
        /** doepint10_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint10_nakintrpt:1;
        /** doepint10_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint10_nyetintrpt:1;
        /** doepint10_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint10_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint10_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 10 of the
 *  Device controller.
 */
/** Type of doeptsiz10 register
 *  This register contains the Transfer Size for the OUT Endpoint 10 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz10_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz10_xfersize:19;
        /** doeptsiz10_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz10_pktcnt:10;
        /** doeptsiz10_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz10_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz10_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 10 of the Device
 *  controller.
 */
/** Type of doepdma10 register
 *  This register contains the DMA Address for the OUT Endpoint 10 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma10_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma10_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma10_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 10 of the
 *  Device controller.
 */
/** Type of doepdmab10 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 10 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab10_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab10_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab10_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 11 of
 *  the Device controller.
 */
/** Type of doepctl11 register
 *  This register is used to control the characteristics of OUT Endpoint 11 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl11_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl11_mps:11;
        uint32_t reserved_11:4;
        /** doepctl11_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl11_usbactep:1;
        /** doepctl11_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl11_dpid:1;
        /** doepctl11_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl11_naksts:1;
        /** doepctl11_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl11_eptype:2;
        /** doepctl11_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl11_snp:1;
        /** doepctl11_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl11_stall:1;
        uint32_t reserved_22:4;
        /** doepctl11_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl11_cnak:1;
        /** doepctl11_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl11_snak:1;
        /** doepctl11_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl11_setd0pid:1;
        /** doepctl11_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl11_setd1pid:1;
        /** doepctl11_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl11_epdis:1;
        /** doepctl11_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl11_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl11_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 11 of the Device
 *  controller.
 */
/** Type of doepint11 register
 *  This register contains the interrupts for the OUT Endpoint 11 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint11_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint11_xfercompl:1;
        /** doepint11_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint11_epdisbld:1;
        /** doepint11_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint11_ahberr:1;
        /** doepint11_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint11_setup:1;
        /** doepint11_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint11_outtknepdis:1;
        /** doepint11_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint11_stsphsercvd:1;
        /** doepint11_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint11_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint11_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint11_outpkterr:1;
        /** doepint11_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint11_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint11_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint11_pktdrpsts:1;
        /** doepint11_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint11_bbleerr:1;
        /** doepint11_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint11_nakintrpt:1;
        /** doepint11_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint11_nyetintrpt:1;
        /** doepint11_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint11_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint11_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 11 of the
 *  Device controller.
 */
/** Type of doeptsiz11 register
 *  This register contains the Transfer Size for the OUT Endpoint 11 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz11_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz11_xfersize:19;
        /** doeptsiz11_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz11_pktcnt:10;
        /** doeptsiz11_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz11_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz11_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 11 of the Device
 *  controller.
 */
/** Type of doepdma11 register
 *  This register contains the DMA Address for the OUT Endpoint 11 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma11_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma11_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma11_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 11 of the
 *  Device controller.
 */
/** Type of doepdmab11 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 11 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab11_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab11_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab11_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 12 of
 *  the Device controller.
 */
/** Type of doepctl12 register
 *  This register is used to control the characteristics of OUT Endpoint 12 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl12_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl12_mps:11;
        uint32_t reserved_11:4;
        /** doepctl12_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl12_usbactep:1;
        /** doepctl12_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl12_dpid:1;
        /** doepctl12_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl12_naksts:1;
        /** doepctl12_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl12_eptype:2;
        /** doepctl12_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl12_snp:1;
        /** doepctl12_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl12_stall:1;
        uint32_t reserved_22:4;
        /** doepctl12_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl12_cnak:1;
        /** doepctl12_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl12_snak:1;
        /** doepctl12_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl12_setd0pid:1;
        /** doepctl12_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl12_setd1pid:1;
        /** doepctl12_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl12_epdis:1;
        /** doepctl12_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl12_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl12_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 12 of the Device
 *  controller.
 */
/** Type of doepint12 register
 *  This register contains the interrupts for the OUT Endpoint 12 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint12_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint12_xfercompl:1;
        /** doepint12_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint12_epdisbld:1;
        /** doepint12_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint12_ahberr:1;
        /** doepint12_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint12_setup:1;
        /** doepint12_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint12_outtknepdis:1;
        /** doepint12_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint12_stsphsercvd:1;
        /** doepint12_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint12_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint12_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint12_outpkterr:1;
        /** doepint12_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint12_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint12_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint12_pktdrpsts:1;
        /** doepint12_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint12_bbleerr:1;
        /** doepint12_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint12_nakintrpt:1;
        /** doepint12_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint12_nyetintrpt:1;
        /** doepint12_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint12_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint12_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 12 of the
 *  Device controller.
 */
/** Type of doeptsiz12 register
 *  This register contains the Transfer Size for the OUT Endpoint 12 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz12_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz12_xfersize:19;
        /** doeptsiz12_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz12_pktcnt:10;
        /** doeptsiz12_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz12_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz12_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 12 of the Device
 *  controller.
 */
/** Type of doepdma12 register
 *  This register contains the DMA Address for the OUT Endpoint 12 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma12_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma12_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma12_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 12 of the
 *  Device controller.
 */
/** Type of doepdmab12 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 12 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab12_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab12_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab12_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 13 of
 *  the Device controller.
 */
/** Type of doepctl13 register
 *  This register is used to control the characteristics of OUT Endpoint 13 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl13_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl13_mps:11;
        uint32_t reserved_11:4;
        /** doepctl13_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl13_usbactep:1;
        /** doepctl13_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl13_dpid:1;
        /** doepctl13_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl13_naksts:1;
        /** doepctl13_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl13_eptype:2;
        /** doepctl13_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl13_snp:1;
        /** doepctl13_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl13_stall:1;
        uint32_t reserved_22:4;
        /** doepctl13_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl13_cnak:1;
        /** doepctl13_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl13_snak:1;
        /** doepctl13_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl13_setd0pid:1;
        /** doepctl13_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl13_setd1pid:1;
        /** doepctl13_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl13_epdis:1;
        /** doepctl13_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl13_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl13_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 13 of the Device
 *  controller.
 */
/** Type of doepint13 register
 *  This register contains the interrupts for the OUT Endpoint 13 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint13_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint13_xfercompl:1;
        /** doepint13_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint13_epdisbld:1;
        /** doepint13_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint13_ahberr:1;
        /** doepint13_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint13_setup:1;
        /** doepint13_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint13_outtknepdis:1;
        /** doepint13_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint13_stsphsercvd:1;
        /** doepint13_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint13_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint13_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint13_outpkterr:1;
        /** doepint13_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint13_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint13_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint13_pktdrpsts:1;
        /** doepint13_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint13_bbleerr:1;
        /** doepint13_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint13_nakintrpt:1;
        /** doepint13_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint13_nyetintrpt:1;
        /** doepint13_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint13_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint13_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 13 of the
 *  Device controller.
 */
/** Type of doeptsiz13 register
 *  This register contains the Transfer Size for the OUT Endpoint 13 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz13_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz13_xfersize:19;
        /** doeptsiz13_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz13_pktcnt:10;
        /** doeptsiz13_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz13_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz13_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 13 of the Device
 *  controller.
 */
/** Type of doepdma13 register
 *  This register contains the DMA Address for the OUT Endpoint 13 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma13_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma13_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma13_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 13 of the
 *  Device controller.
 */
/** Type of doepdmab13 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 13 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab13_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab13_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab13_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 14 of
 *  the Device controller.
 */
/** Type of doepctl14 register
 *  This register is used to control the characteristics of OUT Endpoint 14 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl14_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl14_mps:11;
        uint32_t reserved_11:4;
        /** doepctl14_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl14_usbactep:1;
        /** doepctl14_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl14_dpid:1;
        /** doepctl14_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl14_naksts:1;
        /** doepctl14_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl14_eptype:2;
        /** doepctl14_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl14_snp:1;
        /** doepctl14_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl14_stall:1;
        uint32_t reserved_22:4;
        /** doepctl14_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl14_cnak:1;
        /** doepctl14_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl14_snak:1;
        /** doepctl14_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl14_setd0pid:1;
        /** doepctl14_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl14_setd1pid:1;
        /** doepctl14_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl14_epdis:1;
        /** doepctl14_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl14_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl14_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 14 of the Device
 *  controller.
 */
/** Type of doepint14 register
 *  This register contains the interrupts for the OUT Endpoint 14 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint14_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint14_xfercompl:1;
        /** doepint14_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint14_epdisbld:1;
        /** doepint14_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint14_ahberr:1;
        /** doepint14_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint14_setup:1;
        /** doepint14_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint14_outtknepdis:1;
        /** doepint14_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint14_stsphsercvd:1;
        /** doepint14_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint14_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint14_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint14_outpkterr:1;
        /** doepint14_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint14_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint14_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint14_pktdrpsts:1;
        /** doepint14_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint14_bbleerr:1;
        /** doepint14_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint14_nakintrpt:1;
        /** doepint14_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint14_nyetintrpt:1;
        /** doepint14_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint14_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint14_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 14 of the
 *  Device controller.
 */
/** Type of doeptsiz14 register
 *  This register contains the Transfer Size for the OUT Endpoint 14 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz14_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz14_xfersize:19;
        /** doeptsiz14_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz14_pktcnt:10;
        /** doeptsiz14_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz14_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz14_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 14 of the Device
 *  controller.
 */
/** Type of doepdma14 register
 *  This register contains the DMA Address for the OUT Endpoint 14 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma14_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma14_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma14_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 14 of the
 *  Device controller.
 */
/** Type of doepdmab14 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 14 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab14_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab14_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab14_reg_t;


/** Group: This register is used to control the characteristics of OUT Endpoint 15 of
 *  the Device controller.
 */
/** Type of doepctl15 register
 *  This register is used to control the characteristics of OUT Endpoint 15 of the
 *  Device controller.
 */
typedef union {
    struct {
        /** doepctl15_mps : R/W; bitpos: [10:0]; default: 0;
         *  Maximum Packet Size (MPS)
         *
         *  The application must program this field with the maximum packet size for the current
         *  logical endpoint. This value is in bytes.
         */
        uint32_t doepctl15_mps:11;
        uint32_t reserved_11:4;
        /** doepctl15_usbactep : R/W; bitpos: [15]; default: 0;
         *  USB Active Endpoint (USBActEP)
         *
         *  Indicates whether this endpoint is active in the current configuration and
         *  interface. The
         *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
         *  reset. After
         *  receiving the SetConfiguration and SetInterface commands, the application must
         *  program endpoint registers accordingly and set this bit.
         */
        uint32_t doepctl15_usbactep:1;
        /** doepctl15_dpid : RO; bitpos: [16]; default: 0;
         *  Endpoint Data PID (DPID)
         *
         *  Applies to interrupt/bulk IN and OUT endpoints only.
         *
         *  Contains the PID of the packet to be received or transmitted on this endpoint. The
         *  application must program the PID of the first packet to be received or transmitted
         *  on
         *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
         *  and
         *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
         *  - 1'b0: DATA0
         *  - 1'b1: DATA1
         *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *
         *  Reset: 1'b0
         *
         *  Even/Odd (Micro)Frame (EO_FrNum)
         *
         *  In non-Scatter/Gather DMA mode:
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Indicates the (micro)frame number in which the core transmits/receives
         *  isochronous data for this endpoint. The application must program the even/odd
         *  (micro)frame number in which it intends to transmit/receive isochronous data for
         *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
         *  -- 1'b0: Even (micro)frame
         *  -- 1'b1: Odd (micro)frame
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is provided in the transmit descriptor structure. The frame
         *  in which data is received is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl15_dpid:1;
        /** doepctl15_naksts : RO; bitpos: [17]; default: 0;
         *  NAK Status (NAKSts)
         *
         *  Indicates the following:
         *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
         *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
         *  When either the application or the core sets this bit:
         *  - The core stops receiving any data on an OUT endpoint, even if there is space in
         *  the RxFIFO to accommodate the incoming packet.
         *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
         *  endpoint, even if there data is available in the TxFIFO.
         *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
         *  if there data is available in the TxFIFO.
         *  Irrespective of this bit's setting, the core always responds to SETUP data packets
         *  with an ACK handshake.
         */
        uint32_t doepctl15_naksts:1;
        /** doepctl15_eptype : R/W; bitpos: [19:18]; default: 0;
         *  Endpoint Type (EPType)
         *
         *  This is the transfer type supported by this logical endpoint.
         *  - 2'b00: Control
         *  - 2'b01: Isochronous
         *  - 2'b10: Bulk
         *  - 2'b11: Interrupt
         */
        uint32_t doepctl15_eptype:2;
        /** doepctl15_snp : R/W; bitpos: [20]; default: 0;
         *  RESERVED
         */
        uint32_t doepctl15_snp:1;
        /** doepctl15_stall : R/W; bitpos: [21]; default: 0;
         *  STALL Handshake (Stall)
         *
         *  Applies to non-control, non-isochronous IN and OUT endpoints only.
         *
         *  The application sets this bit to stall all tokens from the USB host to this
         *  endpoint. If a
         *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
         *  the
         *  STALL bit takes priority. Only the application can clear this bit, never the core.
         *
         *  Applies to control endpoints only.
         *
         *  The application can only set this bit, and the core clears it, when a SETUP token is
         *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
         *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
         *  bit's
         *  setting, the core always responds to SETUP data packets with an ACK handshake.
         */
        uint32_t doepctl15_stall:1;
        uint32_t reserved_22:4;
        /** doepctl15_cnak : R/W; bitpos: [26]; default: 0;
         *
         *  Clear NAK (CNAK)
         *  A write to this bit clears the NAK bit for the endpoint.
         */
        uint32_t doepctl15_cnak:1;
        /** doepctl15_snak : R/W; bitpos: [27]; default: 0;
         *  Set NAK (SNAK)
         *
         *  A write to this bit sets the NAK bit for the endpoint.
         *
         *  Using this bit, the application can control the transmission of NAK
         *  handshakes on an endpoint. The core can also set this bit for an
         *  endpoint after a SETUP packet is received on that endpoint.
         */
        uint32_t doepctl15_snak:1;
        /** doepctl15_setd0pid : R/W; bitpos: [28]; default: 0;
         *  Set DATA0 PID (SetD0PID)
         *  - Applies to interrupt/bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA0.
         *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
         *  (micro)frame.
         *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
         *  in which to send data is in the transmit descriptor structure. The frame in which
         *  to receive data is updated in receive descriptor structure.
         *  Reset: 1'b0
         */
        uint32_t doepctl15_setd0pid:1;
        /** doepctl15_setd1pid : R/W; bitpos: [29]; default: 0;
         *  Set DATA1 PID (SetD1PID)
         *  - Applies to interrupt and bulk IN and OUT endpoints only.
         *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
         *  DATA1.
         *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
         *  DMA mode.
         *  Reset: 1'b0
         *
         *  Set Odd (micro)frame (SetOddFr)
         *  - Applies to isochronous IN and OUT endpoints only.
         *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
         *  (micro)frame.
         *  Reset: 1'b0
         */
        uint32_t doepctl15_setd1pid:1;
        /** doepctl15_epdis : R/W; bitpos: [30]; default: 0;
         *  Endpoint Disable (EPDis)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  The application sets this bit to stop transmitting/receiving data on an endpoint,
         *  even
         *  before the transfer for that endpoint is complete. The application must wait for the
         *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
         *  clears
         *  this bit before setting the Endpoint Disabled interrupt. The application must set
         *  this bit
         *  only if Endpoint Enable is already set for this endpoint.
         */
        uint32_t doepctl15_epdis:1;
        /** doepctl15_epena : R/W; bitpos: [31]; default: 0;
         *  Endpoint Enable (EPEna)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  When Scatter/Gather DMA mode is enabled,
         *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
         *  with data ready to transmit is setup.
         *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
         *  receive data is setup.
         *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
         *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
         *  endpoint.
         *  - For OUT endpoints, this bit indicates that the application has allocated the
         *  memory to start receiving data from the USB.
         *  The core clears this bit before setting any of the following interrupts on this
         *  endpoint:
         *  - SETUP Phase Done
         *  - Endpoint Disabled
         *  - Transfer Completed
         *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
         *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
         *  Completed interrupt of the SETUP packet.
         */
        uint32_t doepctl15_epena:1;
    };
    uint32_t val;
} usb_otghs_doepctl15_reg_t;


/** Group: This register contains the interrupts for the OUT Endpoint 15 of the Device
 *  controller.
 */
/** Type of doepint15 register
 *  This register contains the interrupts for the OUT Endpoint 15 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepint15_xfercompl : R/W; bitpos: [0]; default: 0;
         *  Transfer Completed Interrupt (XferCompl)
         *
         *  Applies to IN and OUT endpoints.
         *  - When Scatter/Gather DMA mode is enabled
         *  -- For IN endpoint this field indicates that the requested data from the descriptor
         *  is moved from external system memory to internal FIFO.
         *  -- For OUT endpoint this field indicates that the requested data from the internal
         *  FIFO is moved to external system memory. This interrupt is generated only when the
         *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
         *  descriptor is Set.
         *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
         *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
         */
        uint32_t doepint15_xfercompl:1;
        /** doepint15_epdisbld : R/W; bitpos: [1]; default: 0;
         *  Endpoint Disabled Interrupt (EPDisbld)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This bit indicates that the endpoint is disabled per the application's request.
         */
        uint32_t doepint15_epdisbld:1;
        /** doepint15_ahberr : R/W; bitpos: [2]; default: 0;
         *  AHB Error (AHBErr)
         *
         *  Applies to IN and OUT endpoints.
         *
         *  This is generated only in Internal DMA mode when there is an AHB error during an
         *  AHB read/write. The application can read the corresponding endpoint DMA address
         *  register to get the error address. For details, see AHB Error Handling section in
         *  the Programming Guide.
         */
        uint32_t doepint15_ahberr:1;
        /** doepint15_setup : R/W; bitpos: [3]; default: 0;
         *  SETUP Phase Done (SetUp)
         *
         *  Applies to control OUT endpoints only.
         *
         *  Indicates that the SETUP phase for the control endpoint is
         *  complete and no more back-to-back SETUP packets were
         *  received for the current control transfer. On this interrupt, the
         *  application can decode the received SETUP data packet.
         */
        uint32_t doepint15_setup:1;
        /** doepint15_outtknepdis : R/W; bitpos: [4]; default: 0;
         *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
         *
         *  Applies only to control OUT endpoints.
         *
         *  Indicates that an OUT token was received when the endpoint was not yet enabled.
         *  This interrupt is asserted on the endpoint for which the OUT token was received.
         */
        uint32_t doepint15_outtknepdis:1;
        /** doepint15_stsphsercvd : R/W; bitpos: [5]; default: 0;
         *  Status Phase Received for Control Write (StsPhseRcvd)
         *
         *  This interrupt is valid only for Control OUT endpoints.
         *
         *  This interrupt is generated only after the core has transferred all
         *  the data that the host has sent during the data phase of a control
         *  write transfer, to the system memory buffer.
         *
         *  The interrupt indicates to the application that the host has
         *  switched from data phase to the status phase of a Control Write
         *  transfer. The application can use this interrupt to ACK or STALL
         *  the Status phase, after it has decoded the data phase.
         */
        uint32_t doepint15_stsphsercvd:1;
        /** doepint15_back2backsetup : R/W; bitpos: [6]; default: 0;
         *  Back-to-Back SETUP Packets Received (Back2BackSETup)
         *
         *  Applies to Control OUT endpoints only.
         *
         *  This bit indicates that the core has received more than three
         *  back-to-back SETUP packets for this particular endpoint. For
         *  information about handling this interrupt,
         */
        uint32_t doepint15_back2backsetup:1;
        uint32_t reserved_7:1;
        /** doepint15_outpkterr : R/W; bitpos: [8]; default: 0;
         *  OUT Packet Error (OutPktErr)
         *
         *  Applies to OUT endpoints Only
         *
         *  This interrupt is valid only when thresholding is enabled. This interrupt is
         *  asserted when the
         *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
         */
        uint32_t doepint15_outpkterr:1;
        /** doepint15_bnaintr : R/W; bitpos: [9]; default: 0;
         *  BNA (Buffer Not Available) Interrupt (BNAIntr)
         *
         *  This bit is valid only when Scatter/Gather DMA mode is enabled.
         *
         *  The core generates this interrupt when the descriptor accessed
         *  is not ready for the Core to process, such as Host busy or DMA
         *  done
         */
        uint32_t doepint15_bnaintr:1;
        uint32_t reserved_10:1;
        /** doepint15_pktdrpsts : R/W; bitpos: [11]; default: 0;
         *  Packet Drop Status (PktDrpSts)
         *
         *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
         *  bit does not have an associated mask bit and does not generate an interrupt.
         *
         *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
         *  interrupt feature is selected.
         */
        uint32_t doepint15_pktdrpsts:1;
        /** doepint15_bbleerr : R/W; bitpos: [12]; default: 0;
         *  NAK Interrupt (BbleErr)
         *
         *  The core generates this interrupt when babble is received for the endpoint.
         */
        uint32_t doepint15_bbleerr:1;
        /** doepint15_nakintrpt : R/W; bitpos: [13]; default: 0;
         *  NAK Interrupt (NAKInterrupt)
         *
         *  The core generates this interrupt when a NAK is transmitted or received by the
         *  device.
         *
         *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
         *  packet is transmitted due to un-availability of data in the TXFifo.
         */
        uint32_t doepint15_nakintrpt:1;
        /** doepint15_nyetintrpt : R/W; bitpos: [14]; default: 0;
         *  NYET Interrupt (NYETIntrpt)
         *
         *  The core generates this interrupt when a NYET response is transmitted for a non
         *  isochronous OUT endpoint.
         */
        uint32_t doepint15_nyetintrpt:1;
        /** doepint15_stuppktrcvd : R/W; bitpos: [15]; default: 0;
         *  Setup Packet Received
         *
         *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
         *
         *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
         *  setup data. There is only one Setup packet per buffer. On receiving a
         *  Setup packet, the controller closes the buffer and disables the
         *  corresponding endpoint. The application has to re-enable the endpoint to
         *  receive any OUT data for the Control Transfer and reprogram the buffer
         *  start address.
         *
         *  Note: Because of the above behavior, the controller can receive any
         *  number of back to back setup packets and one buffer for every setup
         *  packet is used.
         *  - 1'b0: No Setup packet received
         *  - 1'b1: Setup packet received
         *  Reset: 1'b0
         */
        uint32_t doepint15_stuppktrcvd:1;
        uint32_t reserved_16:16;
    };
    uint32_t val;
} usb_otghs_doepint15_reg_t;


/** Group: This register contains the Transfer Size for the OUT Endpoint 15 of the
 *  Device controller.
 */
/** Type of doeptsiz15 register
 *  This register contains the Transfer Size for the OUT Endpoint 15 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doeptsiz15_xfersize : R/W; bitpos: [18:0]; default: 0;
         *  Transfer Size (XferSize)
         *
         *  Indicates the transfer size in bytes for the endpoint. The core
         *  interrupts the application only after it has exhausted the transfer
         *  size amount of data. The transfer size can be Set to the
         *  maximum packet size of the endpoint, to be interrupted at the
         *  end of each packet.
         *
         *  The core decrements this field every time a packet is read from
         *  the RxFIFO and written to the external memory.
         */
        uint32_t doeptsiz15_xfersize:19;
        /** doeptsiz15_pktcnt : R/W; bitpos: [28:19]; default: 0;
         *  Packet Count (PktCnt)
         *  This field is decremented to zero after a packet is written into the RxFIFO.
         */
        uint32_t doeptsiz15_pktcnt:10;
        /** doeptsiz15_rxdpid : RO; bitpos: [30:29]; default: 0;
         *  RxDPID
         *
         *  Applies to isochronous OUT endpoints only.
         *
         *  This is the data PID received in the last packet for this endpoint.
         *  - 2'b00: DATA0
         *  - 2'b01: DATA2
         *  - 2'b10: DATA1
         *  - 2'b11: MDATA
         *  SETUP Packet Count (SUPCnt)
         *
         *  Applies to control OUT Endpoints only.
         *
         *  This field specifies the number of back-to-back SETUP data
         *  packets the endpoint can receive.
         *  - 2'b01: 1 packet
         *  - 2'b10: 2 packets
         *  - 2'b11: 3 packets
         */
        uint32_t doeptsiz15_rxdpid:2;
        uint32_t reserved_31:1;
    };
    uint32_t val;
} usb_otghs_doeptsiz15_reg_t;


/** Group: This register contains the DMA Address for the OUT Endpoint 15 of the Device
 *  controller.
 */
/** Type of doepdma15 register
 *  This register contains the DMA Address for the OUT Endpoint 15 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdma15_dmaaddr : R/W; bitpos: [31:0]; default: 0;
         *  Holds the start address of the external memory for storing or fetching endpoint
         *  data.
         *
         *  Note: For control endpoints, this field stores control OUT data packets as well as
         *  SETUP transaction data packets. When more than three SETUP packets are
         *  received back-to-back, the SETUP data packet in the memory is overwritten.
         *
         *  This register is incremented on every AHB transaction. The application can give
         *  only a DWORD-aligned address.
         *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
         *  address value in this field.
         *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
         *  for the descriptor list.
         */
        uint32_t doepdma15_dmaaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdma15_reg_t;


/** Group: This register contains the DMA Buffer Address for the OUT Endpoint 15 of the
 *  Device controller.
 */
/** Type of doepdmab15 register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 15 of the Device
 *  controller.
 */
typedef union {
    struct {
        /** doepdmab15_dmabufferaddr : RO; bitpos: [31:0]; default: 0;
         *  Holds the current buffer address.This register is updated as and when the data
         *  transfer for the corresponding end point is in progress.
         *
         *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
         *  reserved.
         */
        uint32_t doepdmab15_dmabufferaddr:32;
    };
    uint32_t val;
} usb_otghs_doepdmab15_reg_t;


/** Group: This register is used to control the Power and Clock Gating characteristics
 *  of the controller.
 */
/** Type of pcgcctl register
 *  This register is used to control the Power and Clock Gating characteristics of the
 *  controller.
 */
typedef union {
    struct {
        /** pcgcctl_stoppclk : R/W; bitpos: [0]; default: 0;
         *  Stop Pclk (StopPclk)
         *  - The application sets this bit to stop the PHY clock (phy_clk) when the USB is
         *  suspended, the session is not valid, or the device is disconnected.
         *  - The application clears this bit when the USB is resumed or a new session starts.
         */
        uint32_t pcgcctl_stoppclk:1;
        /** pcgcctl_gatehclk : R/W; bitpos: [1]; default: 0;
         *  Gate Hclk (GateHclk)
         *  - The application sets this bit to gate hclk to modules other than the AHB Slave
         *  and Master and wakeup logic when the USB is suspended or the session is not valid.
         *  - The application clears this bit when the USB is resumed or a new session starts.
         */
        uint32_t pcgcctl_gatehclk:1;
        /** pcgcctl_pwrclmp : R/W; bitpos: [2]; default: 0;
         *  Power Clamp (PwrClmp)
         *
         *  This bit is valid only in Partial Power-Down mode
         *  - The application sets this bit before the power is turned off to clamp the signals
         *  between the power-on modules and the power-off modules.
         *  - The application clears the bit to disable the clamping before the power is turned
         *  on.
         */
        uint32_t pcgcctl_pwrclmp:1;
        /** pcgcctl_rstpdwnmodule : R/W; bitpos: [3]; default: 0;
         *  Reset Power-Down Modules (RstPdwnModule)
         *
         *  This bit is valid only in Partial Power-Down mode.
         *  - The application sets this bit when the power is turned off.
         *  - The application clears this bit after the power is turned on and the PHY clock is
         *  up.
         *
         *  Note: The R/W of all core registers are possible only when this bit is set to 1b0.
         */
        uint32_t pcgcctl_rstpdwnmodule:1;
        uint32_t reserved_4:2;
        /** pcgcctl_physleep : RO; bitpos: [6]; default: 0;
         *  PHY In Sleep
         *
         *  Indicates that the PHY is in Sleep State.
         */
        uint32_t pcgcctl_physleep:1;
        /** pcgcctl_l1suspended : RO; bitpos: [7]; default: 0;
         *  L1 Deep Sleep
         *
         *  Indicates that the PHY is in deep sleep when in L1 state.
         */
        uint32_t pcgcctl_l1suspended:1;
        /** pcgcctl_resetaftersusp : R/W; bitpos: [8]; default: 0;
         *  Reset after suspend
         *
         *  Applicable in Partial power-down mode
         *
         *  In partial power-down mode of operation, this bit needs to be set in host mode
         *  before
         *  clamp is removed if the host needs to issue reset after suspend. If this bit is not
         *  set,
         *  then the host issues resume after suspend.
         *
         *  This bit is not applicable in device mode and non-partial power-down mode.
         *  In Hibernation mode, this bit needs to be set at RESTORE_POINT before
         *  PCGCCTL.EssRegRestored is set. In this case, PCGCCTL.restore_mode needs to
         *  be set to wait_restore.
         */
        uint32_t pcgcctl_resetaftersusp:1;
        uint32_t reserved_9:23;
    };
    uint32_t val;
} usb_otghs_pcgcctl_reg_t;


/** Group: This register is used to disable STAR fixes added in the controller. The
 *  application can set the register fields to operate with the functionality before
 *  the fix was done.
 */
/** Type of gstarfxdis register
 *  This register is used to disable STAR fixes added in the controller. The
 *  application can set the register fields to operate with the functionality before
 *  the fix was done.
 */
typedef union {
    struct {
        /** gstarfxdis_host_ignores_rmtwkup_dis : R/W; bitpos: [0]; default: 0;
         *  Disable the STAR fix added for Device controller to go back to low power mode when
         *  Host ignores Remote wakeup
         *  The application programs Host_Ignores_RmtWkup_dis=1 to disable the device
         *  controller from going back to low power mode (SUSPENDED state) when the host
         *  ignores the remote wakeup signalling from the device and does not respond back with
         *  resume. This bit must be programmed during the initial configuration of the
         *  controller and must not be modified later.
         */
        uint32_t gstarfxdis_host_ignores_rmtwkup_dis:1;
        /** gstarfxdis_resume_frm_chk_bus_dis : R/W; bitpos: [1]; default: 0;
         *  Disable the STAR fix added for Device controller to detect lineK and move to
         *  RESUMING state after the 50us pull-up delay ends
         *  The application programs Resume_frm_CHK_BUS_dis=1 to disable the device controller
         *  from detecting line K and transitioning to RESUMING state in the scenario where
         *  Host resume starts immediately after the 50us pull-up delay timer expires. This bit
         *  must be programmed during the initial configuration of the controller and must not
         *  be modified later.
         */
        uint32_t gstarfxdis_resume_frm_chk_bus_dis:1;
        /** gstarfxdis_ignore_ctlout_data0_dis : R/W; bitpos: [2]; default: 0;
         *  Disable the STAR fix added for Device controller to reject DATA0 for the first
         *  Control OUT Data Phase and Control Status OUT Phase
         *  The application programs Ignore_CtlOUT_DATA0_dis=1 to disable the device controller
         *  from reporting transaction error when DATA0 PID is received from host for the first
         *  Control OUT Data Phase and Control Status OUT phase. This bit must be programmed
         *  during the initial configuration of the controller and must not be modified later.
         */
        uint32_t gstarfxdis_ignore_ctlout_data0_dis:1;
        /** gstarfxdis_ssplit_stallnyet_err_dis : R/W; bitpos: [3]; default: 0;
         *  Disable the STAR fix added for Host controller to flag error for SSPLIT STALL/NYET
         *  The application programs SSPLIT_STALLNYET_Err_dis=1 to disable the host controller
         *  from reporting transaction error for STALL/NYET received from device for SSPLIT
         *  transfer. This bit must be programmed during the initial configuration of the
         *  controller and must not be modified later.
         */
        uint32_t gstarfxdis_ssplit_stallnyet_err_dis:1;
        /** gstarfxdis_accept_isoc_split_data1_dis : R/W; bitpos: [4]; default: 0;
         *  Disable the STAR fix added for Host controller to accept DATA1 PID from device for
         *  ISOC Split transfers
         *  The application programs Accept_Isoc_split_DATA1_dis=1 to disable the host
         *  controller from accepting DATA1 PID from device for ISOC Split transfers. This bit
         *  must be programmed during the initial configuration of the controller and must not
         *  be modified later.
         */
        uint32_t gstarfxdis_accept_isoc_split_data1_dis:1;
        /** gstarfxdis_handlefaultycable_dis : R/W; bitpos: [5]; default: 0;
         *  Disable the STAR fix added for Host controller to handle Faulty cable scenarios
         *  The application programs HandleFaultyCable_dis=1 to disable the host controller
         *  from reporting Port Babble error when the linestate is stuck at 1 (in FS mode) or 2
         *  (in LS mode) due to a Faulty cable. This bit must be programmed during the initial
         *  configuration of the controller and must not be modified later.
         */
        uint32_t gstarfxdis_handlefaultycable_dis:1;
        /** gstarfxdis_ls_ipg_incr_dis : R/W; bitpos: [6]; default: 0;
         *  Disable the STAR fix added for Host controller LS mode IPG increment from 2 LS bit
         *  times to 3 LS bit times
         *  The application programs LS_IPG_incr_dis=1 to disable the IPG increment from 2 to 3
         *  LS bit times when host controller is operating in LS mode. This bit must be
         *  programmed during the initial configuration of the controller and must not be
         *  modified later.
         */
        uint32_t gstarfxdis_ls_ipg_incr_dis:1;
        /** gstarfxdis_fsdisc_idle_dis : R/W; bitpos: [7]; default: 0;
         *  Disable the STAR fix added for Device controller to transition to IDLE state during
         *  FS device disconnect
         *  The application programs FSDisc_Idle_dis=1 to disable the Transmit/Receive state
         *  machine from moving to IDLE state when FS device disconnect happens. This bit must
         *  be programmed during the initial configuration of the controller and must not be
         *  modified later.
         */
        uint32_t gstarfxdis_fsdisc_idle_dis:1;
        /** gstarfxdis_concurrent_rmtwkup_usbresume_dis : R/W; bitpos: [8]; default: 0;
         *  Disable the STAR fix added for Device controller to not start Remote Wakeup
         *  signalling when USB resume has already started
         *  The application programs Concurrent_Rmtwkup_USBResume_dis=1 to allow the controller
         *  to do remote wakeup signalling when USB resume has already started from the Host.
         *  This bit must be programmed during the initial configuration of the controller and
         *  must not be modified later.
         */
        uint32_t gstarfxdis_concurrent_rmtwkup_usbresume_dis:1;
        /** gstarfxdis_concurrent_rmtwkup_usbresume_hib_dis : R/W; bitpos: [9]; default: 1;
         *  Disable the STAR fix added for Device controller to not hang when Remote Wakeup
         *  signalling clashes with Host resume
         *  The application can program Concurrent_Rmtwkup_USBResume_Hib_dis=1 to disable the
         *  fix.
         *  Note: With Concurrent_Rmtwkup_USBResume_Hib_dis=0, the STAR fix is enabled and the
         *  device controller does not hang when the remote wakeup clashes with host resume.
         *  After the remote wakeup programming is done, if there was no utmi_txready received
         *  from the PHY while the utmi_txvalid was asserted, then the controller detects the
         *  line K as the host resume and directly moves to the RESUMING state, along with
         *  de-asserting utmi_txvalid. This prevents the controller from hanging but also
         *  violates the UTMI spec requirement which states that utmi_txvalid must be
         *  de-asserted only after getting utmi_txready. Hence, if any misbehaviour is observed
         *  with this fix enabled, it is recommended to keep the fix disabled.
         *  This bit must be programmed during the initial configuration of the controller and
         *  must not be modified later. The fix is applicable only for Hibernation case.
         */
        uint32_t gstarfxdis_concurrent_rmtwkup_usbresume_hib_dis:1;
        /** gstarfxdis_ls_ipg_chk_after_nak_stall_for_in_dis : R/W; bitpos: [10]; default: 0;
         *  Disable the STAR fix added for Host controller to wait for IPG duration to send
         *  next token after receiving NAK/STALL for previous IN token with FS/LS device
         *  The application programs LS_IPG_chk_after_NAK_STALL_for_IN_dis=1 to allow the
         *  controller to send the next token without waiting for the interpacket gap duration
         *  after receiving a NAK/STALL from device for the previous IN token. This bit must be
         *  programmed during the initial configuration of the controller and must not be
         *  modified later.
         */
        uint32_t gstarfxdis_ls_ipg_chk_after_nak_stall_for_in_dis:1;
        /** gstarfxdis_phy_iop_xcvrsel_txvld_corr_dis : R/W; bitpos: [11]; default: 0;
         *  Disable the STAR fix added for Host controller to increase the gap between
         *  utmi_xcvrselect switching and utmi_txvalid assertion in LS/FS mode
         *  The application programs PHY_IOp_xcvrsel_txvld_corr_dis=1 to allow the controller
         *  to assert utmi_txvalid 1 cycle after the utmi_xcvrselect switching. This can cause
         *  interop issues with SNPS PHY which requires at least 2 cycles of gap between the
         *  utmi_xcvrselect switch and the utmi_txvalid assertion. Hence it is recommended to
         *  program PHY_IOp_xcvrsel_txvld_corr_dis=0.
         *  This bit must be programmed during the initial configuration of the controller and
         *  must not be modified later.
         */
        uint32_t gstarfxdis_phy_iop_xcvrsel_txvld_corr_dis:1;
        /** gstarfxdis_ulpi_xcvrsel_switch_corr_dis : R/W; bitpos: [12]; default: 0;
         *  Disable the STAR fix added for Host controller to increase the preamble transceiver
         *  select switch delay to accommodate time taken for ULPI function control write
         *  The application programs ULPI_xcvrsel_switch_corr_dis=1 to allow the controller to
         *  do back to back transceiver select switching within the duration required for a
         *  single ULPI function control write (around 5-6 ulpi_clk cycles). This can cause a
         *  corrupted packet to go on the bus since the ULPI wrapper may not be able to do the
         *  second ULPI functional update (register write) correctly. Hence it is recommended
         *  to program ULPI_xcvrsel_switch_corr_dis=0.
         *  With ULPI_xcvrsel_switch_corr_dis=0, the delay between transceiver select switch
         *  and txvalid assertion has also been increased for FS/LS mode to resolve PHY interop
         *  issues.
         *  This bit must be programmed during the initial configuration of the controller and
         *  must not be modified later.
         */
        uint32_t gstarfxdis_ulpi_xcvrsel_switch_corr_dis:1;
        /** gstarfxdis_xacterr_data0_ctrl_sts_in_dis : R/W; bitpos: [13]; default: 1;
         *  Disable the STAR fix added for Host controller to report transaction error when
         *  DATA0 PID is received for CTRL STATUS IN transfer in DMA mode
         *  The application programs XactErr_DATA0_CTRL_STS_IN_dis=1 to allow the controller to
         *  respond with ACK for the incorrect DATA0 PID and then retry the control STATUS IN
         *  transfer until DATA1 PID is received. With XactErr_DATA0_CTRL_STS_IN_dis=0, the
         *  controller generates Transaction Error interrupt when the incorrect PID is
         *  received. This STAR fix is applicable only for Buffer DMA and Descriptor DMA modes.
         *  This bit must be programmed during the initial configuration of the controller and
         *  must not be modified later.
         */
        uint32_t gstarfxdis_xacterr_data0_ctrl_sts_in_dis:1;
        uint32_t reserved_14:1;
        /** gstarfxdis_host_xcvrsel_resetaftrsusp_corr_dis : R/W; bitpos: [15]; default: 0;
         *  Disable the STAR fix added for correcting XcvrSel on UTMI Interface in host mode.
         *  When host controller drives reset in power down suspend state, the behavior of
         *  XcvrSel has been corrected to drive the valid combination of XcvrSel (HS_XCVR) and
         *  TermSel (HS_TERM) on the UTMI interface.
         *  The application can set this register bit to 1'b1 to fall back to the original
         *  behavior of the Host controller driving XcvrSel (FS_XCVR) and TermSel (HS_TERM)
         *  when reset is driven to exit from power down state.
         *  This bit must be programmed during the initial configuration of the controller and
         *  must not be modified later.
         */
        uint32_t gstarfxdis_host_xcvrsel_resetaftrsusp_corr_dis:1;
        /** gstarfxdis_host_utmi_txvld_corr_dis : R/W; bitpos: [16]; default: 0;
         *  Disable the correction to OpMode/XcvrSel/TermSel on UTMI Interface in Host mode.
         *  When HPRT.PrtRst is set by the application, the Host controller can change the
         *  Opmode, XcvrSel and TermSel while TxValid is still high (1'b1) during SOF
         *  transmission in 8-bit UTMI mode. This behavior of the controller has been corrected
         *  to handle port reset during SOF transmission. With the fix, the controller waits
         *  for Txvalid to go low (1'b0) and then changes the OpMode, XcvrSel and TermSel.
         *  The application can set this register bit to 1'b1 to fall back to the original
         *  behavior of the controller.
         *  This bit must be programmed during the initial configuration of the controller and
         *  must not be modified later.
         */
        uint32_t gstarfxdis_host_utmi_txvld_corr_dis:1;
        /** gstarfxdis_opmode_xcvrsel_chirpen_corr_dis : R/W; bitpos: [17]; default: 0;
         *  Disable the STAR fix added for correcting Opmode and XcvrSel on UTMI Interface when
         *  reset is detected in suspend state.
         *  In configurations with Battery charger support enabled (and GOTGCTL.ChirpEn
         *  programmed to 1), the RTL has been updated to wait for 1ms and then change the
         *  opmode and xcvrselect when reset is detected in the suspend state.
         *  The application can set this register bit to 1'b1 to fall back to the original
         *  behavior of the controller and change Opmode and XcvrSel without waiting for 1ms
         *  after reset detection.
         *  This bit must be programmed during the initial configuration of the controller and
         *  must not be modified later.
         */
        uint32_t gstarfxdis_opmode_xcvrsel_chirpen_corr_dis:1;
        /** gstarfxdis_txvalid_deassertion_corr_dis : R/W; bitpos: [18]; default: 0;
         *  Disable the STAR fix added for correcting Txvalid deassertion on UTMI Interface
         *  when soft disconnect is done.
         *  The RTL has been updated to wait for utmi_txready and then de-assert the
         *  utmi_txvalid being driven by MAC DSSR when soft disconnect is done.
         *  The application can set this register bit to 1'b1 to fall back to the original
         *  behavior of the controller and change Txvalid without waiting for Txready.
         *  This bit must be programmed during the initial configuration of the controller and
         *  must not be modified later.
         */
        uint32_t gstarfxdis_txvalid_deassertion_corr_dis:1;
        /** gstarfxdis_host_no_xfer_after_prtdis_fix_dis : R/W; bitpos: [19]; default: 0;
         *  Disable the STAR fix added for correcting Host behavior when port is disabled.
         *  The RTL has been updated to not assert utmi_txvalid when the port is disabled.
         *  The application can set this register bit to 1'b1 to fall back to the original
         *  behavior of the controller.
         *  This bit must be programmed during the initial configuration of the controller and
         *  must not be modified later.
         */
        uint32_t gstarfxdis_host_no_xfer_after_prtdis_fix_dis:1;
        uint32_t reserved_20:1;
        /** gstarfxdis_reserved : RO; bitpos: [31:21]; default: 0;
         *  RESERVED
         */
        uint32_t gstarfxdis_reserved:11;
    };
    uint32_t val;
} usb_otghs_gstarfxdis_reg_t;


typedef struct {
    volatile usb_otghs_gotgctl_reg_t gotgctl;
    volatile usb_otghs_gotgint_reg_t gotgint;
    volatile usb_otghs_gahbcfg_reg_t gahbcfg;
    volatile usb_otghs_gusbcfg_reg_t gusbcfg;
    volatile usb_otghs_grstctl_reg_t grstctl;
    volatile usb_otghs_gintsts_reg_t gintsts;
    volatile usb_otghs_gintmsk_reg_t gintmsk;
    volatile usb_otghs_grxstsr_reg_t grxstsr;
    volatile usb_otghs_grxstsp_reg_t grxstsp;
    volatile usb_otghs_grxfsiz_reg_t grxfsiz;
    volatile usb_otghs_gnptxfsiz_reg_t gnptxfsiz;
    volatile usb_otghs_gnptxsts_reg_t gnptxsts;
    uint32_t reserved_030;
    volatile usb_otghs_gpvndctl_reg_t gpvndctl;
    uint32_t reserved_038[2];
    volatile usb_otghs_gsnpsid_reg_t gsnpsid;
    volatile usb_otghs_ghwcfg1_reg_t ghwcfg1;
    volatile usb_otghs_ghwcfg2_reg_t ghwcfg2;
    volatile usb_otghs_ghwcfg3_reg_t ghwcfg3;
    volatile usb_otghs_ghwcfg4_reg_t ghwcfg4;
    uint32_t reserved_054[2];
    volatile usb_otghs_gdfifocfg_reg_t gdfifocfg;
    uint32_t reserved_060[2];
    volatile usb_otghs_gintmsk2_reg_t gintmsk2;
    volatile usb_otghs_gintsts2_reg_t gintsts2;
    uint32_t reserved_070[36];
    volatile usb_otghs_hptxfsiz_reg_t hptxfsiz;
    volatile usb_otghs_dieptxf1_reg_t dieptxf1;
    volatile usb_otghs_dieptxf2_reg_t dieptxf2;
    volatile usb_otghs_dieptxf3_reg_t dieptxf3;
    volatile usb_otghs_dieptxf4_reg_t dieptxf4;
    volatile usb_otghs_dieptxf5_reg_t dieptxf5;
    volatile usb_otghs_dieptxf6_reg_t dieptxf6;
    volatile usb_otghs_dieptxf7_reg_t dieptxf7;
    uint32_t reserved_120[184];
    volatile usb_otghs_hcfg_reg_t hcfg;
    volatile usb_otghs_hfir_reg_t hfir;
    volatile usb_otghs_hfnum_reg_t hfnum;
    uint32_t reserved_40c;
    volatile usb_otghs_hptxsts_reg_t hptxsts;
    volatile usb_otghs_haint_reg_t haint;
    volatile usb_otghs_haintmsk_reg_t haintmsk;
    volatile usb_otghs_hflbaddr_reg_t hflbaddr;
    uint32_t reserved_420[8];
    volatile usb_otghs_hprt_reg_t hprt;
    uint32_t reserved_444[47];
    volatile usb_otghs_hcchar0_reg_t hcchar0;
    volatile usb_otghs_hcsplt0_reg_t hcsplt0;
    volatile usb_otghs_hcint0_reg_t hcint0;
    volatile usb_otghs_hcintmsk0_reg_t hcintmsk0;
    volatile usb_otghs_hctsiz0_reg_t hctsiz0;
    volatile usb_otghs_hcdma0_reg_t hcdma0;
    uint32_t reserved_518;
    volatile usb_otghs_hcdmab0_reg_t hcdmab0;
    volatile usb_otghs_hcchar1_reg_t hcchar1;
    volatile usb_otghs_hcsplt1_reg_t hcsplt1;
    volatile usb_otghs_hcint1_reg_t hcint1;
    volatile usb_otghs_hcintmsk1_reg_t hcintmsk1;
    volatile usb_otghs_hctsiz1_reg_t hctsiz1;
    volatile usb_otghs_hcdma1_reg_t hcdma1;
    uint32_t reserved_538;
    volatile usb_otghs_hcdmab1_reg_t hcdmab1;
    volatile usb_otghs_hcchar2_reg_t hcchar2;
    volatile usb_otghs_hcsplt2_reg_t hcsplt2;
    volatile usb_otghs_hcint2_reg_t hcint2;
    volatile usb_otghs_hcintmsk2_reg_t hcintmsk2;
    volatile usb_otghs_hctsiz2_reg_t hctsiz2;
    volatile usb_otghs_hcdma2_reg_t hcdma2;
    uint32_t reserved_558;
    volatile usb_otghs_hcdmab2_reg_t hcdmab2;
    volatile usb_otghs_hcchar3_reg_t hcchar3;
    volatile usb_otghs_hcsplt3_reg_t hcsplt3;
    volatile usb_otghs_hcint3_reg_t hcint3;
    volatile usb_otghs_hcintmsk3_reg_t hcintmsk3;
    volatile usb_otghs_hctsiz3_reg_t hctsiz3;
    volatile usb_otghs_hcdma3_reg_t hcdma3;
    uint32_t reserved_578;
    volatile usb_otghs_hcdmab3_reg_t hcdmab3;
    volatile usb_otghs_hcchar4_reg_t hcchar4;
    volatile usb_otghs_hcsplt4_reg_t hcsplt4;
    volatile usb_otghs_hcint4_reg_t hcint4;
    volatile usb_otghs_hcintmsk4_reg_t hcintmsk4;
    volatile usb_otghs_hctsiz4_reg_t hctsiz4;
    volatile usb_otghs_hcdma4_reg_t hcdma4;
    uint32_t reserved_598;
    volatile usb_otghs_hcdmab4_reg_t hcdmab4;
    volatile usb_otghs_hcchar5_reg_t hcchar5;
    volatile usb_otghs_hcsplt5_reg_t hcsplt5;
    volatile usb_otghs_hcint5_reg_t hcint5;
    volatile usb_otghs_hcintmsk5_reg_t hcintmsk5;
    volatile usb_otghs_hctsiz5_reg_t hctsiz5;
    volatile usb_otghs_hcdma5_reg_t hcdma5;
    uint32_t reserved_5b8;
    volatile usb_otghs_hcdmab5_reg_t hcdmab5;
    volatile usb_otghs_hcchar6_reg_t hcchar6;
    volatile usb_otghs_hcsplt6_reg_t hcsplt6;
    volatile usb_otghs_hcint6_reg_t hcint6;
    volatile usb_otghs_hcintmsk6_reg_t hcintmsk6;
    volatile usb_otghs_hctsiz6_reg_t hctsiz6;
    volatile usb_otghs_hcdma6_reg_t hcdma6;
    uint32_t reserved_5d8;
    volatile usb_otghs_hcdmab6_reg_t hcdmab6;
    volatile usb_otghs_hcchar7_reg_t hcchar7;
    volatile usb_otghs_hcsplt7_reg_t hcsplt7;
    volatile usb_otghs_hcint7_reg_t hcint7;
    volatile usb_otghs_hcintmsk7_reg_t hcintmsk7;
    volatile usb_otghs_hctsiz7_reg_t hctsiz7;
    volatile usb_otghs_hcdma7_reg_t hcdma7;
    uint32_t reserved_5f8;
    volatile usb_otghs_hcdmab7_reg_t hcdmab7;
    volatile usb_otghs_hcchar8_reg_t hcchar8;
    volatile usb_otghs_hcsplt8_reg_t hcsplt8;
    volatile usb_otghs_hcint8_reg_t hcint8;
    volatile usb_otghs_hcintmsk8_reg_t hcintmsk8;
    volatile usb_otghs_hctsiz8_reg_t hctsiz8;
    volatile usb_otghs_hcdma8_reg_t hcdma8;
    uint32_t reserved_618;
    volatile usb_otghs_hcdmab8_reg_t hcdmab8;
    volatile usb_otghs_hcchar9_reg_t hcchar9;
    volatile usb_otghs_hcsplt9_reg_t hcsplt9;
    volatile usb_otghs_hcint9_reg_t hcint9;
    volatile usb_otghs_hcintmsk9_reg_t hcintmsk9;
    volatile usb_otghs_hctsiz9_reg_t hctsiz9;
    volatile usb_otghs_hcdma9_reg_t hcdma9;
    uint32_t reserved_638;
    volatile usb_otghs_hcdmab9_reg_t hcdmab9;
    volatile usb_otghs_hcchar10_reg_t hcchar10;
    volatile usb_otghs_hcsplt10_reg_t hcsplt10;
    volatile usb_otghs_hcint10_reg_t hcint10;
    volatile usb_otghs_hcintmsk10_reg_t hcintmsk10;
    volatile usb_otghs_hctsiz10_reg_t hctsiz10;
    volatile usb_otghs_hcdma10_reg_t hcdma10;
    uint32_t reserved_658;
    volatile usb_otghs_hcdmab10_reg_t hcdmab10;
    volatile usb_otghs_hcchar11_reg_t hcchar11;
    volatile usb_otghs_hcsplt11_reg_t hcsplt11;
    volatile usb_otghs_hcint11_reg_t hcint11;
    volatile usb_otghs_hcintmsk11_reg_t hcintmsk11;
    volatile usb_otghs_hctsiz11_reg_t hctsiz11;
    volatile usb_otghs_hcdma11_reg_t hcdma11;
    uint32_t reserved_678;
    volatile usb_otghs_hcdmab11_reg_t hcdmab11;
    volatile usb_otghs_hcchar12_reg_t hcchar12;
    volatile usb_otghs_hcsplt12_reg_t hcsplt12;
    volatile usb_otghs_hcint12_reg_t hcint12;
    volatile usb_otghs_hcintmsk12_reg_t hcintmsk12;
    volatile usb_otghs_hctsiz12_reg_t hctsiz12;
    volatile usb_otghs_hcdma12_reg_t hcdma12;
    uint32_t reserved_698;
    volatile usb_otghs_hcdmab12_reg_t hcdmab12;
    volatile usb_otghs_hcchar13_reg_t hcchar13;
    volatile usb_otghs_hcsplt13_reg_t hcsplt13;
    volatile usb_otghs_hcint13_reg_t hcint13;
    volatile usb_otghs_hcintmsk13_reg_t hcintmsk13;
    volatile usb_otghs_hctsiz13_reg_t hctsiz13;
    volatile usb_otghs_hcdma13_reg_t hcdma13;
    uint32_t reserved_6b8;
    volatile usb_otghs_hcdmab13_reg_t hcdmab13;
    volatile usb_otghs_hcchar14_reg_t hcchar14;
    volatile usb_otghs_hcsplt14_reg_t hcsplt14;
    volatile usb_otghs_hcint14_reg_t hcint14;
    volatile usb_otghs_hcintmsk14_reg_t hcintmsk14;
    volatile usb_otghs_hctsiz14_reg_t hctsiz14;
    volatile usb_otghs_hcdma14_reg_t hcdma14;
    uint32_t reserved_6d8;
    volatile usb_otghs_hcdmab14_reg_t hcdmab14;
    volatile usb_otghs_hcchar15_reg_t hcchar15;
    volatile usb_otghs_hcsplt15_reg_t hcsplt15;
    volatile usb_otghs_hcint15_reg_t hcint15;
    volatile usb_otghs_hcintmsk15_reg_t hcintmsk15;
    volatile usb_otghs_hctsiz15_reg_t hctsiz15;
    volatile usb_otghs_hcdma15_reg_t hcdma15;
    uint32_t reserved_6f8;
    volatile usb_otghs_hcdmab15_reg_t hcdmab15;
    uint32_t reserved_700[64];
    volatile usb_otghs_dcfg_reg_t dcfg;
    volatile usb_otghs_dctl_reg_t dctl;
    volatile usb_otghs_dsts_reg_t dsts;
    uint32_t reserved_80c;
    volatile usb_otghs_diepmsk_reg_t diepmsk;
    volatile usb_otghs_doepmsk_reg_t doepmsk;
    volatile usb_otghs_daint_reg_t daint;
    volatile usb_otghs_daintmsk_reg_t daintmsk;
    uint32_t reserved_820[2];
    volatile usb_otghs_dvbusdis_reg_t dvbusdis;
    volatile usb_otghs_dvbuspulse_reg_t dvbuspulse;
    volatile usb_otghs_dthrctl_reg_t dthrctl;
    volatile usb_otghs_diepempmsk_reg_t diepempmsk;
    volatile usb_otghs_deachint_reg_t deachint;
    volatile usb_otghs_deachintmsk_reg_t deachintmsk;
    volatile usb_otghs_diepeachmsk0_reg_t diepeachmsk0;
    volatile usb_otghs_diepeachmsk1_reg_t diepeachmsk1;
    volatile usb_otghs_diepeachmsk2_reg_t diepeachmsk2;
    volatile usb_otghs_diepeachmsk3_reg_t diepeachmsk3;
    volatile usb_otghs_diepeachmsk4_reg_t diepeachmsk4;
    volatile usb_otghs_diepeachmsk5_reg_t diepeachmsk5;
    volatile usb_otghs_diepeachmsk6_reg_t diepeachmsk6;
    volatile usb_otghs_diepeachmsk7_reg_t diepeachmsk7;
    volatile usb_otghs_diepeachmsk8_reg_t diepeachmsk8;
    volatile usb_otghs_diepeachmsk9_reg_t diepeachmsk9;
    volatile usb_otghs_diepeachmsk10_reg_t diepeachmsk10;
    volatile usb_otghs_diepeachmsk11_reg_t diepeachmsk11;
    volatile usb_otghs_diepeachmsk12_reg_t diepeachmsk12;
    volatile usb_otghs_diepeachmsk13_reg_t diepeachmsk13;
    volatile usb_otghs_diepeachmsk14_reg_t diepeachmsk14;
    volatile usb_otghs_diepeachmsk15_reg_t diepeachmsk15;
    volatile usb_otghs_doepeachmsk0_reg_t doepeachmsk0;
    volatile usb_otghs_doepeachmsk1_reg_t doepeachmsk1;
    volatile usb_otghs_doepeachmsk2_reg_t doepeachmsk2;
    volatile usb_otghs_doepeachmsk3_reg_t doepeachmsk3;
    volatile usb_otghs_doepeachmsk4_reg_t doepeachmsk4;
    volatile usb_otghs_doepeachmsk5_reg_t doepeachmsk5;
    volatile usb_otghs_doepeachmsk6_reg_t doepeachmsk6;
    volatile usb_otghs_doepeachmsk7_reg_t doepeachmsk7;
    volatile usb_otghs_doepeachmsk8_reg_t doepeachmsk8;
    volatile usb_otghs_doepeachmsk9_reg_t doepeachmsk9;
    volatile usb_otghs_doepeachmsk10_reg_t doepeachmsk10;
    volatile usb_otghs_doepeachmsk11_reg_t doepeachmsk11;
    volatile usb_otghs_doepeachmsk12_reg_t doepeachmsk12;
    volatile usb_otghs_doepeachmsk13_reg_t doepeachmsk13;
    volatile usb_otghs_doepeachmsk14_reg_t doepeachmsk14;
    volatile usb_otghs_doepeachmsk15_reg_t doepeachmsk15;
    uint32_t reserved_8c0[16];
    volatile usb_otghs_diepctl0_reg_t diepctl0;
    uint32_t reserved_904;
    volatile usb_otghs_diepint0_reg_t diepint0;
    uint32_t reserved_90c;
    volatile usb_otghs_dieptsiz0_reg_t dieptsiz0;
    volatile usb_otghs_diepdma0_reg_t diepdma0;
    volatile usb_otghs_dtxfsts0_reg_t dtxfsts0;
    volatile usb_otghs_diepdmab0_reg_t diepdmab0;
    volatile usb_otghs_diepctl1_reg_t diepctl1;
    uint32_t reserved_924;
    volatile usb_otghs_diepint1_reg_t diepint1;
    uint32_t reserved_92c;
    volatile usb_otghs_dieptsiz1_reg_t dieptsiz1;
    volatile usb_otghs_diepdma1_reg_t diepdma1;
    volatile usb_otghs_dtxfsts1_reg_t dtxfsts1;
    volatile usb_otghs_diepdmab1_reg_t diepdmab1;
    volatile usb_otghs_diepctl2_reg_t diepctl2;
    uint32_t reserved_944;
    volatile usb_otghs_diepint2_reg_t diepint2;
    uint32_t reserved_94c;
    volatile usb_otghs_dieptsiz2_reg_t dieptsiz2;
    volatile usb_otghs_diepdma2_reg_t diepdma2;
    volatile usb_otghs_dtxfsts2_reg_t dtxfsts2;
    volatile usb_otghs_diepdmab2_reg_t diepdmab2;
    volatile usb_otghs_diepctl3_reg_t diepctl3;
    uint32_t reserved_964;
    volatile usb_otghs_diepint3_reg_t diepint3;
    uint32_t reserved_96c;
    volatile usb_otghs_dieptsiz3_reg_t dieptsiz3;
    volatile usb_otghs_diepdma3_reg_t diepdma3;
    volatile usb_otghs_dtxfsts3_reg_t dtxfsts3;
    volatile usb_otghs_diepdmab3_reg_t diepdmab3;
    volatile usb_otghs_diepctl4_reg_t diepctl4;
    uint32_t reserved_984;
    volatile usb_otghs_diepint4_reg_t diepint4;
    uint32_t reserved_98c;
    volatile usb_otghs_dieptsiz4_reg_t dieptsiz4;
    volatile usb_otghs_diepdma4_reg_t diepdma4;
    volatile usb_otghs_dtxfsts4_reg_t dtxfsts4;
    volatile usb_otghs_diepdmab4_reg_t diepdmab4;
    volatile usb_otghs_diepctl5_reg_t diepctl5;
    uint32_t reserved_9a4;
    volatile usb_otghs_diepint5_reg_t diepint5;
    uint32_t reserved_9ac;
    volatile usb_otghs_dieptsiz5_reg_t dieptsiz5;
    volatile usb_otghs_diepdma5_reg_t diepdma5;
    volatile usb_otghs_dtxfsts5_reg_t dtxfsts5;
    volatile usb_otghs_diepdmab5_reg_t diepdmab5;
    volatile usb_otghs_diepctl6_reg_t diepctl6;
    uint32_t reserved_9c4;
    volatile usb_otghs_diepint6_reg_t diepint6;
    uint32_t reserved_9cc;
    volatile usb_otghs_dieptsiz6_reg_t dieptsiz6;
    volatile usb_otghs_diepdma6_reg_t diepdma6;
    volatile usb_otghs_dtxfsts6_reg_t dtxfsts6;
    volatile usb_otghs_diepdmab6_reg_t diepdmab6;
    volatile usb_otghs_diepctl7_reg_t diepctl7;
    uint32_t reserved_9e4;
    volatile usb_otghs_diepint7_reg_t diepint7;
    uint32_t reserved_9ec;
    volatile usb_otghs_dieptsiz7_reg_t dieptsiz7;
    volatile usb_otghs_diepdma7_reg_t diepdma7;
    volatile usb_otghs_dtxfsts7_reg_t dtxfsts7;
    volatile usb_otghs_diepdmab7_reg_t diepdmab7;
    volatile usb_otghs_diepctl8_reg_t diepctl8;
    uint32_t reserved_a04;
    volatile usb_otghs_diepint8_reg_t diepint8;
    uint32_t reserved_a0c;
    volatile usb_otghs_dieptsiz8_reg_t dieptsiz8;
    volatile usb_otghs_diepdma8_reg_t diepdma8;
    volatile usb_otghs_dtxfsts8_reg_t dtxfsts8;
    volatile usb_otghs_diepdmab8_reg_t diepdmab8;
    volatile usb_otghs_diepctl9_reg_t diepctl9;
    uint32_t reserved_a24;
    volatile usb_otghs_diepint9_reg_t diepint9;
    uint32_t reserved_a2c;
    volatile usb_otghs_dieptsiz9_reg_t dieptsiz9;
    volatile usb_otghs_diepdma9_reg_t diepdma9;
    volatile usb_otghs_dtxfsts9_reg_t dtxfsts9;
    volatile usb_otghs_diepdmab9_reg_t diepdmab9;
    volatile usb_otghs_diepctl10_reg_t diepctl10;
    uint32_t reserved_a44;
    volatile usb_otghs_diepint10_reg_t diepint10;
    uint32_t reserved_a4c;
    volatile usb_otghs_dieptsiz10_reg_t dieptsiz10;
    volatile usb_otghs_diepdma10_reg_t diepdma10;
    volatile usb_otghs_dtxfsts10_reg_t dtxfsts10;
    volatile usb_otghs_diepdmab10_reg_t diepdmab10;
    volatile usb_otghs_diepctl11_reg_t diepctl11;
    uint32_t reserved_a64;
    volatile usb_otghs_diepint11_reg_t diepint11;
    uint32_t reserved_a6c;
    volatile usb_otghs_dieptsiz11_reg_t dieptsiz11;
    volatile usb_otghs_diepdma11_reg_t diepdma11;
    volatile usb_otghs_dtxfsts11_reg_t dtxfsts11;
    volatile usb_otghs_diepdmab11_reg_t diepdmab11;
    volatile usb_otghs_diepctl12_reg_t diepctl12;
    uint32_t reserved_a84;
    volatile usb_otghs_diepint12_reg_t diepint12;
    uint32_t reserved_a8c;
    volatile usb_otghs_dieptsiz12_reg_t dieptsiz12;
    volatile usb_otghs_diepdma12_reg_t diepdma12;
    volatile usb_otghs_dtxfsts12_reg_t dtxfsts12;
    volatile usb_otghs_diepdmab12_reg_t diepdmab12;
    volatile usb_otghs_diepctl13_reg_t diepctl13;
    uint32_t reserved_aa4;
    volatile usb_otghs_diepint13_reg_t diepint13;
    uint32_t reserved_aac;
    volatile usb_otghs_dieptsiz13_reg_t dieptsiz13;
    volatile usb_otghs_diepdma13_reg_t diepdma13;
    volatile usb_otghs_dtxfsts13_reg_t dtxfsts13;
    volatile usb_otghs_diepdmab13_reg_t diepdmab13;
    volatile usb_otghs_diepctl14_reg_t diepctl14;
    uint32_t reserved_ac4;
    volatile usb_otghs_diepint14_reg_t diepint14;
    uint32_t reserved_acc;
    volatile usb_otghs_dieptsiz14_reg_t dieptsiz14;
    volatile usb_otghs_diepdma14_reg_t diepdma14;
    volatile usb_otghs_dtxfsts14_reg_t dtxfsts14;
    volatile usb_otghs_diepdmab14_reg_t diepdmab14;
    volatile usb_otghs_diepctl15_reg_t diepctl15;
    uint32_t reserved_ae4;
    volatile usb_otghs_diepint15_reg_t diepint15;
    uint32_t reserved_aec;
    volatile usb_otghs_dieptsiz15_reg_t dieptsiz15;
    volatile usb_otghs_diepdma15_reg_t diepdma15;
    volatile usb_otghs_dtxfsts15_reg_t dtxfsts15;
    volatile usb_otghs_diepdmab15_reg_t diepdmab15;
    volatile usb_otghs_doepctl0_reg_t doepctl0;
    uint32_t reserved_b04;
    volatile usb_otghs_doepint0_reg_t doepint0;
    uint32_t reserved_b0c;
    volatile usb_otghs_doeptsiz0_reg_t doeptsiz0;
    volatile usb_otghs_doepdma0_reg_t doepdma0;
    uint32_t reserved_b18;
    volatile usb_otghs_doepdmab0_reg_t doepdmab0;
    volatile usb_otghs_doepctl1_reg_t doepctl1;
    uint32_t reserved_b24;
    volatile usb_otghs_doepint1_reg_t doepint1;
    uint32_t reserved_b2c;
    volatile usb_otghs_doeptsiz1_reg_t doeptsiz1;
    volatile usb_otghs_doepdma1_reg_t doepdma1;
    uint32_t reserved_b38;
    volatile usb_otghs_doepdmab1_reg_t doepdmab1;
    volatile usb_otghs_doepctl2_reg_t doepctl2;
    uint32_t reserved_b44;
    volatile usb_otghs_doepint2_reg_t doepint2;
    uint32_t reserved_b4c;
    volatile usb_otghs_doeptsiz2_reg_t doeptsiz2;
    volatile usb_otghs_doepdma2_reg_t doepdma2;
    uint32_t reserved_b58;
    volatile usb_otghs_doepdmab2_reg_t doepdmab2;
    volatile usb_otghs_doepctl3_reg_t doepctl3;
    uint32_t reserved_b64;
    volatile usb_otghs_doepint3_reg_t doepint3;
    uint32_t reserved_b6c;
    volatile usb_otghs_doeptsiz3_reg_t doeptsiz3;
    volatile usb_otghs_doepdma3_reg_t doepdma3;
    uint32_t reserved_b78;
    volatile usb_otghs_doepdmab3_reg_t doepdmab3;
    volatile usb_otghs_doepctl4_reg_t doepctl4;
    uint32_t reserved_b84;
    volatile usb_otghs_doepint4_reg_t doepint4;
    uint32_t reserved_b8c;
    volatile usb_otghs_doeptsiz4_reg_t doeptsiz4;
    volatile usb_otghs_doepdma4_reg_t doepdma4;
    uint32_t reserved_b98;
    volatile usb_otghs_doepdmab4_reg_t doepdmab4;
    volatile usb_otghs_doepctl5_reg_t doepctl5;
    uint32_t reserved_ba4;
    volatile usb_otghs_doepint5_reg_t doepint5;
    uint32_t reserved_bac;
    volatile usb_otghs_doeptsiz5_reg_t doeptsiz5;
    volatile usb_otghs_doepdma5_reg_t doepdma5;
    uint32_t reserved_bb8;
    volatile usb_otghs_doepdmab5_reg_t doepdmab5;
    volatile usb_otghs_doepctl6_reg_t doepctl6;
    uint32_t reserved_bc4;
    volatile usb_otghs_doepint6_reg_t doepint6;
    uint32_t reserved_bcc;
    volatile usb_otghs_doeptsiz6_reg_t doeptsiz6;
    volatile usb_otghs_doepdma6_reg_t doepdma6;
    uint32_t reserved_bd8;
    volatile usb_otghs_doepdmab6_reg_t doepdmab6;
    volatile usb_otghs_doepctl7_reg_t doepctl7;
    uint32_t reserved_be4;
    volatile usb_otghs_doepint7_reg_t doepint7;
    uint32_t reserved_bec;
    volatile usb_otghs_doeptsiz7_reg_t doeptsiz7;
    volatile usb_otghs_doepdma7_reg_t doepdma7;
    uint32_t reserved_bf8;
    volatile usb_otghs_doepdmab7_reg_t doepdmab7;
    volatile usb_otghs_doepctl8_reg_t doepctl8;
    uint32_t reserved_c04;
    volatile usb_otghs_doepint8_reg_t doepint8;
    uint32_t reserved_c0c;
    volatile usb_otghs_doeptsiz8_reg_t doeptsiz8;
    volatile usb_otghs_doepdma8_reg_t doepdma8;
    uint32_t reserved_c18;
    volatile usb_otghs_doepdmab8_reg_t doepdmab8;
    volatile usb_otghs_doepctl9_reg_t doepctl9;
    uint32_t reserved_c24;
    volatile usb_otghs_doepint9_reg_t doepint9;
    uint32_t reserved_c2c;
    volatile usb_otghs_doeptsiz9_reg_t doeptsiz9;
    volatile usb_otghs_doepdma9_reg_t doepdma9;
    uint32_t reserved_c38;
    volatile usb_otghs_doepdmab9_reg_t doepdmab9;
    volatile usb_otghs_doepctl10_reg_t doepctl10;
    uint32_t reserved_c44;
    volatile usb_otghs_doepint10_reg_t doepint10;
    uint32_t reserved_c4c;
    volatile usb_otghs_doeptsiz10_reg_t doeptsiz10;
    volatile usb_otghs_doepdma10_reg_t doepdma10;
    uint32_t reserved_c58;
    volatile usb_otghs_doepdmab10_reg_t doepdmab10;
    volatile usb_otghs_doepctl11_reg_t doepctl11;
    uint32_t reserved_c64;
    volatile usb_otghs_doepint11_reg_t doepint11;
    uint32_t reserved_c6c;
    volatile usb_otghs_doeptsiz11_reg_t doeptsiz11;
    volatile usb_otghs_doepdma11_reg_t doepdma11;
    uint32_t reserved_c78;
    volatile usb_otghs_doepdmab11_reg_t doepdmab11;
    volatile usb_otghs_doepctl12_reg_t doepctl12;
    uint32_t reserved_c84;
    volatile usb_otghs_doepint12_reg_t doepint12;
    uint32_t reserved_c8c;
    volatile usb_otghs_doeptsiz12_reg_t doeptsiz12;
    volatile usb_otghs_doepdma12_reg_t doepdma12;
    uint32_t reserved_c98;
    volatile usb_otghs_doepdmab12_reg_t doepdmab12;
    volatile usb_otghs_doepctl13_reg_t doepctl13;
    uint32_t reserved_ca4;
    volatile usb_otghs_doepint13_reg_t doepint13;
    uint32_t reserved_cac;
    volatile usb_otghs_doeptsiz13_reg_t doeptsiz13;
    volatile usb_otghs_doepdma13_reg_t doepdma13;
    uint32_t reserved_cb8;
    volatile usb_otghs_doepdmab13_reg_t doepdmab13;
    volatile usb_otghs_doepctl14_reg_t doepctl14;
    uint32_t reserved_cc4;
    volatile usb_otghs_doepint14_reg_t doepint14;
    uint32_t reserved_ccc;
    volatile usb_otghs_doeptsiz14_reg_t doeptsiz14;
    volatile usb_otghs_doepdma14_reg_t doepdma14;
    uint32_t reserved_cd8;
    volatile usb_otghs_doepdmab14_reg_t doepdmab14;
    volatile usb_otghs_doepctl15_reg_t doepctl15;
    uint32_t reserved_ce4;
    volatile usb_otghs_doepint15_reg_t doepint15;
    uint32_t reserved_cec;
    volatile usb_otghs_doeptsiz15_reg_t doeptsiz15;
    volatile usb_otghs_doepdma15_reg_t doepdma15;
    uint32_t reserved_cf8;
    volatile usb_otghs_doepdmab15_reg_t doepdmab15;
    uint32_t reserved_d00[64];
    volatile usb_otghs_pcgcctl_reg_t pcgcctl;
    uint32_t reserved_e04[63];
    volatile usb_otghs_gstarfxdis_reg_t gstarfxdis;
} usb_otghs_dev_t;


#ifndef __cplusplus
_Static_assert(sizeof(usb_otghs_dev_t) == 0xf04, "Invalid size of usb_otghs_dev_t structure");
#endif

#ifdef __cplusplus
}
#endif
