/**
 * SPDX-FileCopyrightText: 2025 Espressif Systems (Shanghai) CO LTD
 *
 *  SPDX-License-Identifier: Apache-2.0
 */
#pragma once

#include <stdint.h>
#include "soc/soc.h"
#ifdef __cplusplus
extern "C" {
#endif

/** USB_OTGHS_GOTGCTL_REG register
 *  The OTG Control and Status register controls the behavior and reflects the status
 *  of the OTG function of the controller.
 */
#define USB_OTGHS_GOTGCTL_REG (DR_REG_USB_OTGHS_BASE + 0x0)
/** USB_OTGHS_GOTGCTL_VBVALIDOVEN : R/W; bitpos: [2]; default: 0;
 *  Mode: Host only
 *  VBUS Valid Override Enable (VbvalidOvEn)
 *  This bit is used to enable/disable the software to override the Bvalid signal using
 *  the GOTGCTL.VbvalidOvVal.
 *  - 1'b1 : Internally Bvalid received from the PHY is overridden with
 *  GOTGCTL.VbvalidOvVal.
 *  - 1'b0 : Override is disabled and bvalid signal from the respective PHY selected is
 *  used internally by the controller.
 */
#define USB_OTGHS_GOTGCTL_VBVALIDOVEN    (BIT(2))
#define USB_OTGHS_GOTGCTL_VBVALIDOVEN_M  (USB_OTGHS_GOTGCTL_VBVALIDOVEN_V << USB_OTGHS_GOTGCTL_VBVALIDOVEN_S)
#define USB_OTGHS_GOTGCTL_VBVALIDOVEN_V  0x00000001U
#define USB_OTGHS_GOTGCTL_VBVALIDOVEN_S  2
/** USB_OTGHS_GOTGCTL_VBVALIDOVVAL : R/W; bitpos: [3]; default: 0;
 *  Mode: Host only
 *  VBUS Valid OverrideValue (VbvalidOvVal)
 *  This bit is used to set Override value for vbusvalid signal when
 *  GOTGCTL.VbvalidOvEn is set.
 *  - 1'b0 : vbusvalid value is 1'b0 when GOTGCTL.VbvalidOvEn =1
 *  - 1'b1 : vbusvalid value is 1'b1 when GOTGCTL.VbvalidOvEn =1
 */
#define USB_OTGHS_GOTGCTL_VBVALIDOVVAL    (BIT(3))
#define USB_OTGHS_GOTGCTL_VBVALIDOVVAL_M  (USB_OTGHS_GOTGCTL_VBVALIDOVVAL_V << USB_OTGHS_GOTGCTL_VBVALIDOVVAL_S)
#define USB_OTGHS_GOTGCTL_VBVALIDOVVAL_V  0x00000001U
#define USB_OTGHS_GOTGCTL_VBVALIDOVVAL_S  3
/** USB_OTGHS_GOTGCTL_AVALIDOVEN : R/W; bitpos: [4]; default: 0;
 *  Mode: Host only
 *  A-Peripheral Session Valid Override Enable (AvalidOvEn)
 *  This bit is used to enable/disable the software to override the Avalid signal using
 *  the GOTGCTL.AvalidOvVal.
 *  - 1'b1: Internally Avalid received from the PHY is overridden with
 *  GOTGCTL.AvalidOvVal.
 *  - 1'b0: Override is disabled and avalid signal from the respective PHY selected is
 *  used internally by the core
 */
#define USB_OTGHS_GOTGCTL_AVALIDOVEN    (BIT(4))
#define USB_OTGHS_GOTGCTL_AVALIDOVEN_M  (USB_OTGHS_GOTGCTL_AVALIDOVEN_V << USB_OTGHS_GOTGCTL_AVALIDOVEN_S)
#define USB_OTGHS_GOTGCTL_AVALIDOVEN_V  0x00000001U
#define USB_OTGHS_GOTGCTL_AVALIDOVEN_S  4
/** USB_OTGHS_GOTGCTL_AVALIDOVVAL : R/W; bitpos: [5]; default: 0;
 *  Mode: Host only
 *  A-Peripheral Session Valid OverrideValue (AvalidOvVal)
 *  This bit is used to set Override value for Avalid signal when GOTGCTL.AvalidOvEn is
 *  set.
 *  - 1'b0 : Avalid value is 1'b0 when GOTGCTL.AvalidOvEn =1
 *  - 1'b1 : Avalid value is 1'b1 when GOTGCTL.AvalidOvEn =1
 */
#define USB_OTGHS_GOTGCTL_AVALIDOVVAL    (BIT(5))
#define USB_OTGHS_GOTGCTL_AVALIDOVVAL_M  (USB_OTGHS_GOTGCTL_AVALIDOVVAL_V << USB_OTGHS_GOTGCTL_AVALIDOVVAL_S)
#define USB_OTGHS_GOTGCTL_AVALIDOVVAL_V  0x00000001U
#define USB_OTGHS_GOTGCTL_AVALIDOVVAL_S  5
/** USB_OTGHS_GOTGCTL_BVALIDOVEN : R/W; bitpos: [6]; default: 0;
 *  Mode: Device only
 *  B-Peripheral Session Valid Override Value (BvalidOvEn)
 *  This bit is used to enable/disable the software to override the Bvalid signal using
 *  the GOTGCTL.BvalidOvVal.
 *  - 1'b1 : Internally Bvalid received from the PHY is overridden with
 *  GOTGCTL.BvalidOvVal.
 *  - 1'b0 : Override is disabled and bvalid signal from the respective PHY selected is
 *  used internally by the force
 */
#define USB_OTGHS_GOTGCTL_BVALIDOVEN    (BIT(6))
#define USB_OTGHS_GOTGCTL_BVALIDOVEN_M  (USB_OTGHS_GOTGCTL_BVALIDOVEN_V << USB_OTGHS_GOTGCTL_BVALIDOVEN_S)
#define USB_OTGHS_GOTGCTL_BVALIDOVEN_V  0x00000001U
#define USB_OTGHS_GOTGCTL_BVALIDOVEN_S  6
/** USB_OTGHS_GOTGCTL_BVALIDOVVAL : R/W; bitpos: [7]; default: 0;
 *  Mode: Device only
 *  B-Peripheral Session Valid OverrideValue (BvalidOvVal)
 *  This bit is used to set Override value for Bvalid signal when GOTGCTL.BvalidOvEn is
 *  set.
 *  - 1'b0 : Bvalid value is 1'b0 when GOTGCTL.BvalidOvEn =1
 *  - 1'b1 : Bvalid value is 1'b1 when GOTGCTL.BvalidOvEn =1
 */
#define USB_OTGHS_GOTGCTL_BVALIDOVVAL    (BIT(7))
#define USB_OTGHS_GOTGCTL_BVALIDOVVAL_M  (USB_OTGHS_GOTGCTL_BVALIDOVVAL_V << USB_OTGHS_GOTGCTL_BVALIDOVVAL_S)
#define USB_OTGHS_GOTGCTL_BVALIDOVVAL_V  0x00000001U
#define USB_OTGHS_GOTGCTL_BVALIDOVVAL_S  7
/** USB_OTGHS_GOTGCTL_DBNCEFLTRBYPASS : R/W; bitpos: [15]; default: 0;
 *  Mode: Host and Device
 *  Debounce Filter Bypass
 *  Bypass Debounce filters for avalid, bvalid, vbusvalid, sessend, iddig signals when
 *  enabled.
 *  - 1'b0: Disabled
 *  - 1'b1: Enabled
 *
 *
 *  Note:  This register bit is valid only when debounce filters are present in core.
 */
#define USB_OTGHS_GOTGCTL_DBNCEFLTRBYPASS    (BIT(15))
#define USB_OTGHS_GOTGCTL_DBNCEFLTRBYPASS_M  (USB_OTGHS_GOTGCTL_DBNCEFLTRBYPASS_V << USB_OTGHS_GOTGCTL_DBNCEFLTRBYPASS_S)
#define USB_OTGHS_GOTGCTL_DBNCEFLTRBYPASS_V  0x00000001U
#define USB_OTGHS_GOTGCTL_DBNCEFLTRBYPASS_S  15
/** USB_OTGHS_GOTGCTL_CONIDSTS : RO; bitpos: [16]; default: 1;
 *  Mode: Host and Device
 *  Connector ID Status (ConIDSts)
 *  Indicates the connector ID status on a connect event.
 *  - 1'b0: The core is in A-Device mode.
 *  - 1'b1: The core is in B-Device mode.
 *
 *  Note:
 *  The reset value of this register field can be read only after the PHY clock is
 *  stable, or if IDDIG_FILTER is enabled, wait for the filter timer to expire to read
 *  the correct reset value which ever event is later.
 *  Reset:
 *  - 1'b0: in host only mode (OTG_MODE = 5 or 6)
 *  - 1'b1: in all other configurations
 */
#define USB_OTGHS_GOTGCTL_CONIDSTS    (BIT(16))
#define USB_OTGHS_GOTGCTL_CONIDSTS_M  (USB_OTGHS_GOTGCTL_CONIDSTS_V << USB_OTGHS_GOTGCTL_CONIDSTS_S)
#define USB_OTGHS_GOTGCTL_CONIDSTS_V  0x00000001U
#define USB_OTGHS_GOTGCTL_CONIDSTS_S  16
/** USB_OTGHS_GOTGCTL_DBNCTIME : RO; bitpos: [17]; default: 0;
 *  Mode: Host only
 *  Long/Short Debounce Time (DbncTime)
 *  Indicates the debounce time of a detected connection.
 *  - 1'b0: Long debounce time, used for physical connections (100 ms + 2.5 micro-sec)
 *  - 1'b1: Short debounce time, used for soft connections (2.5 micro-sec)
 */
#define USB_OTGHS_GOTGCTL_DBNCTIME    (BIT(17))
#define USB_OTGHS_GOTGCTL_DBNCTIME_M  (USB_OTGHS_GOTGCTL_DBNCTIME_V << USB_OTGHS_GOTGCTL_DBNCTIME_S)
#define USB_OTGHS_GOTGCTL_DBNCTIME_V  0x00000001U
#define USB_OTGHS_GOTGCTL_DBNCTIME_S  17
/** USB_OTGHS_GOTGCTL_ASESVLD : RO; bitpos: [18]; default: 1;
 *  Mode: Host only
 *  A-Session Valid (ASesVld)
 *  Indicates the Host mode transceiver status.
 *  - 1'b0: A-session is not valid
 *  - 1'b1: A-session is valid
 *  Note: If you do not enabled OTG features (such as SRP and HNP), the read reset
 *  value will be 1. The vbus assigns the values internally for non-SRP or non-HNP
 *  configurations.
 *  In case of OTG_MODE=0, the reset value of this bit is 1'b0.
 */
#define USB_OTGHS_GOTGCTL_ASESVLD    (BIT(18))
#define USB_OTGHS_GOTGCTL_ASESVLD_M  (USB_OTGHS_GOTGCTL_ASESVLD_V << USB_OTGHS_GOTGCTL_ASESVLD_S)
#define USB_OTGHS_GOTGCTL_ASESVLD_V  0x00000001U
#define USB_OTGHS_GOTGCTL_ASESVLD_S  18
/** USB_OTGHS_GOTGCTL_BSESVLD : RO; bitpos: [19]; default: 1;
 *  Mode: Device only
 *  B-Session Valid (BSesVld)
 *  Indicates the Device mode transceiver status.
 *  - 1'b0: B-session is not valid.
 *  - 1'b1: B-session is valid.
 *  In OTG mode, you can use this bit to determine if the device is connected or
 *  disconnected.
 *
 *  Note:
 *  - If you do not enable OTG features (such as SRP and HNP), the read reset value
 *  will be 1.The vbus assigns the values internally for non- SRP or non-HNP
 *  configurations.
 *  - In case of OTG_MODE=0, the reset value of this bit is 1'b0.
 *  - The reset value of this register field can be read only after the PHY clock is
 *  stable, or if IDDIG_FILTER is enabled, wait for the filter timer to expire to read
 *  the correct reset value which ever event is later.
 */
#define USB_OTGHS_GOTGCTL_BSESVLD    (BIT(19))
#define USB_OTGHS_GOTGCTL_BSESVLD_M  (USB_OTGHS_GOTGCTL_BSESVLD_V << USB_OTGHS_GOTGCTL_BSESVLD_S)
#define USB_OTGHS_GOTGCTL_BSESVLD_V  0x00000001U
#define USB_OTGHS_GOTGCTL_BSESVLD_S  19
/** USB_OTGHS_GOTGCTL_OTGVER : R/W; bitpos: [20]; default: 0;
 *  OTG Version (OTGVer)
 *  Indicates the OTG revision.
 *  - 1'b0: OTG Version 1.3. In this version the core supports Data line pulsing and
 *  VBus pulsing for SRP.
 *  - 1'b1: OTG Version 2.0. In this version the core supports only Data line pulsing
 *  for SRP.
 */
#define USB_OTGHS_GOTGCTL_OTGVER    (BIT(20))
#define USB_OTGHS_GOTGCTL_OTGVER_M  (USB_OTGHS_GOTGCTL_OTGVER_V << USB_OTGHS_GOTGCTL_OTGVER_S)
#define USB_OTGHS_GOTGCTL_OTGVER_V  0x00000001U
#define USB_OTGHS_GOTGCTL_OTGVER_S  20
/** USB_OTGHS_GOTGCTL_CURMOD : RO; bitpos: [21]; default: 0;
 *  Current Mode of Operation (CurMod)
 *  Mode: Host and Device
 *  Indicates the current mode.
 *  - 1'b0: Device mode
 *  - 1'b1: Host mode
 *  Reset:
 *  - 1'b1 in Host-only mode (OTG_MODE=5 or 6)
 *  - 1'b0 in all other configurations
 *  Note: The reset value of this register field can be read only after the PHY clock
 *  is stable, or if IDDIG_FILTER is enabled, wait for the filter timer to expire to
 *  read the correct reset value which ever event is later.
 */
#define USB_OTGHS_GOTGCTL_CURMOD    (BIT(21))
#define USB_OTGHS_GOTGCTL_CURMOD_M  (USB_OTGHS_GOTGCTL_CURMOD_V << USB_OTGHS_GOTGCTL_CURMOD_S)
#define USB_OTGHS_GOTGCTL_CURMOD_V  0x00000001U
#define USB_OTGHS_GOTGCTL_CURMOD_S  21
/** USB_OTGHS_GOTGCTL_MULTVALIDBC : RO; bitpos: [26:22]; default: 0;
 *  Mode: Host and Device
 *  Multi Valued ID pin (MultValIdBC)
 *  Battery Charger ACA inputs in the following order:
 *  - Bit 26: rid_float.
 *  - Bit 25: rid_gnd
 *  - Bit 24: rid_a
 *  - Bit 23: rid_b
 *  - Bit 22: rid_c
 */
#define USB_OTGHS_GOTGCTL_MULTVALIDBC    0x0000001FU
#define USB_OTGHS_GOTGCTL_MULTVALIDBC_M  (USB_OTGHS_GOTGCTL_MULTVALIDBC_V << USB_OTGHS_GOTGCTL_MULTVALIDBC_S)
#define USB_OTGHS_GOTGCTL_MULTVALIDBC_V  0x0000001FU
#define USB_OTGHS_GOTGCTL_MULTVALIDBC_S  22
/** USB_OTGHS_GOTGCTL_CHIRPEN : R/W; bitpos: [27]; default: 0;
 *  Mode: Device Only
 *  This bit when programmed to 1'b1 results in the core asserting chirp_on before
 *  sending an actual Chirp K signal on USB. This bit is present only if OTG_BC_SUPPORT
 *  = 1.If OTG_BC_SUPPORT!=1, this bit is a reserved bit. Do not set this bit when core
 *  is operating in HSIC mode because HSIC always operates at High Speed and High speed
 *  chirp is not used
 */
#define USB_OTGHS_GOTGCTL_CHIRPEN    (BIT(27))
#define USB_OTGHS_GOTGCTL_CHIRPEN_M  (USB_OTGHS_GOTGCTL_CHIRPEN_V << USB_OTGHS_GOTGCTL_CHIRPEN_S)
#define USB_OTGHS_GOTGCTL_CHIRPEN_V  0x00000001U
#define USB_OTGHS_GOTGCTL_CHIRPEN_S  27

/** USB_OTGHS_GOTGINT_REG register
 *  The application reads this register whenever there is an OTG interrupt and clears
 *  the bits in this register to clear the OTG interrupt.
 */
#define USB_OTGHS_GOTGINT_REG (DR_REG_USB_OTGHS_BASE + 0x4)
/** USB_OTGHS_GOTGINT_SESENDDET : R/W; bitpos: [2]; default: 0;
 *  Mode: Host and Device
 *  Session End Detected (SesEndDet)
 *  The controller sets this bit when the utmiotg_bvalid signal is deasserted. This bit
 *  can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_GOTGINT_SESENDDET    (BIT(2))
#define USB_OTGHS_GOTGINT_SESENDDET_M  (USB_OTGHS_GOTGINT_SESENDDET_V << USB_OTGHS_GOTGINT_SESENDDET_S)
#define USB_OTGHS_GOTGINT_SESENDDET_V  0x00000001U
#define USB_OTGHS_GOTGINT_SESENDDET_S  2
/** USB_OTGHS_GOTGINT_SESREQSUCSTSCHNG : R/W; bitpos: [8]; default: 0;
 *  Mode: Host and Device
 *  Session Request Success Status Change (SesReqSucStsChng)
 *  The core sets this bit on the success or failure of a session request. The
 *  application must read the Session Request Success bit in the OTG Control and Status
 *  register (GOTGCTL.SesReqScs) to check for success or failure. This bit can be set
 *  only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_GOTGINT_SESREQSUCSTSCHNG    (BIT(8))
#define USB_OTGHS_GOTGINT_SESREQSUCSTSCHNG_M  (USB_OTGHS_GOTGINT_SESREQSUCSTSCHNG_V << USB_OTGHS_GOTGINT_SESREQSUCSTSCHNG_S)
#define USB_OTGHS_GOTGINT_SESREQSUCSTSCHNG_V  0x00000001U
#define USB_OTGHS_GOTGINT_SESREQSUCSTSCHNG_S  8
/** USB_OTGHS_GOTGINT_HSTNEGSUCSTSCHNG : R/W; bitpos: [9]; default: 0;
 *  Mode: Host and Device
 *  Host Negotiation Success Status Change (HstNegSucStsChng)
 *  The core sets this bit on the success or failure of a USB host negotiation request.
 *  The application must read the Host Negotiation Success bit of the OTG Control and
 *  Status register (GOTGCTL.HstNegScs) to check for success or failure. This bit can
 *  be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_GOTGINT_HSTNEGSUCSTSCHNG    (BIT(9))
#define USB_OTGHS_GOTGINT_HSTNEGSUCSTSCHNG_M  (USB_OTGHS_GOTGINT_HSTNEGSUCSTSCHNG_V << USB_OTGHS_GOTGINT_HSTNEGSUCSTSCHNG_S)
#define USB_OTGHS_GOTGINT_HSTNEGSUCSTSCHNG_V  0x00000001U
#define USB_OTGHS_GOTGINT_HSTNEGSUCSTSCHNG_S  9
/** USB_OTGHS_GOTGINT_HSTNEGDET : R/W; bitpos: [17]; default: 0;
 *  Mode:Host and Device
 *  Host Negotiation Detected (HstNegDet)
 *  The core sets this bit when it detects a host negotiation request on the USB. This
 *  bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_GOTGINT_HSTNEGDET    (BIT(17))
#define USB_OTGHS_GOTGINT_HSTNEGDET_M  (USB_OTGHS_GOTGINT_HSTNEGDET_V << USB_OTGHS_GOTGINT_HSTNEGDET_S)
#define USB_OTGHS_GOTGINT_HSTNEGDET_V  0x00000001U
#define USB_OTGHS_GOTGINT_HSTNEGDET_S  17
/** USB_OTGHS_GOTGINT_ADEVTOUTCHG : R/W; bitpos: [18]; default: 0;
 *  Mode: Host and Device
 *  A-Device Timeout Change (ADevTOUTChg)
 *  The core sets this bit to indicate that the A-device has timed out while waiting
 *  for the B-device to connect.This bit can be set only by the core and the
 *  application must write 1 to clear it.
 */
#define USB_OTGHS_GOTGINT_ADEVTOUTCHG    (BIT(18))
#define USB_OTGHS_GOTGINT_ADEVTOUTCHG_M  (USB_OTGHS_GOTGINT_ADEVTOUTCHG_V << USB_OTGHS_GOTGINT_ADEVTOUTCHG_S)
#define USB_OTGHS_GOTGINT_ADEVTOUTCHG_V  0x00000001U
#define USB_OTGHS_GOTGINT_ADEVTOUTCHG_S  18
/** USB_OTGHS_GOTGINT_DBNCEDONE : R/W; bitpos: [19]; default: 0;
 *  Mode: Host only
 *  Debounce Done (DbnceDone)
 *  The core sets this bit when the debounce is completed after the device connect. The
 *  application can start driving USB reset after seeing this interrupt. This bit is
 *  only valid when the HNP Capable or SRP Capable bit is SET in the Core USB
 *  Configuration register (GUSBCFG.HNPCap or GUSBCFG.SRPCap, respectively). This bit
 *  can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_GOTGINT_DBNCEDONE    (BIT(19))
#define USB_OTGHS_GOTGINT_DBNCEDONE_M  (USB_OTGHS_GOTGINT_DBNCEDONE_V << USB_OTGHS_GOTGINT_DBNCEDONE_S)
#define USB_OTGHS_GOTGINT_DBNCEDONE_V  0x00000001U
#define USB_OTGHS_GOTGINT_DBNCEDONE_S  19
/** USB_OTGHS_GOTGINT_MULTVALIPCHNG : R/W; bitpos: [20]; default: 0;
 *  This bit when set indicates that there is a change in the value of at least one ACA
 *  pin value.
 *  This bit is present only if OTG_BC_SUPPORT=1, otherwise it is reserved.
 */
#define USB_OTGHS_GOTGINT_MULTVALIPCHNG    (BIT(20))
#define USB_OTGHS_GOTGINT_MULTVALIPCHNG_M  (USB_OTGHS_GOTGINT_MULTVALIPCHNG_V << USB_OTGHS_GOTGINT_MULTVALIPCHNG_S)
#define USB_OTGHS_GOTGINT_MULTVALIPCHNG_V  0x00000001U
#define USB_OTGHS_GOTGINT_MULTVALIPCHNG_S  20

/** USB_OTGHS_GAHBCFG_REG register
 *  This register can be used to configure the core after power-on or a change in mode.
 *  This register mainly contains AHB system-related configuration parameters. Do not
 *  change this register after the initial programming. The application must program
 *  this register before starting any transactions on either the AHB or the USB.
 */
#define USB_OTGHS_GAHBCFG_REG (DR_REG_USB_OTGHS_BASE + 0x8)
/** USB_OTGHS_GAHBCFG_GLBLINTRMSK : R/W; bitpos: [0]; default: 0;
 *  Mode: Host and device
 *  Global Interrupt Mask (GlblIntrMsk)
 *  The application uses this bit to mask or unmask the interrupt line assertion to
 *  itself. Irrespective of this bit's setting, the interrupt status registers are
 *  updated by the controller.
 */
#define USB_OTGHS_GAHBCFG_GLBLINTRMSK    (BIT(0))
#define USB_OTGHS_GAHBCFG_GLBLINTRMSK_M  (USB_OTGHS_GAHBCFG_GLBLINTRMSK_V << USB_OTGHS_GAHBCFG_GLBLINTRMSK_S)
#define USB_OTGHS_GAHBCFG_GLBLINTRMSK_V  0x00000001U
#define USB_OTGHS_GAHBCFG_GLBLINTRMSK_S  0
/** USB_OTGHS_GAHBCFG_HBSTLEN : R/W; bitpos: [4:1]; default: 0;
 *  Mode: Host and device
 *  Burst Length/Type (HBstLen)
 *  This field is used in both External and Internal DMA modes. In External DMA mode,
 *  these bits appear on dma_burst[3:0] ports, which can be used by an external wrapper
 *  to interface the External DMA Controller interface to Synopsis DW_ahb_dmac or ARM
 *  PrimeCell.
 *  External DMA Mode defines the DMA burst length in terms of 32-bit words:
 *  - 4'b0000: 1 word
 *  - 4'b0001: 4 words
 *  - 4'b0010: 8 words
 *  - 4'b0011: 16 words
 *  - 4'b0100: 32 words
 *  - 4'b0101: 64 words
 *  - 4'b0110: 128 words
 *  - 4'b0111: 256 words
 *  - Others: Reserved
 *  Internal DMA Mode AHB Master burst type:
 *  - 4'b0000 Single
 *  - 4'b0001 INCR
 *  - 4'b0011 INCR4
 *  - 4'b0101 INCR8
 *  - 4'b0111 INCR16
 *  - Others: Reserved
 */
#define USB_OTGHS_GAHBCFG_HBSTLEN    0x0000000FU
#define USB_OTGHS_GAHBCFG_HBSTLEN_M  (USB_OTGHS_GAHBCFG_HBSTLEN_V << USB_OTGHS_GAHBCFG_HBSTLEN_S)
#define USB_OTGHS_GAHBCFG_HBSTLEN_V  0x0000000FU
#define USB_OTGHS_GAHBCFG_HBSTLEN_S  1
/** USB_OTGHS_GAHBCFG_DMAEN : R/W; bitpos: [5]; default: 0;
 *  Mode: Host and device
 *  DMA Enable (DMAEn)
 *
 *  This bit is always 0 when Slave-Only mode has been selected.
 *
 *  Reset: 1'b0
 */
#define USB_OTGHS_GAHBCFG_DMAEN    (BIT(5))
#define USB_OTGHS_GAHBCFG_DMAEN_M  (USB_OTGHS_GAHBCFG_DMAEN_V << USB_OTGHS_GAHBCFG_DMAEN_S)
#define USB_OTGHS_GAHBCFG_DMAEN_V  0x00000001U
#define USB_OTGHS_GAHBCFG_DMAEN_S  5
/** USB_OTGHS_GAHBCFG_NPTXFEMPLVL : R/W; bitpos: [7]; default: 0;
 *  Mode: Host and device
 *  Non-Periodic TxFIFO Empty Level (NPTxFEmpLvl)
 *  This bit is used only in Slave mode. In host mode and with Shared FIFO with device
 *  mode, this bit indicates when the Non-Periodic TxFIFO Empty Interrupt bit in the
 *  Core Interrupt register (GINTSTS.NPTxFEmp) is triggered.
 *  With dedicated FIFO in device mode, this bit indicates when IN endpoint Transmit
 *  FIFO empty interrupt (DIEPINTn.TxFEmp) is triggered.
 *  Host mode and with Shared FIFO with device mode:
 *  - 1'b0: GINTSTS.NPTxFEmp interrupt indicates that the Non-Periodic TxFIFO is half
 *  empty
 *  - 1'b1: GINTSTS.NPTxFEmp interrupt indicates that the Non-Periodic TxFIFO is
 *  completely empty
 *  Dedicated FIFO in device mode:
 *  - 1'b0: DIEPINTn.TxFEmp interrupt indicates that the IN Endpoint TxFIFO is half
 *  empty
 *  - 1'b1: DIEPINTn.TxFEmp interrupt indicates that the IN Endpoint TxFIFO is
 *  completely empty
 */
#define USB_OTGHS_GAHBCFG_NPTXFEMPLVL    (BIT(7))
#define USB_OTGHS_GAHBCFG_NPTXFEMPLVL_M  (USB_OTGHS_GAHBCFG_NPTXFEMPLVL_V << USB_OTGHS_GAHBCFG_NPTXFEMPLVL_S)
#define USB_OTGHS_GAHBCFG_NPTXFEMPLVL_V  0x00000001U
#define USB_OTGHS_GAHBCFG_NPTXFEMPLVL_S  7
/** USB_OTGHS_GAHBCFG_PTXFEMPLVL : R/W; bitpos: [8]; default: 0;
 *  Mode: Host only
 *  Periodic TxFIFO Empty Level (PTxFEmpLvl)
 *  Indicates when the Periodic TxFIFO Empty Interrupt bit in the Core Interrupt
 *  register (GINTSTS.PTxFEmp) is triggered. This bit is used only in Slave mode.
 *  - 1'b0: GINTSTS.PTxFEmp interrupt indicates that the Periodic TxFIFO is half empty
 *  - 1'b1: GINTSTS.PTxFEmp interrupt indicates that the Periodic TxFIFO is completely
 *  empty
 */
#define USB_OTGHS_GAHBCFG_PTXFEMPLVL    (BIT(8))
#define USB_OTGHS_GAHBCFG_PTXFEMPLVL_M  (USB_OTGHS_GAHBCFG_PTXFEMPLVL_V << USB_OTGHS_GAHBCFG_PTXFEMPLVL_S)
#define USB_OTGHS_GAHBCFG_PTXFEMPLVL_V  0x00000001U
#define USB_OTGHS_GAHBCFG_PTXFEMPLVL_S  8
/** USB_OTGHS_GAHBCFG_REMMEMSUPP : R/W; bitpos: [21]; default: 0;
 *  Mode: Host and Device
 *  Remote Memory Support (RemMemSupp)
 *  This bit is programmed to enable the functionality to wait for the system DMA Done
 *  Signal for the DMA Write Transfers.
 *  - GAHBCFG.RemMemSupp=1
 *  The int_dma_req output signal is asserted when the DMA starts write transfer to the
 *  external memory. When the core is done with the Transfers it asserts int_dma_done
 *  signal to flag the completion of DMA writes from the controller. The core then
 *  waits for sys_dma_done signal from the system to proceed further and complete the
 *  Data Transfer corresponding to a particular Channel/Endpoint.
 *  - GAHBCFG.RemMemSupp=0
 *  The int_dma_req and int_dma_done signals are not asserted and the core proceeds
 *  with the assertion of the XferComp interrupt as soon as the DMA write transfer is
 *  done at the Core Boundary and it does not wait for the sys_dma_done signal to
 *  complete the DATA transfers.
 */
#define USB_OTGHS_GAHBCFG_REMMEMSUPP    (BIT(21))
#define USB_OTGHS_GAHBCFG_REMMEMSUPP_M  (USB_OTGHS_GAHBCFG_REMMEMSUPP_V << USB_OTGHS_GAHBCFG_REMMEMSUPP_S)
#define USB_OTGHS_GAHBCFG_REMMEMSUPP_V  0x00000001U
#define USB_OTGHS_GAHBCFG_REMMEMSUPP_S  21
/** USB_OTGHS_GAHBCFG_NOTIALLDMAWRIT : R/W; bitpos: [22]; default: 0;
 *  Mode: Host and Device
 *  Notify All DMA Write Transactions (NotiAllDmaWrit)
 *  This bit is programmed to enable the System DMA Done functionality for all the DMA
 *  write Transactions corresponding to the Channel/Endpoint. This bit is valid only
 *  when GAHBCFG.RemMemSupp is set to 1.
 *  - GAHBCFG.NotiAllDmaWrit = 1
 *  The core asserts int_dma_req for all the DMA write transactions on the AHB
 *  interface along with int_dma_done, chep_last_transact and chep_number signal
 *  information. The core waits for sys_dma_done signal for all the DMA write
 *  transactions in order to complete the transfer of a particular Channel/Endpoint.
 *  - GAHBCFG.NotiAllDmaWrit = 0
 *  The core asserts int_dma_req signal only for the last transaction of DMA write
 *  transfer corresponding to a particular Channel/Endpoint. Similarly, the core waits
 *  for sys_dma_done signal only for that transaction of DMA write to complete the
 *  transfer of a particular Channel/Endpoint.
 */
#define USB_OTGHS_GAHBCFG_NOTIALLDMAWRIT    (BIT(22))
#define USB_OTGHS_GAHBCFG_NOTIALLDMAWRIT_M  (USB_OTGHS_GAHBCFG_NOTIALLDMAWRIT_V << USB_OTGHS_GAHBCFG_NOTIALLDMAWRIT_S)
#define USB_OTGHS_GAHBCFG_NOTIALLDMAWRIT_V  0x00000001U
#define USB_OTGHS_GAHBCFG_NOTIALLDMAWRIT_S  22
/** USB_OTGHS_GAHBCFG_AHBSINGLE : R/W; bitpos: [23]; default: 0;
 *  Mode: Host and Device
 *  AHB Single Support (AHBSingle)
 *  This bit when programmed supports Single transfers for the remaining data in a
 *  transfer when the core is operating in DMA mode.
 *  - 1'b0: The remaining data in the transfer is sent using INCR burst size.
 *  - 1'b1: The remaining data in the transfer is sent using Single burst size.
 *  Note: If this feature is enabled, the AHB RETRY and SPLIT transfers still have INCR
 *  burst type. Enable this feature when the AHB Slave connected to the core does not
 *  support INCR burst (and when Split, and Retry transactions are not being used in
 *  the bus).
 */
#define USB_OTGHS_GAHBCFG_AHBSINGLE    (BIT(23))
#define USB_OTGHS_GAHBCFG_AHBSINGLE_M  (USB_OTGHS_GAHBCFG_AHBSINGLE_V << USB_OTGHS_GAHBCFG_AHBSINGLE_S)
#define USB_OTGHS_GAHBCFG_AHBSINGLE_V  0x00000001U
#define USB_OTGHS_GAHBCFG_AHBSINGLE_S  23
/** USB_OTGHS_GAHBCFG_INVDESCENDIANESS : R/W; bitpos: [24]; default: 0;
 *  Mode: Host and Device
 *  Invert Descriptor Endianness (InvDescEndianess)
 *  - 1'b0: Descriptor Endianness is same as AHB Master Endianness.
 *  - 1'b1:
 *  -- If the AHB Master endianness is Big Endian, the Descriptor Endianness is Little
 *  Endian.
 *  -- If the AHB Master endianness is Little Endian, the Descriptor Endianness is Big
 *  Endian.
 */
#define USB_OTGHS_GAHBCFG_INVDESCENDIANESS    (BIT(24))
#define USB_OTGHS_GAHBCFG_INVDESCENDIANESS_M  (USB_OTGHS_GAHBCFG_INVDESCENDIANESS_V << USB_OTGHS_GAHBCFG_INVDESCENDIANESS_S)
#define USB_OTGHS_GAHBCFG_INVDESCENDIANESS_V  0x00000001U
#define USB_OTGHS_GAHBCFG_INVDESCENDIANESS_S  24

/** USB_OTGHS_GUSBCFG_REG register
 *  This register can be used to configure the core after power-on or when changing to
 *  Host mode or Device mode. It contains USB and USB-PHY related configuration
 *  parameters. The application must program this register before starting any
 *  transactions on either the AHB or the USB. If you are using the HSIC interface,
 *  HSIC PHY must be in reset while programming this register. Do not make changes to
 *  this register after the initial programming.
 */
#define USB_OTGHS_GUSBCFG_REG (DR_REG_USB_OTGHS_BASE + 0xc)
/** USB_OTGHS_GUSBCFG_TOUTCAL : R/W; bitpos: [2:0]; default: 0;
 *  Mode: Host and Device
 *  HS/FS Timeout Calibration (TOutCal)
 *
 *  The number of PHY clocks that the application programs in this field is added to
 *  the high-speed/full-speed interpacket timeout duration in the core to account for
 *  any additional delays introduced by the PHY. This can be required, because the
 *  delay introduced by the PHY in generating the linestate condition can vary from one
 *  PHY to another.
 *
 *  The USB standard timeout value for high-speed operation is 736 to 816 (inclusive)
 *  bit times. The USB standard timeout value for full-speed operation is 16 to 18
 *  (inclusive) bit times. The application must program this field based on the speed
 *  of enumeration. The number of bit times added per PHY clock are as follows:
 *
 *  High-speed operation:
 *  - One 30-MHz PHY clock = 16 bit times
 *  - One 60-MHz PHY clock = 8 bit times
 *  Full-speed operation:
 *  - One 30-MHz PHY clock = 0.4 bit times
 *  - One 60-MHz PHY clock = 0.2 bit times
 *  - One 48-MHz PHY clock = 0.25 bit times
 */
#define USB_OTGHS_GUSBCFG_TOUTCAL    0x00000007U
#define USB_OTGHS_GUSBCFG_TOUTCAL_M  (USB_OTGHS_GUSBCFG_TOUTCAL_V << USB_OTGHS_GUSBCFG_TOUTCAL_S)
#define USB_OTGHS_GUSBCFG_TOUTCAL_V  0x00000007U
#define USB_OTGHS_GUSBCFG_TOUTCAL_S  0
/** USB_OTGHS_GUSBCFG_PHYIF : R/W; bitpos: [3]; default: 0;
 *  Mode: Host and Device
 *  PHY Interface (PHYIf)
 *  The application uses this bit to configure the core to support a UTMI+ PHY with an
 *  8- or 16-bit interface. When a ULPI PHY is chosen, this must be Set to 8-bit mode.
 *  - 1'b0: 8 bits
 *  - 1'b1: 16 bits
 *  This bit is writable only If UTMI+ and ULPI were selected. Otherwise, this bit
 *  returns the value for the power-on interface selected during configuration.
 */
#define USB_OTGHS_GUSBCFG_PHYIF    (BIT(3))
#define USB_OTGHS_GUSBCFG_PHYIF_M  (USB_OTGHS_GUSBCFG_PHYIF_V << USB_OTGHS_GUSBCFG_PHYIF_S)
#define USB_OTGHS_GUSBCFG_PHYIF_V  0x00000001U
#define USB_OTGHS_GUSBCFG_PHYIF_S  3
/** USB_OTGHS_GUSBCFG_ULPI_UTMI_SEL : R/W; bitpos: [4]; default: 0;
 *  Mode: Host and Device
 *  ULPI or UTMI+ Select (ULPI_UTMI_Sel)
 *
 *  The application uses this bit to select either a UTMI+ interface or ULPI Interface.
 *  - 1'b0: UTMI+ Interface
 *  - 1'b1: ULPI Interface
 */
#define USB_OTGHS_GUSBCFG_ULPI_UTMI_SEL    (BIT(4))
#define USB_OTGHS_GUSBCFG_ULPI_UTMI_SEL_M  (USB_OTGHS_GUSBCFG_ULPI_UTMI_SEL_V << USB_OTGHS_GUSBCFG_ULPI_UTMI_SEL_S)
#define USB_OTGHS_GUSBCFG_ULPI_UTMI_SEL_V  0x00000001U
#define USB_OTGHS_GUSBCFG_ULPI_UTMI_SEL_S  4
/** USB_OTGHS_GUSBCFG_FSINTF : R/W; bitpos: [5]; default: 0;
 *  Mode: Host and Device
 *  Full-Speed Serial Interface Select (FSIntf)
 *
 *  The application uses this bit to select either a unidirectional or bidirectional
 *  USB 1.1 full-speed serial transceiver interface.
 *  - 1'b0: 6-pin unidirectional full-speed serial interface
 *  - 1'b1: 3-pin bidirectional full-speed serial interface
 *  If a USB 1.1 Full-Speed Serial Transceiver interface was not selected, this bit is
 *  always 0, with Write Only access. If a USB 1.1 FS interface was selected, Then the
 *  application can Set this bit to select between the 3- and 6-pin interfaces, and
 *  access is Read and Write.
 *
 *  Note: For supporting the new 4-pin bi-directional interface, you need to select
 *  6-pin unidirectional FS serial mode, and add an external control to convert it to a
 *  4-pin interface.
 */
#define USB_OTGHS_GUSBCFG_FSINTF    (BIT(5))
#define USB_OTGHS_GUSBCFG_FSINTF_M  (USB_OTGHS_GUSBCFG_FSINTF_V << USB_OTGHS_GUSBCFG_FSINTF_S)
#define USB_OTGHS_GUSBCFG_FSINTF_V  0x00000001U
#define USB_OTGHS_GUSBCFG_FSINTF_S  5
/** USB_OTGHS_GUSBCFG_PHYSEL : R/W; bitpos: [6]; default: 0;
 *  PHYSel
 *
 *  Mode: Host and Device
 *
 *  USB 2.0 High-Speed PHY or USB 1.1 Full-Speed Serial Transceiver Select (PHYSel)
 *  The application uses this bit to select either a high-speed UTMI+ or ULPI PHY, or a
 *  full-speed transceiver.
 *  - 1'b0: USB 2.0 high-speed UTMI+ or ULPI PHY
 *  - 1'b1: USB 1.1 full-speed serial transceiver
 *  If a USB 1.1 Full-Speed Serial Transceiver interface was not selected in, this bit
 *  is always 0, with Write Only access.
 *  If a high-speed PHY interface was not selected in, this bit is always 1, with Write
 *  Only access.
 *  If both interface types were selected (parameters have non-zero values), the
 *  application uses this bit to select which interface is active, and access is Read
 *  and Write.
 */
#define USB_OTGHS_GUSBCFG_PHYSEL    (BIT(6))
#define USB_OTGHS_GUSBCFG_PHYSEL_M  (USB_OTGHS_GUSBCFG_PHYSEL_V << USB_OTGHS_GUSBCFG_PHYSEL_S)
#define USB_OTGHS_GUSBCFG_PHYSEL_V  0x00000001U
#define USB_OTGHS_GUSBCFG_PHYSEL_S  6
/** USB_OTGHS_GUSBCFG_DDRSEL : R/W; bitpos: [7]; default: 0;
 *  Mode: Host and Device
 *  ULPI DDR Select (DDRSel)
 *  The application uses this bit to select a Single Data Rate (SDR) or Double Data
 *  Rate (DDR) or ULPI interface.
 *  - 1'b0: Single Data Rate ULPI Interface, with 8-bit-wide data bus
 *  - 1'b1: Double Data Rate ULPI Interface, with 4-bit-wide data bus
 */
#define USB_OTGHS_GUSBCFG_DDRSEL    (BIT(7))
#define USB_OTGHS_GUSBCFG_DDRSEL_M  (USB_OTGHS_GUSBCFG_DDRSEL_V << USB_OTGHS_GUSBCFG_DDRSEL_S)
#define USB_OTGHS_GUSBCFG_DDRSEL_V  0x00000001U
#define USB_OTGHS_GUSBCFG_DDRSEL_S  7
/** USB_OTGHS_GUSBCFG_USBTRDTIM : R/W; bitpos: [13:10]; default: 5;
 *  Mode: Device only
 *  USB Turnaround Time (USBTrdTim)
 *  Sets the turnaround time in PHY clocks. Specifies the response time for a MAC
 *  request to the Packet FIFO Controller (PFC) to fetch data from the DFIFO (SPRAM).
 *  This must be programmed to
 *  - 4'h5 : When the MAC interface is 16-bit UTMI+
 *  - 4'h9 : When the MAC interface is 8-bit UTMI+
 *  Note:Refer to Programming Guide Section Choosing the Value of GUSBCFG.USBTrdTim for
 *  the turnaround time calculation. During the AHB Clock Frequency selection, it is
 *  recommended to consider mis-sampling into account for USBTrdTim. USB turnaround
 *  time is critical for certification where long cables and 5-Hubs are used. If you
 *  need the AHB to run at less than 30 MHz (or less than 42MHz when operating in
 *  16-bit UTMI mode in HS speed), and if USB turnaround time is not critical, these
 *  bits can be programmed to a larger value.
 */
#define USB_OTGHS_GUSBCFG_USBTRDTIM    0x0000000FU
#define USB_OTGHS_GUSBCFG_USBTRDTIM_M  (USB_OTGHS_GUSBCFG_USBTRDTIM_V << USB_OTGHS_GUSBCFG_USBTRDTIM_S)
#define USB_OTGHS_GUSBCFG_USBTRDTIM_V  0x0000000FU
#define USB_OTGHS_GUSBCFG_USBTRDTIM_S  10
/** USB_OTGHS_GUSBCFG_PHYLPWRCLKSEL : R/W; bitpos: [15]; default: 0;
 *  PHY Low-Power Clock Select (PhyLPwrClkSel)
 *  Mode: Host and Device
 *  Selects either 480-MHz or 48-MHz (low-power) PHY mode. In FS and LS modes, the PHY
 *  can usually operate on a 48-MHz clock to save power.
 *  - 1'b0: 480-MHz Internal PLL clock
 *  - 1'b1: 48-MHz External Clock
 *  In 480 MHz mode, the UTMI interface operates at either 60 or 30-MHz, depending upon
 *  whether 8- or 16-bit data width is selected.
 *  In 48-MHz mode, the UTMI interface operates at 48 MHz in FS mode and at either 48
 *  or 6 MHz in LS mode (depending on the PHY vendor). This bit drives the
 *  utmi_fsls_low_power core output signal, and is valid only for UTMI+ PHYs.
 */
#define USB_OTGHS_GUSBCFG_PHYLPWRCLKSEL    (BIT(15))
#define USB_OTGHS_GUSBCFG_PHYLPWRCLKSEL_M  (USB_OTGHS_GUSBCFG_PHYLPWRCLKSEL_V << USB_OTGHS_GUSBCFG_PHYLPWRCLKSEL_S)
#define USB_OTGHS_GUSBCFG_PHYLPWRCLKSEL_V  0x00000001U
#define USB_OTGHS_GUSBCFG_PHYLPWRCLKSEL_S  15
/** USB_OTGHS_GUSBCFG_ULPIFSLS : R/W; bitpos: [17]; default: 0;
 *  Mode: Host and Device
 *  ULPI FS/LS Select (ULPIFsLs)
 *  The application uses this bit to select the FS/LS serial interface for the ULPI
 *  PHY. This bit is valid only when the FS serial transceiver is selected on the ULPI
 *  PHY.
 *  - 1'b0: ULPI interface
 *  - 1'b1: ULPI FS/LS serial interface
 *  Note: Before setting this bit, the application needs to ensure that
 *  GUSBCFG.ULPI_UTMI_SEL = 1'b1.
 */
#define USB_OTGHS_GUSBCFG_ULPIFSLS    (BIT(17))
#define USB_OTGHS_GUSBCFG_ULPIFSLS_M  (USB_OTGHS_GUSBCFG_ULPIFSLS_V << USB_OTGHS_GUSBCFG_ULPIFSLS_S)
#define USB_OTGHS_GUSBCFG_ULPIFSLS_V  0x00000001U
#define USB_OTGHS_GUSBCFG_ULPIFSLS_S  17
/** USB_OTGHS_GUSBCFG_ULPIAUTORES : R/W; bitpos: [18]; default: 0;
 *  Mode: Host and Device
 *  ULPI Auto Resume (ULPIAutoRes)
 *  This bit sets the AutoResume bit in the Interface Control register on the ULPI PHY.
 *  - 1'b0: PHY does not use AutoResume feature.
 *  - 1'b1: PHY uses AutoResume feature.
 */
#define USB_OTGHS_GUSBCFG_ULPIAUTORES    (BIT(18))
#define USB_OTGHS_GUSBCFG_ULPIAUTORES_M  (USB_OTGHS_GUSBCFG_ULPIAUTORES_V << USB_OTGHS_GUSBCFG_ULPIAUTORES_S)
#define USB_OTGHS_GUSBCFG_ULPIAUTORES_V  0x00000001U
#define USB_OTGHS_GUSBCFG_ULPIAUTORES_S  18
/** USB_OTGHS_GUSBCFG_ULPICLKSUSM : R/W; bitpos: [19]; default: 0;
 *  Mode: Host and Device
 *  ULPI Clock SuspendM (ULPIClkSusM)
 *  This bit sets the ClockSuspendM bit in the Interface Control register on the ULPI
 *  PHY. This bit applies only in serial or carkit modes.
 *  - 1'b0: PHY powers down internal clock during suspend.
 *  - 1'b1: PHY does not power down internal clock.
 */
#define USB_OTGHS_GUSBCFG_ULPICLKSUSM    (BIT(19))
#define USB_OTGHS_GUSBCFG_ULPICLKSUSM_M  (USB_OTGHS_GUSBCFG_ULPICLKSUSM_V << USB_OTGHS_GUSBCFG_ULPICLKSUSM_S)
#define USB_OTGHS_GUSBCFG_ULPICLKSUSM_V  0x00000001U
#define USB_OTGHS_GUSBCFG_ULPICLKSUSM_S  19
/** USB_OTGHS_GUSBCFG_ULPIEXTVBUSDRV : R/W; bitpos: [20]; default: 0;
 *  Mode: Host only
 *  ULPI External VBUS Drive (ULPIExtVbusDrv)
 *  This bit selects between internal or external supply to drive 5V on VBUS, in ULPI
 *  PHY.
 *  - 1'b0: PHY drives VBUS using internal charge pump (Default).
 *  - 1'b1: PHY drives VBUS using external supply.
 */
#define USB_OTGHS_GUSBCFG_ULPIEXTVBUSDRV    (BIT(20))
#define USB_OTGHS_GUSBCFG_ULPIEXTVBUSDRV_M  (USB_OTGHS_GUSBCFG_ULPIEXTVBUSDRV_V << USB_OTGHS_GUSBCFG_ULPIEXTVBUSDRV_S)
#define USB_OTGHS_GUSBCFG_ULPIEXTVBUSDRV_V  0x00000001U
#define USB_OTGHS_GUSBCFG_ULPIEXTVBUSDRV_S  20
/** USB_OTGHS_GUSBCFG_ULPIEXTVBUSINDICATOR : R/W; bitpos: [21]; default: 0;
 *  Mode: Host only
 *  ULPI External VBUS Indicator (ULPIExtVbusIndicator)
 *  This bit indicates to the ULPI PHY to use an external VBUS overcurrent indicator.
 *  - 1'b0: PHY uses internal VBUS valid comparator.
 *  - 1'b1: PHY uses external VBUS valid comparator.
 */
#define USB_OTGHS_GUSBCFG_ULPIEXTVBUSINDICATOR    (BIT(21))
#define USB_OTGHS_GUSBCFG_ULPIEXTVBUSINDICATOR_M  (USB_OTGHS_GUSBCFG_ULPIEXTVBUSINDICATOR_V << USB_OTGHS_GUSBCFG_ULPIEXTVBUSINDICATOR_S)
#define USB_OTGHS_GUSBCFG_ULPIEXTVBUSINDICATOR_V  0x00000001U
#define USB_OTGHS_GUSBCFG_ULPIEXTVBUSINDICATOR_S  21
/** USB_OTGHS_GUSBCFG_TERMSELDLPULSE : R/W; bitpos: [22]; default: 0;
 *  Mode: Device only
 *  TermSel DLine Pulsing Selection (TermSelDLPulse)
 *  This bit selects utmi_termselect to drive data line pulse during SRP.
 *  - 1'b0: Data line pulsing using utmi_txvalid (Default).
 *  - 1'b1: Data line pulsing using utmi_termsel.
 */
#define USB_OTGHS_GUSBCFG_TERMSELDLPULSE    (BIT(22))
#define USB_OTGHS_GUSBCFG_TERMSELDLPULSE_M  (USB_OTGHS_GUSBCFG_TERMSELDLPULSE_V << USB_OTGHS_GUSBCFG_TERMSELDLPULSE_S)
#define USB_OTGHS_GUSBCFG_TERMSELDLPULSE_V  0x00000001U
#define USB_OTGHS_GUSBCFG_TERMSELDLPULSE_S  22
/** USB_OTGHS_GUSBCFG_COMPLEMENT : R/W; bitpos: [23]; default: 0;
 *  Mode: Host only
 *  Indicator Complement Controls the PHY to invert the ExternalVbusIndicator input
 *  signal, generating the Complement Output. For more information, refer to the ULPI
 *  Specification.
 *  - 1'b0: PHY does not invert ExternalVbusIndicator signal
 *  - 1'b1: PHY does invert ExternalVbusIndicator signal
 *  This bit is reserved and read-only when OTG_HSPHY_INTERFACE is set to 0 or 1.
 */
#define USB_OTGHS_GUSBCFG_COMPLEMENT    (BIT(23))
#define USB_OTGHS_GUSBCFG_COMPLEMENT_M  (USB_OTGHS_GUSBCFG_COMPLEMENT_V << USB_OTGHS_GUSBCFG_COMPLEMENT_S)
#define USB_OTGHS_GUSBCFG_COMPLEMENT_V  0x00000001U
#define USB_OTGHS_GUSBCFG_COMPLEMENT_S  23
/** USB_OTGHS_GUSBCFG_INDICATOR : R/W; bitpos: [24]; default: 0;
 *  Mode: Host only
 *  Indicator Pass Through
 *  Controls whether the Complement Output is qualified with the Internal Vbus Valid
 *  comparator before being used in the Vbus State in the RX CMD. For more information,
 *  refer to the ULPI Specification.
 *  - 1'b0: Complement Output signal is qualified with the Internal VbusValid
 *  comparator.
 *  - 1'b1: Complement Output signal is not qualified with the Internal VbusValid
 *  comparator.
 *  This bit is reserved and read-only when OTG_HSPHY_INTERFACE is set to 0 or 1.
 */
#define USB_OTGHS_GUSBCFG_INDICATOR    (BIT(24))
#define USB_OTGHS_GUSBCFG_INDICATOR_M  (USB_OTGHS_GUSBCFG_INDICATOR_V << USB_OTGHS_GUSBCFG_INDICATOR_S)
#define USB_OTGHS_GUSBCFG_INDICATOR_V  0x00000001U
#define USB_OTGHS_GUSBCFG_INDICATOR_S  24
/** USB_OTGHS_GUSBCFG_ULPI : R/W; bitpos: [25]; default: 0;
 *  Mode: Host only
 *  ULPI Interface Protect Disable
 *  Controls circuitry built into the PHY for protecting the ULPI interface when the
 *  link tri-states STP and data. Any pull-ups or pull-downs employed by this feature
 *  can be disabled. For more information, refer to the ULPI Specification.
 *  - 1'b0: Enables the interface protect circuit
 *  - 1'b1: Disables the interface protect circuit
 */
#define USB_OTGHS_GUSBCFG_ULPI    (BIT(25))
#define USB_OTGHS_GUSBCFG_ULPI_M  (USB_OTGHS_GUSBCFG_ULPI_V << USB_OTGHS_GUSBCFG_ULPI_S)
#define USB_OTGHS_GUSBCFG_ULPI_V  0x00000001U
#define USB_OTGHS_GUSBCFG_ULPI_S  25
/** USB_OTGHS_GUSBCFG_IC_USBCAP : RO; bitpos: [26]; default: 0;
 *  Mode: Host and Device
 *  IC_USB-Capable (IC_USBCap)
 *  The application uses this bit to control the core's IC_USB capabilities.
 *  - 1'b0: IC_USB PHY Interface is not selected.
 *  - 1'b1: IC_USB PHY Interface is selected.
 *  This bit is writable only if OTG_ENABLE_IC_USB=1 and OTG_FSPHY_INTERFACE!=0.
 *  The reset value depends on the configuration parameter OTG_SELECT_IC_USB when
 *  OTG_ENABLE_IC_USB = 1. In all other cases, this bit is set to 1'b0 and the bit is
 *  read only.
 */
#define USB_OTGHS_GUSBCFG_IC_USBCAP    (BIT(26))
#define USB_OTGHS_GUSBCFG_IC_USBCAP_M  (USB_OTGHS_GUSBCFG_IC_USBCAP_V << USB_OTGHS_GUSBCFG_IC_USBCAP_S)
#define USB_OTGHS_GUSBCFG_IC_USBCAP_V  0x00000001U
#define USB_OTGHS_GUSBCFG_IC_USBCAP_S  26
/** USB_OTGHS_GUSBCFG_TXENDDELAY : R/W; bitpos: [28]; default: 1;
 *  Mode: Device only
 *  Tx End Delay (TxEndDelay)
 *  Setting this bit to 1'b1 enables the controller to follow the TxEndDelay timings as
 *  per UTMI+ specification 1.05 section 4.1.5 for opmode signal during remote wakeup.
 *  - 1'b0 : Normal Mode.
 *  - 1'b1 : Tx End delay.
 *  The default value of this field is 1'b1 and it is not recommended to program it to
 *  1'b0. The option to set it to 1'b0 (Normal Mode) is present only for debug purpose.
 */
#define USB_OTGHS_GUSBCFG_TXENDDELAY    (BIT(28))
#define USB_OTGHS_GUSBCFG_TXENDDELAY_M  (USB_OTGHS_GUSBCFG_TXENDDELAY_V << USB_OTGHS_GUSBCFG_TXENDDELAY_S)
#define USB_OTGHS_GUSBCFG_TXENDDELAY_V  0x00000001U
#define USB_OTGHS_GUSBCFG_TXENDDELAY_S  28
/** USB_OTGHS_GUSBCFG_FORCEHSTMODE : R/W; bitpos: [29]; default: 0;
 *  Mode: Host and device
 *  Force Host Mode (ForceHstMode)
 *  Writing a 1 to this bit forces the core to host mode irrespective of utmiotg_iddig
 *  input pin.
 *  - 1'b0 : Normal Mode.
 *  - 1'b1 : Force Host Mode.
 *  After setting the force bit, the application must wait at least 25 ms before the
 *  change to take effect. When the simulation is in scale down mode, waiting for 500
 *  micro sec is sufficient. This bit is valid only when OTG_MODE = 0, 1 or 2. In all
 *  other cases, this bit reads 0.
 */
#define USB_OTGHS_GUSBCFG_FORCEHSTMODE    (BIT(29))
#define USB_OTGHS_GUSBCFG_FORCEHSTMODE_M  (USB_OTGHS_GUSBCFG_FORCEHSTMODE_V << USB_OTGHS_GUSBCFG_FORCEHSTMODE_S)
#define USB_OTGHS_GUSBCFG_FORCEHSTMODE_V  0x00000001U
#define USB_OTGHS_GUSBCFG_FORCEHSTMODE_S  29
/** USB_OTGHS_GUSBCFG_FORCEDEVMODE : R/W; bitpos: [30]; default: 0;
 *  Mode:Host and device
 *  Force Device Mode (ForceDevMode)
 *  Writing a 1 to this bit forces the controller to device mode irrespective of
 *  utmiotg_iddig input pin.
 *  - 1'b0 : Normal Mode.
 *  - 1'b1 : Force Device Mode.
 *  After setting the force bit, the application must wait at least 25 ms before the
 *  change to take effect. When the simulation is in scale down mode, waiting for 500
 *  micro sec is sufficient. This bit is valid only when OTG_MODE = 0, 1 or 2. In all
 *  other cases, this bit reads 0.
 */
#define USB_OTGHS_GUSBCFG_FORCEDEVMODE    (BIT(30))
#define USB_OTGHS_GUSBCFG_FORCEDEVMODE_M  (USB_OTGHS_GUSBCFG_FORCEDEVMODE_V << USB_OTGHS_GUSBCFG_FORCEDEVMODE_S)
#define USB_OTGHS_GUSBCFG_FORCEDEVMODE_V  0x00000001U
#define USB_OTGHS_GUSBCFG_FORCEDEVMODE_S  30
/** USB_OTGHS_GUSBCFG_CORRUPTTXPKT : R/W; bitpos: [31]; default: 0;
 *  Mode: Host and device
 *  Corrupt Tx packet (CorruptTxPkt)
 *  This bit is for debug purposes only. Never Set this bit to 1. The application must
 *  always write 1'b0 to this bit.
 */
#define USB_OTGHS_GUSBCFG_CORRUPTTXPKT    (BIT(31))
#define USB_OTGHS_GUSBCFG_CORRUPTTXPKT_M  (USB_OTGHS_GUSBCFG_CORRUPTTXPKT_V << USB_OTGHS_GUSBCFG_CORRUPTTXPKT_S)
#define USB_OTGHS_GUSBCFG_CORRUPTTXPKT_V  0x00000001U
#define USB_OTGHS_GUSBCFG_CORRUPTTXPKT_S  31

/** USB_OTGHS_GRSTCTL_REG register
 *  The application uses this register to reset various hardware features inside the
 *  controller.
 */
#define USB_OTGHS_GRSTCTL_REG (DR_REG_USB_OTGHS_BASE + 0x10)
/** USB_OTGHS_GRSTCTL_CSFTRST : R/W; bitpos: [0]; default: 0;
 *  Mode: Host and Device
 *  Core Soft Reset (CSftRst)
 *  Resets the hclk and phy_clock domains as follows:
 *  - Clears the interrupts and all the CSR registers except the following register
 *  bits:
 *  -- PCGCCTL.RstPdwnModule
 *  -- PCGCCTL.GateHclk
 *  -- PCGCCTL.PwrClmp
 *  -- PCGCCTL.StopPPhyLPwrClkSelclk
 *  -- GUSBCFG.ForceDevMode
 *  -- GUSBCFG.ForceHstMode
 *  -- GUSBCFG.PhyLPwrClkSel
 *  -- GUSBCFG.DDRSel
 *  -- GUSBCFG.PHYSel
 *  -- GUSBCFG.FSIntf
 *  -- GUSBCFG.ULPI_UTMI_Sel
 *  -- GUSBCFG.PHYIf
 *  -- GUSBCFG.TxEndDelay
 *  -- GUSBCFG.TermSelDLPulse
 *  -- GUSBCFG.ULPIClkSusM
 *  -- GUSBCFG.ULPIAutoRes
 *  -- GUSBCFG.ULPIFsLs
 *  -- GGPIO
 *  -- GPWRDN
 *  -- GADPCTL
 *  -- HCFG.FSLSPclkSel
 *  -- DCFG.DevSpd
 *  -- DCTL.SftDiscon
 *  - All module state machines
 *  - All module state machines (except the AHB Slave Unit) are reset to the IDLE
 *  state, and all the transmit FIFOs and the receive FIFO are flushed.
 *  - Any transactions on the AHB Master are terminated as soon as possible, after
 *  gracefully completing the last data phase of an AHB transfer. Any transactions on
 *  the USB are terminated immediately.
 *  - When Hibernation or ADP feature is enabled, the PMU module is not reset by the
 *  Core Soft Reset.
 *  The application can write to this bit any time it wants to reset the core. The
 *  application must clear this bit after checking the bit 29 of this register (Core
 *  Soft Reset Done). Software must also must check that bit 31 of this register is 1
 *  (AHB Master is IDLE) before starting any operation.
 *
 *  Typically software reset is used during software development and also when you
 *  dynamically change the PHY selection bits in the USB configuration registers listed
 *  above. When you change the PHY, the corresponding clock for the PHY is selected and
 *  used in the PHY domain. Once a new clock is selected, the PHY domain has to be
 *  reset for proper operation.
 */
#define USB_OTGHS_GRSTCTL_CSFTRST    (BIT(0))
#define USB_OTGHS_GRSTCTL_CSFTRST_M  (USB_OTGHS_GRSTCTL_CSFTRST_V << USB_OTGHS_GRSTCTL_CSFTRST_S)
#define USB_OTGHS_GRSTCTL_CSFTRST_V  0x00000001U
#define USB_OTGHS_GRSTCTL_CSFTRST_S  0
/** USB_OTGHS_GRSTCTL_PIUFSSFTRST : R/W; bitpos: [1]; default: 0;
 *  Mode: Host and Device
 *  PIU FS Dedicated Controller Soft Reset (PIUFSSftRst)
 *
 *  Resets the PIU FS Dedicated Controller
 *  All module state machines in FS Dedicated Controller of PIU are reset to the IDLE
 *  state. Used to reset the FS Dedicated controller in PIU in case of any PHY Errors
 *  like Loss of activity or Babble Error resulting in the PHY remaining in RX state
 *  for more than one frame boundary.
 *  This is a self clearing bit and core clears this bit after all the necessary logic
 *  is reset in the core.
 */
#define USB_OTGHS_GRSTCTL_PIUFSSFTRST    (BIT(1))
#define USB_OTGHS_GRSTCTL_PIUFSSFTRST_M  (USB_OTGHS_GRSTCTL_PIUFSSFTRST_V << USB_OTGHS_GRSTCTL_PIUFSSFTRST_S)
#define USB_OTGHS_GRSTCTL_PIUFSSFTRST_V  0x00000001U
#define USB_OTGHS_GRSTCTL_PIUFSSFTRST_S  1
/** USB_OTGHS_GRSTCTL_FRMCNTRRST : R/W; bitpos: [2]; default: 0;
 *  Mode: Host only
 *  Host Frame Counter Reset (FrmCntrRst)
 *  The application writes this bit to reset the (micro)Frame number counter inside the
 *  core. When the (micro)Frame counter is reset, the subsequent SOF sent out by the
 *  core has a (micro)Frame number of 0.
 *  When application writes 1 to the bit, it might not be able to read back the value
 *  as it gets cleared by the core in a few clock cycles.
 */
#define USB_OTGHS_GRSTCTL_FRMCNTRRST    (BIT(2))
#define USB_OTGHS_GRSTCTL_FRMCNTRRST_M  (USB_OTGHS_GRSTCTL_FRMCNTRRST_V << USB_OTGHS_GRSTCTL_FRMCNTRRST_S)
#define USB_OTGHS_GRSTCTL_FRMCNTRRST_V  0x00000001U
#define USB_OTGHS_GRSTCTL_FRMCNTRRST_S  2
/** USB_OTGHS_GRSTCTL_RXFFLSH : R/W; bitpos: [4]; default: 0;
 *  Mode: Host and Device
 *  RxFIFO Flush (RxFFlsh)
 *  The application can flush the entire RxFIFO using this bit, but must first ensure
 *  that the core is not in the middle of a transaction.
 *  The application must only write to this bit after checking that the controller is
 *  neither reading from the RxFIFO nor writing to the RxFIFO.
 *
 *  The application must wait until the bit is cleared before performing any other
 *  operations. This bit requires eight clocks (slowest of PHY or AHB clock) to clear.
 */
#define USB_OTGHS_GRSTCTL_RXFFLSH    (BIT(4))
#define USB_OTGHS_GRSTCTL_RXFFLSH_M  (USB_OTGHS_GRSTCTL_RXFFLSH_V << USB_OTGHS_GRSTCTL_RXFFLSH_S)
#define USB_OTGHS_GRSTCTL_RXFFLSH_V  0x00000001U
#define USB_OTGHS_GRSTCTL_RXFFLSH_S  4
/** USB_OTGHS_GRSTCTL_TXFFLSH : R/W; bitpos: [5]; default: 0;
 *  Mode: Host and Device
 *  TxFIFO Flush (TxFFlsh)
 *  This bit selectively flushes a single or all transmit FIFOs, but cannot do so If
 *  the core is in the midst of a transaction.
 *  The application must write this bit only after checking that the core is neither
 *  writing to the TxFIFO nor reading from the TxFIFO.
 *  Verify using these registers:
 *  - ReadNAK Effective Interrupt ensures the core is not reading from the FIFO
 *  - WriteGRSTCTL.AHBIdle ensures the core is not writing anything to the FIFO.
 *  Flushing is normally recommended when FIFOs are reconfigured or when switching
 *  between Shared FIFO and Dedicated Transmit FIFO operation. FIFO flushing is also
 *  recommended during device endpoint disable. The application must wait until the
 *  core clears this bit before performing any operations. This bit takes eight clocks
 *  to clear, using the slower clock of phy_clk or hclk.
 */
#define USB_OTGHS_GRSTCTL_TXFFLSH    (BIT(5))
#define USB_OTGHS_GRSTCTL_TXFFLSH_M  (USB_OTGHS_GRSTCTL_TXFFLSH_V << USB_OTGHS_GRSTCTL_TXFFLSH_S)
#define USB_OTGHS_GRSTCTL_TXFFLSH_V  0x00000001U
#define USB_OTGHS_GRSTCTL_TXFFLSH_S  5
/** USB_OTGHS_GRSTCTL_TXFNUM : R/W; bitpos: [10:6]; default: 0;
 *  Mode: Host and Device
 *  TxFIFO Number (TxFNum)
 *  This is the FIFO number that must be flushed using the TxFIFO Flush bit. This field
 *  must not be changed until the core clears the TxFIFO Flush bit.
 *  - 5'h0:
 *  -- Non-periodic TxFIFO flush in Host mode
 *  -- Non-periodic TxFIFO flush in device mode when in shared FIFO operation
 *  -- Tx FIFO 0 flush in device mode when in dedicated FIFO mode
 *  - 5'h1:
 *  -- Periodic TxFIFO flush in Host mode
 *  -- Periodic TxFIFO 1 flush in Device mode when in shared FIFO operation
 *  -- TXFIFO 1 flush in device mode when in dedicated FIFO mode
 *  - 5'h2:
 *  -- Periodic TxFIFO 2 flush in Device mode when in shared FIFO operation
 *  -- TXFIFO 2 flush in device mode when in dedicated FIFO mode
 *  ...
 *  - 5'hF
 *  -- Periodic TxFIFO 15 flush in Device mode when in shared FIFO operation
 *  -- TXFIFO 15 flush in device mode when in dedicated FIFO mode
 *  - 5'h10: Flush all the transmit FIFOs in device or host mode
 */
#define USB_OTGHS_GRSTCTL_TXFNUM    0x0000001FU
#define USB_OTGHS_GRSTCTL_TXFNUM_M  (USB_OTGHS_GRSTCTL_TXFNUM_V << USB_OTGHS_GRSTCTL_TXFNUM_S)
#define USB_OTGHS_GRSTCTL_TXFNUM_V  0x0000001FU
#define USB_OTGHS_GRSTCTL_TXFNUM_S  6
/** USB_OTGHS_GRSTCTL_CSFTRSTDONE : R/W; bitpos: [29]; default: 0;
 *  Mode: Host and Device
 *  Core Soft Reset Done (CSftRstDone)
 *  The core sets this bit when all the necessary logic is reset in the core.This bit
 *  is cleared by the application along with GRSTCTL.CSftRst (bit 0)
 */
#define USB_OTGHS_GRSTCTL_CSFTRSTDONE    (BIT(29))
#define USB_OTGHS_GRSTCTL_CSFTRSTDONE_M  (USB_OTGHS_GRSTCTL_CSFTRSTDONE_V << USB_OTGHS_GRSTCTL_CSFTRSTDONE_S)
#define USB_OTGHS_GRSTCTL_CSFTRSTDONE_V  0x00000001U
#define USB_OTGHS_GRSTCTL_CSFTRSTDONE_S  29
/** USB_OTGHS_GRSTCTL_DMAREQ : RO; bitpos: [30]; default: 0;
 *  Mode: Host and Device
 *  DMA Request Signal (DMAReq)
 *  Indicates that the DMA request is in progress. Used for debug.
 */
#define USB_OTGHS_GRSTCTL_DMAREQ    (BIT(30))
#define USB_OTGHS_GRSTCTL_DMAREQ_M  (USB_OTGHS_GRSTCTL_DMAREQ_V << USB_OTGHS_GRSTCTL_DMAREQ_S)
#define USB_OTGHS_GRSTCTL_DMAREQ_V  0x00000001U
#define USB_OTGHS_GRSTCTL_DMAREQ_S  30
/** USB_OTGHS_GRSTCTL_AHBIDLE : RO; bitpos: [31]; default: 1;
 *  Mode: Host and Device
 *  AHB Master Idle (AHBIdle)
 *  Indicates that the AHB Master State Machine is in the IDLE condition.
 */
#define USB_OTGHS_GRSTCTL_AHBIDLE    (BIT(31))
#define USB_OTGHS_GRSTCTL_AHBIDLE_M  (USB_OTGHS_GRSTCTL_AHBIDLE_V << USB_OTGHS_GRSTCTL_AHBIDLE_S)
#define USB_OTGHS_GRSTCTL_AHBIDLE_V  0x00000001U
#define USB_OTGHS_GRSTCTL_AHBIDLE_S  31

/** USB_OTGHS_GINTSTS_REG register
 *  This register interrupts the application for system-level events in the current
 *  mode (Device mode or Host mode). Some of the bits in this register are valid only
 *  in Host mode, while others are valid in Device mode only. This register also
 *  indicates the current mode. To clear the interrupt status bits of type R_SS_WC, the
 *  application must write 1'b1 to the bit. The FIFO status interrupts are read only;
 *  once software reads from or writes to the FIFO while servicing these interrupts,
 *  FIFO interrupt conditions are cleared automatically. The application must clear the
 *  GINTSTS register at initialization before unmasking the interrupt bit to avoid any
 *  interrupts generated prior to initialization.  Note: Read the reset value of
 *  GINTSTS.CurMod only after the following conditions:  - If IDDIG_FILTER is disabled,
 *  read only after PHY clock is stable.  - If IDDIG_FILTER is enabled, read only after
 *  the filter timer expires.
 */
#define USB_OTGHS_GINTSTS_REG (DR_REG_USB_OTGHS_BASE + 0x14)
/** USB_OTGHS_GINTSTS_CURMOD : RO; bitpos: [0]; default: 0;
 *  Mode: Host and Device
 *  Current Mode of Operation (CurMod)
 *  Indicates the current mode.
 *  - 1'b0: Device mode
 *  - 1'b1: Host mode
 *
 *
 *  Note: The reset value of this register field can be read only after the PHY clock
 *  is stable, or if IDDIG_FILTER is enabled, wait for the filter timer to expire to
 *  read the correct reset value which ever event is later.
 */
#define USB_OTGHS_GINTSTS_CURMOD    (BIT(0))
#define USB_OTGHS_GINTSTS_CURMOD_M  (USB_OTGHS_GINTSTS_CURMOD_V << USB_OTGHS_GINTSTS_CURMOD_S)
#define USB_OTGHS_GINTSTS_CURMOD_V  0x00000001U
#define USB_OTGHS_GINTSTS_CURMOD_S  0
/** USB_OTGHS_GINTSTS_MODEMIS : R/W; bitpos: [1]; default: 0;
 *  Mode: Host and Device
 *  Mode Mismatch Interrupt (ModeMis)
 *  The core sets this bit when the application is trying to access:
 *  - A Host mode register, when the controller is operating in Device mode
 *  - A Device mode register, when the controller is operating in Host mode
 *  The register access is completed on the AHB with an OKAY response, but is ignored
 *  by the controller internally and does not affect the operation of the controller.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_GINTSTS_MODEMIS    (BIT(1))
#define USB_OTGHS_GINTSTS_MODEMIS_M  (USB_OTGHS_GINTSTS_MODEMIS_V << USB_OTGHS_GINTSTS_MODEMIS_S)
#define USB_OTGHS_GINTSTS_MODEMIS_V  0x00000001U
#define USB_OTGHS_GINTSTS_MODEMIS_S  1
/** USB_OTGHS_GINTSTS_OTGINT : RO; bitpos: [2]; default: 0;
 *  Mode: Host and Device
 *  OTG Interrupt (OTGInt)
 *  The controller sets this bit to indicate an OTG protocol event. The application
 *  must read the OTG Interrupt Status (GOTGINT) register to determine the exact event
 *  that caused this interrupt. The application must clear the appropriate status bit
 *  in the GOTGINT register to clear this bit.
 */
#define USB_OTGHS_GINTSTS_OTGINT    (BIT(2))
#define USB_OTGHS_GINTSTS_OTGINT_M  (USB_OTGHS_GINTSTS_OTGINT_V << USB_OTGHS_GINTSTS_OTGINT_S)
#define USB_OTGHS_GINTSTS_OTGINT_V  0x00000001U
#define USB_OTGHS_GINTSTS_OTGINT_S  2
/** USB_OTGHS_GINTSTS_SOF : R/W; bitpos: [3]; default: 0;
 *  Mode: Host and Device
 *  Start of (micro)Frame (Sof)
 *
 *  In Host mode, the core sets this bit to indicate that an SOF (FS), micro-SOF (HS),
 *  or Keep-Alive (LS) is transmitted on the USB. The application must write a 1 to
 *  this bit to clear the interrupt.
 *
 *  In Device mode, the controller sets this bit to indicate that an SOF token has been
 *  received on the USB. The application can read the Device Status register to get the
 *  current (micro)Frame number. This interrupt is seen only when the core is operating
 *  at either HS or FS. This bit can be set only by the core and the application must
 *  write 1 to clear it.
 *
 *  Note: This register may return 1'b1 if read immediately after power-on reset.
 *  If the register bit reads 1'b1 immediately after power-on reset, it does not
 *  indicate that an SOF has been sent (in case of host mode) or SOF has been received
 *  (in case of device mode).
 *  The read value of this interrupt is valid only after a valid connection between
 *  host and device is established. If the bit is set after power on reset the
 *  application can clear the bit.
 */
#define USB_OTGHS_GINTSTS_SOF    (BIT(3))
#define USB_OTGHS_GINTSTS_SOF_M  (USB_OTGHS_GINTSTS_SOF_V << USB_OTGHS_GINTSTS_SOF_S)
#define USB_OTGHS_GINTSTS_SOF_V  0x00000001U
#define USB_OTGHS_GINTSTS_SOF_S  3
/** USB_OTGHS_GINTSTS_RXFLVL : RO; bitpos: [4]; default: 0;
 *  Mode: Host and Device
 *  RxFIFO Non-Empty (RxFLvl)
 *
 *  Indicates that there is at least one packet pending to be read from the RxFIFO.
 */
#define USB_OTGHS_GINTSTS_RXFLVL    (BIT(4))
#define USB_OTGHS_GINTSTS_RXFLVL_M  (USB_OTGHS_GINTSTS_RXFLVL_V << USB_OTGHS_GINTSTS_RXFLVL_S)
#define USB_OTGHS_GINTSTS_RXFLVL_V  0x00000001U
#define USB_OTGHS_GINTSTS_RXFLVL_S  4
/** USB_OTGHS_GINTSTS_NPTXFEMP : RO; bitpos: [5]; default: 1;
 *  Mode: Host and Device
 *  Non-periodic TxFIFO Empty (NPTxFEmp)
 *  This interrupt is asserted when the Non-periodic TxFIFO is either half or
 *  completely empty, and there is space for at least one Entry to be written to the
 *  Non-periodic Transmit Request Queue. The half or completely empty status is
 *  determined by the Non-periodic TxFIFO Empty Level bit in the Core AHB Configuration
 *  register (GAHBCFG.NPTxFEmpLvl).
 *  In host mode, the application can use GINTSTS.NPTxFEmp with the OTG_EN_DED_TX_FIFO
 *  parameter set to either 1 or 0.
 *  In device mode, the application uses GINTSTS.NPTxFEmp when OTG_EN_DED_TX_FIFO=0.
 *  When OTG_EN_DED_TX_FIFO=1, the application uses DIEPINTn.TxFEmp.
 */
#define USB_OTGHS_GINTSTS_NPTXFEMP    (BIT(5))
#define USB_OTGHS_GINTSTS_NPTXFEMP_M  (USB_OTGHS_GINTSTS_NPTXFEMP_V << USB_OTGHS_GINTSTS_NPTXFEMP_S)
#define USB_OTGHS_GINTSTS_NPTXFEMP_V  0x00000001U
#define USB_OTGHS_GINTSTS_NPTXFEMP_S  5
/** USB_OTGHS_GINTSTS_GINNAKEFF : RO; bitpos: [6]; default: 0;
 *  Mode: Device only
 *  Global IN Non-periodic NAK Effective (GINNakEff)
 *  Indicates that the Set Global Non-periodic IN NAK bit in the Device Control
 *  register (DCTL.SGNPInNak) set by the application, has taken effect in the core.
 *  That is, the core has sampled the Global IN NAK bit Set by the application. This
 *  bit can be cleared by clearing the Clear Global Non-periodic IN NAK bit in the
 *  Device Control register (DCTL.CGNPInNak). This interrupt does not necessarily mean
 *  that a NAK handshake
 *  is sent out on the USB. The STALL bit takes precedence over the NAK bit.
 */
#define USB_OTGHS_GINTSTS_GINNAKEFF    (BIT(6))
#define USB_OTGHS_GINTSTS_GINNAKEFF_M  (USB_OTGHS_GINTSTS_GINNAKEFF_V << USB_OTGHS_GINTSTS_GINNAKEFF_S)
#define USB_OTGHS_GINTSTS_GINNAKEFF_V  0x00000001U
#define USB_OTGHS_GINTSTS_GINNAKEFF_S  6
/** USB_OTGHS_GINTSTS_GOUTNAKEFF : RO; bitpos: [7]; default: 0;
 *  Mode: Device only
 *  Global OUT NAK Effective (GOUTNakEff)
 *  Indicates that the Set Global OUT NAK bit in the Device Control register
 *  (DCTL.SGOUTNak), Set by the application, has taken effect in the core. This bit can
 *  be cleared by writing the Clear Global OUT NAK bit in the Device Control register
 *  (DCTL.CGOUTNak).
 */
#define USB_OTGHS_GINTSTS_GOUTNAKEFF    (BIT(7))
#define USB_OTGHS_GINTSTS_GOUTNAKEFF_M  (USB_OTGHS_GINTSTS_GOUTNAKEFF_V << USB_OTGHS_GINTSTS_GOUTNAKEFF_S)
#define USB_OTGHS_GINTSTS_GOUTNAKEFF_V  0x00000001U
#define USB_OTGHS_GINTSTS_GOUTNAKEFF_S  7
/** USB_OTGHS_GINTSTS_ERLYSUSP : R/W; bitpos: [10]; default: 0;
 *  Mode: Device only
 *  Early Suspend (ErlySusp)
 *  The controller sets this bit to indicate that an Idle state has been detected on
 *  the USB for 3 ms.
 */
#define USB_OTGHS_GINTSTS_ERLYSUSP    (BIT(10))
#define USB_OTGHS_GINTSTS_ERLYSUSP_M  (USB_OTGHS_GINTSTS_ERLYSUSP_V << USB_OTGHS_GINTSTS_ERLYSUSP_S)
#define USB_OTGHS_GINTSTS_ERLYSUSP_V  0x00000001U
#define USB_OTGHS_GINTSTS_ERLYSUSP_S  10
/** USB_OTGHS_GINTSTS_USBSUSP : R/W; bitpos: [11]; default: 0;
 *  Mode: Device only
 *  USB Suspend (USBSusp)
 *  The controller sets this bit to indicate that a suspend was detected on the USB.
 *  The controller enters the Suspended state when there is no activity on the
 *  linestate signal for an extended period of time.
 */
#define USB_OTGHS_GINTSTS_USBSUSP    (BIT(11))
#define USB_OTGHS_GINTSTS_USBSUSP_M  (USB_OTGHS_GINTSTS_USBSUSP_V << USB_OTGHS_GINTSTS_USBSUSP_S)
#define USB_OTGHS_GINTSTS_USBSUSP_V  0x00000001U
#define USB_OTGHS_GINTSTS_USBSUSP_S  11
/** USB_OTGHS_GINTSTS_USBRST : R/W; bitpos: [12]; default: 0;
 *  Mode: Device only
 *  USB Reset (USBRst)
 *  The controller sets this bit to indicate that a reset is detected on the USB.
 */
#define USB_OTGHS_GINTSTS_USBRST    (BIT(12))
#define USB_OTGHS_GINTSTS_USBRST_M  (USB_OTGHS_GINTSTS_USBRST_V << USB_OTGHS_GINTSTS_USBRST_S)
#define USB_OTGHS_GINTSTS_USBRST_V  0x00000001U
#define USB_OTGHS_GINTSTS_USBRST_S  12
/** USB_OTGHS_GINTSTS_ENUMDONE : R/W; bitpos: [13]; default: 0;
 *  Mode: Device only
 *  Enumeration Done (EnumDone)
 *  The core sets this bit to indicate that speed enumeration is complete. The
 *  application must read the Device Status (DSTS) register to obtain the enumerated
 *  speed.
 */
#define USB_OTGHS_GINTSTS_ENUMDONE    (BIT(13))
#define USB_OTGHS_GINTSTS_ENUMDONE_M  (USB_OTGHS_GINTSTS_ENUMDONE_V << USB_OTGHS_GINTSTS_ENUMDONE_S)
#define USB_OTGHS_GINTSTS_ENUMDONE_V  0x00000001U
#define USB_OTGHS_GINTSTS_ENUMDONE_S  13
/** USB_OTGHS_GINTSTS_ISOOUTDROP : R/W; bitpos: [14]; default: 0;
 *  Mode: Device only
 *  Isochronous OUT Packet Dropped Interrupt (ISOOutDrop)
 *  The controller sets this bit when it fails to write an isochronous OUT packet into
 *  the RxFIFO because the RxFIFO does not have enough space to accommodate a maximum
 *  packet size packet for the isochronous OUT endpoint.
 */
#define USB_OTGHS_GINTSTS_ISOOUTDROP    (BIT(14))
#define USB_OTGHS_GINTSTS_ISOOUTDROP_M  (USB_OTGHS_GINTSTS_ISOOUTDROP_V << USB_OTGHS_GINTSTS_ISOOUTDROP_S)
#define USB_OTGHS_GINTSTS_ISOOUTDROP_V  0x00000001U
#define USB_OTGHS_GINTSTS_ISOOUTDROP_S  14
/** USB_OTGHS_GINTSTS_EOPF : R/W; bitpos: [15]; default: 0;
 *  Mode: Device only
 *  End of Periodic Frame Interrupt (EOPF)
 *  Indicates that the period specified in the Periodic Frame Interval field of the
 *  Device Configuration register (DCFG.PerFrInt) has been reached in the current
 *  microframe.
 *  In case of Non-Ignore Frame Number Scatter/Gather (Descriptor DMA) mode, the
 *  controller internally handles the following scenarios based on EOPF:
 *
 *  Read Flush: At the EOPF, the controller checks if there are any pending packets in
 *  the FIFO corresponding to the current (micro)Frame.
 *  - If there are any pending packets, then the controller initiates read flush, due
 *  to which the read pointer is updated to the starting location of the next
 *  micro-frame packet.
 *  - If there are no pending packets corresponding to the current (micro)Frame, the
 *  controller does not take any action.
 *  Write Flush: At the EOPF, if the controller is still fetching the current
 *  micro-frame data, then the controller stops pushing data into the TXFIFO but keeps
 *  fetching the complete packet from the System Memory. After completing the scheduled
 *  packet size fetch, the controller updates the Status Quadlet Fields (Transmit
 *  Status to BUFFLUSH) and closes the Descriptor.  During the descriptor close, the
 *  controller initiates write flush, due to which the write pointer is updated to the
 *  starting location of the next micro-frame packet. Because the controller stops
 *  pushing the packet to the TxFIFO after EOPF, to bring the write pointer to the
 *  starting location of the next micro-frame, write flush is done.
 */
#define USB_OTGHS_GINTSTS_EOPF    (BIT(15))
#define USB_OTGHS_GINTSTS_EOPF_M  (USB_OTGHS_GINTSTS_EOPF_V << USB_OTGHS_GINTSTS_EOPF_S)
#define USB_OTGHS_GINTSTS_EOPF_V  0x00000001U
#define USB_OTGHS_GINTSTS_EOPF_S  15
/** USB_OTGHS_GINTSTS_EPMIS : R/W; bitpos: [17]; default: 0;
 *  Mode: Device only
 *  Endpoint Mismatch Interrupt (EPMis)
 *  Note: This interrupt is valid only in shared FIFO operation.
 *  Indicates that an IN token has been received for a non-periodic endpoint, but the
 *  data for another endpoint is present in the top of the Non-periodic Transmit FIFO
 *  and the IN endpoint mismatch count programmed by the application has expired.
 */
#define USB_OTGHS_GINTSTS_EPMIS    (BIT(17))
#define USB_OTGHS_GINTSTS_EPMIS_M  (USB_OTGHS_GINTSTS_EPMIS_V << USB_OTGHS_GINTSTS_EPMIS_S)
#define USB_OTGHS_GINTSTS_EPMIS_V  0x00000001U
#define USB_OTGHS_GINTSTS_EPMIS_S  17
/** USB_OTGHS_GINTSTS_IEPINT : RO; bitpos: [18]; default: 0;
 *  Mode: Device only
 *  IN Endpoints Interrupt (IEPInt)
 *  The core sets this bit to indicate that an interrupt is pending on one of the IN
 *  endpoints of the core (in Device mode). The application must read the Device All
 *  Endpoints Interrupt (DAINT) register to determine the exact number of the IN
 *  endpoint on Device IN Endpoint-n Interrupt (DIEPINTn) register to determine the
 *  exact cause of the interrupt. The application must clear the appropriate status bit
 *  in the corresponding DIEPINTn register to
 *  clear this bit.
 */
#define USB_OTGHS_GINTSTS_IEPINT    (BIT(18))
#define USB_OTGHS_GINTSTS_IEPINT_M  (USB_OTGHS_GINTSTS_IEPINT_V << USB_OTGHS_GINTSTS_IEPINT_S)
#define USB_OTGHS_GINTSTS_IEPINT_V  0x00000001U
#define USB_OTGHS_GINTSTS_IEPINT_S  18
/** USB_OTGHS_GINTSTS_OEPINT : RO; bitpos: [19]; default: 0;
 *  Mode: Device only
 *  OUT Endpoints Interrupt (OEPInt)
 *  The controller sets this bit to indicate that an interrupt is pending on one of the
 *  OUT endpoints of the core (in Device mode). The application must read the Device
 *  All Endpoints Interrupt (DAINT) register to determine the exact number of the OUT
 *  endpoint on which the interrupt occurred, and then read the corresponding Device
 *  OUT Endpoint-n Interrupt (DOEPINTn) register to determine the exact cause of the
 *  interrupt. The application must
 *  clear the appropriate status bit in the corresponding DOEPINTn register to clear
 *  this bit.
 */
#define USB_OTGHS_GINTSTS_OEPINT    (BIT(19))
#define USB_OTGHS_GINTSTS_OEPINT_M  (USB_OTGHS_GINTSTS_OEPINT_V << USB_OTGHS_GINTSTS_OEPINT_S)
#define USB_OTGHS_GINTSTS_OEPINT_V  0x00000001U
#define USB_OTGHS_GINTSTS_OEPINT_S  19
/** USB_OTGHS_GINTSTS_INCOMPISOIN : R/W; bitpos: [20]; default: 0;
 *  Mode: Device only
 *  Incomplete Isochronous IN Transfer (incompISOIN)
 *  The core sets this interrupt to indicate that there is at least one isochronous IN
 *  endpoint on which the transfer is not completed in the current microframe. This
 *  interrupt is asserted along with the End of Periodic Frame Interrupt (EOPF) bit in
 *  this register.
 *  Note: This interrupt is not asserted in Scatter/Gather DMA mode.
 */
#define USB_OTGHS_GINTSTS_INCOMPISOIN    (BIT(20))
#define USB_OTGHS_GINTSTS_INCOMPISOIN_M  (USB_OTGHS_GINTSTS_INCOMPISOIN_V << USB_OTGHS_GINTSTS_INCOMPISOIN_S)
#define USB_OTGHS_GINTSTS_INCOMPISOIN_V  0x00000001U
#define USB_OTGHS_GINTSTS_INCOMPISOIN_S  20
/** USB_OTGHS_GINTSTS_INCOMPLP : R/W; bitpos: [21]; default: 0;
 *  Incomplete Periodic Transfer (incomplP)
 *  Mode: Host only
 *  In Host mode, the core sets this interrupt bit when there are incomplete periodic
 *  transactions still pending which are scheduled for the current microframe.
 *  Incomplete Isochronous OUT Transfer (incompISOOUT)
 *  Mode: Device only
 *  The Device mode, the core sets this interrupt to indicate that there is at least
 *  one isochronous OUT endpoint on which the transfer is not completed in the current
 *  microframe. This interrupt is asserted along with the End of Periodic Frame
 *  Interrupt (EOPF) bit in this register.
 */
#define USB_OTGHS_GINTSTS_INCOMPLP    (BIT(21))
#define USB_OTGHS_GINTSTS_INCOMPLP_M  (USB_OTGHS_GINTSTS_INCOMPLP_V << USB_OTGHS_GINTSTS_INCOMPLP_S)
#define USB_OTGHS_GINTSTS_INCOMPLP_V  0x00000001U
#define USB_OTGHS_GINTSTS_INCOMPLP_S  21
/** USB_OTGHS_GINTSTS_FETSUSP : R/W; bitpos: [22]; default: 0;
 *  Mode: Device only
 *  Data Fetch Suspended (FetSusp)
 *  This interrupt is valid only in DMA mode. This interrupt indicates that the core
 *  has stopped fetching data. For IN endpoints due to the unavailability of TxFIFO
 *  space or Request Queue space. This interrupt is used by the application for an
 *  endpoint mismatch algorithm.
 *
 *  For example, after detecting an endpoint mismatch, the application:
 *  - Sets a Global non-periodic IN NAK handshake
 *  - Disables IN endpoints
 *  - Flushes the FIFO
 *  - Determines the token sequence from the IN Token Sequence Learning Queue
 *  - Re-enables the endpoints
 *  - Clears the Global non-periodic IN NAK handshake
 *  If the Global non-periodic IN NAK is cleared, the core has not yet fetched data for
 *  the IN endpoint, and the IN token is received. The core generates an 'IN token
 *  received when FIFO empty' interrupt. It then sends the host a NAK response. To
 *  avoid this scenario, the application can check the GINTSTS.FetSusp interrupt, which
 *  ensures that the FIFO is full before clearing a Global NAK handshake.
 *
 *  Alternatively, the application can mask the IN token received when FIFO empty
 *  interrupt when clearing a Global IN NAK handshake.
 */
#define USB_OTGHS_GINTSTS_FETSUSP    (BIT(22))
#define USB_OTGHS_GINTSTS_FETSUSP_M  (USB_OTGHS_GINTSTS_FETSUSP_V << USB_OTGHS_GINTSTS_FETSUSP_S)
#define USB_OTGHS_GINTSTS_FETSUSP_V  0x00000001U
#define USB_OTGHS_GINTSTS_FETSUSP_S  22
/** USB_OTGHS_GINTSTS_RESETDET : R/W; bitpos: [23]; default: 0;
 *  Mode: Device only
 *  Reset detected Interrupt (ResetDet)
 *  In Device mode, this interrupt is asserted when a reset is detected on the USB in
 *  partial power-down mode when the device is in Suspend.
 *
 *  In Host mode, this interrupt is not asserted.
 */
#define USB_OTGHS_GINTSTS_RESETDET    (BIT(23))
#define USB_OTGHS_GINTSTS_RESETDET_M  (USB_OTGHS_GINTSTS_RESETDET_V << USB_OTGHS_GINTSTS_RESETDET_S)
#define USB_OTGHS_GINTSTS_RESETDET_V  0x00000001U
#define USB_OTGHS_GINTSTS_RESETDET_S  23
/** USB_OTGHS_GINTSTS_PRTINT : RO; bitpos: [24]; default: 0;
 *  Mode: Host only
 *  Host Port Interrupt (PrtInt)
 *  The core sets this bit to indicate a change in port status of one of the controller
 *  ports in Host mode. The application must read the Host Port Control and Status
 *  (HPRT) register to determine the exact event that caused this interrupt. The
 *  application must clear the appropriate status bit in the Host Port
 *  Control and Status register to clear this bit.
 */
#define USB_OTGHS_GINTSTS_PRTINT    (BIT(24))
#define USB_OTGHS_GINTSTS_PRTINT_M  (USB_OTGHS_GINTSTS_PRTINT_V << USB_OTGHS_GINTSTS_PRTINT_S)
#define USB_OTGHS_GINTSTS_PRTINT_V  0x00000001U
#define USB_OTGHS_GINTSTS_PRTINT_S  24
/** USB_OTGHS_GINTSTS_HCHINT : RO; bitpos: [25]; default: 0;
 *  Mode: Host only
 *  Host Channels Interrupt (HChInt)
 *  The core sets this bit to indicate that an interrupt is pending on one of the
 *  channels of the core (in Host mode). The application must read the Host All
 *  Channels Interrupt (HAINT) register to determine the exact number of the channel on
 *  which the interrupt occurred, and Then read the corresponding Host
 *  Channel-n Interrupt (HCINTn) register to determine the exact cause of the
 *  interrupt. The application must clear the appropriate status bit in the HCINTn
 *  register to clear this bit.
 */
#define USB_OTGHS_GINTSTS_HCHINT    (BIT(25))
#define USB_OTGHS_GINTSTS_HCHINT_M  (USB_OTGHS_GINTSTS_HCHINT_V << USB_OTGHS_GINTSTS_HCHINT_S)
#define USB_OTGHS_GINTSTS_HCHINT_V  0x00000001U
#define USB_OTGHS_GINTSTS_HCHINT_S  25
/** USB_OTGHS_GINTSTS_PTXFEMP : RO; bitpos: [26]; default: 1;
 *  Mode: Host only
 *  Periodic TxFIFO Empty (PTxFEmp)
 *  This interrupt is asserted when the Periodic Transmit FIFO is either half or
 *  completely empty and there is space for at least one entry to be written in the
 *  Periodic Request Queue. The half or completely empty status is determined by the
 *  Periodic TxFIFO Empty Level bit in the Core AHB Configuration register
 *  (GAHBCFG.PTxFEmpLvl).
 */
#define USB_OTGHS_GINTSTS_PTXFEMP    (BIT(26))
#define USB_OTGHS_GINTSTS_PTXFEMP_M  (USB_OTGHS_GINTSTS_PTXFEMP_V << USB_OTGHS_GINTSTS_PTXFEMP_S)
#define USB_OTGHS_GINTSTS_PTXFEMP_V  0x00000001U
#define USB_OTGHS_GINTSTS_PTXFEMP_S  26
/** USB_OTGHS_GINTSTS_CONIDSTSCHNG : R/W; bitpos: [28]; default: 0;
 *  Mode: Host and Device
 *  Connector ID Status Change (ConIDStsChng)
 *  The core sets this bit when there is a change in connector ID status.
 */
#define USB_OTGHS_GINTSTS_CONIDSTSCHNG    (BIT(28))
#define USB_OTGHS_GINTSTS_CONIDSTSCHNG_M  (USB_OTGHS_GINTSTS_CONIDSTSCHNG_V << USB_OTGHS_GINTSTS_CONIDSTSCHNG_S)
#define USB_OTGHS_GINTSTS_CONIDSTSCHNG_V  0x00000001U
#define USB_OTGHS_GINTSTS_CONIDSTSCHNG_S  28
/** USB_OTGHS_GINTSTS_DISCONNINT : R/W; bitpos: [29]; default: 0;
 *  Mode: Host only
 *  Disconnect Detected Interrupt (DisconnInt)
 *  Asserted when a device disconnect is detected.
 */
#define USB_OTGHS_GINTSTS_DISCONNINT    (BIT(29))
#define USB_OTGHS_GINTSTS_DISCONNINT_M  (USB_OTGHS_GINTSTS_DISCONNINT_V << USB_OTGHS_GINTSTS_DISCONNINT_S)
#define USB_OTGHS_GINTSTS_DISCONNINT_V  0x00000001U
#define USB_OTGHS_GINTSTS_DISCONNINT_S  29
/** USB_OTGHS_GINTSTS_SESSREQINT : R/W; bitpos: [30]; default: 0;
 *  Mode: Host and Device
 *  Session Request/New Session Detected Interrupt (SessReqInt)
 *  In Host mode, this interrupt is asserted when a session request is detected from
 *  the device. In Host mode, this interrupt is asserted when a session request is
 *  detected from the device.
 *  In Device mode, this interrupt is asserted when the utmisrp_bvalid signal goes high.
 *  For more information on how to use this interrupt, see 'Partial Power-Down and
 *  Clock Gating Programming Model' in the Programming Guide.
 */
#define USB_OTGHS_GINTSTS_SESSREQINT    (BIT(30))
#define USB_OTGHS_GINTSTS_SESSREQINT_M  (USB_OTGHS_GINTSTS_SESSREQINT_V << USB_OTGHS_GINTSTS_SESSREQINT_S)
#define USB_OTGHS_GINTSTS_SESSREQINT_V  0x00000001U
#define USB_OTGHS_GINTSTS_SESSREQINT_S  30
/** USB_OTGHS_GINTSTS_WKUPINT : R/W; bitpos: [31]; default: 0;
 *  Mode: Host and Device
 *  Resume/Remote Wakeup Detected Interrupt (WkUpInt)
 *  Wakeup Interrupt during Suspend(L2) or LPM(L1) state.
 *  - During Suspend(L2):
 *  -- Device Mode: This interrupt is asserted only when Host Initiated Resume is
 *  detected on USB.
 *  -- Host Mode: This interrupt is asserted only when Device Initiated Remote Wakeup
 *  is detected on USB.
 *  For more information, see 'Partial Power-Down and Clock Gating Programming Model'
 *  in the Programming Guide.
 *  - During LPM(L1):
 *  -- Device Mode: This interrupt is asserted for either Host Initiated Resume or
 *  Device Initiated Remote Wakeup on USB.
 *  -- Host Mode: This interrupt is asserted for either Host Initiated Resume or Device
 *  Initiated Remote Wakeup on USB.
 *  For more information, see 'LPM Entry and Exit Programming Model' in the Programming
 *  Guide.
 */
#define USB_OTGHS_GINTSTS_WKUPINT    (BIT(31))
#define USB_OTGHS_GINTSTS_WKUPINT_M  (USB_OTGHS_GINTSTS_WKUPINT_V << USB_OTGHS_GINTSTS_WKUPINT_S)
#define USB_OTGHS_GINTSTS_WKUPINT_V  0x00000001U
#define USB_OTGHS_GINTSTS_WKUPINT_S  31

/** USB_OTGHS_GINTMSK_REG register
 *  This register works with the Interrupt Register (GINTSTS) to interrupt the
 *  application. When an interrupt bit is masked, the interrupt associated with that
 *  bit is not generated. However, the GINTSTS register bit corresponding to that
 *  interrupt is still set.  Note: The fields of this register change depending on host
 *  or device mode.
 */
#define USB_OTGHS_GINTMSK_REG (DR_REG_USB_OTGHS_BASE + 0x18)
/** USB_OTGHS_GINTMSK_MODEMISMSK : R/W; bitpos: [1]; default: 0;
 *  Mode: Host and Device
 *  Mode Mismatch Interrupt Mask (ModeMisMsk)
 */
#define USB_OTGHS_GINTMSK_MODEMISMSK    (BIT(1))
#define USB_OTGHS_GINTMSK_MODEMISMSK_M  (USB_OTGHS_GINTMSK_MODEMISMSK_V << USB_OTGHS_GINTMSK_MODEMISMSK_S)
#define USB_OTGHS_GINTMSK_MODEMISMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_MODEMISMSK_S  1
/** USB_OTGHS_GINTMSK_OTGINTMSK : R/W; bitpos: [2]; default: 0;
 *  Mode: Host and Device
 *  OTG Interrupt Mask (OTGIntMsk)
 */
#define USB_OTGHS_GINTMSK_OTGINTMSK    (BIT(2))
#define USB_OTGHS_GINTMSK_OTGINTMSK_M  (USB_OTGHS_GINTMSK_OTGINTMSK_V << USB_OTGHS_GINTMSK_OTGINTMSK_S)
#define USB_OTGHS_GINTMSK_OTGINTMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_OTGINTMSK_S  2
/** USB_OTGHS_GINTMSK_SOFMSK : R/W; bitpos: [3]; default: 0;
 *  Mode: Host and Device
 *  Start of (micro)Frame Mask (SofMsk)
 */
#define USB_OTGHS_GINTMSK_SOFMSK    (BIT(3))
#define USB_OTGHS_GINTMSK_SOFMSK_M  (USB_OTGHS_GINTMSK_SOFMSK_V << USB_OTGHS_GINTMSK_SOFMSK_S)
#define USB_OTGHS_GINTMSK_SOFMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_SOFMSK_S  3
/** USB_OTGHS_GINTMSK_RXFLVLMSK : R/W; bitpos: [4]; default: 0;
 *  Mode: Host and Device
 *  Receive FIFO Non-Empty Mask (RxFLvlMsk)
 */
#define USB_OTGHS_GINTMSK_RXFLVLMSK    (BIT(4))
#define USB_OTGHS_GINTMSK_RXFLVLMSK_M  (USB_OTGHS_GINTMSK_RXFLVLMSK_V << USB_OTGHS_GINTMSK_RXFLVLMSK_S)
#define USB_OTGHS_GINTMSK_RXFLVLMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_RXFLVLMSK_S  4
/** USB_OTGHS_GINTMSK_NPTXFEMPMSK : R/W; bitpos: [5]; default: 0;
 *  Mode: Host and Device
 *  Non-periodic TxFIFO Empty Mask (NPTxFEmpMsk)
 */
#define USB_OTGHS_GINTMSK_NPTXFEMPMSK    (BIT(5))
#define USB_OTGHS_GINTMSK_NPTXFEMPMSK_M  (USB_OTGHS_GINTMSK_NPTXFEMPMSK_V << USB_OTGHS_GINTMSK_NPTXFEMPMSK_S)
#define USB_OTGHS_GINTMSK_NPTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_NPTXFEMPMSK_S  5
/** USB_OTGHS_GINTMSK_GINNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  Mode: Device only,
 *  Global Non-periodic IN NAK Effective Mask (GINNakEffMsk)
 */
#define USB_OTGHS_GINTMSK_GINNAKEFFMSK    (BIT(6))
#define USB_OTGHS_GINTMSK_GINNAKEFFMSK_M  (USB_OTGHS_GINTMSK_GINNAKEFFMSK_V << USB_OTGHS_GINTMSK_GINNAKEFFMSK_S)
#define USB_OTGHS_GINTMSK_GINNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_GINNAKEFFMSK_S  6
/** USB_OTGHS_GINTMSK_GOUTNAKEFFMSK : R/W; bitpos: [7]; default: 0;
 *  Mode: Device only
 *  Global OUT NAK Effective Mask (GOUTNakEffMsk)
 */
#define USB_OTGHS_GINTMSK_GOUTNAKEFFMSK    (BIT(7))
#define USB_OTGHS_GINTMSK_GOUTNAKEFFMSK_M  (USB_OTGHS_GINTMSK_GOUTNAKEFFMSK_V << USB_OTGHS_GINTMSK_GOUTNAKEFFMSK_S)
#define USB_OTGHS_GINTMSK_GOUTNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_GOUTNAKEFFMSK_S  7
/** USB_OTGHS_GINTMSK_ERLYSUSPMSK : R/W; bitpos: [10]; default: 0;
 *  Mode: Device only
 *  Early Suspend Mask (ErlySuspMsk)
 */
#define USB_OTGHS_GINTMSK_ERLYSUSPMSK    (BIT(10))
#define USB_OTGHS_GINTMSK_ERLYSUSPMSK_M  (USB_OTGHS_GINTMSK_ERLYSUSPMSK_V << USB_OTGHS_GINTMSK_ERLYSUSPMSK_S)
#define USB_OTGHS_GINTMSK_ERLYSUSPMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_ERLYSUSPMSK_S  10
/** USB_OTGHS_GINTMSK_USBSUSPMSK : R/W; bitpos: [11]; default: 0;
 *  Mode: Device only
 *  USB Suspend Mask (USBSuspMsk)
 */
#define USB_OTGHS_GINTMSK_USBSUSPMSK    (BIT(11))
#define USB_OTGHS_GINTMSK_USBSUSPMSK_M  (USB_OTGHS_GINTMSK_USBSUSPMSK_V << USB_OTGHS_GINTMSK_USBSUSPMSK_S)
#define USB_OTGHS_GINTMSK_USBSUSPMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_USBSUSPMSK_S  11
/** USB_OTGHS_GINTMSK_USBRSTMSK : R/W; bitpos: [12]; default: 0;
 *  Mode: Device only
 *  USB Reset Mask (USBRstMsk)
 */
#define USB_OTGHS_GINTMSK_USBRSTMSK    (BIT(12))
#define USB_OTGHS_GINTMSK_USBRSTMSK_M  (USB_OTGHS_GINTMSK_USBRSTMSK_V << USB_OTGHS_GINTMSK_USBRSTMSK_S)
#define USB_OTGHS_GINTMSK_USBRSTMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_USBRSTMSK_S  12
/** USB_OTGHS_GINTMSK_ENUMDONEMSK : R/W; bitpos: [13]; default: 0;
 *  Mode: Device only
 *  Enumeration Done Mask (EnumDoneMsk)
 */
#define USB_OTGHS_GINTMSK_ENUMDONEMSK    (BIT(13))
#define USB_OTGHS_GINTMSK_ENUMDONEMSK_M  (USB_OTGHS_GINTMSK_ENUMDONEMSK_V << USB_OTGHS_GINTMSK_ENUMDONEMSK_S)
#define USB_OTGHS_GINTMSK_ENUMDONEMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_ENUMDONEMSK_S  13
/** USB_OTGHS_GINTMSK_ISOOUTDROPMSK : R/W; bitpos: [14]; default: 0;
 *  Mode: Device only
 *  Isochronous OUT Packet Dropped Interrupt Mask (ISOOutDropMsk)
 */
#define USB_OTGHS_GINTMSK_ISOOUTDROPMSK    (BIT(14))
#define USB_OTGHS_GINTMSK_ISOOUTDROPMSK_M  (USB_OTGHS_GINTMSK_ISOOUTDROPMSK_V << USB_OTGHS_GINTMSK_ISOOUTDROPMSK_S)
#define USB_OTGHS_GINTMSK_ISOOUTDROPMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_ISOOUTDROPMSK_S  14
/** USB_OTGHS_GINTMSK_EOPFMSK : R/W; bitpos: [15]; default: 0;
 *  Mode: Device only
 *  End of Periodic Frame Interrupt Mask (EOPFMsk)
 */
#define USB_OTGHS_GINTMSK_EOPFMSK    (BIT(15))
#define USB_OTGHS_GINTMSK_EOPFMSK_M  (USB_OTGHS_GINTMSK_EOPFMSK_V << USB_OTGHS_GINTMSK_EOPFMSK_S)
#define USB_OTGHS_GINTMSK_EOPFMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_EOPFMSK_S  15
/** USB_OTGHS_GINTMSK_EPMISMSK : R/W; bitpos: [17]; default: 0;
 *  Mode: Device only
 *  Endpoint Mismatch Interrupt Mask (EPMisMsk)
 */
#define USB_OTGHS_GINTMSK_EPMISMSK    (BIT(17))
#define USB_OTGHS_GINTMSK_EPMISMSK_M  (USB_OTGHS_GINTMSK_EPMISMSK_V << USB_OTGHS_GINTMSK_EPMISMSK_S)
#define USB_OTGHS_GINTMSK_EPMISMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_EPMISMSK_S  17
/** USB_OTGHS_GINTMSK_IEPINTMSK : R/W; bitpos: [18]; default: 0;
 *  Mode: Device only
 *  IN Endpoints Interrupt Mask (IEPIntMsk)
 */
#define USB_OTGHS_GINTMSK_IEPINTMSK    (BIT(18))
#define USB_OTGHS_GINTMSK_IEPINTMSK_M  (USB_OTGHS_GINTMSK_IEPINTMSK_V << USB_OTGHS_GINTMSK_IEPINTMSK_S)
#define USB_OTGHS_GINTMSK_IEPINTMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_IEPINTMSK_S  18
/** USB_OTGHS_GINTMSK_OEPINTMSK : R/W; bitpos: [19]; default: 0;
 *  Mode: Device only
 *  OUT Endpoints Interrupt Mask (OEPIntMsk)
 */
#define USB_OTGHS_GINTMSK_OEPINTMSK    (BIT(19))
#define USB_OTGHS_GINTMSK_OEPINTMSK_M  (USB_OTGHS_GINTMSK_OEPINTMSK_V << USB_OTGHS_GINTMSK_OEPINTMSK_S)
#define USB_OTGHS_GINTMSK_OEPINTMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_OEPINTMSK_S  19
/** USB_OTGHS_GINTMSK_INCOMPLPMSK : R/W; bitpos: [21]; default: 0;
 *  Incomplete Periodic Transfer Mask (incomplPMsk)
 *  Mode: Host only
 *  Incomplete Isochronous OUT Transfer Interrupt Mask (incompISOOUTMsk)
 *  Mode: Device only
 */
#define USB_OTGHS_GINTMSK_INCOMPLPMSK    (BIT(21))
#define USB_OTGHS_GINTMSK_INCOMPLPMSK_M  (USB_OTGHS_GINTMSK_INCOMPLPMSK_V << USB_OTGHS_GINTMSK_INCOMPLPMSK_S)
#define USB_OTGHS_GINTMSK_INCOMPLPMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_INCOMPLPMSK_S  21
/** USB_OTGHS_GINTMSK_FETSUSPMSK : R/W; bitpos: [22]; default: 0;
 *  Mode: Device only
 *  Data Fetch Suspended Mask (FetSuspMsk)
 */
#define USB_OTGHS_GINTMSK_FETSUSPMSK    (BIT(22))
#define USB_OTGHS_GINTMSK_FETSUSPMSK_M  (USB_OTGHS_GINTMSK_FETSUSPMSK_V << USB_OTGHS_GINTMSK_FETSUSPMSK_S)
#define USB_OTGHS_GINTMSK_FETSUSPMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_FETSUSPMSK_S  22
/** USB_OTGHS_GINTMSK_RESETDETMSK : R/W; bitpos: [23]; default: 0;
 *  Mode: Device only
 *  Reset detected Interrupt Mask (ResetDetMsk)
 */
#define USB_OTGHS_GINTMSK_RESETDETMSK    (BIT(23))
#define USB_OTGHS_GINTMSK_RESETDETMSK_M  (USB_OTGHS_GINTMSK_RESETDETMSK_V << USB_OTGHS_GINTMSK_RESETDETMSK_S)
#define USB_OTGHS_GINTMSK_RESETDETMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_RESETDETMSK_S  23
/** USB_OTGHS_GINTMSK_PRTINTMSK : R/W; bitpos: [24]; default: 0;
 *  Mode: Host only
 *  Host Port Interrupt Mask (PrtIntMsk)
 */
#define USB_OTGHS_GINTMSK_PRTINTMSK    (BIT(24))
#define USB_OTGHS_GINTMSK_PRTINTMSK_M  (USB_OTGHS_GINTMSK_PRTINTMSK_V << USB_OTGHS_GINTMSK_PRTINTMSK_S)
#define USB_OTGHS_GINTMSK_PRTINTMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_PRTINTMSK_S  24
/** USB_OTGHS_GINTMSK_HCHINTMSK : R/W; bitpos: [25]; default: 0;
 *  Mode: Host only
 *  Host Channels Interrupt Mask (HChIntMsk)
 */
#define USB_OTGHS_GINTMSK_HCHINTMSK    (BIT(25))
#define USB_OTGHS_GINTMSK_HCHINTMSK_M  (USB_OTGHS_GINTMSK_HCHINTMSK_V << USB_OTGHS_GINTMSK_HCHINTMSK_S)
#define USB_OTGHS_GINTMSK_HCHINTMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_HCHINTMSK_S  25
/** USB_OTGHS_GINTMSK_PTXFEMPMSK : R/W; bitpos: [26]; default: 0;
 *  Mode: Host only
 *  Periodic TxFIFO Empty Mask (PTxFEmpMsk)
 */
#define USB_OTGHS_GINTMSK_PTXFEMPMSK    (BIT(26))
#define USB_OTGHS_GINTMSK_PTXFEMPMSK_M  (USB_OTGHS_GINTMSK_PTXFEMPMSK_V << USB_OTGHS_GINTMSK_PTXFEMPMSK_S)
#define USB_OTGHS_GINTMSK_PTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_PTXFEMPMSK_S  26
/** USB_OTGHS_GINTMSK_CONIDSTSCHNGMSK : R/W; bitpos: [28]; default: 0;
 *  Mode: Host and Device
 *  Connector ID Status Change Mask (ConIDStsChngMsk)
 */
#define USB_OTGHS_GINTMSK_CONIDSTSCHNGMSK    (BIT(28))
#define USB_OTGHS_GINTMSK_CONIDSTSCHNGMSK_M  (USB_OTGHS_GINTMSK_CONIDSTSCHNGMSK_V << USB_OTGHS_GINTMSK_CONIDSTSCHNGMSK_S)
#define USB_OTGHS_GINTMSK_CONIDSTSCHNGMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_CONIDSTSCHNGMSK_S  28
/** USB_OTGHS_GINTMSK_DISCONNINTMSK : R/W; bitpos: [29]; default: 0;
 *  Mode: Host and Device
 *  Disconnect Detected Interrupt Mask (DisconnIntMsk)
 */
#define USB_OTGHS_GINTMSK_DISCONNINTMSK    (BIT(29))
#define USB_OTGHS_GINTMSK_DISCONNINTMSK_M  (USB_OTGHS_GINTMSK_DISCONNINTMSK_V << USB_OTGHS_GINTMSK_DISCONNINTMSK_S)
#define USB_OTGHS_GINTMSK_DISCONNINTMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_DISCONNINTMSK_S  29
/** USB_OTGHS_GINTMSK_SESSREQINTMSK : R/W; bitpos: [30]; default: 0;
 *  Mode: Host and Device
 *  Session Request/New Session Detected Interrupt Mask (SessReqIntMsk)
 */
#define USB_OTGHS_GINTMSK_SESSREQINTMSK    (BIT(30))
#define USB_OTGHS_GINTMSK_SESSREQINTMSK_M  (USB_OTGHS_GINTMSK_SESSREQINTMSK_V << USB_OTGHS_GINTMSK_SESSREQINTMSK_S)
#define USB_OTGHS_GINTMSK_SESSREQINTMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_SESSREQINTMSK_S  30
/** USB_OTGHS_GINTMSK_WKUPINTMSK : R/W; bitpos: [31]; default: 0;
 *  Mode: Host and Device
 *  Resume/Remote Wakeup Detected Interrupt Mask (WkUpIntMsk)
 *  The WakeUp bit is used for LPM state wake up in a way similar to that of wake up in
 *  suspend state.
 */
#define USB_OTGHS_GINTMSK_WKUPINTMSK    (BIT(31))
#define USB_OTGHS_GINTMSK_WKUPINTMSK_M  (USB_OTGHS_GINTMSK_WKUPINTMSK_V << USB_OTGHS_GINTMSK_WKUPINTMSK_S)
#define USB_OTGHS_GINTMSK_WKUPINTMSK_V  0x00000001U
#define USB_OTGHS_GINTMSK_WKUPINTMSK_S  31

/** USB_OTGHS_GRXSTSR_REG register
 *  A read to the Receive Status Debug Read register returns the contents of the top of
 *  the Receive FIFO.  The receive status contents must be interpreted differently in
 *  Host and Device modes. The core ignores the receive status read when the receive
 *  FIFO is empty and returns a value of 32'h0000_0000.  Note:  - Use of these fields
 *  vary based on whether the core is functioning as a host or a device.  - Do not read
 *  this register's reset value before configuring the core because the read value is
 *  'X' in the simulation.
 */
#define USB_OTGHS_GRXSTSR_REG (DR_REG_USB_OTGHS_BASE + 0x1c)
/** USB_OTGHS_GRXSTSR_CHNUM : RO; bitpos: [3:0]; default: 0;
 *  Channel Number (ChNum)
 *  Mode: Host only
 *  Indicates the channel number to which the current received packet belongs.
 *  Endpoint Number (EPNum)
 *  Mode: Device only
 *  Indicates the endpoint number to which the current received packet belongs.
 */
#define USB_OTGHS_GRXSTSR_CHNUM    0x0000000FU
#define USB_OTGHS_GRXSTSR_CHNUM_M  (USB_OTGHS_GRXSTSR_CHNUM_V << USB_OTGHS_GRXSTSR_CHNUM_S)
#define USB_OTGHS_GRXSTSR_CHNUM_V  0x0000000FU
#define USB_OTGHS_GRXSTSR_CHNUM_S  0
/** USB_OTGHS_GRXSTSR_BCNT : RO; bitpos: [14:4]; default: 0;
 *  Byte Count (BCnt)
 *
 *  In host mode, indicates the byte count of the received IN data packet.
 *
 *  In device mode, indicates the byte count of the received data packet.
 */
#define USB_OTGHS_GRXSTSR_BCNT    0x000007FFU
#define USB_OTGHS_GRXSTSR_BCNT_M  (USB_OTGHS_GRXSTSR_BCNT_V << USB_OTGHS_GRXSTSR_BCNT_S)
#define USB_OTGHS_GRXSTSR_BCNT_V  0x000007FFU
#define USB_OTGHS_GRXSTSR_BCNT_S  4
/** USB_OTGHS_GRXSTSR_DPID : RO; bitpos: [16:15]; default: 0;
 *  Data PID (DPID)
 *
 *  In host mode, indicates the Data PID of the received packet. In device mode,
 *  indicates the Data PID of the received OUT data packet.
 *  - 2'b00: DATA0
 *  - 2'b10: DATA1
 *  - 2'b01: DATA2
 *  - 2'b11: MDATA
 *  Reset: 2'h0
 */
#define USB_OTGHS_GRXSTSR_DPID    0x00000003U
#define USB_OTGHS_GRXSTSR_DPID_M  (USB_OTGHS_GRXSTSR_DPID_V << USB_OTGHS_GRXSTSR_DPID_S)
#define USB_OTGHS_GRXSTSR_DPID_V  0x00000003U
#define USB_OTGHS_GRXSTSR_DPID_S  15
/** USB_OTGHS_GRXSTSR_PKTSTS : RO; bitpos: [20:17]; default: 0;
 *  Packet Status (PktSts) indicates the status of the received packet.
 *  In host mode,
 *  - 4'b0010: IN data packet received
 *  - 4'b0011: IN transfer completed (triggers an interrupt)
 *  - 4'b0101: Data toggle error (triggers an interrupt)
 *  - 4'b0111: Channel halted (triggers an interrupt)
 *  - Others: Reserved
 *  Reset:4'b0
 *
 *  In device mode,
 *  - 4'b0001: Global OUT NAK (triggers an interrupt)
 *  - 4'b0010: OUT data packet received
 *  - 4'b0011: OUT transfer completed (triggers an interrupt)
 *  - 4'b0100: SETUP transaction completed (triggers an interrupt)
 *  - 4'b0110: SETUP data packet received
 *  - Others: Reserved
 *  Reset:4'h0
 */
#define USB_OTGHS_GRXSTSR_PKTSTS    0x0000000FU
#define USB_OTGHS_GRXSTSR_PKTSTS_M  (USB_OTGHS_GRXSTSR_PKTSTS_V << USB_OTGHS_GRXSTSR_PKTSTS_S)
#define USB_OTGHS_GRXSTSR_PKTSTS_V  0x0000000FU
#define USB_OTGHS_GRXSTSR_PKTSTS_S  17
/** USB_OTGHS_GRXSTSR_FN : RO; bitpos: [24:21]; default: 0;
 *  Mode: Device only
 *  Frame Number (FN)
 *  This is the least significant 4 bits of the (micro)Frame number in which the packet
 *  is received on the USB. This field is supported only when isochronous OUT endpoints
 *  are supported.
 */
#define USB_OTGHS_GRXSTSR_FN    0x0000000FU
#define USB_OTGHS_GRXSTSR_FN_M  (USB_OTGHS_GRXSTSR_FN_V << USB_OTGHS_GRXSTSR_FN_S)
#define USB_OTGHS_GRXSTSR_FN_V  0x0000000FU
#define USB_OTGHS_GRXSTSR_FN_S  21

/** USB_OTGHS_GRXSTSP_REG register
 *  A read to the Receive Status Read and Pop register returns the contents of the top
 *  of the Receive FIFO and additionally pops the top data entry out of the RxFIFO. The
 *  receive status contents must be interpreted differently in Host and Device modes.
 *  The core ignores the receive status pop/read when the receive FIFO is empty and
 *  returns a value of 32'h0000_0000. The application must only pop the Receive Status
 *  FIFO when the Receive FIFO Non-Empty bit of the Core Interrupt register
 *  (GINTSTS.RxFLvl) is asserted.  Note:  - Use of these fields vary based on whether
 *  the core is functioning as a host or a device.  - Do not read this register's reset
 *  value before configuring the core because the read value is 'X' in the simulation.
 */
#define USB_OTGHS_GRXSTSP_REG (DR_REG_USB_OTGHS_BASE + 0x20)
/** USB_OTGHS_GRXSTSP_CHNUM : RO; bitpos: [3:0]; default: 0;
 *  Channel Number (ChNum)
 *  Mode: Host only
 *  Indicates the channel number to which the current received packet belongs.
 *  Endpoint Number (EPNum)
 *  Mode: Device only
 *  Indicates the endpoint number to which the current received packet belongs.
 */
#define USB_OTGHS_GRXSTSP_CHNUM    0x0000000FU
#define USB_OTGHS_GRXSTSP_CHNUM_M  (USB_OTGHS_GRXSTSP_CHNUM_V << USB_OTGHS_GRXSTSP_CHNUM_S)
#define USB_OTGHS_GRXSTSP_CHNUM_V  0x0000000FU
#define USB_OTGHS_GRXSTSP_CHNUM_S  0
/** USB_OTGHS_GRXSTSP_BCNT : RO; bitpos: [14:4]; default: 0;
 *  Byte Count (BCnt)
 *
 *  In host mode, indicates the byte count of the received IN data packet.
 *
 *  In device mode, indicates the byte count of the received data packet.
 */
#define USB_OTGHS_GRXSTSP_BCNT    0x000007FFU
#define USB_OTGHS_GRXSTSP_BCNT_M  (USB_OTGHS_GRXSTSP_BCNT_V << USB_OTGHS_GRXSTSP_BCNT_S)
#define USB_OTGHS_GRXSTSP_BCNT_V  0x000007FFU
#define USB_OTGHS_GRXSTSP_BCNT_S  4
/** USB_OTGHS_GRXSTSP_DPID : RO; bitpos: [16:15]; default: 0;
 *  Data PID (DPID)
 *
 *  In host mode, indicates the Data PID of the received packet. In device mode,
 *  indicates the Data PID of the received OUT data packet.
 *  - 2'b00: DATA0
 *  - 2'b10: DATA1
 *  - 2'b01: DATA2
 *  - 2'b11: MDATA
 *  Reset: 2'h0
 */
#define USB_OTGHS_GRXSTSP_DPID    0x00000003U
#define USB_OTGHS_GRXSTSP_DPID_M  (USB_OTGHS_GRXSTSP_DPID_V << USB_OTGHS_GRXSTSP_DPID_S)
#define USB_OTGHS_GRXSTSP_DPID_V  0x00000003U
#define USB_OTGHS_GRXSTSP_DPID_S  15
/** USB_OTGHS_GRXSTSP_PKTSTS : RO; bitpos: [20:17]; default: 0;
 *  Packet Status (PktSts) indicates the status of the received packet.
 *  In host mode,
 *  - 4'b0010: IN data packet received
 *  - 4'b0011: IN transfer completed (triggers an interrupt)
 *  - 4'b0101: Data toggle error (triggers an interrupt)
 *  - 4'b0111: Channel halted (triggers an interrupt)
 *  - Others: Reserved
 *  Reset:4'b0
 *
 *  In device mode,
 *  - 4'b0001: Global OUT NAK (triggers an interrupt)
 *  - 4'b0010: OUT data packet received
 *  - 4'b0011: OUT transfer completed (triggers an interrupt)
 *  - 4'b0100: SETUP transaction completed (triggers an interrupt)
 *  - 4'b0110: SETUP data packet received
 *  - Others: Reserved
 *  Reset:4'h0
 */
#define USB_OTGHS_GRXSTSP_PKTSTS    0x0000000FU
#define USB_OTGHS_GRXSTSP_PKTSTS_M  (USB_OTGHS_GRXSTSP_PKTSTS_V << USB_OTGHS_GRXSTSP_PKTSTS_S)
#define USB_OTGHS_GRXSTSP_PKTSTS_V  0x0000000FU
#define USB_OTGHS_GRXSTSP_PKTSTS_S  17
/** USB_OTGHS_GRXSTSP_FN : RO; bitpos: [24:21]; default: 0;
 *  Mode: Device only
 *  Frame Number (FN)
 *  This is the least significant 4 bits of the (micro)Frame number in which the packet
 *  is received on the USB. This field is supported only when isochronous OUT endpoints
 *  are supported.
 */
#define USB_OTGHS_GRXSTSP_FN    0x0000000FU
#define USB_OTGHS_GRXSTSP_FN_M  (USB_OTGHS_GRXSTSP_FN_V << USB_OTGHS_GRXSTSP_FN_S)
#define USB_OTGHS_GRXSTSP_FN_V  0x0000000FU
#define USB_OTGHS_GRXSTSP_FN_S  21

/** USB_OTGHS_GRXFSIZ_REG register
 *  The application can program the RAM size that must be allocated to the RxFIFO.
 */
#define USB_OTGHS_GRXFSIZ_REG (DR_REG_USB_OTGHS_BASE + 0x24)
/** USB_OTGHS_GRXFSIZ_RXFDEP : R/W; bitpos: [10:0]; default: 1024;
 *  Mode: Host and Device
 *  RxFIFO Depth (RxFDep)
 *  This value is in terms of 32-bit words.
 *  - Minimum value is 16
 *  - Maximum value is 32,768
 *  The power-on reset value of this register is specified as the Largest Rx Data FIFO
 *  Depth during configuration.
 *  If Enable Dynamic FIFO Sizing is selected in coreConsultant, these flops are
 *  optimized, and reads return the power-on value.
 *  If Enable Dynamic FIFO Sizing is selected in coreConsultant, you can write a new
 *  value in this field. Programmed values must not exceed the power-on value.
 */
#define USB_OTGHS_GRXFSIZ_RXFDEP    0x000007FFU
#define USB_OTGHS_GRXFSIZ_RXFDEP_M  (USB_OTGHS_GRXFSIZ_RXFDEP_V << USB_OTGHS_GRXFSIZ_RXFDEP_S)
#define USB_OTGHS_GRXFSIZ_RXFDEP_V  0x000007FFU
#define USB_OTGHS_GRXFSIZ_RXFDEP_S  0

/** USB_OTGHS_GNPTXFSIZ_REG register
 *  The application can program the RAM size and the memory start address for the
 *  Non-periodic TxFIFO  Note: The fields of this register change depending on host or
 *  device mode.
 */
#define USB_OTGHS_GNPTXFSIZ_REG (DR_REG_USB_OTGHS_BASE + 0x28)
/** USB_OTGHS_GNPTXFSIZ_NPTXFSTADDR : R/W; bitpos: [10:0]; default: 1024;
 *  Non-periodic Transmit RAM Start Address (NPTxFStAddr)
 *  For host mode, this field is always valid.
 *  This field contains the memory start address for Non-periodic Transmit FIFO RAM.
 *  - This field is determined during coreConsultant configuration by Enable Dynamic
 *  FIFO Sizing? (OTG_DFIFO_DYNAMIC):OTG_DFIFO_DYNAMIC = 0
 *  These flops are optimized, and reads return the power-on value.
 *  - OTG_DFIFO_DYNAMIC = 1 The application can write a new value in this field.
 *  Programmed values must not exceed the power-on value set in coreConsultant.
 *  Programmed values must not exceed the power-on value set in coreConsultant.
 *  The power-on reset value of this field is specified during coreConsultant
 *  configuration by Largest Rx Data FIFO Depth (parameter OTG_RX_DFIFO_DEPTH).
 */
#define USB_OTGHS_GNPTXFSIZ_NPTXFSTADDR    0x000007FFU
#define USB_OTGHS_GNPTXFSIZ_NPTXFSTADDR_M  (USB_OTGHS_GNPTXFSIZ_NPTXFSTADDR_V << USB_OTGHS_GNPTXFSIZ_NPTXFSTADDR_S)
#define USB_OTGHS_GNPTXFSIZ_NPTXFSTADDR_V  0x000007FFU
#define USB_OTGHS_GNPTXFSIZ_NPTXFSTADDR_S  0
/** USB_OTGHS_GNPTXFSIZ_NPTXFDEP : R/W; bitpos: [26:16]; default: 1024;
 *  Mode: Host only
 *  Non-periodic TxFIFO Depth (NPTxFDep)
 *  For host mode, this field is always valid.
 *  For device mode, this field is valid only when OTG_EN_DED_TX_FIFO=0.
 *  This value is in terms of 32-bit words.
 *  - Minimum value is 16
 *  - Maximum value is 32,768
 *  This attribute of field is determined during coreConsultant configuration by Enable
 *  Dynamic FIFO Sizing? (OTG_DFIFO_DYNAMIC):
 *  - OTG_DFIFO_DYNAMIC = 0: These flops are optimized, and reads return the power-on
 *  value.
 *  - OTG_DFIFO_DYNAMIC = 1: The application can write a new value in this field.
 *  Programmed values must not exceed the power-on value set in coreConsultant.
 *  The power-on reset value of this field is specified during coreConsultant
 *  configuration as Largest IN Endpoint FIFO 0 Depth (parameter
 *  OTG_TX_DINEP_DFIFO_DEPTH_0).
 */
#define USB_OTGHS_GNPTXFSIZ_NPTXFDEP    0x000007FFU
#define USB_OTGHS_GNPTXFSIZ_NPTXFDEP_M  (USB_OTGHS_GNPTXFSIZ_NPTXFDEP_V << USB_OTGHS_GNPTXFSIZ_NPTXFDEP_S)
#define USB_OTGHS_GNPTXFSIZ_NPTXFDEP_V  0x000007FFU
#define USB_OTGHS_GNPTXFSIZ_NPTXFDEP_S  16

/** USB_OTGHS_GNPTXSTS_REG register
 *  In Device mode, this register is valid only in Shared FIFO operation. This
 *  read-only register contains the free space information for the Non-periodic TxFIFO
 *  and the Non-periodic Transmit Request Queue.
 */
#define USB_OTGHS_GNPTXSTS_REG (DR_REG_USB_OTGHS_BASE + 0x2c)
/** USB_OTGHS_GNPTXSTS_NPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  Non-periodic TxFIFO Space Avail (NPTxFSpcAvail)
 *  Indicates the amount of free space available in the Non-periodic TxFIFO.
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Non-periodic TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0 <= n <= 32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  Reset: Configurable
 */
#define USB_OTGHS_GNPTXSTS_NPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_GNPTXSTS_NPTXFSPCAVAIL_M  (USB_OTGHS_GNPTXSTS_NPTXFSPCAVAIL_V << USB_OTGHS_GNPTXSTS_NPTXFSPCAVAIL_S)
#define USB_OTGHS_GNPTXSTS_NPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_GNPTXSTS_NPTXFSPCAVAIL_S  0
/** USB_OTGHS_GNPTXSTS_NPTXQSPCAVAIL : RO; bitpos: [23:16]; default: 8;
 *  Non-periodic Transmit Request Queue Space Available (NPTxQSpcAvail)
 *  Indicates the amount of free space available in the Non-periodic Transmit Request
 *  Queue. This queue holds both IN and OUT requests in Host mode. Device mode has only
 *  IN requests.
 *  - 8'h0: Non-periodic Transmit Request Queue is full
 *  - 8'h1: 1 location available
 *  - 8'h2: 2 locations available
 *  - n: n locations available (0 <= n <= 8)
 *  - Others: Reserved
 *  Reset: Configurable
 */
#define USB_OTGHS_GNPTXSTS_NPTXQSPCAVAIL    0x000000FFU
#define USB_OTGHS_GNPTXSTS_NPTXQSPCAVAIL_M  (USB_OTGHS_GNPTXSTS_NPTXQSPCAVAIL_V << USB_OTGHS_GNPTXSTS_NPTXQSPCAVAIL_S)
#define USB_OTGHS_GNPTXSTS_NPTXQSPCAVAIL_V  0x000000FFU
#define USB_OTGHS_GNPTXSTS_NPTXQSPCAVAIL_S  16
/** USB_OTGHS_GNPTXSTS_NPTXQTOP : RO; bitpos: [30:24]; default: 0;
 *  Top of the Non-periodic Transmit Request Queue (NPTxQTop)
 *  Entry in the Non-periodic Tx Request Queue that is currently being processed by the
 *  MAC.
 *
 *  - Bits [30:27]: Channel/endpoint number
 *  - Bits [26:25]:
 *  - 2'b00: IN/OUT token
 *  -- 2'b01: Zero-length transmit packet (device IN/host OUT)
 *  -- 2'b10: PING/CSPLIT token
 *  -- 2'b11: Channel halt command
 *  - Bit [24]: Terminate (last Entry for selected channel/endpoint)
 *  Reset: 7'h0
 */
#define USB_OTGHS_GNPTXSTS_NPTXQTOP    0x0000007FU
#define USB_OTGHS_GNPTXSTS_NPTXQTOP_M  (USB_OTGHS_GNPTXSTS_NPTXQTOP_V << USB_OTGHS_GNPTXSTS_NPTXQTOP_S)
#define USB_OTGHS_GNPTXSTS_NPTXQTOP_V  0x0000007FU
#define USB_OTGHS_GNPTXSTS_NPTXQTOP_S  24

/** USB_OTGHS_GPVNDCTL_REG register
 *  The application can use this register to access PHY registers. It is implemented
 *  only if Enable PHY Vendor Control Interface was selected during coreConsultant
 *  configuration (parameter OTG_VENDOR_CTL_INTERFACE = 1). For a UTMI+ PHY, the
 *  DWC_otg core uses the UTMI+ Vendor Control interface for PHY register access. For a
 *  ULPI PHY, the core uses the ULPI interface for PHY register access. The application
 *  sets Vendor Control register for PHY register access and times the PHY register
 *  access. The application polls the VStatus Done bit in this register for the
 *  completion of the PHY register access.
 */
#define USB_OTGHS_GPVNDCTL_REG (DR_REG_USB_OTGHS_BASE + 0x34)
/** USB_OTGHS_GPVNDCTL_REGDATA : R/W; bitpos: [7:0]; default: 0;
 *  Register Data (RegData)
 *
 *  Contains the write data for register write.
 *
 *  Read data for register read, valid when VStatus Done is set.
 */
#define USB_OTGHS_GPVNDCTL_REGDATA    0x000000FFU
#define USB_OTGHS_GPVNDCTL_REGDATA_M  (USB_OTGHS_GPVNDCTL_REGDATA_V << USB_OTGHS_GPVNDCTL_REGDATA_S)
#define USB_OTGHS_GPVNDCTL_REGDATA_V  0x000000FFU
#define USB_OTGHS_GPVNDCTL_REGDATA_S  0
/** USB_OTGHS_GPVNDCTL_VCTRL : R/W; bitpos: [15:8]; default: 0;
 *
 *  UTMI+ Vendor Control Register Address (VCtrl)
 *  The 4-bit register address a vendor defined 4-bit parallel
 *  output bus. Bits 11:8 of this field are placed on
 *  utmi_vcontrol[3:0].
 *  ULPI Extended Register Address (ExtRegAddr)
 *  The 6-bit PHY extended register address.
 */
#define USB_OTGHS_GPVNDCTL_VCTRL    0x000000FFU
#define USB_OTGHS_GPVNDCTL_VCTRL_M  (USB_OTGHS_GPVNDCTL_VCTRL_V << USB_OTGHS_GPVNDCTL_VCTRL_S)
#define USB_OTGHS_GPVNDCTL_VCTRL_V  0x000000FFU
#define USB_OTGHS_GPVNDCTL_VCTRL_S  8
/** USB_OTGHS_GPVNDCTL_REGADDR : R/W; bitpos: [21:16]; default: 0;
 *  Register Address (RegAddr)
 *
 *  The 6-bit PHY register address for immediate PHY Register set access. Set to 6'h2F
 *  for Extended PHY Register set access.
 */
#define USB_OTGHS_GPVNDCTL_REGADDR    0x0000003FU
#define USB_OTGHS_GPVNDCTL_REGADDR_M  (USB_OTGHS_GPVNDCTL_REGADDR_V << USB_OTGHS_GPVNDCTL_REGADDR_S)
#define USB_OTGHS_GPVNDCTL_REGADDR_V  0x0000003FU
#define USB_OTGHS_GPVNDCTL_REGADDR_S  16
/** USB_OTGHS_GPVNDCTL_REGWR : R/W; bitpos: [22]; default: 0;
 *
 *  Register Write (RegWr)
 *  Set this bit for register writes, and clear it for register reads.
 */
#define USB_OTGHS_GPVNDCTL_REGWR    (BIT(22))
#define USB_OTGHS_GPVNDCTL_REGWR_M  (USB_OTGHS_GPVNDCTL_REGWR_V << USB_OTGHS_GPVNDCTL_REGWR_S)
#define USB_OTGHS_GPVNDCTL_REGWR_V  0x00000001U
#define USB_OTGHS_GPVNDCTL_REGWR_S  22
/** USB_OTGHS_GPVNDCTL_NEWREGREQ : R/W; bitpos: [25]; default: 0;
 *
 *  New Register Request (NewRegReq)
 *
 *  The application sets this bit for a new vendor control
 *  access.
 */
#define USB_OTGHS_GPVNDCTL_NEWREGREQ    (BIT(25))
#define USB_OTGHS_GPVNDCTL_NEWREGREQ_M  (USB_OTGHS_GPVNDCTL_NEWREGREQ_V << USB_OTGHS_GPVNDCTL_NEWREGREQ_S)
#define USB_OTGHS_GPVNDCTL_NEWREGREQ_V  0x00000001U
#define USB_OTGHS_GPVNDCTL_NEWREGREQ_S  25
/** USB_OTGHS_GPVNDCTL_VSTSBSY : RO; bitpos: [26]; default: 0;
 *
 *  VStatus Busy (VStsBsy)
 *
 *  The core sets this bit when the vendor control access is in
 *  progress and clears this bit when done.
 */
#define USB_OTGHS_GPVNDCTL_VSTSBSY    (BIT(26))
#define USB_OTGHS_GPVNDCTL_VSTSBSY_M  (USB_OTGHS_GPVNDCTL_VSTSBSY_V << USB_OTGHS_GPVNDCTL_VSTSBSY_S)
#define USB_OTGHS_GPVNDCTL_VSTSBSY_V  0x00000001U
#define USB_OTGHS_GPVNDCTL_VSTSBSY_S  26
/** USB_OTGHS_GPVNDCTL_VSTSDONE : R/W; bitpos: [27]; default: 0;
 *
 *  VStatus Done (VStsDone)
 *
 *  The core sets this bit when the vendor control access is
 *  done.
 *  This bit is cleared by the core when the application sets the
 *  New Register Request bit (bit 25).
 */
#define USB_OTGHS_GPVNDCTL_VSTSDONE    (BIT(27))
#define USB_OTGHS_GPVNDCTL_VSTSDONE_M  (USB_OTGHS_GPVNDCTL_VSTSDONE_V << USB_OTGHS_GPVNDCTL_VSTSDONE_S)
#define USB_OTGHS_GPVNDCTL_VSTSDONE_V  0x00000001U
#define USB_OTGHS_GPVNDCTL_VSTSDONE_S  27
/** USB_OTGHS_GPVNDCTL_DISULPIDRVR : R/W; bitpos: [31]; default: 0;
 *
 *  Disable ULPI Drivers (DisUlpiDrvr)
 *
 *  The application sets this bit when it has finished processing
 *  the ULPI Carkit Interrupt (GINTSTS.ULPICKINT). When
 *  set, the controller disables drivers for output signals
 *  and masks input signal for the ULPI interface. The controller clears this bit
 *  before enabling the ULPI interface.
 */
#define USB_OTGHS_GPVNDCTL_DISULPIDRVR    (BIT(31))
#define USB_OTGHS_GPVNDCTL_DISULPIDRVR_M  (USB_OTGHS_GPVNDCTL_DISULPIDRVR_V << USB_OTGHS_GPVNDCTL_DISULPIDRVR_S)
#define USB_OTGHS_GPVNDCTL_DISULPIDRVR_V  0x00000001U
#define USB_OTGHS_GPVNDCTL_DISULPIDRVR_S  31

/** USB_OTGHS_GSNPSID_REG register
 *  This read-only register contains the release number of the core being used.
 */
#define USB_OTGHS_GSNPSID_REG (DR_REG_USB_OTGHS_BASE + 0x40)
/** USB_OTGHS_GSNPSID_SYNOPSYSID : RO; bitpos: [31:0]; default: 1330922250;
 *  Release number of the controller being used currently.
 *
 *  Bits [31:16]:
 *  - 0x4f54: ASCII Value for OT
 *  Bits [15:0]: Current Release Number. For example, 0x400a corresponds to v4.00a
 *  Release number.
 */
#define USB_OTGHS_GSNPSID_SYNOPSYSID    0xFFFFFFFFU
#define USB_OTGHS_GSNPSID_SYNOPSYSID_M  (USB_OTGHS_GSNPSID_SYNOPSYSID_V << USB_OTGHS_GSNPSID_SYNOPSYSID_S)
#define USB_OTGHS_GSNPSID_SYNOPSYSID_V  0xFFFFFFFFU
#define USB_OTGHS_GSNPSID_SYNOPSYSID_S  0

/** USB_OTGHS_GHWCFG1_REG register
 *  This register contains the logical endpoint direction(s) selected using
 *  coreConsultant.
 */
#define USB_OTGHS_GHWCFG1_REG (DR_REG_USB_OTGHS_BASE + 0x44)
/** USB_OTGHS_GHWCFG1_EPDIR : RO; bitpos: [31:0]; default: 0;
 *  This 32-bit field uses two bits per
 *  endpoint to determine the endpoint direction.
 *
 *  Endpoint
 *  - Bits [31:30]: Endpoint 15 direction
 *  - Bits [29:28]: Endpoint 14 direction
 *  ...
 *  - Bits [3:2]: Endpoint 1 direction
 *  - Bits[1:0]: Endpoint 0 direction (always BIDIR)
 *  Direction
 *  - 2'b00: BIDIR (IN and OUT) endpoint
 *  - 2'b01: IN endpoint
 *  - 2'b10: OUT endpoint
 *  - 2'b11: Reserved
 *  Note: This field is configured using the OTG_EP_DIR_1(n) parameter.
 */
#define USB_OTGHS_GHWCFG1_EPDIR    0xFFFFFFFFU
#define USB_OTGHS_GHWCFG1_EPDIR_M  (USB_OTGHS_GHWCFG1_EPDIR_V << USB_OTGHS_GHWCFG1_EPDIR_S)
#define USB_OTGHS_GHWCFG1_EPDIR_V  0xFFFFFFFFU
#define USB_OTGHS_GHWCFG1_EPDIR_S  0

/** USB_OTGHS_GHWCFG2_REG register
 *  This register contains configuration options selected using coreConsultant.
 */
#define USB_OTGHS_GHWCFG2_REG (DR_REG_USB_OTGHS_BASE + 0x48)
/** USB_OTGHS_GHWCFG2_OTGMODE : RO; bitpos: [2:0]; default: 2;
 *  Mode of Operation (OtgMode)
 *  - 3'b000: HNP- and SRP-Capable OTG (Host & Device)
 *  - 3'b001: SRP-Capable OTG (Host & Device)
 *  - 3'b010: Non-HNP and Non-SRP Capable OTG (Host and Device)
 *  - 3'b011: SRP-Capable Device
 *  - 3'b100: Non-OTG Device
 *  - 3'b101: SRP-Capable Host
 *  - 3'b110: Non-OTG Host
 *  - Others: Reserved
 *  Note: This field is configured using the OTG_MODE parameter.
 */
#define USB_OTGHS_GHWCFG2_OTGMODE    0x00000007U
#define USB_OTGHS_GHWCFG2_OTGMODE_M  (USB_OTGHS_GHWCFG2_OTGMODE_V << USB_OTGHS_GHWCFG2_OTGMODE_S)
#define USB_OTGHS_GHWCFG2_OTGMODE_V  0x00000007U
#define USB_OTGHS_GHWCFG2_OTGMODE_S  0
/** USB_OTGHS_GHWCFG2_OTGARCH : RO; bitpos: [4:3]; default: 2;
 *  Architecture (OtgArch)
 *  - 2'b00: Slave-Only
 *  - 2'b01: External DMA
 *  - 2'b10: Internal DMA
 *  - Others: Reserved
 *  Note: This field is configured using the OTG_ARCHITECTURE parameter.
 */
#define USB_OTGHS_GHWCFG2_OTGARCH    0x00000003U
#define USB_OTGHS_GHWCFG2_OTGARCH_M  (USB_OTGHS_GHWCFG2_OTGARCH_V << USB_OTGHS_GHWCFG2_OTGARCH_S)
#define USB_OTGHS_GHWCFG2_OTGARCH_V  0x00000003U
#define USB_OTGHS_GHWCFG2_OTGARCH_S  3
/** USB_OTGHS_GHWCFG2_SINGPNT : RO; bitpos: [5]; default: 0;
 *  Point-to-Point (SingPnt)
 *  - 1'b0: Multi-point application  (hub and split support)
 *  - 1'b1: Single-point application (no hub and split support)
 *  Note: This field is configured using the OTG_SINGLE_POINT parameter.
 */
#define USB_OTGHS_GHWCFG2_SINGPNT    (BIT(5))
#define USB_OTGHS_GHWCFG2_SINGPNT_M  (USB_OTGHS_GHWCFG2_SINGPNT_V << USB_OTGHS_GHWCFG2_SINGPNT_S)
#define USB_OTGHS_GHWCFG2_SINGPNT_V  0x00000001U
#define USB_OTGHS_GHWCFG2_SINGPNT_S  5
/** USB_OTGHS_GHWCFG2_HSPHYTYPE : RO; bitpos: [7:6]; default: 3;
 *  High-Speed PHY Interface Type (HSPhyType)
 *  - 2'b00: High-Speed interface not supported
 *  - 2'b01: UTMI+
 *  - 2'b10: ULPI
 *  - 2'b11: UTMI+ and ULPI
 *  Note: This field is configured using the OTG_HSPHY_INTERFACE parameter.
 */
#define USB_OTGHS_GHWCFG2_HSPHYTYPE    0x00000003U
#define USB_OTGHS_GHWCFG2_HSPHYTYPE_M  (USB_OTGHS_GHWCFG2_HSPHYTYPE_V << USB_OTGHS_GHWCFG2_HSPHYTYPE_S)
#define USB_OTGHS_GHWCFG2_HSPHYTYPE_V  0x00000003U
#define USB_OTGHS_GHWCFG2_HSPHYTYPE_S  6
/** USB_OTGHS_GHWCFG2_FSPHYTYPE : RO; bitpos: [9:8]; default: 2;
 *  Full-Speed PHY Interface Type (FSPhyType)
 *  - 2'b00: Full-speed interface not supported
 *  - 2'b01: Dedicated full-speed interface
 *  - 2'b10: FS pins shared with UTMI+ pins
 *  - 2'b11: FS pins shared with ULPI pins
 *  Note: This field is configured using the OTG_FSPHY_INTERFACE parameter.
 */
#define USB_OTGHS_GHWCFG2_FSPHYTYPE    0x00000003U
#define USB_OTGHS_GHWCFG2_FSPHYTYPE_M  (USB_OTGHS_GHWCFG2_FSPHYTYPE_V << USB_OTGHS_GHWCFG2_FSPHYTYPE_S)
#define USB_OTGHS_GHWCFG2_FSPHYTYPE_V  0x00000003U
#define USB_OTGHS_GHWCFG2_FSPHYTYPE_S  8
/** USB_OTGHS_GHWCFG2_NUMDEVEPS : RO; bitpos: [13:10]; default: 15;
 *  Number of Device Endpoints (NumDevEps)
 *
 *  Indicates the number of device endpoints supported by the core in Device mode.
 *
 *  The range of this field is 0-15.
 *
 *  Note: This field is configured using the OTG_NUM_EPS parameter.
 */
#define USB_OTGHS_GHWCFG2_NUMDEVEPS    0x0000000FU
#define USB_OTGHS_GHWCFG2_NUMDEVEPS_M  (USB_OTGHS_GHWCFG2_NUMDEVEPS_V << USB_OTGHS_GHWCFG2_NUMDEVEPS_S)
#define USB_OTGHS_GHWCFG2_NUMDEVEPS_V  0x0000000FU
#define USB_OTGHS_GHWCFG2_NUMDEVEPS_S  10
/** USB_OTGHS_GHWCFG2_NUMHSTCHNL : RO; bitpos: [17:14]; default: 15;
 *  Number of Host Channels (NumHstChnl)
 *  Indicates the number of host channels supported by the core in Host mode. The range
 *  of this field is 0-15: 0 specifies 1 channel, 15 specifies 16 channels.
 *
 *  Note: This field is configured using the OTG_NUM_HOST_CHAN parameter.
 */
#define USB_OTGHS_GHWCFG2_NUMHSTCHNL    0x0000000FU
#define USB_OTGHS_GHWCFG2_NUMHSTCHNL_M  (USB_OTGHS_GHWCFG2_NUMHSTCHNL_V << USB_OTGHS_GHWCFG2_NUMHSTCHNL_S)
#define USB_OTGHS_GHWCFG2_NUMHSTCHNL_V  0x0000000FU
#define USB_OTGHS_GHWCFG2_NUMHSTCHNL_S  14
/** USB_OTGHS_GHWCFG2_PERIOSUPPORT : RO; bitpos: [18]; default: 1;
 *  Periodic OUT Channels Supported in Host Mode (PerioSupport)
 *  - 1'b0: No
 *  - 1'b1: Yes
 *  Note: This field is configured using the OTG_EN_PERIO_HOST parameter.
 */
#define USB_OTGHS_GHWCFG2_PERIOSUPPORT    (BIT(18))
#define USB_OTGHS_GHWCFG2_PERIOSUPPORT_M  (USB_OTGHS_GHWCFG2_PERIOSUPPORT_V << USB_OTGHS_GHWCFG2_PERIOSUPPORT_S)
#define USB_OTGHS_GHWCFG2_PERIOSUPPORT_V  0x00000001U
#define USB_OTGHS_GHWCFG2_PERIOSUPPORT_S  18
/** USB_OTGHS_GHWCFG2_DYNFIFOSIZING : RO; bitpos: [19]; default: 1;
 *  Dynamic FIFO Sizing Enabled (DynFifoSizing)
 *  - 1'b0: No
 *  - 1'b1: Yes
 *  Note: This field is configured using the OTG_DFIFO_DYNAMIC parameter.
 */
#define USB_OTGHS_GHWCFG2_DYNFIFOSIZING    (BIT(19))
#define USB_OTGHS_GHWCFG2_DYNFIFOSIZING_M  (USB_OTGHS_GHWCFG2_DYNFIFOSIZING_V << USB_OTGHS_GHWCFG2_DYNFIFOSIZING_S)
#define USB_OTGHS_GHWCFG2_DYNFIFOSIZING_V  0x00000001U
#define USB_OTGHS_GHWCFG2_DYNFIFOSIZING_S  19
/** USB_OTGHS_GHWCFG2_MULTIPROCINTRPT : RO; bitpos: [20]; default: 1;
 *  Multi Processor Interrupt Enabled (MultiProcIntrpt)
 *  - 1'b0: No
 *  - 1'b1: Yes
 *  Note: This field is configured using the OTG_MULTI_PROC_INTRPT parameter.
 */
#define USB_OTGHS_GHWCFG2_MULTIPROCINTRPT    (BIT(20))
#define USB_OTGHS_GHWCFG2_MULTIPROCINTRPT_M  (USB_OTGHS_GHWCFG2_MULTIPROCINTRPT_V << USB_OTGHS_GHWCFG2_MULTIPROCINTRPT_S)
#define USB_OTGHS_GHWCFG2_MULTIPROCINTRPT_V  0x00000001U
#define USB_OTGHS_GHWCFG2_MULTIPROCINTRPT_S  20
/** USB_OTGHS_GHWCFG2_NPTXQDEPTH : RO; bitpos: [23:22]; default: 2;
 *  Non-periodic Request Queue Depth (NPTxQDepth)
 *  - 2'b00: 2
 *  - 2'b01: 4
 *  - 2'b10: 8
 *  - Others: Reserved
 *  Note: This field is configured using the OTG_NPERIO_TX_QUEUE_DEPTH parameter.
 */
#define USB_OTGHS_GHWCFG2_NPTXQDEPTH    0x00000003U
#define USB_OTGHS_GHWCFG2_NPTXQDEPTH_M  (USB_OTGHS_GHWCFG2_NPTXQDEPTH_V << USB_OTGHS_GHWCFG2_NPTXQDEPTH_S)
#define USB_OTGHS_GHWCFG2_NPTXQDEPTH_V  0x00000003U
#define USB_OTGHS_GHWCFG2_NPTXQDEPTH_S  22
/** USB_OTGHS_GHWCFG2_PTXQDEPTH : RO; bitpos: [25:24]; default: 3;
 *  Host Mode Periodic Request Queue Depth (PTxQDepth)
 *  - 2'b00: 2
 *  - 2'b01: 4
 *  - 2'b10: 8
 *  - 2'b11:16
 *  Note: This field is configured using the OTG_PERIO_TX_QUEUE_DEPTH parameter.
 */
#define USB_OTGHS_GHWCFG2_PTXQDEPTH    0x00000003U
#define USB_OTGHS_GHWCFG2_PTXQDEPTH_M  (USB_OTGHS_GHWCFG2_PTXQDEPTH_V << USB_OTGHS_GHWCFG2_PTXQDEPTH_S)
#define USB_OTGHS_GHWCFG2_PTXQDEPTH_V  0x00000003U
#define USB_OTGHS_GHWCFG2_PTXQDEPTH_S  24
/** USB_OTGHS_GHWCFG2_TKNQDEPTH : RO; bitpos: [30:26]; default: 8;
 *  Device Mode IN Token Sequence Learning Queue Depth (TknQDepth)
 *  Range: 0-30
 *
 *  Note: This field is configured using the OTG_TOKEN_QUEUE_DEPTH parameter.
 */
#define USB_OTGHS_GHWCFG2_TKNQDEPTH    0x0000001FU
#define USB_OTGHS_GHWCFG2_TKNQDEPTH_M  (USB_OTGHS_GHWCFG2_TKNQDEPTH_V << USB_OTGHS_GHWCFG2_TKNQDEPTH_S)
#define USB_OTGHS_GHWCFG2_TKNQDEPTH_V  0x0000001FU
#define USB_OTGHS_GHWCFG2_TKNQDEPTH_S  26

/** USB_OTGHS_GHWCFG3_REG register
 *  This register contains configuration options selected using coreConsultant.
 */
#define USB_OTGHS_GHWCFG3_REG (DR_REG_USB_OTGHS_BASE + 0x4c)
/** USB_OTGHS_GHWCFG3_XFERSIZEWIDTH : RO; bitpos: [3:0]; default: 8;
 *  Width of Transfer Size Counters (XferSizeWidth)
 *  - 4'b0000: 11 bits
 *  - 4'b0001: 12 bits
 *  ...
 *  - 4'b1000: 19 bits
 *  - Others: Reserved
 *  Note: This field is configured using the OTG_PACKET_COUNT_WIDTH parameter.
 */
#define USB_OTGHS_GHWCFG3_XFERSIZEWIDTH    0x0000000FU
#define USB_OTGHS_GHWCFG3_XFERSIZEWIDTH_M  (USB_OTGHS_GHWCFG3_XFERSIZEWIDTH_V << USB_OTGHS_GHWCFG3_XFERSIZEWIDTH_S)
#define USB_OTGHS_GHWCFG3_XFERSIZEWIDTH_V  0x0000000FU
#define USB_OTGHS_GHWCFG3_XFERSIZEWIDTH_S  0
/** USB_OTGHS_GHWCFG3_PKTSIZEWIDTH : RO; bitpos: [6:4]; default: 6;
 *  Width of Packet Size Counters (PktSizeWidth)
 *  - 3'b000: 4 bits
 *  - 3'b001: 5 bits
 *  - 3'b010: 6 bits
 *  - 3'b011: 7 bits
 *  - 3'b100: 8 bits
 *  - 3'b101: 9 bits
 *  - 3'b110: 10 bits
 *  - Others: Reserved
 *  Note: This field is configured using the OTG_PACKET_COUNT_WIDTH parameter.
 */
#define USB_OTGHS_GHWCFG3_PKTSIZEWIDTH    0x00000007U
#define USB_OTGHS_GHWCFG3_PKTSIZEWIDTH_M  (USB_OTGHS_GHWCFG3_PKTSIZEWIDTH_V << USB_OTGHS_GHWCFG3_PKTSIZEWIDTH_S)
#define USB_OTGHS_GHWCFG3_PKTSIZEWIDTH_V  0x00000007U
#define USB_OTGHS_GHWCFG3_PKTSIZEWIDTH_S  4
/** USB_OTGHS_GHWCFG3_OTGEN : RO; bitpos: [7]; default: 1;
 *  OTG Function Enabled (OtgEn)
 *
 *  The application uses this bit to indicate the OTG capabilities of the controller .
 *  - 1'b0: Not OTG capable
 *  - 1'b1: OTG Capable
 *  Note: This field is configured using the OTG_MODE parameter.
 */
#define USB_OTGHS_GHWCFG3_OTGEN    (BIT(7))
#define USB_OTGHS_GHWCFG3_OTGEN_M  (USB_OTGHS_GHWCFG3_OTGEN_V << USB_OTGHS_GHWCFG3_OTGEN_S)
#define USB_OTGHS_GHWCFG3_OTGEN_V  0x00000001U
#define USB_OTGHS_GHWCFG3_OTGEN_S  7
/** USB_OTGHS_GHWCFG3_I2CINTSEL : RO; bitpos: [8]; default: 0;
 *  I2C Selection (I2CIntSel)
 *  - 1'b0: I2C Interface is not available on the controller.
 *  - 1'b1: I2C Interface is available on the controller.
 *  Note: This field is configured using the OTG_I2C_INTERFACE parameter.
 */
#define USB_OTGHS_GHWCFG3_I2CINTSEL    (BIT(8))
#define USB_OTGHS_GHWCFG3_I2CINTSEL_M  (USB_OTGHS_GHWCFG3_I2CINTSEL_V << USB_OTGHS_GHWCFG3_I2CINTSEL_S)
#define USB_OTGHS_GHWCFG3_I2CINTSEL_V  0x00000001U
#define USB_OTGHS_GHWCFG3_I2CINTSEL_S  8
/** USB_OTGHS_GHWCFG3_VNDCTLSUPT : RO; bitpos: [9]; default: 1;
 *  Vendor Control Interface Support (VndctlSupt)
 *  - 1'b0: Vendor Control Interface is not available on the core.
 *  - 1'b1: Vendor Control Interface is available.
 *  Note: This field is configured using the OTG_VENDOR_CTL_INTERFACE parameter.
 */
#define USB_OTGHS_GHWCFG3_VNDCTLSUPT    (BIT(9))
#define USB_OTGHS_GHWCFG3_VNDCTLSUPT_M  (USB_OTGHS_GHWCFG3_VNDCTLSUPT_V << USB_OTGHS_GHWCFG3_VNDCTLSUPT_S)
#define USB_OTGHS_GHWCFG3_VNDCTLSUPT_V  0x00000001U
#define USB_OTGHS_GHWCFG3_VNDCTLSUPT_S  9
/** USB_OTGHS_GHWCFG3_OPTFEATURE : RO; bitpos: [10]; default: 1;
 *  Optional Features Removed (OptFeature)
 *  Indicates whether the User ID register, GPIO interface ports, and SOF toggle and
 *  counter ports were removed for gate count optimization by enabling Remove Optional
 *  Features.
 *  - 1'b0: No
 *  - 1'b1: Yes
 *  Note: This field is configured using the OTG_RM_OPT_FEATURES parameter.
 */
#define USB_OTGHS_GHWCFG3_OPTFEATURE    (BIT(10))
#define USB_OTGHS_GHWCFG3_OPTFEATURE_M  (USB_OTGHS_GHWCFG3_OPTFEATURE_V << USB_OTGHS_GHWCFG3_OPTFEATURE_S)
#define USB_OTGHS_GHWCFG3_OPTFEATURE_V  0x00000001U
#define USB_OTGHS_GHWCFG3_OPTFEATURE_S  10
/** USB_OTGHS_GHWCFG3_RSTTYPE : RO; bitpos: [11]; default: 0;
 *  Reset Style for Clocked always Blocks in RTL (RstType)
 *  - 1'b0: Asynchronous reset is used in the controller
 *  - 1'b1: Synchronous reset is used in the controller
 *  Note: This field is configured using the OTG_SYNC_RESET_TYPE parameter.
 */
#define USB_OTGHS_GHWCFG3_RSTTYPE    (BIT(11))
#define USB_OTGHS_GHWCFG3_RSTTYPE_M  (USB_OTGHS_GHWCFG3_RSTTYPE_V << USB_OTGHS_GHWCFG3_RSTTYPE_S)
#define USB_OTGHS_GHWCFG3_RSTTYPE_V  0x00000001U
#define USB_OTGHS_GHWCFG3_RSTTYPE_S  11
/** USB_OTGHS_GHWCFG3_ADPSUPPORT : RO; bitpos: [12]; default: 0;
 *  This bit indicates whether ADP logic is present within or external to the controller
 *  - 0: No ADP logic present with the controller
 *  - 1: ADP logic is present along with the controller.
 */
#define USB_OTGHS_GHWCFG3_ADPSUPPORT    (BIT(12))
#define USB_OTGHS_GHWCFG3_ADPSUPPORT_M  (USB_OTGHS_GHWCFG3_ADPSUPPORT_V << USB_OTGHS_GHWCFG3_ADPSUPPORT_S)
#define USB_OTGHS_GHWCFG3_ADPSUPPORT_V  0x00000001U
#define USB_OTGHS_GHWCFG3_ADPSUPPORT_S  12
/** USB_OTGHS_GHWCFG3_HSICMODE : RO; bitpos: [13]; default: 0;
 *  HSIC mode specified for Mode of Operation
 *  Value Range: 0 - 1
 *  - 1: HSIC-capable with shared UTMI PHY interface
 *  - 0: Non-HSIC-capable
 */
#define USB_OTGHS_GHWCFG3_HSICMODE    (BIT(13))
#define USB_OTGHS_GHWCFG3_HSICMODE_M  (USB_OTGHS_GHWCFG3_HSICMODE_V << USB_OTGHS_GHWCFG3_HSICMODE_S)
#define USB_OTGHS_GHWCFG3_HSICMODE_V  0x00000001U
#define USB_OTGHS_GHWCFG3_HSICMODE_S  13
/** USB_OTGHS_GHWCFG3_BCSUPPORT : RO; bitpos: [14]; default: 1;
 *  This bit indicates the controller support for Battery Charger.
 *  - 0 - No Battery Charger Support
 *  - 1 - Battery Charger support present
 */
#define USB_OTGHS_GHWCFG3_BCSUPPORT    (BIT(14))
#define USB_OTGHS_GHWCFG3_BCSUPPORT_M  (USB_OTGHS_GHWCFG3_BCSUPPORT_V << USB_OTGHS_GHWCFG3_BCSUPPORT_S)
#define USB_OTGHS_GHWCFG3_BCSUPPORT_V  0x00000001U
#define USB_OTGHS_GHWCFG3_BCSUPPORT_S  14
/** USB_OTGHS_GHWCFG3_LPMMODE : RO; bitpos: [15]; default: 0;
 *  LPM mode specified for Mode of Operation.
 */
#define USB_OTGHS_GHWCFG3_LPMMODE    (BIT(15))
#define USB_OTGHS_GHWCFG3_LPMMODE_M  (USB_OTGHS_GHWCFG3_LPMMODE_V << USB_OTGHS_GHWCFG3_LPMMODE_S)
#define USB_OTGHS_GHWCFG3_LPMMODE_V  0x00000001U
#define USB_OTGHS_GHWCFG3_LPMMODE_S  15
/** USB_OTGHS_GHWCFG3_DFIFODEPTH : RO; bitpos: [31:16]; default: 896;
 *  DFIFO Depth (DfifoDepth - EP_LOC_CNT)
 *
 *  This value is in terms of 32-bit words.
 *  - Minimum value is 32
 *  - Maximum value is 32,768
 *  Note: This field is configured using the OTG_DFIFO_DEPTH parameter. For more
 *  information on EP_LOC_CNT, see the Endpoint Information Controller (EPINFO_CTL)
 *  section.
 */
#define USB_OTGHS_GHWCFG3_DFIFODEPTH    0x0000FFFFU
#define USB_OTGHS_GHWCFG3_DFIFODEPTH_M  (USB_OTGHS_GHWCFG3_DFIFODEPTH_V << USB_OTGHS_GHWCFG3_DFIFODEPTH_S)
#define USB_OTGHS_GHWCFG3_DFIFODEPTH_V  0x0000FFFFU
#define USB_OTGHS_GHWCFG3_DFIFODEPTH_S  16

/** USB_OTGHS_GHWCFG4_REG register
 *  This register contains configuration options selected using coreConsultant. Note:
 *  Bit [31] is available only when Scatter/Gather DMA mode is enabled. When
 *  Scatter/Gather DMA mode is disabled, this field is reserved.
 */
#define USB_OTGHS_GHWCFG4_REG (DR_REG_USB_OTGHS_BASE + 0x50)
/** USB_OTGHS_GHWCFG4_NUMDEVPERIOEPS : RO; bitpos: [3:0]; default: 0;
 *  Number of Device Mode Periodic IN Endpoints (NumDevPerioEps)
 *
 *  Range: 0-15
 */
#define USB_OTGHS_GHWCFG4_NUMDEVPERIOEPS    0x0000000FU
#define USB_OTGHS_GHWCFG4_NUMDEVPERIOEPS_M  (USB_OTGHS_GHWCFG4_NUMDEVPERIOEPS_V << USB_OTGHS_GHWCFG4_NUMDEVPERIOEPS_S)
#define USB_OTGHS_GHWCFG4_NUMDEVPERIOEPS_V  0x0000000FU
#define USB_OTGHS_GHWCFG4_NUMDEVPERIOEPS_S  0
/** USB_OTGHS_GHWCFG4_PARTIALPWRDN : RO; bitpos: [4]; default: 1;
 *  Enable Partial Power Down (PartialPwrDn)
 *  - 1'b0: Partial Power Down Not Enabled
 *  - 1'b1: Partial Power Down Enabled
 */
#define USB_OTGHS_GHWCFG4_PARTIALPWRDN    (BIT(4))
#define USB_OTGHS_GHWCFG4_PARTIALPWRDN_M  (USB_OTGHS_GHWCFG4_PARTIALPWRDN_V << USB_OTGHS_GHWCFG4_PARTIALPWRDN_S)
#define USB_OTGHS_GHWCFG4_PARTIALPWRDN_V  0x00000001U
#define USB_OTGHS_GHWCFG4_PARTIALPWRDN_S  4
/** USB_OTGHS_GHWCFG4_AHBFREQ : RO; bitpos: [5]; default: 1;
 *  Minimum AHB Frequency Less Than 60 MHz (AhbFreq)
 *  - 1'b0: No
 *  - 1'b1: Yes
 */
#define USB_OTGHS_GHWCFG4_AHBFREQ    (BIT(5))
#define USB_OTGHS_GHWCFG4_AHBFREQ_M  (USB_OTGHS_GHWCFG4_AHBFREQ_V << USB_OTGHS_GHWCFG4_AHBFREQ_S)
#define USB_OTGHS_GHWCFG4_AHBFREQ_V  0x00000001U
#define USB_OTGHS_GHWCFG4_AHBFREQ_S  5
/** USB_OTGHS_GHWCFG4_HIBERNATION : RO; bitpos: [6]; default: 0;
 *  Enable Hibernation (Hibernation)
 *  - 1'b0: Hibernation feature not enabled
 *  - 1'b1: Hibernation feature enabled
 */
#define USB_OTGHS_GHWCFG4_HIBERNATION    (BIT(6))
#define USB_OTGHS_GHWCFG4_HIBERNATION_M  (USB_OTGHS_GHWCFG4_HIBERNATION_V << USB_OTGHS_GHWCFG4_HIBERNATION_S)
#define USB_OTGHS_GHWCFG4_HIBERNATION_V  0x00000001U
#define USB_OTGHS_GHWCFG4_HIBERNATION_S  6
/** USB_OTGHS_GHWCFG4_EXTENDEDHIBERNATION : RO; bitpos: [7]; default: 0;
 *  Enable Hibernation
 *  - 1'b0: Extended Hibernation feature not enabled
 *  - 1'b1: Extended Hibernation feature enabled
 */
#define USB_OTGHS_GHWCFG4_EXTENDEDHIBERNATION    (BIT(7))
#define USB_OTGHS_GHWCFG4_EXTENDEDHIBERNATION_M  (USB_OTGHS_GHWCFG4_EXTENDEDHIBERNATION_V << USB_OTGHS_GHWCFG4_EXTENDEDHIBERNATION_S)
#define USB_OTGHS_GHWCFG4_EXTENDEDHIBERNATION_V  0x00000001U
#define USB_OTGHS_GHWCFG4_EXTENDEDHIBERNATION_S  7
/** USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT1 : RO; bitpos: [9]; default: 1;
 *  Enhanced LPM Support1 (EnhancedLPMSupt1)
 *  - This bit indicates that the controller supports L1 entry based on FIFO status.
 *  - Accept L1 Request even if Bulk/Interrupt TxFIFO is not empty.
 */
#define USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT1    (BIT(9))
#define USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT1_M  (USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT1_V << USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT1_S)
#define USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT1_V  0x00000001U
#define USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT1_S  9
/** USB_OTGHS_GHWCFG4_SERVINTFLOW : RO; bitpos: [10]; default: 0;
 *  Service Interval Flow
 *
 *  This bit indicates that the controller supports Service-Interval based scheduling
 *  flow for ISOC IN EPs.
 */
#define USB_OTGHS_GHWCFG4_SERVINTFLOW    (BIT(10))
#define USB_OTGHS_GHWCFG4_SERVINTFLOW_M  (USB_OTGHS_GHWCFG4_SERVINTFLOW_V << USB_OTGHS_GHWCFG4_SERVINTFLOW_S)
#define USB_OTGHS_GHWCFG4_SERVINTFLOW_V  0x00000001U
#define USB_OTGHS_GHWCFG4_SERVINTFLOW_S  10
/** USB_OTGHS_GHWCFG4_IPGISOCSUPT : RO; bitpos: [11]; default: 1;
 *  Interpacket Gap ISOC OUT Worst-case Support (ipgisocSupt)
 *
 *  This bit indicates that the controller supports the worst-case scenario of Rx
 *  followed by Rx Inter Packet Gap (IPG) (32-bit times) as per the UTMI Specification
 *  for any token following an ISOC OUT token. Without this support, when any token
 *  follows an ISOC OUT token with the worst-case IPG, the controller does not detect
 *  the followed token. The worst-case IPG of the controller without this support
 *  depends on the AHB and PHY clock frequency.By default IPG Support is enabled.
 */
#define USB_OTGHS_GHWCFG4_IPGISOCSUPT    (BIT(11))
#define USB_OTGHS_GHWCFG4_IPGISOCSUPT_M  (USB_OTGHS_GHWCFG4_IPGISOCSUPT_V << USB_OTGHS_GHWCFG4_IPGISOCSUPT_S)
#define USB_OTGHS_GHWCFG4_IPGISOCSUPT_V  0x00000001U
#define USB_OTGHS_GHWCFG4_IPGISOCSUPT_S  11
/** USB_OTGHS_GHWCFG4_ACGSUPT : RO; bitpos: [12]; default: 0;
 *  Active Clock Gating Support
 *
 *  This bit indicates that the controller supports the Dynamic (Switching) Power
 *  Reduction during periods
 *  when there is no USB and AHB Traffic.
 *  - 1'b0:  Active Clock Gating is not enabled.
 *  - 1'b1:  Active Clock Gating Enabled.
 */
#define USB_OTGHS_GHWCFG4_ACGSUPT    (BIT(12))
#define USB_OTGHS_GHWCFG4_ACGSUPT_M  (USB_OTGHS_GHWCFG4_ACGSUPT_V << USB_OTGHS_GHWCFG4_ACGSUPT_S)
#define USB_OTGHS_GHWCFG4_ACGSUPT_V  0x00000001U
#define USB_OTGHS_GHWCFG4_ACGSUPT_S  12
/** USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT : RO; bitpos: [13]; default: 1;
 *  Enhanced LPM Support (EnhancedLPMSupt)
 *
 *  This bit indicates that the controller supports the following behavior:
 *  L1 Entry Behavior based on FIFO Status
 *  - TX FIFO
 *  - Accept L1 Request even if ISOC IN TX FIFO is not empty.
 *  - Reject L1 Request if Non-Periodic TX FIFO is not empty.
 *  - Ensure application can flush the TX FIFO while the Controller is in L1.
 *  - RX FIFO
 *  - Accept L1 Request even if RX FIFO (common to Periodic and Non-Periodic) is not
 *  empty.
 *  - Accept L1 Request but delay SLEEPM assertion until RX SINK Buffer is empty.
 *
 *  Prevent L1 Entry if a Control Transfer is in progress on any Control Endpoint.
 *  Ability to Flush TxFIFO even if PHY Clock is gated.
 *
 */
#define USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT    (BIT(13))
#define USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT_M  (USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT_V << USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT_S)
#define USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT_V  0x00000001U
#define USB_OTGHS_GHWCFG4_ENHANCEDLPMSUPT_S  13
/** USB_OTGHS_GHWCFG4_PHYDATAWIDTH : RO; bitpos: [15:14]; default: 2;
 *  UTMI+ PHY/ULPI-to-Internal UTMI+ Wrapper Data Width
 *  (PhyDataWidth)<vr>When a ULPI PHY is used, an internal wrapper converts ULPI to
 *  UTMI+.
 *  - 2'b00: 8 bits
 *  - 2'b01: 16 bits
 *  - 2'b10: 8/16 bits, software selectable
 *  - Others: Reserved
 */
#define USB_OTGHS_GHWCFG4_PHYDATAWIDTH    0x00000003U
#define USB_OTGHS_GHWCFG4_PHYDATAWIDTH_M  (USB_OTGHS_GHWCFG4_PHYDATAWIDTH_V << USB_OTGHS_GHWCFG4_PHYDATAWIDTH_S)
#define USB_OTGHS_GHWCFG4_PHYDATAWIDTH_V  0x00000003U
#define USB_OTGHS_GHWCFG4_PHYDATAWIDTH_S  14
/** USB_OTGHS_GHWCFG4_NUMCTLEPS : RO; bitpos: [19:16]; default: 1;
 *  Number of Device Mode Control Endpoints in Addition to
 *  Endpoint 0 (NumCtlEps)
 *  Range: 0-15
 */
#define USB_OTGHS_GHWCFG4_NUMCTLEPS    0x0000000FU
#define USB_OTGHS_GHWCFG4_NUMCTLEPS_M  (USB_OTGHS_GHWCFG4_NUMCTLEPS_V << USB_OTGHS_GHWCFG4_NUMCTLEPS_S)
#define USB_OTGHS_GHWCFG4_NUMCTLEPS_V  0x0000000FU
#define USB_OTGHS_GHWCFG4_NUMCTLEPS_S  16
/** USB_OTGHS_GHWCFG4_IDDGFLTR : RO; bitpos: [20]; default: 1;
 *  IDDIG Filter Enable (IddgFltr)
 *  - 1'b0: No filter
 *  - 1'b1: Filter
 */
#define USB_OTGHS_GHWCFG4_IDDGFLTR    (BIT(20))
#define USB_OTGHS_GHWCFG4_IDDGFLTR_M  (USB_OTGHS_GHWCFG4_IDDGFLTR_V << USB_OTGHS_GHWCFG4_IDDGFLTR_S)
#define USB_OTGHS_GHWCFG4_IDDGFLTR_V  0x00000001U
#define USB_OTGHS_GHWCFG4_IDDGFLTR_S  20
/** USB_OTGHS_GHWCFG4_VBUSVALIDFLTR : RO; bitpos: [21]; default: 0;
 *  VBUS Valid Filter Enabled (VBusValidFltr)
 *  - 1'b0: No filter
 *  - 1'b1: Filter
 */
#define USB_OTGHS_GHWCFG4_VBUSVALIDFLTR    (BIT(21))
#define USB_OTGHS_GHWCFG4_VBUSVALIDFLTR_M  (USB_OTGHS_GHWCFG4_VBUSVALIDFLTR_V << USB_OTGHS_GHWCFG4_VBUSVALIDFLTR_S)
#define USB_OTGHS_GHWCFG4_VBUSVALIDFLTR_V  0x00000001U
#define USB_OTGHS_GHWCFG4_VBUSVALIDFLTR_S  21
/** USB_OTGHS_GHWCFG4_AVALIDFLTR : RO; bitpos: [22]; default: 0;
 *  a_valid Filter Enabled (AValidFltr)
 *  - 1'b0: No filter
 *  - 1'b1: Filter
 */
#define USB_OTGHS_GHWCFG4_AVALIDFLTR    (BIT(22))
#define USB_OTGHS_GHWCFG4_AVALIDFLTR_M  (USB_OTGHS_GHWCFG4_AVALIDFLTR_V << USB_OTGHS_GHWCFG4_AVALIDFLTR_S)
#define USB_OTGHS_GHWCFG4_AVALIDFLTR_V  0x00000001U
#define USB_OTGHS_GHWCFG4_AVALIDFLTR_S  22
/** USB_OTGHS_GHWCFG4_BVALIDFLTR : RO; bitpos: [23]; default: 0;
 *  b_valid Filter Enabled (BValidFltr)
 *  - 1'b0: No filter
 *  - 1'b1: Filter
 */
#define USB_OTGHS_GHWCFG4_BVALIDFLTR    (BIT(23))
#define USB_OTGHS_GHWCFG4_BVALIDFLTR_M  (USB_OTGHS_GHWCFG4_BVALIDFLTR_V << USB_OTGHS_GHWCFG4_BVALIDFLTR_S)
#define USB_OTGHS_GHWCFG4_BVALIDFLTR_V  0x00000001U
#define USB_OTGHS_GHWCFG4_BVALIDFLTR_S  23
/** USB_OTGHS_GHWCFG4_SESSENDFLTR : RO; bitpos: [24]; default: 0;
 *  session_end Filter Enabled (SessEndFltr)
 *  - 1'b0: No filter
 *  - 1'b1: Filter
 */
#define USB_OTGHS_GHWCFG4_SESSENDFLTR    (BIT(24))
#define USB_OTGHS_GHWCFG4_SESSENDFLTR_M  (USB_OTGHS_GHWCFG4_SESSENDFLTR_V << USB_OTGHS_GHWCFG4_SESSENDFLTR_S)
#define USB_OTGHS_GHWCFG4_SESSENDFLTR_V  0x00000001U
#define USB_OTGHS_GHWCFG4_SESSENDFLTR_S  24
/** USB_OTGHS_GHWCFG4_DEDFIFOMODE : RO; bitpos: [25]; default: 1;
 *  Enable Dedicated Transmit FIFO for device IN Endpoints
 *  (DedFifoMode)
 *  - 1'b0 : Dedicated Transmit FIFO Operation not enabled.
 *  - 1'b1 : Dedicated Transmit FIFO Operation enabled.
 */
#define USB_OTGHS_GHWCFG4_DEDFIFOMODE    (BIT(25))
#define USB_OTGHS_GHWCFG4_DEDFIFOMODE_M  (USB_OTGHS_GHWCFG4_DEDFIFOMODE_V << USB_OTGHS_GHWCFG4_DEDFIFOMODE_S)
#define USB_OTGHS_GHWCFG4_DEDFIFOMODE_V  0x00000001U
#define USB_OTGHS_GHWCFG4_DEDFIFOMODE_S  25
/** USB_OTGHS_GHWCFG4_INEPS : RO; bitpos: [29:26]; default: 7;
 *  Number of Device Mode IN Endpoints Including Control Endpoints (INEps)
 *  - 0: 1 IN Endpoint
 *  - 1: 2 IN Endpoints
 *  ....
 *  - 15: 16 IN Endpoints
 */
#define USB_OTGHS_GHWCFG4_INEPS    0x0000000FU
#define USB_OTGHS_GHWCFG4_INEPS_M  (USB_OTGHS_GHWCFG4_INEPS_V << USB_OTGHS_GHWCFG4_INEPS_S)
#define USB_OTGHS_GHWCFG4_INEPS_V  0x0000000FU
#define USB_OTGHS_GHWCFG4_INEPS_S  26
/** USB_OTGHS_GHWCFG4_DESCDMAENABLED : RO; bitpos: [30]; default: 1;
 *  Scatter/Gather DMA configuration
 *  - 1'b0: Non-Scatter/Gather DMA configuration
 *  - 1'b1: Scatter/Gather DMA configuration
 */
#define USB_OTGHS_GHWCFG4_DESCDMAENABLED    (BIT(30))
#define USB_OTGHS_GHWCFG4_DESCDMAENABLED_M  (USB_OTGHS_GHWCFG4_DESCDMAENABLED_V << USB_OTGHS_GHWCFG4_DESCDMAENABLED_S)
#define USB_OTGHS_GHWCFG4_DESCDMAENABLED_V  0x00000001U
#define USB_OTGHS_GHWCFG4_DESCDMAENABLED_S  30
/** USB_OTGHS_GHWCFG4_DESCDMA : RO; bitpos: [31]; default: 1;
 *  Scatter/Gather DMA configuration
 *  - 1'b0: Non Dynamic configuration
 *  - 1'b1: Dynamic configuration
 *  Note: This field is configured using the OTG_EN_DESC_DMA parameter.
 */
#define USB_OTGHS_GHWCFG4_DESCDMA    (BIT(31))
#define USB_OTGHS_GHWCFG4_DESCDMA_M  (USB_OTGHS_GHWCFG4_DESCDMA_V << USB_OTGHS_GHWCFG4_DESCDMA_S)
#define USB_OTGHS_GHWCFG4_DESCDMA_V  0x00000001U
#define USB_OTGHS_GHWCFG4_DESCDMA_S  31

/** USB_OTGHS_GDFIFOCFG_REG register
 *  Register to configure the DFIFOs for the controller.
 */
#define USB_OTGHS_GDFIFOCFG_REG (DR_REG_USB_OTGHS_BASE + 0x5c)
/** USB_OTGHS_GDFIFOCFG_GDFIFOCFG : R/W; bitpos: [15:0]; default: 1024;
 *  GDFIFOCfg
 *
 *  This field is for dynamic programming of the DFIFO Size. This value takes effect
 *  only when the application programs a non zero value to this register. The value
 *  programmed must conform to the guidelines described in 'FIFO RAM Allocation'. The
 *  core does not have any corrective logic if the FIFO sizes are programmed
 *  incorrectly.
 */
#define USB_OTGHS_GDFIFOCFG_GDFIFOCFG    0x0000FFFFU
#define USB_OTGHS_GDFIFOCFG_GDFIFOCFG_M  (USB_OTGHS_GDFIFOCFG_GDFIFOCFG_V << USB_OTGHS_GDFIFOCFG_GDFIFOCFG_S)
#define USB_OTGHS_GDFIFOCFG_GDFIFOCFG_V  0x0000FFFFU
#define USB_OTGHS_GDFIFOCFG_GDFIFOCFG_S  0
/** USB_OTGHS_GDFIFOCFG_EPINFOBASEADDR : R/W; bitpos: [31:16]; default: 896;
 *  This field provides the start address of the EP info controller.
 *  The EP info controller manages the stored values in the last few locations of the
 *  SPRAM as listed below.
 *
 *  - Host Buffer DMA mode: One location per channel is used in SPRAM to store the
 *  HCDMAn value.
 *  - Host Scatter/Gather DMA mode: Four locations per channel are used in SPRAM to
 *  store the Base Descriptor address, Current Descriptor address, Current Buffer
 *  Pointer, and the Status Quadlet.
 *  - Device Buffer DMA mode: One location per endpoint direction is used in SPRAM to
 *  store the DIEPDMA and DOEPDMA value.
 *  - Device Scatter/Gather DMA mode: Four locations per endpoint direction are used in
 *  SPRAM to store the Base Descriptor address, Current Descriptor address, Current
 *  Buffer Pointer and the Status Quadlet.
 */
#define USB_OTGHS_GDFIFOCFG_EPINFOBASEADDR    0x0000FFFFU
#define USB_OTGHS_GDFIFOCFG_EPINFOBASEADDR_M  (USB_OTGHS_GDFIFOCFG_EPINFOBASEADDR_V << USB_OTGHS_GDFIFOCFG_EPINFOBASEADDR_S)
#define USB_OTGHS_GDFIFOCFG_EPINFOBASEADDR_V  0x0000FFFFU
#define USB_OTGHS_GDFIFOCFG_EPINFOBASEADDR_S  16

/** USB_OTGHS_GINTMSK2_REG register
 *  This register works with the Interrupt Register (GINTSTS2) to interrupt the
 *  application. When an interrupt bit is masked, the interrupt associated with that
 *  bit is not generated. However, the GINTSTS2 register bit corresponding to that
 *  interrupt is still set.  Note: The fields of this register change depending on host
 *  or device mode.
 */
#define USB_OTGHS_GINTMSK2_REG (DR_REG_USB_OTGHS_BASE + 0x68)
/** USB_OTGHS_GINTMSK2_GINTMSK2 : R/W; bitpos: [31:0]; default: 0;
 *  Resvered
 */
#define USB_OTGHS_GINTMSK2_GINTMSK2    0xFFFFFFFFU
#define USB_OTGHS_GINTMSK2_GINTMSK2_M  (USB_OTGHS_GINTMSK2_GINTMSK2_V << USB_OTGHS_GINTMSK2_GINTMSK2_S)
#define USB_OTGHS_GINTMSK2_GINTMSK2_V  0xFFFFFFFFU
#define USB_OTGHS_GINTMSK2_GINTMSK2_S  0

/** USB_OTGHS_GINTSTS2_REG register
 *  This register interrupts the application for system-level events in the current
 *  mode (Device mode or Host mode). Some of the bits in this register are valid only
 *  in Host mode, while others are valid in Device mode only. This register also
 *  indicates the current mode. To clear the interrupt status bits of type R_SS_WC, the
 *  application must write 1'b1 to the bit. The application must clear the GINTSTS2
 *  register at initialization before unmasking the interrupt bit to avoid any
 *  interrupts generated prior to initialization.
 */
#define USB_OTGHS_GINTSTS2_REG (DR_REG_USB_OTGHS_BASE + 0x6c)
/** USB_OTGHS_GINTSTS2_GINTSTS2 : R/W; bitpos: [31:0]; default: 0;
 *  Resvered
 */
#define USB_OTGHS_GINTSTS2_GINTSTS2    0xFFFFFFFFU
#define USB_OTGHS_GINTSTS2_GINTSTS2_M  (USB_OTGHS_GINTSTS2_GINTSTS2_V << USB_OTGHS_GINTSTS2_GINTSTS2_S)
#define USB_OTGHS_GINTSTS2_GINTSTS2_V  0xFFFFFFFFU
#define USB_OTGHS_GINTSTS2_GINTSTS2_S  0

/** USB_OTGHS_HPTXFSIZ_REG register
 *  This register holds the size and the memory start address of the Periodic TxFIFO.
 *  Note: Read the reset value of this register only after the following conditions:  -
 *  If IDDIG_FILTER is disabled, read only after PHY clock is stable.  - If
 *  IDDIG_FILTER is enabled, read only after the filter timer expires.
 */
#define USB_OTGHS_HPTXFSIZ_REG (DR_REG_USB_OTGHS_BASE + 0x100)
/** USB_OTGHS_HPTXFSIZ_PTXFSTADDR : R/W; bitpos: [11:0]; default: 2048;
 *  Host Periodic TxFIFO Start Address (PTxFStAddr)
 *
 *  The power-on reset value of this register is the sum of the Largest Rx Data FIFO
 *  Depth and Largest Non-periodic Tx Data FIFO Depth.These parameters are:
 *
 *  In shared FIFO operation:
 *  - OTG_RX_DFIFO_DEPTH + OTG_TX_NPERIO_DFIFO_DEPTH
 *
 *  In dedicated FIFO mode:
 *  - OTG_RX_DFIFO_DEPTH + OTG_TX_HNPERIO_DFIFO_DEPTH If Enable Dynamic FIFO Sizing?
 *  was deselected in coreConsultant (parameter OTG_DFIFO_DYNAMIC = 0), these flops are
 *  optimized, and reads return the power-on value. If Enable Dynamic FIFO Sizing? was
 *  selected in coreConsultant (parameter OTG_DFIFO_DYNAMIC = 1), you can write a new
 *  value in this field.
 *
 *  Programmed values must not exceed the power-on value set in coreConsultant.
 */
#define USB_OTGHS_HPTXFSIZ_PTXFSTADDR    0x00000FFFU
#define USB_OTGHS_HPTXFSIZ_PTXFSTADDR_M  (USB_OTGHS_HPTXFSIZ_PTXFSTADDR_V << USB_OTGHS_HPTXFSIZ_PTXFSTADDR_S)
#define USB_OTGHS_HPTXFSIZ_PTXFSTADDR_V  0x00000FFFU
#define USB_OTGHS_HPTXFSIZ_PTXFSTADDR_S  0
/** USB_OTGHS_HPTXFSIZ_PTXFSIZE : R/W; bitpos: [26:16]; default: 1024;
 *  Host Periodic TxFIFO Depth (PTxFSize)
 *
 *  This value is in terms of 32-bit words.
 *  - Minimum value is 16
 *  - Maximum value is 32,768
 *  The power-on reset value of this register is specified as the Largest Host Mode
 *  Periodic Tx Data FIFO Depth.
 *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
 *  value.
 *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
 *  Programmed values must not exceed the power-on value set in coreConsultant.
 */
#define USB_OTGHS_HPTXFSIZ_PTXFSIZE    0x000007FFU
#define USB_OTGHS_HPTXFSIZ_PTXFSIZE_M  (USB_OTGHS_HPTXFSIZ_PTXFSIZE_V << USB_OTGHS_HPTXFSIZ_PTXFSIZE_S)
#define USB_OTGHS_HPTXFSIZ_PTXFSIZE_V  0x000007FFU
#define USB_OTGHS_HPTXFSIZ_PTXFSIZE_S  16

/** USB_OTGHS_DIEPTXF1_REG register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
#define USB_OTGHS_DIEPTXF1_REG (DR_REG_USB_OTGHS_BASE + 0x104)
/** USB_OTGHS_DIEPTXF1_INEPNTXFSTADDR : R/W; bitpos: [10:0]; default: 1536;
 *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
 *
 *  This field contains the memory start address for the IN endpoint Transmit FIFO that
 *  this register corresponds to.
 *  The power-on reset value of this register is calculated according to the following
 *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
 *  (FIFO number-1).
 *  For example,
 *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
 *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
 *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
 *  so on.
 *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
 *  Reset Value(A) = (C-65536).
 *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
 *  = 0), this field is read-only and read value is the power-on reset value.
 *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
 *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
 *  depths, you can program their values according to the above formula. Programmed
 *  values must not exceed the power-on value set in coreConsultant.
 */
#define USB_OTGHS_DIEPTXF1_INEPNTXFSTADDR    0x000007FFU
#define USB_OTGHS_DIEPTXF1_INEPNTXFSTADDR_M  (USB_OTGHS_DIEPTXF1_INEPNTXFSTADDR_V << USB_OTGHS_DIEPTXF1_INEPNTXFSTADDR_S)
#define USB_OTGHS_DIEPTXF1_INEPNTXFSTADDR_V  0x000007FFU
#define USB_OTGHS_DIEPTXF1_INEPNTXFSTADDR_S  0
/** USB_OTGHS_DIEPTXF1_INEPNTXFDEP : R/W; bitpos: [25:16]; default: 512;
 *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
 *
 *  This value is in terms of 32-bit words.
 *  - Minimum value is 16
 *  - Maximum value is 32,768
 *  The power-on reset value of this register is specified as the Largest IN Endpoint
 *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
 *  configuration, where i is the FIFO number this register corresponds to.
 *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
 *  value.
 *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
 *  Programmed values must not exceed the power-on value.
 */
#define USB_OTGHS_DIEPTXF1_INEPNTXFDEP    0x000003FFU
#define USB_OTGHS_DIEPTXF1_INEPNTXFDEP_M  (USB_OTGHS_DIEPTXF1_INEPNTXFDEP_V << USB_OTGHS_DIEPTXF1_INEPNTXFDEP_S)
#define USB_OTGHS_DIEPTXF1_INEPNTXFDEP_V  0x000003FFU
#define USB_OTGHS_DIEPTXF1_INEPNTXFDEP_S  16

/** USB_OTGHS_DIEPTXF2_REG register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
#define USB_OTGHS_DIEPTXF2_REG (DR_REG_USB_OTGHS_BASE + 0x108)
/** USB_OTGHS_DIEPTXF2_INEPNTXFSTADDR : R/W; bitpos: [11:0]; default: 2048;
 *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
 *
 *  This field contains the memory start address for the IN endpoint Transmit FIFO that
 *  this register corresponds to.
 *  The power-on reset value of this register is calculated according to the following
 *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
 *  (FIFO number-1).
 *  For example,
 *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
 *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
 *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
 *  so on.
 *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
 *  Reset Value(A) = (C-65536).
 *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
 *  = 0), this field is read-only and read value is the power-on reset value.
 *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
 *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
 *  depths, you can program their values according to the above formula. Programmed
 *  values must not exceed the power-on value set in coreConsultant.
 */
#define USB_OTGHS_DIEPTXF2_INEPNTXFSTADDR    0x00000FFFU
#define USB_OTGHS_DIEPTXF2_INEPNTXFSTADDR_M  (USB_OTGHS_DIEPTXF2_INEPNTXFSTADDR_V << USB_OTGHS_DIEPTXF2_INEPNTXFSTADDR_S)
#define USB_OTGHS_DIEPTXF2_INEPNTXFSTADDR_V  0x00000FFFU
#define USB_OTGHS_DIEPTXF2_INEPNTXFSTADDR_S  0
/** USB_OTGHS_DIEPTXF2_INEPNTXFDEP : R/W; bitpos: [25:16]; default: 512;
 *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
 *
 *  This value is in terms of 32-bit words.
 *  - Minimum value is 16
 *  - Maximum value is 32,768
 *  The power-on reset value of this register is specified as the Largest IN Endpoint
 *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
 *  configuration, where i is the FIFO number this register corresponds to.
 *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
 *  value.
 *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
 *  Programmed values must not exceed the power-on value.
 */
#define USB_OTGHS_DIEPTXF2_INEPNTXFDEP    0x000003FFU
#define USB_OTGHS_DIEPTXF2_INEPNTXFDEP_M  (USB_OTGHS_DIEPTXF2_INEPNTXFDEP_V << USB_OTGHS_DIEPTXF2_INEPNTXFDEP_S)
#define USB_OTGHS_DIEPTXF2_INEPNTXFDEP_V  0x000003FFU
#define USB_OTGHS_DIEPTXF2_INEPNTXFDEP_S  16

/** USB_OTGHS_DIEPTXF3_REG register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
#define USB_OTGHS_DIEPTXF3_REG (DR_REG_USB_OTGHS_BASE + 0x10c)
/** USB_OTGHS_DIEPTXF3_INEPNTXFSTADDR : R/W; bitpos: [11:0]; default: 2560;
 *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
 *
 *  This field contains the memory start address for the IN endpoint Transmit FIFO that
 *  this register corresponds to.
 *  The power-on reset value of this register is calculated according to the following
 *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
 *  (FIFO number-1).
 *  For example,
 *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
 *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
 *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
 *  so on.
 *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
 *  Reset Value(A) = (C-65536).
 *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
 *  = 0), this field is read-only and read value is the power-on reset value.
 *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
 *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
 *  depths, you can program their values according to the above formula. Programmed
 *  values must not exceed the power-on value set in coreConsultant.
 */
#define USB_OTGHS_DIEPTXF3_INEPNTXFSTADDR    0x00000FFFU
#define USB_OTGHS_DIEPTXF3_INEPNTXFSTADDR_M  (USB_OTGHS_DIEPTXF3_INEPNTXFSTADDR_V << USB_OTGHS_DIEPTXF3_INEPNTXFSTADDR_S)
#define USB_OTGHS_DIEPTXF3_INEPNTXFSTADDR_V  0x00000FFFU
#define USB_OTGHS_DIEPTXF3_INEPNTXFSTADDR_S  0
/** USB_OTGHS_DIEPTXF3_INEPNTXFDEP : R/W; bitpos: [25:16]; default: 512;
 *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
 *
 *  This value is in terms of 32-bit words.
 *  - Minimum value is 16
 *  - Maximum value is 32,768
 *  The power-on reset value of this register is specified as the Largest IN Endpoint
 *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
 *  configuration, where i is the FIFO number this register corresponds to.
 *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
 *  value.
 *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
 *  Programmed values must not exceed the power-on value.
 */
#define USB_OTGHS_DIEPTXF3_INEPNTXFDEP    0x000003FFU
#define USB_OTGHS_DIEPTXF3_INEPNTXFDEP_M  (USB_OTGHS_DIEPTXF3_INEPNTXFDEP_V << USB_OTGHS_DIEPTXF3_INEPNTXFDEP_S)
#define USB_OTGHS_DIEPTXF3_INEPNTXFDEP_V  0x000003FFU
#define USB_OTGHS_DIEPTXF3_INEPNTXFDEP_S  16

/** USB_OTGHS_DIEPTXF4_REG register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
#define USB_OTGHS_DIEPTXF4_REG (DR_REG_USB_OTGHS_BASE + 0x110)
/** USB_OTGHS_DIEPTXF4_INEPNTXFSTADDR : R/W; bitpos: [11:0]; default: 3072;
 *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
 *
 *  This field contains the memory start address for the IN endpoint Transmit FIFO that
 *  this register corresponds to.
 *  The power-on reset value of this register is calculated according to the following
 *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
 *  (FIFO number-1).
 *  For example,
 *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
 *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
 *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
 *  so on.
 *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
 *  Reset Value(A) = (C-65536).
 *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
 *  = 0), this field is read-only and read value is the power-on reset value.
 *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
 *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
 *  depths, you can program their values according to the above formula. Programmed
 *  values must not exceed the power-on value set in coreConsultant.
 */
#define USB_OTGHS_DIEPTXF4_INEPNTXFSTADDR    0x00000FFFU
#define USB_OTGHS_DIEPTXF4_INEPNTXFSTADDR_M  (USB_OTGHS_DIEPTXF4_INEPNTXFSTADDR_V << USB_OTGHS_DIEPTXF4_INEPNTXFSTADDR_S)
#define USB_OTGHS_DIEPTXF4_INEPNTXFSTADDR_V  0x00000FFFU
#define USB_OTGHS_DIEPTXF4_INEPNTXFSTADDR_S  0
/** USB_OTGHS_DIEPTXF4_INEPNTXFDEP : R/W; bitpos: [25:16]; default: 512;
 *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
 *
 *  This value is in terms of 32-bit words.
 *  - Minimum value is 16
 *  - Maximum value is 32,768
 *  The power-on reset value of this register is specified as the Largest IN Endpoint
 *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
 *  configuration, where i is the FIFO number this register corresponds to.
 *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
 *  value.
 *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
 *  Programmed values must not exceed the power-on value.
 */
#define USB_OTGHS_DIEPTXF4_INEPNTXFDEP    0x000003FFU
#define USB_OTGHS_DIEPTXF4_INEPNTXFDEP_M  (USB_OTGHS_DIEPTXF4_INEPNTXFDEP_V << USB_OTGHS_DIEPTXF4_INEPNTXFDEP_S)
#define USB_OTGHS_DIEPTXF4_INEPNTXFDEP_V  0x000003FFU
#define USB_OTGHS_DIEPTXF4_INEPNTXFDEP_S  16

/** USB_OTGHS_DIEPTXF5_REG register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
#define USB_OTGHS_DIEPTXF5_REG (DR_REG_USB_OTGHS_BASE + 0x114)
/** USB_OTGHS_DIEPTXF5_INEPNTXFSTADDR : R/W; bitpos: [11:0]; default: 3584;
 *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
 *
 *  This field contains the memory start address for the IN endpoint Transmit FIFO that
 *  this register corresponds to.
 *  The power-on reset value of this register is calculated according to the following
 *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
 *  (FIFO number-1).
 *  For example,
 *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
 *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
 *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
 *  so on.
 *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
 *  Reset Value(A) = (C-65536).
 *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
 *  = 0), this field is read-only and read value is the power-on reset value.
 *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
 *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
 *  depths, you can program their values according to the above formula. Programmed
 *  values must not exceed the power-on value set in coreConsultant.
 */
#define USB_OTGHS_DIEPTXF5_INEPNTXFSTADDR    0x00000FFFU
#define USB_OTGHS_DIEPTXF5_INEPNTXFSTADDR_M  (USB_OTGHS_DIEPTXF5_INEPNTXFSTADDR_V << USB_OTGHS_DIEPTXF5_INEPNTXFSTADDR_S)
#define USB_OTGHS_DIEPTXF5_INEPNTXFSTADDR_V  0x00000FFFU
#define USB_OTGHS_DIEPTXF5_INEPNTXFSTADDR_S  0
/** USB_OTGHS_DIEPTXF5_INEPNTXFDEP : R/W; bitpos: [25:16]; default: 512;
 *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
 *
 *  This value is in terms of 32-bit words.
 *  - Minimum value is 16
 *  - Maximum value is 32,768
 *  The power-on reset value of this register is specified as the Largest IN Endpoint
 *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
 *  configuration, where i is the FIFO number this register corresponds to.
 *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
 *  value.
 *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
 *  Programmed values must not exceed the power-on value.
 */
#define USB_OTGHS_DIEPTXF5_INEPNTXFDEP    0x000003FFU
#define USB_OTGHS_DIEPTXF5_INEPNTXFDEP_M  (USB_OTGHS_DIEPTXF5_INEPNTXFDEP_V << USB_OTGHS_DIEPTXF5_INEPNTXFDEP_S)
#define USB_OTGHS_DIEPTXF5_INEPNTXFDEP_V  0x000003FFU
#define USB_OTGHS_DIEPTXF5_INEPNTXFDEP_S  16

/** USB_OTGHS_DIEPTXF6_REG register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
#define USB_OTGHS_DIEPTXF6_REG (DR_REG_USB_OTGHS_BASE + 0x118)
/** USB_OTGHS_DIEPTXF6_INEPNTXFSTADDR : R/W; bitpos: [12:0]; default: 4096;
 *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
 *
 *  This field contains the memory start address for the IN endpoint Transmit FIFO that
 *  this register corresponds to.
 *  The power-on reset value of this register is calculated according to the following
 *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
 *  (FIFO number-1).
 *  For example,
 *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
 *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
 *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
 *  so on.
 *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
 *  Reset Value(A) = (C-65536).
 *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
 *  = 0), this field is read-only and read value is the power-on reset value.
 *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
 *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
 *  depths, you can program their values according to the above formula. Programmed
 *  values must not exceed the power-on value set in coreConsultant.
 */
#define USB_OTGHS_DIEPTXF6_INEPNTXFSTADDR    0x00001FFFU
#define USB_OTGHS_DIEPTXF6_INEPNTXFSTADDR_M  (USB_OTGHS_DIEPTXF6_INEPNTXFSTADDR_V << USB_OTGHS_DIEPTXF6_INEPNTXFSTADDR_S)
#define USB_OTGHS_DIEPTXF6_INEPNTXFSTADDR_V  0x00001FFFU
#define USB_OTGHS_DIEPTXF6_INEPNTXFSTADDR_S  0
/** USB_OTGHS_DIEPTXF6_INEPNTXFDEP : R/W; bitpos: [25:16]; default: 512;
 *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
 *
 *  This value is in terms of 32-bit words.
 *  - Minimum value is 16
 *  - Maximum value is 32,768
 *  The power-on reset value of this register is specified as the Largest IN Endpoint
 *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
 *  configuration, where i is the FIFO number this register corresponds to.
 *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
 *  value.
 *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
 *  Programmed values must not exceed the power-on value.
 */
#define USB_OTGHS_DIEPTXF6_INEPNTXFDEP    0x000003FFU
#define USB_OTGHS_DIEPTXF6_INEPNTXFDEP_M  (USB_OTGHS_DIEPTXF6_INEPNTXFDEP_V << USB_OTGHS_DIEPTXF6_INEPNTXFDEP_S)
#define USB_OTGHS_DIEPTXF6_INEPNTXFDEP_V  0x000003FFU
#define USB_OTGHS_DIEPTXF6_INEPNTXFDEP_S  16

/** USB_OTGHS_DIEPTXF7_REG register
 *  This register is valid only in dedicated FIFO mode (OTG_EN_DED_TX_FIFO=1). It holds
 *  the size and memory start address of IN endpoint TxFIFOs implemented in Device
 *  mode. Each FIFO holds the data for one IN endpoint. This register is repeated for
 *  instantiated IN endpoint FIFOs 1 to 15. For IN endpoint FIFO 0, use GNPTXFSIZ
 *  register for programming the size and memory start address.
 */
#define USB_OTGHS_DIEPTXF7_REG (DR_REG_USB_OTGHS_BASE + 0x11c)
/** USB_OTGHS_DIEPTXF7_INEPNTXFSTADDR : R/W; bitpos: [12:0]; default: 4608;
 *  IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
 *
 *  This field contains the memory start address for the IN endpoint Transmit FIFO that
 *  this register corresponds to.
 *  The power-on reset value of this register is calculated according to the following
 *  formula: OTG_RX_DFIFO_DEPTH + SUM of OTG_TX_DINEP_DFIFO_DEPTH_'n', where n = 0 to
 *  (FIFO number-1).
 *  For example,
 *  Start address of INEP FIFO 1 (DIEPTXF1) is OTG_RX_DFIFO_DEPTH +
 *  OTG_TX_DINEP_DFIFO_DEPTH_0, start address of INEP FIFO 2 (DIEPTXF2) is
 *  OTG_RX_DFIFO_DEPTH + OTG_TX_DINEP_DFIFO_DEPTH_0 + OTG_TX_DINEP_DFIFO_DEPTH_1, and
 *  so on.
 *  If at POR the calculated value (C) exceeds 65535, then the Reset value becomes
 *  Reset Value(A) = (C-65536).
 *  - If Enable Dynamic FIFO Sizing is deselected in coreConsultant (OTG_DFIFO_DYNAMIC
 *  = 0), this field is read-only and read value is the power-on reset value.
 *  - If Enable Dynamic FIFO Sizing is selected in coreConsultant (OTG_DFIFO_DYNAMIC =
 *  1), and you have calculated or programmed a new value for RxFIFO depth or TX FIFO
 *  depths, you can program their values according to the above formula. Programmed
 *  values must not exceed the power-on value set in coreConsultant.
 */
#define USB_OTGHS_DIEPTXF7_INEPNTXFSTADDR    0x00001FFFU
#define USB_OTGHS_DIEPTXF7_INEPNTXFSTADDR_M  (USB_OTGHS_DIEPTXF7_INEPNTXFSTADDR_V << USB_OTGHS_DIEPTXF7_INEPNTXFSTADDR_S)
#define USB_OTGHS_DIEPTXF7_INEPNTXFSTADDR_V  0x00001FFFU
#define USB_OTGHS_DIEPTXF7_INEPNTXFSTADDR_S  0
/** USB_OTGHS_DIEPTXF7_INEPNTXFDEP : R/W; bitpos: [25:16]; default: 512;
 *  IN Endpoint TxFIFO Depth (INEPnTxFDep)
 *
 *  This value is in terms of 32-bit words.
 *  - Minimum value is 16
 *  - Maximum value is 32,768
 *  The power-on reset value of this register is specified as the Largest IN Endpoint
 *  FIFO number Depth (parameter OTG_TX_DINEP_DFIFO_DEPTH_i) set during coreConsultant
 *  configuration, where i is the FIFO number this register corresponds to.
 *  - If Enable Dynamic FIFO Sizing? was deselected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 0), these flops are optimized, and reads return the power-on
 *  value.
 *  - If Enable Dynamic FIFO Sizing? was selected in coreConsultant (parameter
 *  OTG_DFIFO_DYNAMIC = 1), you can write a new value in this field.
 *  Programmed values must not exceed the power-on value.
 */
#define USB_OTGHS_DIEPTXF7_INEPNTXFDEP    0x000003FFU
#define USB_OTGHS_DIEPTXF7_INEPNTXFDEP_M  (USB_OTGHS_DIEPTXF7_INEPNTXFDEP_V << USB_OTGHS_DIEPTXF7_INEPNTXFDEP_S)
#define USB_OTGHS_DIEPTXF7_INEPNTXFDEP_V  0x000003FFU
#define USB_OTGHS_DIEPTXF7_INEPNTXFDEP_S  16

/** USB_OTGHS_HCFG_REG register
 *  This register is used to configure the controller in Host mode.
 */
#define USB_OTGHS_HCFG_REG (DR_REG_USB_OTGHS_BASE + 0x400)
/** USB_OTGHS_HCFG_FSLSPCLKSEL : R/W; bitpos: [1:0]; default: 0;
 *  FS/LS PHY Clock Select (FSLSPclkSel)
 *
 *  When the core is in FS Host mode
 *  - 2'b00: PHY clock is running at 30/60 MHz
 *  - 2'b01: PHY clock is running at 48 MHz
 *  - Others: Reserved
 *  When the core is in LS Host mode
 *  - 2'b00: PHY clock is running at 30/60 MHz. When the UTMI+/ULPI PHY Low Power mode
 *  is not selected, use 30/60 MHz.
 *  - 2'b01: PHY clock is running at 48 MHz. When the UTMI+ PHY Low Power mode is
 *  selected, use 48MHz If the PHY supplies a 48 MHz clock during LS mode.
 *  - 2'b10: PHY clock is running at 6 MHz. In USB 1.1 FS mode, use 6 MHz when the
 *  UTMI+ PHY Low Power mode is selected and the PHY supplies a 6 MHz clock during LS
 *  mode. If you select a 6 MHz clock during LS mode, you must do a soft reset.
 *  - 2'b11: Reserved
 *  Notes:
 *  - When Core in FS mode, the internal and external clocks have the same frequency.
 *  - When Core in LS mode,
 *  -- If FSLSPclkSel = 2'b00: Internal and external clocks have the same frequency
 *  -- If FSLSPclkSel = 2'b10: Internal clock is the divided by eight version of
 *  external 48 MHz clock
 */
#define USB_OTGHS_HCFG_FSLSPCLKSEL    0x00000003U
#define USB_OTGHS_HCFG_FSLSPCLKSEL_M  (USB_OTGHS_HCFG_FSLSPCLKSEL_V << USB_OTGHS_HCFG_FSLSPCLKSEL_S)
#define USB_OTGHS_HCFG_FSLSPCLKSEL_V  0x00000003U
#define USB_OTGHS_HCFG_FSLSPCLKSEL_S  0
/** USB_OTGHS_HCFG_FSLSSUPP : R/W; bitpos: [2]; default: 0;
 *  FS- and LS-Only Support (FSLSSupp)
 *
 *  The application uses this bit to control the core's enumeration speed. Using this
 *  bit, the application can make the core
 *  enumerate as a FS host, even If the connected device supports HS traffic. Do not
 *  make changes to this field after initial
 *  programming.
 *  - 1'b0: HS/FS/LS, based on the maximum speed supported by the connected device
 *  - 1'b1: FS/LS-only, even If the connected device can support HS
 */
#define USB_OTGHS_HCFG_FSLSSUPP    (BIT(2))
#define USB_OTGHS_HCFG_FSLSSUPP_M  (USB_OTGHS_HCFG_FSLSSUPP_V << USB_OTGHS_HCFG_FSLSSUPP_S)
#define USB_OTGHS_HCFG_FSLSSUPP_V  0x00000001U
#define USB_OTGHS_HCFG_FSLSSUPP_S  2
/** USB_OTGHS_HCFG_ENA32KHZS : R/W; bitpos: [7]; default: 0;
 *  Enable 32 KHz Suspend mode (Ena32KHzS)
 *
 *  This bit can be set only in FS PHY interface is selected.
 *  Else, this bit needs to be set to zero.
 *  When FS PHY interface is chosen and this bit is set,
 *  the core expects that the PHY clock during Suspend is switched
 *  from 48 MHz to 32 KHz.
 */
#define USB_OTGHS_HCFG_ENA32KHZS    (BIT(7))
#define USB_OTGHS_HCFG_ENA32KHZS_M  (USB_OTGHS_HCFG_ENA32KHZS_V << USB_OTGHS_HCFG_ENA32KHZS_S)
#define USB_OTGHS_HCFG_ENA32KHZS_V  0x00000001U
#define USB_OTGHS_HCFG_ENA32KHZS_S  7
/** USB_OTGHS_HCFG_RESVALID : R/W; bitpos: [15:8]; default: 2;
 *  Resume Validation Period  (ResValid)
 *
 *  This field is effective only when HCFG.Ena32KHzS is set.
 *  It controls the resume period when the core resumes from suspend.
 *  The core counts for 'ResValid' number of clock cycles to detect a
 *  valid resume when this is set.
 */
#define USB_OTGHS_HCFG_RESVALID    0x000000FFU
#define USB_OTGHS_HCFG_RESVALID_M  (USB_OTGHS_HCFG_RESVALID_V << USB_OTGHS_HCFG_RESVALID_S)
#define USB_OTGHS_HCFG_RESVALID_V  0x000000FFU
#define USB_OTGHS_HCFG_RESVALID_S  8
/** USB_OTGHS_HCFG_DESCDMA : R/W; bitpos: [23]; default: 0;
 *  Enable Scatter/gather DMA in Host mode (DescDMA)
 *
 *  When the Scatter/Gather DMA option selected during configuration of the RTL, the
 *  application can set this bit during initialization
 *  to enable the Scatter/Gather DMA operation.
 *
 *  Note: This bit must be modified only once after a reset.
 *
 *  The following combinations are available for programming:
 *  - GAHBCFG.DMAEn=0,HCFG.DescDMA=0 => Slave mode
 *  - GAHBCFG.DMAEn=0,HCFG.DescDMA=1 => Invalid
 *  - GAHBCFG.DMAEn=1,HCFG.DescDMA=0 => Buffered DMA mode
 *  - GAHBCFG.DMAEn=1,HCFG.DescDMA=1 => Scatter/Gather DMA mode
 */
#define USB_OTGHS_HCFG_DESCDMA    (BIT(23))
#define USB_OTGHS_HCFG_DESCDMA_M  (USB_OTGHS_HCFG_DESCDMA_V << USB_OTGHS_HCFG_DESCDMA_S)
#define USB_OTGHS_HCFG_DESCDMA_V  0x00000001U
#define USB_OTGHS_HCFG_DESCDMA_S  23
/** USB_OTGHS_HCFG_FRLISTEN : R/W; bitpos: [25:24]; default: 0;
 *  Frame List Entries(FrListEn)
 *
 *  The value in the register specifies the number of entries in the Frame list.
 *  This field is valid only in Scatter/Gather DMA mode.
 *  - 2'b00: 8 Entries
 *  - 2'b01: 16 Entries
 *  - 2'b10: 32 Entries
 *  - 2'b11: 64 Entries
 */
#define USB_OTGHS_HCFG_FRLISTEN    0x00000003U
#define USB_OTGHS_HCFG_FRLISTEN_M  (USB_OTGHS_HCFG_FRLISTEN_V << USB_OTGHS_HCFG_FRLISTEN_S)
#define USB_OTGHS_HCFG_FRLISTEN_V  0x00000003U
#define USB_OTGHS_HCFG_FRLISTEN_S  24
/** USB_OTGHS_HCFG_PERSCHEDENA : R/W; bitpos: [26]; default: 0;
 *  Enable Periodic Scheduling (PerSchedEna):
 *
 *  Applicable in host DDMA mode only.
 *  Enables periodic scheduling within the core. Initially, the bit is reset.
 *  The core does not process any periodic channels.
 *
 *  As soon as this bit is set,
 *  the core gets ready to start scheduling periodic channels and
 *  sets HCFG.PerSchedStat. The setting of HCFG.PerSchedStat indicates the core
 *  has enabled periodic scheduling. Once HCFG.PerSchedEna is set,
 *  the application is not supposed to again reset the bit unless HCFG.PerSchedStat
 *  is set.
 *
 *  As soon as this bit is reset, the core gets ready to
 *  stop scheduling periodic channels and resets HCFG.PerSchedStat.
 */
#define USB_OTGHS_HCFG_PERSCHEDENA    (BIT(26))
#define USB_OTGHS_HCFG_PERSCHEDENA_M  (USB_OTGHS_HCFG_PERSCHEDENA_V << USB_OTGHS_HCFG_PERSCHEDENA_S)
#define USB_OTGHS_HCFG_PERSCHEDENA_V  0x00000001U
#define USB_OTGHS_HCFG_PERSCHEDENA_S  26
/** USB_OTGHS_HCFG_MODECHTIMEN : R/W; bitpos: [31]; default: 0;
 *  Mode Change Ready Timer Enable (ModeChTimEn)
 *
 *  This bit is used to enable/disable the Host core to wait  200 PHY clock cycles at
 *  the end of Resume to change the opmode signal to the PHY to 00
 *  after Suspend or LPM.
 *  - 1'b0 : The Host core waits for either 200 PHY clock cycles or a linestate of SE0
 *  at the end of resume to the change the opmode from 2'b10 to 2'b00
 *  - 1'b1 : The Host core waits only for a linestate of SE0 at the end of resume to
 *  change the opmode from 2'b10 to 2'b00.
 */
#define USB_OTGHS_HCFG_MODECHTIMEN    (BIT(31))
#define USB_OTGHS_HCFG_MODECHTIMEN_M  (USB_OTGHS_HCFG_MODECHTIMEN_V << USB_OTGHS_HCFG_MODECHTIMEN_S)
#define USB_OTGHS_HCFG_MODECHTIMEN_V  0x00000001U
#define USB_OTGHS_HCFG_MODECHTIMEN_S  31

/** USB_OTGHS_HFIR_REG register
 *  This register is used to control the interval between two consecutive SOFs.
 */
#define USB_OTGHS_HFIR_REG (DR_REG_USB_OTGHS_BASE + 0x404)
/** USB_OTGHS_HFIR_FRINT : R/W; bitpos: [15:0]; default: 60000;
 *  Frame Interval (FrInt)
 *
 *  The value that the application programs to this field specifies
 *  the interval between two consecutive SOFs (FS) or micro-
 *  SOFs (HS) or Keep-Alive tokens (HS). This field contains the
 *  number of PHY clocks that constitute the required frame
 *  interval. The Default value set in this field  is for FS operation
 *  when the PHY clock frequency is 60 MHz. The application can
 *  write a value to this register only after the Port Enable bit of the
 *  Host Port Control and Status register (HPRT.PrtEnaPort) has
 *  been Set. If no value is programmed, the core calculates the
 *  value based on the PHY clock specified in the FS/LS PHY
 *  Clock Select field of the Host Configuration register
 *  (HCFG.FSLSPclkSel). Do not change the value of this field
 *  after the initial configuration.
 *  - 125 us * (PHY clock frequency for HS)
 *  - 1 ms * (PHY clock frequency for FS/LS)
 */
#define USB_OTGHS_HFIR_FRINT    0x0000FFFFU
#define USB_OTGHS_HFIR_FRINT_M  (USB_OTGHS_HFIR_FRINT_V << USB_OTGHS_HFIR_FRINT_S)
#define USB_OTGHS_HFIR_FRINT_V  0x0000FFFFU
#define USB_OTGHS_HFIR_FRINT_S  0
/** USB_OTGHS_HFIR_HFIRRLDCTRL : R/W; bitpos: [16]; default: 0;
 *  Reload Control (HFIRRldCtrl)
 *
 *  This bit allows dynamic reloading of the HFIR register during run time.
 *  - 1'b0 : The HFIR cannot be reloaded dynamically
 *  - 1'b1: the HFIR can be dynamically reloaded during runtime.
 *  This bit needs to be programmed during initial configuration and its value must not
 *  be changed during runtime.
 */
#define USB_OTGHS_HFIR_HFIRRLDCTRL    (BIT(16))
#define USB_OTGHS_HFIR_HFIRRLDCTRL_M  (USB_OTGHS_HFIR_HFIRRLDCTRL_V << USB_OTGHS_HFIR_HFIRRLDCTRL_S)
#define USB_OTGHS_HFIR_HFIRRLDCTRL_V  0x00000001U
#define USB_OTGHS_HFIR_HFIRRLDCTRL_S  16

/** USB_OTGHS_HFNUM_REG register
 *  This register indicates the current frame number. It also indicates the time
 *  remaining (in terms of the number of PHY clocks) in the current (micro)frame.
 *  Note: Read the reset value of this register only after the following conditions:  -
 *  If IDDIG_FILTER is disabled, read only when the PHY clock is stable.  - If
 *  IDDIG_FILTER is enabled, read only after the filter timer expires.
 */
#define USB_OTGHS_HFNUM_REG (DR_REG_USB_OTGHS_BASE + 0x408)
/** USB_OTGHS_HFNUM_FRNUM : RO; bitpos: [15:0]; default: 16383;
 *  Frame Number (FrNum)
 *
 *  This field increments when a new SOF is transmitted on the
 *  USB, and is reset to 0 when it reaches 16'h3FFF.
 */
#define USB_OTGHS_HFNUM_FRNUM    0x0000FFFFU
#define USB_OTGHS_HFNUM_FRNUM_M  (USB_OTGHS_HFNUM_FRNUM_V << USB_OTGHS_HFNUM_FRNUM_S)
#define USB_OTGHS_HFNUM_FRNUM_V  0x0000FFFFU
#define USB_OTGHS_HFNUM_FRNUM_S  0
/** USB_OTGHS_HFNUM_FRREM : RO; bitpos: [31:16]; default: 0;
 *  Frame Time Remaining (FrRem)
 *
 *  Indicates the amount of time remaining in the current
 *  microframe (HS) or Frame (FS/LS), in terms of PHY clocks. This
 *  field decrements on each PHY clock. When it reaches zero, this
 *  field is reloaded with the value in the Frame Interval register and
 *  a new SOF is transmitted on the USB.
 */
#define USB_OTGHS_HFNUM_FRREM    0x0000FFFFU
#define USB_OTGHS_HFNUM_FRREM_M  (USB_OTGHS_HFNUM_FRREM_V << USB_OTGHS_HFNUM_FRREM_S)
#define USB_OTGHS_HFNUM_FRREM_V  0x0000FFFFU
#define USB_OTGHS_HFNUM_FRREM_S  16

/** USB_OTGHS_HPTXSTS_REG register
 *  This register contains information about the Periodic Transmit Queue in the Host
 *  controller.
 */
#define USB_OTGHS_HPTXSTS_REG (DR_REG_USB_OTGHS_BASE + 0x410)
/** USB_OTGHS_HPTXSTS_PTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  Periodic Transmit Data FIFO Space Available (PTxFSpcAvail)
 *
 *  Indicates the number of free locations available to be written to in the Periodic
 *  TxFIFO.
 *
 *  Values are in terms of 32-bit words
 *  - 16'h0    : Periodic TxFIFO is full
 *  - 16'h1    : 1 word available
 *  - 16'h2    : 2 words available
 *  - 16'hn    : n words available (where 0  n  32,768)
 *  - 16'h8000 : 32,768 words
 *  - Others   : Reserved
 */
#define USB_OTGHS_HPTXSTS_PTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_HPTXSTS_PTXFSPCAVAIL_M  (USB_OTGHS_HPTXSTS_PTXFSPCAVAIL_V << USB_OTGHS_HPTXSTS_PTXFSPCAVAIL_S)
#define USB_OTGHS_HPTXSTS_PTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_HPTXSTS_PTXFSPCAVAIL_S  0
/** USB_OTGHS_HPTXSTS_PTXQSPCAVAIL : RO; bitpos: [22:16]; default: 16;
 *  Periodic Transmit Request Queue Space Available (PTxQSpcAvail)
 *
 *  Indicates the number of free locations available to be written in the Periodic
 *  Transmit Request Queue. This queue holds both IN and OUT requests.
 *  - 7'h0: Periodic Transmit Request Queue is full
 *  - 7'h1: 1 location available
 *  - 7'h2: 2 locations available
 *  - n: n locations available (0 <= n <= 16)
 *  - Others: Reserved
 */
#define USB_OTGHS_HPTXSTS_PTXQSPCAVAIL    0x0000007FU
#define USB_OTGHS_HPTXSTS_PTXQSPCAVAIL_M  (USB_OTGHS_HPTXSTS_PTXQSPCAVAIL_V << USB_OTGHS_HPTXSTS_PTXQSPCAVAIL_S)
#define USB_OTGHS_HPTXSTS_PTXQSPCAVAIL_V  0x0000007FU
#define USB_OTGHS_HPTXSTS_PTXQSPCAVAIL_S  16
/** USB_OTGHS_HPTXSTS_PTXQTOP : RO; bitpos: [31:23]; default: 0;
 *  Top of the Periodic Transmit Request Queue (PTxQTop)
 *
 *  This indicates the Entry in the Periodic Tx Request Queue that is
 *  currently being processed by the MAC.
 *
 *  This register is used for debugging.
 *  - Bit [31]: Odd/Even (micro)Frame
 *  -- 1'b0: send in even (micro)Frame
 *  -- 1'b1: send in odd (micro)Frame
 *  - Bits [30:27]: Channel/endpoint number
 *  - Bits [26:25]: Type
 *  -- 2'b00: IN/OUT
 *  -- 2'b01: Zero-length packet
 *  -- 2'b10: CSPLIT
 *  -- 2'b11: Disable channel command
 *  - Bit [24]: Last Periodic Entry for the selected periodic channel/endpoint
 *  - Bit [23]: Terminate (last Entry for the selected channel/endpoint)
 */
#define USB_OTGHS_HPTXSTS_PTXQTOP    0x000001FFU
#define USB_OTGHS_HPTXSTS_PTXQTOP_M  (USB_OTGHS_HPTXSTS_PTXQTOP_V << USB_OTGHS_HPTXSTS_PTXQTOP_S)
#define USB_OTGHS_HPTXSTS_PTXQTOP_V  0x000001FFU
#define USB_OTGHS_HPTXSTS_PTXQTOP_S  23

/** USB_OTGHS_HAINT_REG register
 *  When a significant event occurs on a channel, the Host All Channels Interrupt
 *  register interrupts the application using the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt). This is shown in the Interrupt Hierarchy
 *  figure in the databook. There is one interrupt bit per channel, up to a maximum of
 *  16 bits. Bits in this register are set and cleared when the application sets and
 *  clears bits in the corresponding Host Channel-n Interrupt register.
 */
#define USB_OTGHS_HAINT_REG (DR_REG_USB_OTGHS_BASE + 0x414)
/** USB_OTGHS_HAINT_HAINT : RO; bitpos: [15:0]; default: 0;
 *
 *  Channel Interrupt for channel no.
 */
#define USB_OTGHS_HAINT_HAINT    0x0000FFFFU
#define USB_OTGHS_HAINT_HAINT_M  (USB_OTGHS_HAINT_HAINT_V << USB_OTGHS_HAINT_HAINT_S)
#define USB_OTGHS_HAINT_HAINT_V  0x0000FFFFU
#define USB_OTGHS_HAINT_HAINT_S  0

/** USB_OTGHS_HAINTMSK_REG register
 *  The Host All Channel Interrupt Mask register works with the Host All Channel
 *  Interrupt register to interrupt the application when an event occurs on a channel.
 *  There is one interrupt mask bit per channel, up to a maximum of 16 bits.
 */
#define USB_OTGHS_HAINTMSK_REG (DR_REG_USB_OTGHS_BASE + 0x418)
/** USB_OTGHS_HAINTMSK_HAINTMSK : R/W; bitpos: [15:0]; default: 0;
 *  Channel Interrupt Mask (HAINTMsk)
 *  One bit per channel: Bit 0 for channel 0, bit 15 for channel 15
 */
#define USB_OTGHS_HAINTMSK_HAINTMSK    0x0000FFFFU
#define USB_OTGHS_HAINTMSK_HAINTMSK_M  (USB_OTGHS_HAINTMSK_HAINTMSK_V << USB_OTGHS_HAINTMSK_HAINTMSK_S)
#define USB_OTGHS_HAINTMSK_HAINTMSK_V  0x0000FFFFU
#define USB_OTGHS_HAINTMSK_HAINTMSK_S  0

/** USB_OTGHS_HFLBAddr_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented as
 *  flops. This register holds the starting address of the Frame list information.
 */
#define USB_OTGHS_HFLBADDR_REG (DR_REG_USB_OTGHS_BASE + 0x41c)
/** USB_OTGHS_HFLBADDR_HFLBADDR : R/W; bitpos: [31:0]; default: 0;
 *  The starting address of the Frame list.
 *  This register is used only for Isochronous and Interrupt Channels.
 */
#define USB_OTGHS_HFLBADDR_HFLBADDR    0xFFFFFFFFU
#define USB_OTGHS_HFLBADDR_HFLBADDR_M  (USB_OTGHS_HFLBADDR_HFLBADDR_V << USB_OTGHS_HFLBADDR_HFLBADDR_S)
#define USB_OTGHS_HFLBADDR_HFLBADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HFLBADDR_HFLBADDR_S  0

/** USB_OTGHS_HPRT_REG register
 *  This register is available only in Host mode. Currently, the OTG Host supports only
 *  one port. A single register holds USB port-related information such as USB reset,
 *  enable, suspend, resume, connect status, and test mode for each port. It is shown
 *  in the Interrupt Hierarchy figure in the databook. The R_SS_WC bits in this
 *  register can trigger an interrupt to the application through the Host Port
 *  Interrupt bit of the Core Interrupt register (GINTSTS.PrtInt). On a Port Interrupt,
 *  the application must read this register and clear the bit that caused the
 *  interrupt. For the R_SS_WC bits, the application must write a 1 to the bit to clear
 *  the interrupt.
 */
#define USB_OTGHS_HPRT_REG (DR_REG_USB_OTGHS_BASE + 0x440)
/** USB_OTGHS_HPRT_PRTCONNSTS : RO; bitpos: [0]; default: 0;
 *  Port Connect Status (PrtConnSts)
 *  - 0: No device is attached to the port.
 *  - 1: A device is attached to the port.
 */
#define USB_OTGHS_HPRT_PRTCONNSTS    (BIT(0))
#define USB_OTGHS_HPRT_PRTCONNSTS_M  (USB_OTGHS_HPRT_PRTCONNSTS_V << USB_OTGHS_HPRT_PRTCONNSTS_S)
#define USB_OTGHS_HPRT_PRTCONNSTS_V  0x00000001U
#define USB_OTGHS_HPRT_PRTCONNSTS_S  0
/** USB_OTGHS_HPRT_PRTCONNDET : R/W; bitpos: [1]; default: 0;
 *  Port Connect Detected (PrtConnDet)
 *
 *  The core sets this bit when a device connection is detected
 *  to trigger an interrupt to the application using the Host Port
 *  Interrupt bit of the Core Interrupt register (GINTSTS.PrtInt).This bit can be set
 *  only by the core and the application must write 1 to clear it.The application must
 *  write a 1 to this bit to clear the
 *  interrupt.
 */
#define USB_OTGHS_HPRT_PRTCONNDET    (BIT(1))
#define USB_OTGHS_HPRT_PRTCONNDET_M  (USB_OTGHS_HPRT_PRTCONNDET_V << USB_OTGHS_HPRT_PRTCONNDET_S)
#define USB_OTGHS_HPRT_PRTCONNDET_V  0x00000001U
#define USB_OTGHS_HPRT_PRTCONNDET_S  1
/** USB_OTGHS_HPRT_PRTENA : R/W; bitpos: [2]; default: 0;
 *  Port Enable (PrtEna)
 *
 *  A port is enabled only by the core after a reset sequence,
 *  and is disabled by an overcurrent condition, a disconnect
 *  condition, or by the application clearing this bit. The
 *  application cannot Set this bit by a register write. It can only
 *  clear it to disable the port by writing 1. This bit does not trigger any
 *  interrupt to the application.
 *  - 1'b0: Port disabled
 *  - 1'b1: Port enabled
 */
#define USB_OTGHS_HPRT_PRTENA    (BIT(2))
#define USB_OTGHS_HPRT_PRTENA_M  (USB_OTGHS_HPRT_PRTENA_V << USB_OTGHS_HPRT_PRTENA_S)
#define USB_OTGHS_HPRT_PRTENA_V  0x00000001U
#define USB_OTGHS_HPRT_PRTENA_S  2
/** USB_OTGHS_HPRT_PRTENCHNG : R/W; bitpos: [3]; default: 0;
 *  Port Enable/Disable Change (PrtEnChng)
 *
 *  The core sets this bit when the status of the Port Enable bit [2] of this register
 *  changes.This bit can be set only by the core and the application must write 1 to
 *  clear it.
 */
#define USB_OTGHS_HPRT_PRTENCHNG    (BIT(3))
#define USB_OTGHS_HPRT_PRTENCHNG_M  (USB_OTGHS_HPRT_PRTENCHNG_V << USB_OTGHS_HPRT_PRTENCHNG_S)
#define USB_OTGHS_HPRT_PRTENCHNG_V  0x00000001U
#define USB_OTGHS_HPRT_PRTENCHNG_S  3
/** USB_OTGHS_HPRT_PRTOVRCURRACT : RO; bitpos: [4]; default: 0;
 *  Port Overcurrent Active (PrtOvrCurrAct)
 *
 *  Indicates the overcurrent condition of the port.
 *  - 1'b0: No overcurrent condition
 *  - 1'b1: Overcurrent condition
 */
#define USB_OTGHS_HPRT_PRTOVRCURRACT    (BIT(4))
#define USB_OTGHS_HPRT_PRTOVRCURRACT_M  (USB_OTGHS_HPRT_PRTOVRCURRACT_V << USB_OTGHS_HPRT_PRTOVRCURRACT_S)
#define USB_OTGHS_HPRT_PRTOVRCURRACT_V  0x00000001U
#define USB_OTGHS_HPRT_PRTOVRCURRACT_S  4
/** USB_OTGHS_HPRT_PRTOVRCURRCHNG : R/W; bitpos: [5]; default: 0;
 *  Port Overcurrent Change (PrtOvrCurrChng)
 *
 *  The core sets this bit when the status of the Port Overcurrent Active bit (bit 4)
 *  in this register changes.This bit can be set only by the core and the application
 *  must write 1 to clear it
 */
#define USB_OTGHS_HPRT_PRTOVRCURRCHNG    (BIT(5))
#define USB_OTGHS_HPRT_PRTOVRCURRCHNG_M  (USB_OTGHS_HPRT_PRTOVRCURRCHNG_V << USB_OTGHS_HPRT_PRTOVRCURRCHNG_S)
#define USB_OTGHS_HPRT_PRTOVRCURRCHNG_V  0x00000001U
#define USB_OTGHS_HPRT_PRTOVRCURRCHNG_S  5
/** USB_OTGHS_HPRT_PRTRES : R/W; bitpos: [6]; default: 0;
 *  Port Resume (PrtRes)
 *
 *  The application sets this bit to drive resume signaling on the
 *  port. The core continues to drive the resume signal until the
 *  application clears this bit.
 *
 *  If the core detects a USB remote wakeup sequence, as
 *  indicated by the Port Resume/Remote Wakeup Detected
 *  Interrupt bit of the Core Interrupt register
 *  (GINTSTS.WkUpInt), the core starts driving resume
 *  signaling without application intervention and clears this bit
 *  when it detects a disconnect condition. The read value of
 *  this bit indicates whether the core is currently driving
 *  resume signaling.
 *  - 1'b0: No resume driven
 *  - 1'b1: Resume driven
 *  When LPM is enabled, In L1 state the behavior of this bit is as follows:
 *  The application sets this bit to drive resume signaling on the port.
 *  The core continues to drive the resume signal until a pre-determined time
 *  specified in GLPMCFG.HIRD_Thres[3:0] field. If the core detects a USB remote
 *  wakeup sequence, as indicated by the Port L1Resume/Remote L1Wakeup Detected
 *  Interrupt bit of the Core Interrupt register (GINTSTS.L1WkUpInt),
 *  the core starts driving resume signaling without application intervention
 *  and clears this bit at the end of resume.This bit can be set by both core or
 *  application
 *  and also cleared by core or application. This bit is cleared by the core even if
 *  there is
 *  no device connected to the Host.
 */
#define USB_OTGHS_HPRT_PRTRES    (BIT(6))
#define USB_OTGHS_HPRT_PRTRES_M  (USB_OTGHS_HPRT_PRTRES_V << USB_OTGHS_HPRT_PRTRES_S)
#define USB_OTGHS_HPRT_PRTRES_V  0x00000001U
#define USB_OTGHS_HPRT_PRTRES_S  6
/** USB_OTGHS_HPRT_PRTSUSP : R/W; bitpos: [7]; default: 0;
 *  Port Suspend (PrtSusp)
 *
 *  The application sets this bit to put this port in Suspend
 *  mode. The core only stops sending SOFs when this is Set.
 *  To stop the PHY clock, the application must Set the Port
 *  Clock Stop bit, which asserts the suspend input pin of the
 *  PHY.
 *
 *  The read value of this bit reflects the current suspend status
 *  of the port. This bit is cleared by the core after a remote
 *  wakeup signal is detected or the application sets the Port
 *  Reset bit or Port Resume bit in this register or the
 *  Resume/Remote Wakeup Detected Interrupt bit or
 *  Disconnect Detected Interrupt bit in the Core Interrupt
 *  register (GINTSTS.WkUpInt or GINTSTS.DisconnInt,
 *  respectively).This bit is cleared by the core even if there is
 *  no device connected to the Host.
 *  - 1'b0: Port not in Suspend mode
 *  - 1'b1: Port in Suspend mode
 */
#define USB_OTGHS_HPRT_PRTSUSP    (BIT(7))
#define USB_OTGHS_HPRT_PRTSUSP_M  (USB_OTGHS_HPRT_PRTSUSP_V << USB_OTGHS_HPRT_PRTSUSP_S)
#define USB_OTGHS_HPRT_PRTSUSP_V  0x00000001U
#define USB_OTGHS_HPRT_PRTSUSP_S  7
/** USB_OTGHS_HPRT_PRTRST : R/W; bitpos: [8]; default: 0;
 *  Port Reset (PrtRst)
 *
 *  When the application sets this bit, a reset sequence is
 *  started on this port. The application must time the reset
 *  period and clear this bit after the reset sequence is
 *  complete.
 *  - 1'b0: Port not in reset
 *  - 1'b1: Port in reset
 *  The application must leave this bit set for at least a
 *  minimum duration mentioned below to start a reset on the
 *  port. The application can leave it set for another 10 ms in
 *  addition to the required minimum duration, before clearing
 *  the bit, even though there is no maximum limit Set by the
 *  USB standard.This bit is cleared by the core even if there is
 *  no device connected to the Host.
 *  - High speed: 50 ms
 *  - Full speed/Low speed: 10 ms
 */
#define USB_OTGHS_HPRT_PRTRST    (BIT(8))
#define USB_OTGHS_HPRT_PRTRST_M  (USB_OTGHS_HPRT_PRTRST_V << USB_OTGHS_HPRT_PRTRST_S)
#define USB_OTGHS_HPRT_PRTRST_V  0x00000001U
#define USB_OTGHS_HPRT_PRTRST_S  8
/** USB_OTGHS_HPRT_PRTLNSTS : RO; bitpos: [11:10]; default: 0;
 *  Port Line Status (PrtLnSts)
 *
 *  Indicates the current logic level USB data lines
 *  - Bit [10]: Logic level of D+
 *  - Bit [11]: Logic level of D-
 */
#define USB_OTGHS_HPRT_PRTLNSTS    0x00000003U
#define USB_OTGHS_HPRT_PRTLNSTS_M  (USB_OTGHS_HPRT_PRTLNSTS_V << USB_OTGHS_HPRT_PRTLNSTS_S)
#define USB_OTGHS_HPRT_PRTLNSTS_V  0x00000003U
#define USB_OTGHS_HPRT_PRTLNSTS_S  10
/** USB_OTGHS_HPRT_PRTPWR : R/W; bitpos: [12]; default: 0;
 *  Port Power (PrtPwr)
 *
 *  The application uses this field to control power to this port (write 1'b1 to set to
 *  1'b1
 *  and write 1'b0 to set to 1'b0), and the core can clear this bit on an over current
 *  condition.
 *  - 1'b0: Power off
 *  - 1'b1: Power on
 *
 *  Note: This bit is interface independent. The application needs to program this bit
 *  for all interfaces as described in the host programming flow in the Programming
 *  Guide.
 */
#define USB_OTGHS_HPRT_PRTPWR    (BIT(12))
#define USB_OTGHS_HPRT_PRTPWR_M  (USB_OTGHS_HPRT_PRTPWR_V << USB_OTGHS_HPRT_PRTPWR_S)
#define USB_OTGHS_HPRT_PRTPWR_V  0x00000001U
#define USB_OTGHS_HPRT_PRTPWR_S  12
/** USB_OTGHS_HPRT_PRTTSTCTL : R/W; bitpos: [16:13]; default: 0;
 *  Port Test Control (PrtTstCtl)
 *
 *  The application writes a nonzero value to this field to put the port into a Test
 *  mode, and the corresponding pattern is signaled on the port.
 *  - 4'b0000: Test mode disabled
 *  - 4'b0001: Test_J mode
 *  - 4'b0010: Test_K mode
 *  - 4'b0011: Test_SE0_NAK mode
 *  - 4'b0100: Test_Packet mode
 *  - 4'b0101: Test_Force_Enable
 *  - Others: Reserved
 *
 *  To move the DWC_otg controller to test mode, you must set this field. Complete the
 *  following steps to move the DWC_otg core to test mode:
 *  - 1. Power on the core.
 *  - 2. Load the DWC_otg driver.
 *  - 3. Connect an HS device and enumerate to HS mode.
 *  - 4. Access the HPRT register to send test packets.
 *  - 5. Remove the device and connect to fixture (OPT) port. The DWC_otg host core
 *  continues sending out test packets.
 *  - 6. Test the eye diagram.
 */
#define USB_OTGHS_HPRT_PRTTSTCTL    0x0000000FU
#define USB_OTGHS_HPRT_PRTTSTCTL_M  (USB_OTGHS_HPRT_PRTTSTCTL_V << USB_OTGHS_HPRT_PRTTSTCTL_S)
#define USB_OTGHS_HPRT_PRTTSTCTL_V  0x0000000FU
#define USB_OTGHS_HPRT_PRTTSTCTL_S  13
/** USB_OTGHS_HPRT_PRTSPD : RO; bitpos: [18:17]; default: 0;
 *  Port Speed (PrtSpd)
 *
 *  Indicates the speed of the device attached to this port.
 *  - 2'b00: High speed
 *  - 2'b01: Full speed
 *  - 2'b10: Low speed
 *  - 2'b11: Reserved
 */
#define USB_OTGHS_HPRT_PRTSPD    0x00000003U
#define USB_OTGHS_HPRT_PRTSPD_M  (USB_OTGHS_HPRT_PRTSPD_V << USB_OTGHS_HPRT_PRTSPD_S)
#define USB_OTGHS_HPRT_PRTSPD_V  0x00000003U
#define USB_OTGHS_HPRT_PRTSPD_S  17

/** USB_OTGHS_HCCHAR0_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR0_REG (DR_REG_USB_OTGHS_BASE + 0x500)
/** USB_OTGHS_HCCHAR0_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR0_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR0_MPS_M  (USB_OTGHS_HCCHAR0_MPS_V << USB_OTGHS_HCCHAR0_MPS_S)
#define USB_OTGHS_HCCHAR0_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR0_MPS_S  0
/** USB_OTGHS_HCCHAR0_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR0_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR0_EPNUM_M  (USB_OTGHS_HCCHAR0_EPNUM_V << USB_OTGHS_HCCHAR0_EPNUM_S)
#define USB_OTGHS_HCCHAR0_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR0_EPNUM_S  11
/** USB_OTGHS_HCCHAR0_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR0_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR0_EPDIR_M  (USB_OTGHS_HCCHAR0_EPDIR_V << USB_OTGHS_HCCHAR0_EPDIR_S)
#define USB_OTGHS_HCCHAR0_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR0_EPDIR_S  15
/** USB_OTGHS_HCCHAR0_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR0_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR0_LSPDDEV_M  (USB_OTGHS_HCCHAR0_LSPDDEV_V << USB_OTGHS_HCCHAR0_LSPDDEV_S)
#define USB_OTGHS_HCCHAR0_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR0_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR0_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR0_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR0_EPTYPE_M  (USB_OTGHS_HCCHAR0_EPTYPE_V << USB_OTGHS_HCCHAR0_EPTYPE_S)
#define USB_OTGHS_HCCHAR0_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR0_EPTYPE_S  18
/** USB_OTGHS_HCCHAR0_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR0_EC    0x00000003U
#define USB_OTGHS_HCCHAR0_EC_M  (USB_OTGHS_HCCHAR0_EC_V << USB_OTGHS_HCCHAR0_EC_S)
#define USB_OTGHS_HCCHAR0_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR0_EC_S  20
/** USB_OTGHS_HCCHAR0_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR0_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR0_DEVADDR_M  (USB_OTGHS_HCCHAR0_DEVADDR_V << USB_OTGHS_HCCHAR0_DEVADDR_S)
#define USB_OTGHS_HCCHAR0_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR0_DEVADDR_S  22
/** USB_OTGHS_HCCHAR0_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR0_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR0_ODDFRM_M  (USB_OTGHS_HCCHAR0_ODDFRM_V << USB_OTGHS_HCCHAR0_ODDFRM_S)
#define USB_OTGHS_HCCHAR0_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR0_ODDFRM_S  29
/** USB_OTGHS_HCCHAR0_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR0_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR0_CHDIS_M  (USB_OTGHS_HCCHAR0_CHDIS_V << USB_OTGHS_HCCHAR0_CHDIS_S)
#define USB_OTGHS_HCCHAR0_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR0_CHDIS_S  30
/** USB_OTGHS_HCCHAR0_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR0_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR0_CHENA_M  (USB_OTGHS_HCCHAR0_CHENA_V << USB_OTGHS_HCCHAR0_CHENA_S)
#define USB_OTGHS_HCCHAR0_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR0_CHENA_S  31

/** USB_OTGHS_HCSPLT0_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT0_REG (DR_REG_USB_OTGHS_BASE + 0x504)
/** USB_OTGHS_HCSPLT0_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT0_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT0_PRTADDR_M  (USB_OTGHS_HCSPLT0_PRTADDR_V << USB_OTGHS_HCSPLT0_PRTADDR_S)
#define USB_OTGHS_HCSPLT0_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT0_PRTADDR_S  0
/** USB_OTGHS_HCSPLT0_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT0_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT0_HUBADDR_M  (USB_OTGHS_HCSPLT0_HUBADDR_V << USB_OTGHS_HCSPLT0_HUBADDR_S)
#define USB_OTGHS_HCSPLT0_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT0_HUBADDR_S  7
/** USB_OTGHS_HCSPLT0_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT0_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT0_XACTPOS_M  (USB_OTGHS_HCSPLT0_XACTPOS_V << USB_OTGHS_HCSPLT0_XACTPOS_S)
#define USB_OTGHS_HCSPLT0_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT0_XACTPOS_S  14
/** USB_OTGHS_HCSPLT0_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT0_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT0_COMPSPLT_M  (USB_OTGHS_HCSPLT0_COMPSPLT_V << USB_OTGHS_HCSPLT0_COMPSPLT_S)
#define USB_OTGHS_HCSPLT0_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT0_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT0_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT0_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT0_SPLTENA_M  (USB_OTGHS_HCSPLT0_SPLTENA_V << USB_OTGHS_HCSPLT0_SPLTENA_S)
#define USB_OTGHS_HCSPLT0_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT0_SPLTENA_S  31

/** USB_OTGHS_HCINT0_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT0_REG (DR_REG_USB_OTGHS_BASE + 0x508)
/** USB_OTGHS_HCINT0_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT0_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT0_XFERCOMPL_M  (USB_OTGHS_HCINT0_XFERCOMPL_V << USB_OTGHS_HCINT0_XFERCOMPL_S)
#define USB_OTGHS_HCINT0_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT0_XFERCOMPL_S  0
/** USB_OTGHS_HCINT0_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT0_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT0_CHHLTD_M  (USB_OTGHS_HCINT0_CHHLTD_V << USB_OTGHS_HCINT0_CHHLTD_S)
#define USB_OTGHS_HCINT0_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT0_CHHLTD_S  1
/** USB_OTGHS_HCINT0_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT0_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT0_AHBERR_M  (USB_OTGHS_HCINT0_AHBERR_V << USB_OTGHS_HCINT0_AHBERR_S)
#define USB_OTGHS_HCINT0_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT0_AHBERR_S  2
/** USB_OTGHS_HCINT0_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT0_STALL    (BIT(3))
#define USB_OTGHS_HCINT0_STALL_M  (USB_OTGHS_HCINT0_STALL_V << USB_OTGHS_HCINT0_STALL_S)
#define USB_OTGHS_HCINT0_STALL_V  0x00000001U
#define USB_OTGHS_HCINT0_STALL_S  3
/** USB_OTGHS_HCINT0_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT0_NAK    (BIT(4))
#define USB_OTGHS_HCINT0_NAK_M  (USB_OTGHS_HCINT0_NAK_V << USB_OTGHS_HCINT0_NAK_S)
#define USB_OTGHS_HCINT0_NAK_V  0x00000001U
#define USB_OTGHS_HCINT0_NAK_S  4
/** USB_OTGHS_HCINT0_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT0_ACK    (BIT(5))
#define USB_OTGHS_HCINT0_ACK_M  (USB_OTGHS_HCINT0_ACK_V << USB_OTGHS_HCINT0_ACK_S)
#define USB_OTGHS_HCINT0_ACK_V  0x00000001U
#define USB_OTGHS_HCINT0_ACK_S  5
/** USB_OTGHS_HCINT0_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT0_NYET    (BIT(6))
#define USB_OTGHS_HCINT0_NYET_M  (USB_OTGHS_HCINT0_NYET_V << USB_OTGHS_HCINT0_NYET_S)
#define USB_OTGHS_HCINT0_NYET_V  0x00000001U
#define USB_OTGHS_HCINT0_NYET_S  6
/** USB_OTGHS_HCINT0_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT0_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT0_XACTERR_M  (USB_OTGHS_HCINT0_XACTERR_V << USB_OTGHS_HCINT0_XACTERR_S)
#define USB_OTGHS_HCINT0_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT0_XACTERR_S  7
/** USB_OTGHS_HCINT0_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT0_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT0_BBLERR_M  (USB_OTGHS_HCINT0_BBLERR_V << USB_OTGHS_HCINT0_BBLERR_S)
#define USB_OTGHS_HCINT0_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT0_BBLERR_S  8
/** USB_OTGHS_HCINT0_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT0_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT0_FRMOVRUN_M  (USB_OTGHS_HCINT0_FRMOVRUN_V << USB_OTGHS_HCINT0_FRMOVRUN_S)
#define USB_OTGHS_HCINT0_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT0_FRMOVRUN_S  9
/** USB_OTGHS_HCINT0_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT0_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT0_DATATGLERR_M  (USB_OTGHS_HCINT0_DATATGLERR_V << USB_OTGHS_HCINT0_DATATGLERR_S)
#define USB_OTGHS_HCINT0_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT0_DATATGLERR_S  10
/** USB_OTGHS_HCINT0_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT0_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT0_BNAINTR_M  (USB_OTGHS_HCINT0_BNAINTR_V << USB_OTGHS_HCINT0_BNAINTR_S)
#define USB_OTGHS_HCINT0_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT0_BNAINTR_S  11
/** USB_OTGHS_HCINT0_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT0_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT0_XCS_XACT_ERR_M  (USB_OTGHS_HCINT0_XCS_XACT_ERR_V << USB_OTGHS_HCINT0_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT0_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT0_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT0_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT0_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT0_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT0_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT0_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT0_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT0_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK0_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK0_REG (DR_REG_USB_OTGHS_BASE + 0x50c)
/** USB_OTGHS_HCINTMSK0_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK0_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK0_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK0_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK0_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK0_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK0_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK0_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK0_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK0_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK0_CHHLTDMSK_V << USB_OTGHS_HCINTMSK0_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK0_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK0_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK0_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK0_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK0_AHBERRMSK_M  (USB_OTGHS_HCINTMSK0_AHBERRMSK_V << USB_OTGHS_HCINTMSK0_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK0_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK0_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK0_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK0_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK0_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK0_BNAINTRMSK_V << USB_OTGHS_HCINTMSK0_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK0_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK0_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK0_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK0_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK0_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK0_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK0_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK0_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK0_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ0_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ0_REG (DR_REG_USB_OTGHS_BASE + 0x510)
/** USB_OTGHS_HCTSIZ0_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ0_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ0_XFERSIZE_M  (USB_OTGHS_HCTSIZ0_XFERSIZE_V << USB_OTGHS_HCTSIZ0_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ0_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ0_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ0_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ0_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ0_PKTCNT_M  (USB_OTGHS_HCTSIZ0_PKTCNT_V << USB_OTGHS_HCTSIZ0_PKTCNT_S)
#define USB_OTGHS_HCTSIZ0_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ0_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ0_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ0_PID    0x00000003U
#define USB_OTGHS_HCTSIZ0_PID_M  (USB_OTGHS_HCTSIZ0_PID_V << USB_OTGHS_HCTSIZ0_PID_S)
#define USB_OTGHS_HCTSIZ0_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ0_PID_S  29
/** USB_OTGHS_HCTSIZ0_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ0_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ0_DOPNG_M  (USB_OTGHS_HCTSIZ0_DOPNG_V << USB_OTGHS_HCTSIZ0_DOPNG_S)
#define USB_OTGHS_HCTSIZ0_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ0_DOPNG_S  31

/** USB_OTGHS_HCDMA0_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA0_REG (DR_REG_USB_OTGHS_BASE + 0x514)
/** USB_OTGHS_HCDMA0_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA0_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA0_DMAADDR_M  (USB_OTGHS_HCDMA0_DMAADDR_V << USB_OTGHS_HCDMA0_DMAADDR_S)
#define USB_OTGHS_HCDMA0_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA0_DMAADDR_S  0

/** USB_OTGHS_HCDMAB0_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB0_REG (DR_REG_USB_OTGHS_BASE + 0x51c)
/** USB_OTGHS_HCDMAB0_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB0_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB0_HCDMAB_M  (USB_OTGHS_HCDMAB0_HCDMAB_V << USB_OTGHS_HCDMAB0_HCDMAB_S)
#define USB_OTGHS_HCDMAB0_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB0_HCDMAB_S  0

/** USB_OTGHS_HCCHAR1_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR1_REG (DR_REG_USB_OTGHS_BASE + 0x520)
/** USB_OTGHS_HCCHAR1_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR1_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR1_MPS_M  (USB_OTGHS_HCCHAR1_MPS_V << USB_OTGHS_HCCHAR1_MPS_S)
#define USB_OTGHS_HCCHAR1_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR1_MPS_S  0
/** USB_OTGHS_HCCHAR1_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR1_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR1_EPNUM_M  (USB_OTGHS_HCCHAR1_EPNUM_V << USB_OTGHS_HCCHAR1_EPNUM_S)
#define USB_OTGHS_HCCHAR1_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR1_EPNUM_S  11
/** USB_OTGHS_HCCHAR1_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR1_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR1_EPDIR_M  (USB_OTGHS_HCCHAR1_EPDIR_V << USB_OTGHS_HCCHAR1_EPDIR_S)
#define USB_OTGHS_HCCHAR1_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR1_EPDIR_S  15
/** USB_OTGHS_HCCHAR1_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR1_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR1_LSPDDEV_M  (USB_OTGHS_HCCHAR1_LSPDDEV_V << USB_OTGHS_HCCHAR1_LSPDDEV_S)
#define USB_OTGHS_HCCHAR1_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR1_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR1_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR1_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR1_EPTYPE_M  (USB_OTGHS_HCCHAR1_EPTYPE_V << USB_OTGHS_HCCHAR1_EPTYPE_S)
#define USB_OTGHS_HCCHAR1_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR1_EPTYPE_S  18
/** USB_OTGHS_HCCHAR1_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR1_EC    0x00000003U
#define USB_OTGHS_HCCHAR1_EC_M  (USB_OTGHS_HCCHAR1_EC_V << USB_OTGHS_HCCHAR1_EC_S)
#define USB_OTGHS_HCCHAR1_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR1_EC_S  20
/** USB_OTGHS_HCCHAR1_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR1_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR1_DEVADDR_M  (USB_OTGHS_HCCHAR1_DEVADDR_V << USB_OTGHS_HCCHAR1_DEVADDR_S)
#define USB_OTGHS_HCCHAR1_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR1_DEVADDR_S  22
/** USB_OTGHS_HCCHAR1_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR1_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR1_ODDFRM_M  (USB_OTGHS_HCCHAR1_ODDFRM_V << USB_OTGHS_HCCHAR1_ODDFRM_S)
#define USB_OTGHS_HCCHAR1_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR1_ODDFRM_S  29
/** USB_OTGHS_HCCHAR1_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR1_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR1_CHDIS_M  (USB_OTGHS_HCCHAR1_CHDIS_V << USB_OTGHS_HCCHAR1_CHDIS_S)
#define USB_OTGHS_HCCHAR1_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR1_CHDIS_S  30
/** USB_OTGHS_HCCHAR1_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR1_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR1_CHENA_M  (USB_OTGHS_HCCHAR1_CHENA_V << USB_OTGHS_HCCHAR1_CHENA_S)
#define USB_OTGHS_HCCHAR1_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR1_CHENA_S  31

/** USB_OTGHS_HCSPLT1_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT1_REG (DR_REG_USB_OTGHS_BASE + 0x524)
/** USB_OTGHS_HCSPLT1_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT1_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT1_PRTADDR_M  (USB_OTGHS_HCSPLT1_PRTADDR_V << USB_OTGHS_HCSPLT1_PRTADDR_S)
#define USB_OTGHS_HCSPLT1_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT1_PRTADDR_S  0
/** USB_OTGHS_HCSPLT1_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT1_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT1_HUBADDR_M  (USB_OTGHS_HCSPLT1_HUBADDR_V << USB_OTGHS_HCSPLT1_HUBADDR_S)
#define USB_OTGHS_HCSPLT1_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT1_HUBADDR_S  7
/** USB_OTGHS_HCSPLT1_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT1_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT1_XACTPOS_M  (USB_OTGHS_HCSPLT1_XACTPOS_V << USB_OTGHS_HCSPLT1_XACTPOS_S)
#define USB_OTGHS_HCSPLT1_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT1_XACTPOS_S  14
/** USB_OTGHS_HCSPLT1_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT1_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT1_COMPSPLT_M  (USB_OTGHS_HCSPLT1_COMPSPLT_V << USB_OTGHS_HCSPLT1_COMPSPLT_S)
#define USB_OTGHS_HCSPLT1_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT1_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT1_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT1_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT1_SPLTENA_M  (USB_OTGHS_HCSPLT1_SPLTENA_V << USB_OTGHS_HCSPLT1_SPLTENA_S)
#define USB_OTGHS_HCSPLT1_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT1_SPLTENA_S  31

/** USB_OTGHS_HCINT1_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT1_REG (DR_REG_USB_OTGHS_BASE + 0x528)
/** USB_OTGHS_HCINT1_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT1_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT1_XFERCOMPL_M  (USB_OTGHS_HCINT1_XFERCOMPL_V << USB_OTGHS_HCINT1_XFERCOMPL_S)
#define USB_OTGHS_HCINT1_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT1_XFERCOMPL_S  0
/** USB_OTGHS_HCINT1_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT1_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT1_CHHLTD_M  (USB_OTGHS_HCINT1_CHHLTD_V << USB_OTGHS_HCINT1_CHHLTD_S)
#define USB_OTGHS_HCINT1_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT1_CHHLTD_S  1
/** USB_OTGHS_HCINT1_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT1_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT1_AHBERR_M  (USB_OTGHS_HCINT1_AHBERR_V << USB_OTGHS_HCINT1_AHBERR_S)
#define USB_OTGHS_HCINT1_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT1_AHBERR_S  2
/** USB_OTGHS_HCINT1_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT1_STALL    (BIT(3))
#define USB_OTGHS_HCINT1_STALL_M  (USB_OTGHS_HCINT1_STALL_V << USB_OTGHS_HCINT1_STALL_S)
#define USB_OTGHS_HCINT1_STALL_V  0x00000001U
#define USB_OTGHS_HCINT1_STALL_S  3
/** USB_OTGHS_HCINT1_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT1_NAK    (BIT(4))
#define USB_OTGHS_HCINT1_NAK_M  (USB_OTGHS_HCINT1_NAK_V << USB_OTGHS_HCINT1_NAK_S)
#define USB_OTGHS_HCINT1_NAK_V  0x00000001U
#define USB_OTGHS_HCINT1_NAK_S  4
/** USB_OTGHS_HCINT1_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT1_ACK    (BIT(5))
#define USB_OTGHS_HCINT1_ACK_M  (USB_OTGHS_HCINT1_ACK_V << USB_OTGHS_HCINT1_ACK_S)
#define USB_OTGHS_HCINT1_ACK_V  0x00000001U
#define USB_OTGHS_HCINT1_ACK_S  5
/** USB_OTGHS_HCINT1_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT1_NYET    (BIT(6))
#define USB_OTGHS_HCINT1_NYET_M  (USB_OTGHS_HCINT1_NYET_V << USB_OTGHS_HCINT1_NYET_S)
#define USB_OTGHS_HCINT1_NYET_V  0x00000001U
#define USB_OTGHS_HCINT1_NYET_S  6
/** USB_OTGHS_HCINT1_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT1_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT1_XACTERR_M  (USB_OTGHS_HCINT1_XACTERR_V << USB_OTGHS_HCINT1_XACTERR_S)
#define USB_OTGHS_HCINT1_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT1_XACTERR_S  7
/** USB_OTGHS_HCINT1_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT1_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT1_BBLERR_M  (USB_OTGHS_HCINT1_BBLERR_V << USB_OTGHS_HCINT1_BBLERR_S)
#define USB_OTGHS_HCINT1_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT1_BBLERR_S  8
/** USB_OTGHS_HCINT1_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT1_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT1_FRMOVRUN_M  (USB_OTGHS_HCINT1_FRMOVRUN_V << USB_OTGHS_HCINT1_FRMOVRUN_S)
#define USB_OTGHS_HCINT1_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT1_FRMOVRUN_S  9
/** USB_OTGHS_HCINT1_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT1_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT1_DATATGLERR_M  (USB_OTGHS_HCINT1_DATATGLERR_V << USB_OTGHS_HCINT1_DATATGLERR_S)
#define USB_OTGHS_HCINT1_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT1_DATATGLERR_S  10
/** USB_OTGHS_HCINT1_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT1_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT1_BNAINTR_M  (USB_OTGHS_HCINT1_BNAINTR_V << USB_OTGHS_HCINT1_BNAINTR_S)
#define USB_OTGHS_HCINT1_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT1_BNAINTR_S  11
/** USB_OTGHS_HCINT1_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT1_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT1_XCS_XACT_ERR_M  (USB_OTGHS_HCINT1_XCS_XACT_ERR_V << USB_OTGHS_HCINT1_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT1_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT1_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT1_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT1_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT1_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT1_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT1_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT1_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT1_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK1_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK1_REG (DR_REG_USB_OTGHS_BASE + 0x52c)
/** USB_OTGHS_HCINTMSK1_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK1_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK1_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK1_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK1_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK1_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK1_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK1_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK1_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK1_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK1_CHHLTDMSK_V << USB_OTGHS_HCINTMSK1_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK1_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK1_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK1_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK1_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK1_AHBERRMSK_M  (USB_OTGHS_HCINTMSK1_AHBERRMSK_V << USB_OTGHS_HCINTMSK1_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK1_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK1_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK1_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK1_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK1_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK1_BNAINTRMSK_V << USB_OTGHS_HCINTMSK1_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK1_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK1_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK1_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK1_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK1_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK1_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK1_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK1_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK1_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ1_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ1_REG (DR_REG_USB_OTGHS_BASE + 0x530)
/** USB_OTGHS_HCTSIZ1_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ1_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ1_XFERSIZE_M  (USB_OTGHS_HCTSIZ1_XFERSIZE_V << USB_OTGHS_HCTSIZ1_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ1_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ1_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ1_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ1_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ1_PKTCNT_M  (USB_OTGHS_HCTSIZ1_PKTCNT_V << USB_OTGHS_HCTSIZ1_PKTCNT_S)
#define USB_OTGHS_HCTSIZ1_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ1_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ1_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ1_PID    0x00000003U
#define USB_OTGHS_HCTSIZ1_PID_M  (USB_OTGHS_HCTSIZ1_PID_V << USB_OTGHS_HCTSIZ1_PID_S)
#define USB_OTGHS_HCTSIZ1_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ1_PID_S  29
/** USB_OTGHS_HCTSIZ1_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ1_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ1_DOPNG_M  (USB_OTGHS_HCTSIZ1_DOPNG_V << USB_OTGHS_HCTSIZ1_DOPNG_S)
#define USB_OTGHS_HCTSIZ1_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ1_DOPNG_S  31

/** USB_OTGHS_HCDMA1_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA1_REG (DR_REG_USB_OTGHS_BASE + 0x534)
/** USB_OTGHS_HCDMA1_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA1_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA1_DMAADDR_M  (USB_OTGHS_HCDMA1_DMAADDR_V << USB_OTGHS_HCDMA1_DMAADDR_S)
#define USB_OTGHS_HCDMA1_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA1_DMAADDR_S  0

/** USB_OTGHS_HCDMAB1_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB1_REG (DR_REG_USB_OTGHS_BASE + 0x53c)
/** USB_OTGHS_HCDMAB1_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB1_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB1_HCDMAB_M  (USB_OTGHS_HCDMAB1_HCDMAB_V << USB_OTGHS_HCDMAB1_HCDMAB_S)
#define USB_OTGHS_HCDMAB1_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB1_HCDMAB_S  0

/** USB_OTGHS_HCCHAR2_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR2_REG (DR_REG_USB_OTGHS_BASE + 0x540)
/** USB_OTGHS_HCCHAR2_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR2_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR2_MPS_M  (USB_OTGHS_HCCHAR2_MPS_V << USB_OTGHS_HCCHAR2_MPS_S)
#define USB_OTGHS_HCCHAR2_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR2_MPS_S  0
/** USB_OTGHS_HCCHAR2_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR2_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR2_EPNUM_M  (USB_OTGHS_HCCHAR2_EPNUM_V << USB_OTGHS_HCCHAR2_EPNUM_S)
#define USB_OTGHS_HCCHAR2_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR2_EPNUM_S  11
/** USB_OTGHS_HCCHAR2_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR2_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR2_EPDIR_M  (USB_OTGHS_HCCHAR2_EPDIR_V << USB_OTGHS_HCCHAR2_EPDIR_S)
#define USB_OTGHS_HCCHAR2_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR2_EPDIR_S  15
/** USB_OTGHS_HCCHAR2_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR2_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR2_LSPDDEV_M  (USB_OTGHS_HCCHAR2_LSPDDEV_V << USB_OTGHS_HCCHAR2_LSPDDEV_S)
#define USB_OTGHS_HCCHAR2_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR2_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR2_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR2_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR2_EPTYPE_M  (USB_OTGHS_HCCHAR2_EPTYPE_V << USB_OTGHS_HCCHAR2_EPTYPE_S)
#define USB_OTGHS_HCCHAR2_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR2_EPTYPE_S  18
/** USB_OTGHS_HCCHAR2_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR2_EC    0x00000003U
#define USB_OTGHS_HCCHAR2_EC_M  (USB_OTGHS_HCCHAR2_EC_V << USB_OTGHS_HCCHAR2_EC_S)
#define USB_OTGHS_HCCHAR2_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR2_EC_S  20
/** USB_OTGHS_HCCHAR2_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR2_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR2_DEVADDR_M  (USB_OTGHS_HCCHAR2_DEVADDR_V << USB_OTGHS_HCCHAR2_DEVADDR_S)
#define USB_OTGHS_HCCHAR2_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR2_DEVADDR_S  22
/** USB_OTGHS_HCCHAR2_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR2_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR2_ODDFRM_M  (USB_OTGHS_HCCHAR2_ODDFRM_V << USB_OTGHS_HCCHAR2_ODDFRM_S)
#define USB_OTGHS_HCCHAR2_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR2_ODDFRM_S  29
/** USB_OTGHS_HCCHAR2_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR2_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR2_CHDIS_M  (USB_OTGHS_HCCHAR2_CHDIS_V << USB_OTGHS_HCCHAR2_CHDIS_S)
#define USB_OTGHS_HCCHAR2_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR2_CHDIS_S  30
/** USB_OTGHS_HCCHAR2_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR2_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR2_CHENA_M  (USB_OTGHS_HCCHAR2_CHENA_V << USB_OTGHS_HCCHAR2_CHENA_S)
#define USB_OTGHS_HCCHAR2_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR2_CHENA_S  31

/** USB_OTGHS_HCSPLT2_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT2_REG (DR_REG_USB_OTGHS_BASE + 0x544)
/** USB_OTGHS_HCSPLT2_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT2_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT2_PRTADDR_M  (USB_OTGHS_HCSPLT2_PRTADDR_V << USB_OTGHS_HCSPLT2_PRTADDR_S)
#define USB_OTGHS_HCSPLT2_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT2_PRTADDR_S  0
/** USB_OTGHS_HCSPLT2_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT2_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT2_HUBADDR_M  (USB_OTGHS_HCSPLT2_HUBADDR_V << USB_OTGHS_HCSPLT2_HUBADDR_S)
#define USB_OTGHS_HCSPLT2_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT2_HUBADDR_S  7
/** USB_OTGHS_HCSPLT2_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT2_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT2_XACTPOS_M  (USB_OTGHS_HCSPLT2_XACTPOS_V << USB_OTGHS_HCSPLT2_XACTPOS_S)
#define USB_OTGHS_HCSPLT2_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT2_XACTPOS_S  14
/** USB_OTGHS_HCSPLT2_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT2_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT2_COMPSPLT_M  (USB_OTGHS_HCSPLT2_COMPSPLT_V << USB_OTGHS_HCSPLT2_COMPSPLT_S)
#define USB_OTGHS_HCSPLT2_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT2_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT2_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT2_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT2_SPLTENA_M  (USB_OTGHS_HCSPLT2_SPLTENA_V << USB_OTGHS_HCSPLT2_SPLTENA_S)
#define USB_OTGHS_HCSPLT2_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT2_SPLTENA_S  31

/** USB_OTGHS_HCINT2_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT2_REG (DR_REG_USB_OTGHS_BASE + 0x548)
/** USB_OTGHS_HCINT2_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT2_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT2_XFERCOMPL_M  (USB_OTGHS_HCINT2_XFERCOMPL_V << USB_OTGHS_HCINT2_XFERCOMPL_S)
#define USB_OTGHS_HCINT2_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT2_XFERCOMPL_S  0
/** USB_OTGHS_HCINT2_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT2_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT2_CHHLTD_M  (USB_OTGHS_HCINT2_CHHLTD_V << USB_OTGHS_HCINT2_CHHLTD_S)
#define USB_OTGHS_HCINT2_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT2_CHHLTD_S  1
/** USB_OTGHS_HCINT2_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT2_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT2_AHBERR_M  (USB_OTGHS_HCINT2_AHBERR_V << USB_OTGHS_HCINT2_AHBERR_S)
#define USB_OTGHS_HCINT2_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT2_AHBERR_S  2
/** USB_OTGHS_HCINT2_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT2_STALL    (BIT(3))
#define USB_OTGHS_HCINT2_STALL_M  (USB_OTGHS_HCINT2_STALL_V << USB_OTGHS_HCINT2_STALL_S)
#define USB_OTGHS_HCINT2_STALL_V  0x00000001U
#define USB_OTGHS_HCINT2_STALL_S  3
/** USB_OTGHS_HCINT2_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT2_NAK    (BIT(4))
#define USB_OTGHS_HCINT2_NAK_M  (USB_OTGHS_HCINT2_NAK_V << USB_OTGHS_HCINT2_NAK_S)
#define USB_OTGHS_HCINT2_NAK_V  0x00000001U
#define USB_OTGHS_HCINT2_NAK_S  4
/** USB_OTGHS_HCINT2_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT2_ACK    (BIT(5))
#define USB_OTGHS_HCINT2_ACK_M  (USB_OTGHS_HCINT2_ACK_V << USB_OTGHS_HCINT2_ACK_S)
#define USB_OTGHS_HCINT2_ACK_V  0x00000001U
#define USB_OTGHS_HCINT2_ACK_S  5
/** USB_OTGHS_HCINT2_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT2_NYET    (BIT(6))
#define USB_OTGHS_HCINT2_NYET_M  (USB_OTGHS_HCINT2_NYET_V << USB_OTGHS_HCINT2_NYET_S)
#define USB_OTGHS_HCINT2_NYET_V  0x00000001U
#define USB_OTGHS_HCINT2_NYET_S  6
/** USB_OTGHS_HCINT2_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT2_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT2_XACTERR_M  (USB_OTGHS_HCINT2_XACTERR_V << USB_OTGHS_HCINT2_XACTERR_S)
#define USB_OTGHS_HCINT2_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT2_XACTERR_S  7
/** USB_OTGHS_HCINT2_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT2_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT2_BBLERR_M  (USB_OTGHS_HCINT2_BBLERR_V << USB_OTGHS_HCINT2_BBLERR_S)
#define USB_OTGHS_HCINT2_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT2_BBLERR_S  8
/** USB_OTGHS_HCINT2_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT2_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT2_FRMOVRUN_M  (USB_OTGHS_HCINT2_FRMOVRUN_V << USB_OTGHS_HCINT2_FRMOVRUN_S)
#define USB_OTGHS_HCINT2_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT2_FRMOVRUN_S  9
/** USB_OTGHS_HCINT2_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT2_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT2_DATATGLERR_M  (USB_OTGHS_HCINT2_DATATGLERR_V << USB_OTGHS_HCINT2_DATATGLERR_S)
#define USB_OTGHS_HCINT2_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT2_DATATGLERR_S  10
/** USB_OTGHS_HCINT2_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT2_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT2_BNAINTR_M  (USB_OTGHS_HCINT2_BNAINTR_V << USB_OTGHS_HCINT2_BNAINTR_S)
#define USB_OTGHS_HCINT2_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT2_BNAINTR_S  11
/** USB_OTGHS_HCINT2_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT2_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT2_XCS_XACT_ERR_M  (USB_OTGHS_HCINT2_XCS_XACT_ERR_V << USB_OTGHS_HCINT2_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT2_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT2_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT2_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT2_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT2_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT2_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT2_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT2_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT2_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK2_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK2_REG (DR_REG_USB_OTGHS_BASE + 0x54c)
/** USB_OTGHS_HCINTMSK2_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK2_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK2_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK2_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK2_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK2_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK2_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK2_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK2_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK2_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK2_CHHLTDMSK_V << USB_OTGHS_HCINTMSK2_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK2_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK2_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK2_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK2_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK2_AHBERRMSK_M  (USB_OTGHS_HCINTMSK2_AHBERRMSK_V << USB_OTGHS_HCINTMSK2_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK2_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK2_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK2_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK2_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK2_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK2_BNAINTRMSK_V << USB_OTGHS_HCINTMSK2_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK2_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK2_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK2_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK2_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK2_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK2_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK2_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK2_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK2_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ2_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ2_REG (DR_REG_USB_OTGHS_BASE + 0x550)
/** USB_OTGHS_HCTSIZ2_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ2_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ2_XFERSIZE_M  (USB_OTGHS_HCTSIZ2_XFERSIZE_V << USB_OTGHS_HCTSIZ2_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ2_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ2_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ2_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ2_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ2_PKTCNT_M  (USB_OTGHS_HCTSIZ2_PKTCNT_V << USB_OTGHS_HCTSIZ2_PKTCNT_S)
#define USB_OTGHS_HCTSIZ2_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ2_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ2_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ2_PID    0x00000003U
#define USB_OTGHS_HCTSIZ2_PID_M  (USB_OTGHS_HCTSIZ2_PID_V << USB_OTGHS_HCTSIZ2_PID_S)
#define USB_OTGHS_HCTSIZ2_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ2_PID_S  29
/** USB_OTGHS_HCTSIZ2_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ2_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ2_DOPNG_M  (USB_OTGHS_HCTSIZ2_DOPNG_V << USB_OTGHS_HCTSIZ2_DOPNG_S)
#define USB_OTGHS_HCTSIZ2_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ2_DOPNG_S  31

/** USB_OTGHS_HCDMA2_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA2_REG (DR_REG_USB_OTGHS_BASE + 0x554)
/** USB_OTGHS_HCDMA2_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA2_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA2_DMAADDR_M  (USB_OTGHS_HCDMA2_DMAADDR_V << USB_OTGHS_HCDMA2_DMAADDR_S)
#define USB_OTGHS_HCDMA2_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA2_DMAADDR_S  0

/** USB_OTGHS_HCDMAB2_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB2_REG (DR_REG_USB_OTGHS_BASE + 0x55c)
/** USB_OTGHS_HCDMAB2_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB2_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB2_HCDMAB_M  (USB_OTGHS_HCDMAB2_HCDMAB_V << USB_OTGHS_HCDMAB2_HCDMAB_S)
#define USB_OTGHS_HCDMAB2_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB2_HCDMAB_S  0

/** USB_OTGHS_HCCHAR3_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR3_REG (DR_REG_USB_OTGHS_BASE + 0x560)
/** USB_OTGHS_HCCHAR3_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR3_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR3_MPS_M  (USB_OTGHS_HCCHAR3_MPS_V << USB_OTGHS_HCCHAR3_MPS_S)
#define USB_OTGHS_HCCHAR3_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR3_MPS_S  0
/** USB_OTGHS_HCCHAR3_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR3_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR3_EPNUM_M  (USB_OTGHS_HCCHAR3_EPNUM_V << USB_OTGHS_HCCHAR3_EPNUM_S)
#define USB_OTGHS_HCCHAR3_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR3_EPNUM_S  11
/** USB_OTGHS_HCCHAR3_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR3_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR3_EPDIR_M  (USB_OTGHS_HCCHAR3_EPDIR_V << USB_OTGHS_HCCHAR3_EPDIR_S)
#define USB_OTGHS_HCCHAR3_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR3_EPDIR_S  15
/** USB_OTGHS_HCCHAR3_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR3_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR3_LSPDDEV_M  (USB_OTGHS_HCCHAR3_LSPDDEV_V << USB_OTGHS_HCCHAR3_LSPDDEV_S)
#define USB_OTGHS_HCCHAR3_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR3_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR3_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR3_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR3_EPTYPE_M  (USB_OTGHS_HCCHAR3_EPTYPE_V << USB_OTGHS_HCCHAR3_EPTYPE_S)
#define USB_OTGHS_HCCHAR3_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR3_EPTYPE_S  18
/** USB_OTGHS_HCCHAR3_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR3_EC    0x00000003U
#define USB_OTGHS_HCCHAR3_EC_M  (USB_OTGHS_HCCHAR3_EC_V << USB_OTGHS_HCCHAR3_EC_S)
#define USB_OTGHS_HCCHAR3_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR3_EC_S  20
/** USB_OTGHS_HCCHAR3_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR3_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR3_DEVADDR_M  (USB_OTGHS_HCCHAR3_DEVADDR_V << USB_OTGHS_HCCHAR3_DEVADDR_S)
#define USB_OTGHS_HCCHAR3_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR3_DEVADDR_S  22
/** USB_OTGHS_HCCHAR3_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR3_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR3_ODDFRM_M  (USB_OTGHS_HCCHAR3_ODDFRM_V << USB_OTGHS_HCCHAR3_ODDFRM_S)
#define USB_OTGHS_HCCHAR3_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR3_ODDFRM_S  29
/** USB_OTGHS_HCCHAR3_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR3_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR3_CHDIS_M  (USB_OTGHS_HCCHAR3_CHDIS_V << USB_OTGHS_HCCHAR3_CHDIS_S)
#define USB_OTGHS_HCCHAR3_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR3_CHDIS_S  30
/** USB_OTGHS_HCCHAR3_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR3_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR3_CHENA_M  (USB_OTGHS_HCCHAR3_CHENA_V << USB_OTGHS_HCCHAR3_CHENA_S)
#define USB_OTGHS_HCCHAR3_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR3_CHENA_S  31

/** USB_OTGHS_HCSPLT3_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT3_REG (DR_REG_USB_OTGHS_BASE + 0x564)
/** USB_OTGHS_HCSPLT3_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT3_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT3_PRTADDR_M  (USB_OTGHS_HCSPLT3_PRTADDR_V << USB_OTGHS_HCSPLT3_PRTADDR_S)
#define USB_OTGHS_HCSPLT3_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT3_PRTADDR_S  0
/** USB_OTGHS_HCSPLT3_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT3_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT3_HUBADDR_M  (USB_OTGHS_HCSPLT3_HUBADDR_V << USB_OTGHS_HCSPLT3_HUBADDR_S)
#define USB_OTGHS_HCSPLT3_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT3_HUBADDR_S  7
/** USB_OTGHS_HCSPLT3_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT3_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT3_XACTPOS_M  (USB_OTGHS_HCSPLT3_XACTPOS_V << USB_OTGHS_HCSPLT3_XACTPOS_S)
#define USB_OTGHS_HCSPLT3_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT3_XACTPOS_S  14
/** USB_OTGHS_HCSPLT3_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT3_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT3_COMPSPLT_M  (USB_OTGHS_HCSPLT3_COMPSPLT_V << USB_OTGHS_HCSPLT3_COMPSPLT_S)
#define USB_OTGHS_HCSPLT3_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT3_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT3_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT3_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT3_SPLTENA_M  (USB_OTGHS_HCSPLT3_SPLTENA_V << USB_OTGHS_HCSPLT3_SPLTENA_S)
#define USB_OTGHS_HCSPLT3_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT3_SPLTENA_S  31

/** USB_OTGHS_HCINT3_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT3_REG (DR_REG_USB_OTGHS_BASE + 0x568)
/** USB_OTGHS_HCINT3_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT3_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT3_XFERCOMPL_M  (USB_OTGHS_HCINT3_XFERCOMPL_V << USB_OTGHS_HCINT3_XFERCOMPL_S)
#define USB_OTGHS_HCINT3_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT3_XFERCOMPL_S  0
/** USB_OTGHS_HCINT3_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT3_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT3_CHHLTD_M  (USB_OTGHS_HCINT3_CHHLTD_V << USB_OTGHS_HCINT3_CHHLTD_S)
#define USB_OTGHS_HCINT3_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT3_CHHLTD_S  1
/** USB_OTGHS_HCINT3_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT3_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT3_AHBERR_M  (USB_OTGHS_HCINT3_AHBERR_V << USB_OTGHS_HCINT3_AHBERR_S)
#define USB_OTGHS_HCINT3_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT3_AHBERR_S  2
/** USB_OTGHS_HCINT3_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT3_STALL    (BIT(3))
#define USB_OTGHS_HCINT3_STALL_M  (USB_OTGHS_HCINT3_STALL_V << USB_OTGHS_HCINT3_STALL_S)
#define USB_OTGHS_HCINT3_STALL_V  0x00000001U
#define USB_OTGHS_HCINT3_STALL_S  3
/** USB_OTGHS_HCINT3_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT3_NAK    (BIT(4))
#define USB_OTGHS_HCINT3_NAK_M  (USB_OTGHS_HCINT3_NAK_V << USB_OTGHS_HCINT3_NAK_S)
#define USB_OTGHS_HCINT3_NAK_V  0x00000001U
#define USB_OTGHS_HCINT3_NAK_S  4
/** USB_OTGHS_HCINT3_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT3_ACK    (BIT(5))
#define USB_OTGHS_HCINT3_ACK_M  (USB_OTGHS_HCINT3_ACK_V << USB_OTGHS_HCINT3_ACK_S)
#define USB_OTGHS_HCINT3_ACK_V  0x00000001U
#define USB_OTGHS_HCINT3_ACK_S  5
/** USB_OTGHS_HCINT3_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT3_NYET    (BIT(6))
#define USB_OTGHS_HCINT3_NYET_M  (USB_OTGHS_HCINT3_NYET_V << USB_OTGHS_HCINT3_NYET_S)
#define USB_OTGHS_HCINT3_NYET_V  0x00000001U
#define USB_OTGHS_HCINT3_NYET_S  6
/** USB_OTGHS_HCINT3_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT3_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT3_XACTERR_M  (USB_OTGHS_HCINT3_XACTERR_V << USB_OTGHS_HCINT3_XACTERR_S)
#define USB_OTGHS_HCINT3_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT3_XACTERR_S  7
/** USB_OTGHS_HCINT3_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT3_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT3_BBLERR_M  (USB_OTGHS_HCINT3_BBLERR_V << USB_OTGHS_HCINT3_BBLERR_S)
#define USB_OTGHS_HCINT3_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT3_BBLERR_S  8
/** USB_OTGHS_HCINT3_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT3_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT3_FRMOVRUN_M  (USB_OTGHS_HCINT3_FRMOVRUN_V << USB_OTGHS_HCINT3_FRMOVRUN_S)
#define USB_OTGHS_HCINT3_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT3_FRMOVRUN_S  9
/** USB_OTGHS_HCINT3_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT3_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT3_DATATGLERR_M  (USB_OTGHS_HCINT3_DATATGLERR_V << USB_OTGHS_HCINT3_DATATGLERR_S)
#define USB_OTGHS_HCINT3_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT3_DATATGLERR_S  10
/** USB_OTGHS_HCINT3_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT3_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT3_BNAINTR_M  (USB_OTGHS_HCINT3_BNAINTR_V << USB_OTGHS_HCINT3_BNAINTR_S)
#define USB_OTGHS_HCINT3_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT3_BNAINTR_S  11
/** USB_OTGHS_HCINT3_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT3_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT3_XCS_XACT_ERR_M  (USB_OTGHS_HCINT3_XCS_XACT_ERR_V << USB_OTGHS_HCINT3_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT3_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT3_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT3_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT3_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT3_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT3_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT3_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT3_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT3_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK3_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK3_REG (DR_REG_USB_OTGHS_BASE + 0x56c)
/** USB_OTGHS_HCINTMSK3_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK3_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK3_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK3_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK3_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK3_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK3_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK3_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK3_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK3_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK3_CHHLTDMSK_V << USB_OTGHS_HCINTMSK3_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK3_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK3_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK3_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK3_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK3_AHBERRMSK_M  (USB_OTGHS_HCINTMSK3_AHBERRMSK_V << USB_OTGHS_HCINTMSK3_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK3_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK3_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK3_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK3_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK3_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK3_BNAINTRMSK_V << USB_OTGHS_HCINTMSK3_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK3_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK3_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK3_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK3_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK3_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK3_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK3_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK3_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK3_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ3_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ3_REG (DR_REG_USB_OTGHS_BASE + 0x570)
/** USB_OTGHS_HCTSIZ3_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ3_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ3_XFERSIZE_M  (USB_OTGHS_HCTSIZ3_XFERSIZE_V << USB_OTGHS_HCTSIZ3_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ3_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ3_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ3_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ3_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ3_PKTCNT_M  (USB_OTGHS_HCTSIZ3_PKTCNT_V << USB_OTGHS_HCTSIZ3_PKTCNT_S)
#define USB_OTGHS_HCTSIZ3_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ3_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ3_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ3_PID    0x00000003U
#define USB_OTGHS_HCTSIZ3_PID_M  (USB_OTGHS_HCTSIZ3_PID_V << USB_OTGHS_HCTSIZ3_PID_S)
#define USB_OTGHS_HCTSIZ3_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ3_PID_S  29
/** USB_OTGHS_HCTSIZ3_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ3_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ3_DOPNG_M  (USB_OTGHS_HCTSIZ3_DOPNG_V << USB_OTGHS_HCTSIZ3_DOPNG_S)
#define USB_OTGHS_HCTSIZ3_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ3_DOPNG_S  31

/** USB_OTGHS_HCDMA3_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA3_REG (DR_REG_USB_OTGHS_BASE + 0x574)
/** USB_OTGHS_HCDMA3_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA3_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA3_DMAADDR_M  (USB_OTGHS_HCDMA3_DMAADDR_V << USB_OTGHS_HCDMA3_DMAADDR_S)
#define USB_OTGHS_HCDMA3_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA3_DMAADDR_S  0

/** USB_OTGHS_HCDMAB3_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB3_REG (DR_REG_USB_OTGHS_BASE + 0x57c)
/** USB_OTGHS_HCDMAB3_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB3_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB3_HCDMAB_M  (USB_OTGHS_HCDMAB3_HCDMAB_V << USB_OTGHS_HCDMAB3_HCDMAB_S)
#define USB_OTGHS_HCDMAB3_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB3_HCDMAB_S  0

/** USB_OTGHS_HCCHAR4_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR4_REG (DR_REG_USB_OTGHS_BASE + 0x580)
/** USB_OTGHS_HCCHAR4_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR4_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR4_MPS_M  (USB_OTGHS_HCCHAR4_MPS_V << USB_OTGHS_HCCHAR4_MPS_S)
#define USB_OTGHS_HCCHAR4_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR4_MPS_S  0
/** USB_OTGHS_HCCHAR4_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR4_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR4_EPNUM_M  (USB_OTGHS_HCCHAR4_EPNUM_V << USB_OTGHS_HCCHAR4_EPNUM_S)
#define USB_OTGHS_HCCHAR4_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR4_EPNUM_S  11
/** USB_OTGHS_HCCHAR4_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR4_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR4_EPDIR_M  (USB_OTGHS_HCCHAR4_EPDIR_V << USB_OTGHS_HCCHAR4_EPDIR_S)
#define USB_OTGHS_HCCHAR4_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR4_EPDIR_S  15
/** USB_OTGHS_HCCHAR4_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR4_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR4_LSPDDEV_M  (USB_OTGHS_HCCHAR4_LSPDDEV_V << USB_OTGHS_HCCHAR4_LSPDDEV_S)
#define USB_OTGHS_HCCHAR4_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR4_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR4_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR4_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR4_EPTYPE_M  (USB_OTGHS_HCCHAR4_EPTYPE_V << USB_OTGHS_HCCHAR4_EPTYPE_S)
#define USB_OTGHS_HCCHAR4_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR4_EPTYPE_S  18
/** USB_OTGHS_HCCHAR4_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR4_EC    0x00000003U
#define USB_OTGHS_HCCHAR4_EC_M  (USB_OTGHS_HCCHAR4_EC_V << USB_OTGHS_HCCHAR4_EC_S)
#define USB_OTGHS_HCCHAR4_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR4_EC_S  20
/** USB_OTGHS_HCCHAR4_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR4_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR4_DEVADDR_M  (USB_OTGHS_HCCHAR4_DEVADDR_V << USB_OTGHS_HCCHAR4_DEVADDR_S)
#define USB_OTGHS_HCCHAR4_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR4_DEVADDR_S  22
/** USB_OTGHS_HCCHAR4_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR4_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR4_ODDFRM_M  (USB_OTGHS_HCCHAR4_ODDFRM_V << USB_OTGHS_HCCHAR4_ODDFRM_S)
#define USB_OTGHS_HCCHAR4_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR4_ODDFRM_S  29
/** USB_OTGHS_HCCHAR4_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR4_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR4_CHDIS_M  (USB_OTGHS_HCCHAR4_CHDIS_V << USB_OTGHS_HCCHAR4_CHDIS_S)
#define USB_OTGHS_HCCHAR4_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR4_CHDIS_S  30
/** USB_OTGHS_HCCHAR4_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR4_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR4_CHENA_M  (USB_OTGHS_HCCHAR4_CHENA_V << USB_OTGHS_HCCHAR4_CHENA_S)
#define USB_OTGHS_HCCHAR4_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR4_CHENA_S  31

/** USB_OTGHS_HCSPLT4_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT4_REG (DR_REG_USB_OTGHS_BASE + 0x584)
/** USB_OTGHS_HCSPLT4_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT4_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT4_PRTADDR_M  (USB_OTGHS_HCSPLT4_PRTADDR_V << USB_OTGHS_HCSPLT4_PRTADDR_S)
#define USB_OTGHS_HCSPLT4_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT4_PRTADDR_S  0
/** USB_OTGHS_HCSPLT4_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT4_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT4_HUBADDR_M  (USB_OTGHS_HCSPLT4_HUBADDR_V << USB_OTGHS_HCSPLT4_HUBADDR_S)
#define USB_OTGHS_HCSPLT4_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT4_HUBADDR_S  7
/** USB_OTGHS_HCSPLT4_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT4_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT4_XACTPOS_M  (USB_OTGHS_HCSPLT4_XACTPOS_V << USB_OTGHS_HCSPLT4_XACTPOS_S)
#define USB_OTGHS_HCSPLT4_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT4_XACTPOS_S  14
/** USB_OTGHS_HCSPLT4_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT4_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT4_COMPSPLT_M  (USB_OTGHS_HCSPLT4_COMPSPLT_V << USB_OTGHS_HCSPLT4_COMPSPLT_S)
#define USB_OTGHS_HCSPLT4_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT4_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT4_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT4_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT4_SPLTENA_M  (USB_OTGHS_HCSPLT4_SPLTENA_V << USB_OTGHS_HCSPLT4_SPLTENA_S)
#define USB_OTGHS_HCSPLT4_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT4_SPLTENA_S  31

/** USB_OTGHS_HCINT4_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT4_REG (DR_REG_USB_OTGHS_BASE + 0x588)
/** USB_OTGHS_HCINT4_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT4_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT4_XFERCOMPL_M  (USB_OTGHS_HCINT4_XFERCOMPL_V << USB_OTGHS_HCINT4_XFERCOMPL_S)
#define USB_OTGHS_HCINT4_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT4_XFERCOMPL_S  0
/** USB_OTGHS_HCINT4_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT4_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT4_CHHLTD_M  (USB_OTGHS_HCINT4_CHHLTD_V << USB_OTGHS_HCINT4_CHHLTD_S)
#define USB_OTGHS_HCINT4_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT4_CHHLTD_S  1
/** USB_OTGHS_HCINT4_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT4_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT4_AHBERR_M  (USB_OTGHS_HCINT4_AHBERR_V << USB_OTGHS_HCINT4_AHBERR_S)
#define USB_OTGHS_HCINT4_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT4_AHBERR_S  2
/** USB_OTGHS_HCINT4_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT4_STALL    (BIT(3))
#define USB_OTGHS_HCINT4_STALL_M  (USB_OTGHS_HCINT4_STALL_V << USB_OTGHS_HCINT4_STALL_S)
#define USB_OTGHS_HCINT4_STALL_V  0x00000001U
#define USB_OTGHS_HCINT4_STALL_S  3
/** USB_OTGHS_HCINT4_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT4_NAK    (BIT(4))
#define USB_OTGHS_HCINT4_NAK_M  (USB_OTGHS_HCINT4_NAK_V << USB_OTGHS_HCINT4_NAK_S)
#define USB_OTGHS_HCINT4_NAK_V  0x00000001U
#define USB_OTGHS_HCINT4_NAK_S  4
/** USB_OTGHS_HCINT4_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT4_ACK    (BIT(5))
#define USB_OTGHS_HCINT4_ACK_M  (USB_OTGHS_HCINT4_ACK_V << USB_OTGHS_HCINT4_ACK_S)
#define USB_OTGHS_HCINT4_ACK_V  0x00000001U
#define USB_OTGHS_HCINT4_ACK_S  5
/** USB_OTGHS_HCINT4_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT4_NYET    (BIT(6))
#define USB_OTGHS_HCINT4_NYET_M  (USB_OTGHS_HCINT4_NYET_V << USB_OTGHS_HCINT4_NYET_S)
#define USB_OTGHS_HCINT4_NYET_V  0x00000001U
#define USB_OTGHS_HCINT4_NYET_S  6
/** USB_OTGHS_HCINT4_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT4_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT4_XACTERR_M  (USB_OTGHS_HCINT4_XACTERR_V << USB_OTGHS_HCINT4_XACTERR_S)
#define USB_OTGHS_HCINT4_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT4_XACTERR_S  7
/** USB_OTGHS_HCINT4_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT4_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT4_BBLERR_M  (USB_OTGHS_HCINT4_BBLERR_V << USB_OTGHS_HCINT4_BBLERR_S)
#define USB_OTGHS_HCINT4_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT4_BBLERR_S  8
/** USB_OTGHS_HCINT4_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT4_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT4_FRMOVRUN_M  (USB_OTGHS_HCINT4_FRMOVRUN_V << USB_OTGHS_HCINT4_FRMOVRUN_S)
#define USB_OTGHS_HCINT4_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT4_FRMOVRUN_S  9
/** USB_OTGHS_HCINT4_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT4_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT4_DATATGLERR_M  (USB_OTGHS_HCINT4_DATATGLERR_V << USB_OTGHS_HCINT4_DATATGLERR_S)
#define USB_OTGHS_HCINT4_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT4_DATATGLERR_S  10
/** USB_OTGHS_HCINT4_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT4_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT4_BNAINTR_M  (USB_OTGHS_HCINT4_BNAINTR_V << USB_OTGHS_HCINT4_BNAINTR_S)
#define USB_OTGHS_HCINT4_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT4_BNAINTR_S  11
/** USB_OTGHS_HCINT4_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT4_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT4_XCS_XACT_ERR_M  (USB_OTGHS_HCINT4_XCS_XACT_ERR_V << USB_OTGHS_HCINT4_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT4_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT4_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT4_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT4_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT4_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT4_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT4_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT4_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT4_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK4_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK4_REG (DR_REG_USB_OTGHS_BASE + 0x58c)
/** USB_OTGHS_HCINTMSK4_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK4_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK4_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK4_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK4_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK4_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK4_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK4_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK4_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK4_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK4_CHHLTDMSK_V << USB_OTGHS_HCINTMSK4_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK4_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK4_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK4_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK4_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK4_AHBERRMSK_M  (USB_OTGHS_HCINTMSK4_AHBERRMSK_V << USB_OTGHS_HCINTMSK4_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK4_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK4_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK4_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK4_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK4_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK4_BNAINTRMSK_V << USB_OTGHS_HCINTMSK4_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK4_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK4_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK4_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK4_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK4_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK4_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK4_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK4_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK4_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ4_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ4_REG (DR_REG_USB_OTGHS_BASE + 0x590)
/** USB_OTGHS_HCTSIZ4_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ4_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ4_XFERSIZE_M  (USB_OTGHS_HCTSIZ4_XFERSIZE_V << USB_OTGHS_HCTSIZ4_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ4_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ4_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ4_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ4_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ4_PKTCNT_M  (USB_OTGHS_HCTSIZ4_PKTCNT_V << USB_OTGHS_HCTSIZ4_PKTCNT_S)
#define USB_OTGHS_HCTSIZ4_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ4_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ4_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ4_PID    0x00000003U
#define USB_OTGHS_HCTSIZ4_PID_M  (USB_OTGHS_HCTSIZ4_PID_V << USB_OTGHS_HCTSIZ4_PID_S)
#define USB_OTGHS_HCTSIZ4_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ4_PID_S  29
/** USB_OTGHS_HCTSIZ4_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ4_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ4_DOPNG_M  (USB_OTGHS_HCTSIZ4_DOPNG_V << USB_OTGHS_HCTSIZ4_DOPNG_S)
#define USB_OTGHS_HCTSIZ4_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ4_DOPNG_S  31

/** USB_OTGHS_HCDMA4_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA4_REG (DR_REG_USB_OTGHS_BASE + 0x594)
/** USB_OTGHS_HCDMA4_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA4_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA4_DMAADDR_M  (USB_OTGHS_HCDMA4_DMAADDR_V << USB_OTGHS_HCDMA4_DMAADDR_S)
#define USB_OTGHS_HCDMA4_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA4_DMAADDR_S  0

/** USB_OTGHS_HCDMAB4_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB4_REG (DR_REG_USB_OTGHS_BASE + 0x59c)
/** USB_OTGHS_HCDMAB4_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB4_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB4_HCDMAB_M  (USB_OTGHS_HCDMAB4_HCDMAB_V << USB_OTGHS_HCDMAB4_HCDMAB_S)
#define USB_OTGHS_HCDMAB4_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB4_HCDMAB_S  0

/** USB_OTGHS_HCCHAR5_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR5_REG (DR_REG_USB_OTGHS_BASE + 0x5a0)
/** USB_OTGHS_HCCHAR5_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR5_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR5_MPS_M  (USB_OTGHS_HCCHAR5_MPS_V << USB_OTGHS_HCCHAR5_MPS_S)
#define USB_OTGHS_HCCHAR5_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR5_MPS_S  0
/** USB_OTGHS_HCCHAR5_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR5_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR5_EPNUM_M  (USB_OTGHS_HCCHAR5_EPNUM_V << USB_OTGHS_HCCHAR5_EPNUM_S)
#define USB_OTGHS_HCCHAR5_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR5_EPNUM_S  11
/** USB_OTGHS_HCCHAR5_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR5_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR5_EPDIR_M  (USB_OTGHS_HCCHAR5_EPDIR_V << USB_OTGHS_HCCHAR5_EPDIR_S)
#define USB_OTGHS_HCCHAR5_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR5_EPDIR_S  15
/** USB_OTGHS_HCCHAR5_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR5_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR5_LSPDDEV_M  (USB_OTGHS_HCCHAR5_LSPDDEV_V << USB_OTGHS_HCCHAR5_LSPDDEV_S)
#define USB_OTGHS_HCCHAR5_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR5_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR5_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR5_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR5_EPTYPE_M  (USB_OTGHS_HCCHAR5_EPTYPE_V << USB_OTGHS_HCCHAR5_EPTYPE_S)
#define USB_OTGHS_HCCHAR5_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR5_EPTYPE_S  18
/** USB_OTGHS_HCCHAR5_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR5_EC    0x00000003U
#define USB_OTGHS_HCCHAR5_EC_M  (USB_OTGHS_HCCHAR5_EC_V << USB_OTGHS_HCCHAR5_EC_S)
#define USB_OTGHS_HCCHAR5_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR5_EC_S  20
/** USB_OTGHS_HCCHAR5_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR5_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR5_DEVADDR_M  (USB_OTGHS_HCCHAR5_DEVADDR_V << USB_OTGHS_HCCHAR5_DEVADDR_S)
#define USB_OTGHS_HCCHAR5_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR5_DEVADDR_S  22
/** USB_OTGHS_HCCHAR5_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR5_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR5_ODDFRM_M  (USB_OTGHS_HCCHAR5_ODDFRM_V << USB_OTGHS_HCCHAR5_ODDFRM_S)
#define USB_OTGHS_HCCHAR5_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR5_ODDFRM_S  29
/** USB_OTGHS_HCCHAR5_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR5_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR5_CHDIS_M  (USB_OTGHS_HCCHAR5_CHDIS_V << USB_OTGHS_HCCHAR5_CHDIS_S)
#define USB_OTGHS_HCCHAR5_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR5_CHDIS_S  30
/** USB_OTGHS_HCCHAR5_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR5_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR5_CHENA_M  (USB_OTGHS_HCCHAR5_CHENA_V << USB_OTGHS_HCCHAR5_CHENA_S)
#define USB_OTGHS_HCCHAR5_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR5_CHENA_S  31

/** USB_OTGHS_HCSPLT5_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT5_REG (DR_REG_USB_OTGHS_BASE + 0x5a4)
/** USB_OTGHS_HCSPLT5_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT5_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT5_PRTADDR_M  (USB_OTGHS_HCSPLT5_PRTADDR_V << USB_OTGHS_HCSPLT5_PRTADDR_S)
#define USB_OTGHS_HCSPLT5_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT5_PRTADDR_S  0
/** USB_OTGHS_HCSPLT5_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT5_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT5_HUBADDR_M  (USB_OTGHS_HCSPLT5_HUBADDR_V << USB_OTGHS_HCSPLT5_HUBADDR_S)
#define USB_OTGHS_HCSPLT5_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT5_HUBADDR_S  7
/** USB_OTGHS_HCSPLT5_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT5_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT5_XACTPOS_M  (USB_OTGHS_HCSPLT5_XACTPOS_V << USB_OTGHS_HCSPLT5_XACTPOS_S)
#define USB_OTGHS_HCSPLT5_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT5_XACTPOS_S  14
/** USB_OTGHS_HCSPLT5_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT5_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT5_COMPSPLT_M  (USB_OTGHS_HCSPLT5_COMPSPLT_V << USB_OTGHS_HCSPLT5_COMPSPLT_S)
#define USB_OTGHS_HCSPLT5_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT5_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT5_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT5_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT5_SPLTENA_M  (USB_OTGHS_HCSPLT5_SPLTENA_V << USB_OTGHS_HCSPLT5_SPLTENA_S)
#define USB_OTGHS_HCSPLT5_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT5_SPLTENA_S  31

/** USB_OTGHS_HCINT5_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT5_REG (DR_REG_USB_OTGHS_BASE + 0x5a8)
/** USB_OTGHS_HCINT5_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT5_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT5_XFERCOMPL_M  (USB_OTGHS_HCINT5_XFERCOMPL_V << USB_OTGHS_HCINT5_XFERCOMPL_S)
#define USB_OTGHS_HCINT5_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT5_XFERCOMPL_S  0
/** USB_OTGHS_HCINT5_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT5_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT5_CHHLTD_M  (USB_OTGHS_HCINT5_CHHLTD_V << USB_OTGHS_HCINT5_CHHLTD_S)
#define USB_OTGHS_HCINT5_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT5_CHHLTD_S  1
/** USB_OTGHS_HCINT5_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT5_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT5_AHBERR_M  (USB_OTGHS_HCINT5_AHBERR_V << USB_OTGHS_HCINT5_AHBERR_S)
#define USB_OTGHS_HCINT5_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT5_AHBERR_S  2
/** USB_OTGHS_HCINT5_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT5_STALL    (BIT(3))
#define USB_OTGHS_HCINT5_STALL_M  (USB_OTGHS_HCINT5_STALL_V << USB_OTGHS_HCINT5_STALL_S)
#define USB_OTGHS_HCINT5_STALL_V  0x00000001U
#define USB_OTGHS_HCINT5_STALL_S  3
/** USB_OTGHS_HCINT5_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT5_NAK    (BIT(4))
#define USB_OTGHS_HCINT5_NAK_M  (USB_OTGHS_HCINT5_NAK_V << USB_OTGHS_HCINT5_NAK_S)
#define USB_OTGHS_HCINT5_NAK_V  0x00000001U
#define USB_OTGHS_HCINT5_NAK_S  4
/** USB_OTGHS_HCINT5_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT5_ACK    (BIT(5))
#define USB_OTGHS_HCINT5_ACK_M  (USB_OTGHS_HCINT5_ACK_V << USB_OTGHS_HCINT5_ACK_S)
#define USB_OTGHS_HCINT5_ACK_V  0x00000001U
#define USB_OTGHS_HCINT5_ACK_S  5
/** USB_OTGHS_HCINT5_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT5_NYET    (BIT(6))
#define USB_OTGHS_HCINT5_NYET_M  (USB_OTGHS_HCINT5_NYET_V << USB_OTGHS_HCINT5_NYET_S)
#define USB_OTGHS_HCINT5_NYET_V  0x00000001U
#define USB_OTGHS_HCINT5_NYET_S  6
/** USB_OTGHS_HCINT5_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT5_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT5_XACTERR_M  (USB_OTGHS_HCINT5_XACTERR_V << USB_OTGHS_HCINT5_XACTERR_S)
#define USB_OTGHS_HCINT5_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT5_XACTERR_S  7
/** USB_OTGHS_HCINT5_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT5_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT5_BBLERR_M  (USB_OTGHS_HCINT5_BBLERR_V << USB_OTGHS_HCINT5_BBLERR_S)
#define USB_OTGHS_HCINT5_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT5_BBLERR_S  8
/** USB_OTGHS_HCINT5_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT5_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT5_FRMOVRUN_M  (USB_OTGHS_HCINT5_FRMOVRUN_V << USB_OTGHS_HCINT5_FRMOVRUN_S)
#define USB_OTGHS_HCINT5_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT5_FRMOVRUN_S  9
/** USB_OTGHS_HCINT5_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT5_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT5_DATATGLERR_M  (USB_OTGHS_HCINT5_DATATGLERR_V << USB_OTGHS_HCINT5_DATATGLERR_S)
#define USB_OTGHS_HCINT5_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT5_DATATGLERR_S  10
/** USB_OTGHS_HCINT5_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT5_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT5_BNAINTR_M  (USB_OTGHS_HCINT5_BNAINTR_V << USB_OTGHS_HCINT5_BNAINTR_S)
#define USB_OTGHS_HCINT5_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT5_BNAINTR_S  11
/** USB_OTGHS_HCINT5_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT5_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT5_XCS_XACT_ERR_M  (USB_OTGHS_HCINT5_XCS_XACT_ERR_V << USB_OTGHS_HCINT5_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT5_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT5_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT5_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT5_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT5_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT5_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT5_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT5_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT5_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK5_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK5_REG (DR_REG_USB_OTGHS_BASE + 0x5ac)
/** USB_OTGHS_HCINTMSK5_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK5_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK5_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK5_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK5_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK5_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK5_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK5_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK5_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK5_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK5_CHHLTDMSK_V << USB_OTGHS_HCINTMSK5_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK5_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK5_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK5_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK5_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK5_AHBERRMSK_M  (USB_OTGHS_HCINTMSK5_AHBERRMSK_V << USB_OTGHS_HCINTMSK5_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK5_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK5_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK5_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK5_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK5_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK5_BNAINTRMSK_V << USB_OTGHS_HCINTMSK5_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK5_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK5_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK5_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK5_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK5_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK5_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK5_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK5_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK5_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ5_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ5_REG (DR_REG_USB_OTGHS_BASE + 0x5b0)
/** USB_OTGHS_HCTSIZ5_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ5_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ5_XFERSIZE_M  (USB_OTGHS_HCTSIZ5_XFERSIZE_V << USB_OTGHS_HCTSIZ5_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ5_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ5_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ5_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ5_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ5_PKTCNT_M  (USB_OTGHS_HCTSIZ5_PKTCNT_V << USB_OTGHS_HCTSIZ5_PKTCNT_S)
#define USB_OTGHS_HCTSIZ5_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ5_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ5_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ5_PID    0x00000003U
#define USB_OTGHS_HCTSIZ5_PID_M  (USB_OTGHS_HCTSIZ5_PID_V << USB_OTGHS_HCTSIZ5_PID_S)
#define USB_OTGHS_HCTSIZ5_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ5_PID_S  29
/** USB_OTGHS_HCTSIZ5_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ5_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ5_DOPNG_M  (USB_OTGHS_HCTSIZ5_DOPNG_V << USB_OTGHS_HCTSIZ5_DOPNG_S)
#define USB_OTGHS_HCTSIZ5_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ5_DOPNG_S  31

/** USB_OTGHS_HCDMA5_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA5_REG (DR_REG_USB_OTGHS_BASE + 0x5b4)
/** USB_OTGHS_HCDMA5_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA5_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA5_DMAADDR_M  (USB_OTGHS_HCDMA5_DMAADDR_V << USB_OTGHS_HCDMA5_DMAADDR_S)
#define USB_OTGHS_HCDMA5_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA5_DMAADDR_S  0

/** USB_OTGHS_HCDMAB5_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB5_REG (DR_REG_USB_OTGHS_BASE + 0x5bc)
/** USB_OTGHS_HCDMAB5_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB5_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB5_HCDMAB_M  (USB_OTGHS_HCDMAB5_HCDMAB_V << USB_OTGHS_HCDMAB5_HCDMAB_S)
#define USB_OTGHS_HCDMAB5_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB5_HCDMAB_S  0

/** USB_OTGHS_HCCHAR6_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR6_REG (DR_REG_USB_OTGHS_BASE + 0x5c0)
/** USB_OTGHS_HCCHAR6_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR6_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR6_MPS_M  (USB_OTGHS_HCCHAR6_MPS_V << USB_OTGHS_HCCHAR6_MPS_S)
#define USB_OTGHS_HCCHAR6_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR6_MPS_S  0
/** USB_OTGHS_HCCHAR6_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR6_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR6_EPNUM_M  (USB_OTGHS_HCCHAR6_EPNUM_V << USB_OTGHS_HCCHAR6_EPNUM_S)
#define USB_OTGHS_HCCHAR6_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR6_EPNUM_S  11
/** USB_OTGHS_HCCHAR6_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR6_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR6_EPDIR_M  (USB_OTGHS_HCCHAR6_EPDIR_V << USB_OTGHS_HCCHAR6_EPDIR_S)
#define USB_OTGHS_HCCHAR6_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR6_EPDIR_S  15
/** USB_OTGHS_HCCHAR6_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR6_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR6_LSPDDEV_M  (USB_OTGHS_HCCHAR6_LSPDDEV_V << USB_OTGHS_HCCHAR6_LSPDDEV_S)
#define USB_OTGHS_HCCHAR6_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR6_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR6_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR6_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR6_EPTYPE_M  (USB_OTGHS_HCCHAR6_EPTYPE_V << USB_OTGHS_HCCHAR6_EPTYPE_S)
#define USB_OTGHS_HCCHAR6_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR6_EPTYPE_S  18
/** USB_OTGHS_HCCHAR6_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR6_EC    0x00000003U
#define USB_OTGHS_HCCHAR6_EC_M  (USB_OTGHS_HCCHAR6_EC_V << USB_OTGHS_HCCHAR6_EC_S)
#define USB_OTGHS_HCCHAR6_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR6_EC_S  20
/** USB_OTGHS_HCCHAR6_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR6_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR6_DEVADDR_M  (USB_OTGHS_HCCHAR6_DEVADDR_V << USB_OTGHS_HCCHAR6_DEVADDR_S)
#define USB_OTGHS_HCCHAR6_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR6_DEVADDR_S  22
/** USB_OTGHS_HCCHAR6_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR6_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR6_ODDFRM_M  (USB_OTGHS_HCCHAR6_ODDFRM_V << USB_OTGHS_HCCHAR6_ODDFRM_S)
#define USB_OTGHS_HCCHAR6_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR6_ODDFRM_S  29
/** USB_OTGHS_HCCHAR6_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR6_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR6_CHDIS_M  (USB_OTGHS_HCCHAR6_CHDIS_V << USB_OTGHS_HCCHAR6_CHDIS_S)
#define USB_OTGHS_HCCHAR6_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR6_CHDIS_S  30
/** USB_OTGHS_HCCHAR6_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR6_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR6_CHENA_M  (USB_OTGHS_HCCHAR6_CHENA_V << USB_OTGHS_HCCHAR6_CHENA_S)
#define USB_OTGHS_HCCHAR6_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR6_CHENA_S  31

/** USB_OTGHS_HCSPLT6_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT6_REG (DR_REG_USB_OTGHS_BASE + 0x5c4)
/** USB_OTGHS_HCSPLT6_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT6_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT6_PRTADDR_M  (USB_OTGHS_HCSPLT6_PRTADDR_V << USB_OTGHS_HCSPLT6_PRTADDR_S)
#define USB_OTGHS_HCSPLT6_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT6_PRTADDR_S  0
/** USB_OTGHS_HCSPLT6_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT6_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT6_HUBADDR_M  (USB_OTGHS_HCSPLT6_HUBADDR_V << USB_OTGHS_HCSPLT6_HUBADDR_S)
#define USB_OTGHS_HCSPLT6_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT6_HUBADDR_S  7
/** USB_OTGHS_HCSPLT6_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT6_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT6_XACTPOS_M  (USB_OTGHS_HCSPLT6_XACTPOS_V << USB_OTGHS_HCSPLT6_XACTPOS_S)
#define USB_OTGHS_HCSPLT6_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT6_XACTPOS_S  14
/** USB_OTGHS_HCSPLT6_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT6_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT6_COMPSPLT_M  (USB_OTGHS_HCSPLT6_COMPSPLT_V << USB_OTGHS_HCSPLT6_COMPSPLT_S)
#define USB_OTGHS_HCSPLT6_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT6_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT6_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT6_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT6_SPLTENA_M  (USB_OTGHS_HCSPLT6_SPLTENA_V << USB_OTGHS_HCSPLT6_SPLTENA_S)
#define USB_OTGHS_HCSPLT6_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT6_SPLTENA_S  31

/** USB_OTGHS_HCINT6_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT6_REG (DR_REG_USB_OTGHS_BASE + 0x5c8)
/** USB_OTGHS_HCINT6_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT6_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT6_XFERCOMPL_M  (USB_OTGHS_HCINT6_XFERCOMPL_V << USB_OTGHS_HCINT6_XFERCOMPL_S)
#define USB_OTGHS_HCINT6_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT6_XFERCOMPL_S  0
/** USB_OTGHS_HCINT6_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT6_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT6_CHHLTD_M  (USB_OTGHS_HCINT6_CHHLTD_V << USB_OTGHS_HCINT6_CHHLTD_S)
#define USB_OTGHS_HCINT6_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT6_CHHLTD_S  1
/** USB_OTGHS_HCINT6_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT6_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT6_AHBERR_M  (USB_OTGHS_HCINT6_AHBERR_V << USB_OTGHS_HCINT6_AHBERR_S)
#define USB_OTGHS_HCINT6_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT6_AHBERR_S  2
/** USB_OTGHS_HCINT6_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT6_STALL    (BIT(3))
#define USB_OTGHS_HCINT6_STALL_M  (USB_OTGHS_HCINT6_STALL_V << USB_OTGHS_HCINT6_STALL_S)
#define USB_OTGHS_HCINT6_STALL_V  0x00000001U
#define USB_OTGHS_HCINT6_STALL_S  3
/** USB_OTGHS_HCINT6_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT6_NAK    (BIT(4))
#define USB_OTGHS_HCINT6_NAK_M  (USB_OTGHS_HCINT6_NAK_V << USB_OTGHS_HCINT6_NAK_S)
#define USB_OTGHS_HCINT6_NAK_V  0x00000001U
#define USB_OTGHS_HCINT6_NAK_S  4
/** USB_OTGHS_HCINT6_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT6_ACK    (BIT(5))
#define USB_OTGHS_HCINT6_ACK_M  (USB_OTGHS_HCINT6_ACK_V << USB_OTGHS_HCINT6_ACK_S)
#define USB_OTGHS_HCINT6_ACK_V  0x00000001U
#define USB_OTGHS_HCINT6_ACK_S  5
/** USB_OTGHS_HCINT6_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT6_NYET    (BIT(6))
#define USB_OTGHS_HCINT6_NYET_M  (USB_OTGHS_HCINT6_NYET_V << USB_OTGHS_HCINT6_NYET_S)
#define USB_OTGHS_HCINT6_NYET_V  0x00000001U
#define USB_OTGHS_HCINT6_NYET_S  6
/** USB_OTGHS_HCINT6_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT6_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT6_XACTERR_M  (USB_OTGHS_HCINT6_XACTERR_V << USB_OTGHS_HCINT6_XACTERR_S)
#define USB_OTGHS_HCINT6_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT6_XACTERR_S  7
/** USB_OTGHS_HCINT6_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT6_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT6_BBLERR_M  (USB_OTGHS_HCINT6_BBLERR_V << USB_OTGHS_HCINT6_BBLERR_S)
#define USB_OTGHS_HCINT6_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT6_BBLERR_S  8
/** USB_OTGHS_HCINT6_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT6_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT6_FRMOVRUN_M  (USB_OTGHS_HCINT6_FRMOVRUN_V << USB_OTGHS_HCINT6_FRMOVRUN_S)
#define USB_OTGHS_HCINT6_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT6_FRMOVRUN_S  9
/** USB_OTGHS_HCINT6_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT6_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT6_DATATGLERR_M  (USB_OTGHS_HCINT6_DATATGLERR_V << USB_OTGHS_HCINT6_DATATGLERR_S)
#define USB_OTGHS_HCINT6_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT6_DATATGLERR_S  10
/** USB_OTGHS_HCINT6_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT6_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT6_BNAINTR_M  (USB_OTGHS_HCINT6_BNAINTR_V << USB_OTGHS_HCINT6_BNAINTR_S)
#define USB_OTGHS_HCINT6_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT6_BNAINTR_S  11
/** USB_OTGHS_HCINT6_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT6_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT6_XCS_XACT_ERR_M  (USB_OTGHS_HCINT6_XCS_XACT_ERR_V << USB_OTGHS_HCINT6_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT6_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT6_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT6_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT6_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT6_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT6_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT6_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT6_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT6_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK6_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK6_REG (DR_REG_USB_OTGHS_BASE + 0x5cc)
/** USB_OTGHS_HCINTMSK6_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK6_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK6_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK6_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK6_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK6_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK6_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK6_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK6_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK6_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK6_CHHLTDMSK_V << USB_OTGHS_HCINTMSK6_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK6_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK6_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK6_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK6_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK6_AHBERRMSK_M  (USB_OTGHS_HCINTMSK6_AHBERRMSK_V << USB_OTGHS_HCINTMSK6_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK6_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK6_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK6_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK6_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK6_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK6_BNAINTRMSK_V << USB_OTGHS_HCINTMSK6_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK6_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK6_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK6_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK6_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK6_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK6_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK6_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK6_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK6_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ6_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ6_REG (DR_REG_USB_OTGHS_BASE + 0x5d0)
/** USB_OTGHS_HCTSIZ6_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ6_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ6_XFERSIZE_M  (USB_OTGHS_HCTSIZ6_XFERSIZE_V << USB_OTGHS_HCTSIZ6_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ6_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ6_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ6_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ6_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ6_PKTCNT_M  (USB_OTGHS_HCTSIZ6_PKTCNT_V << USB_OTGHS_HCTSIZ6_PKTCNT_S)
#define USB_OTGHS_HCTSIZ6_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ6_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ6_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ6_PID    0x00000003U
#define USB_OTGHS_HCTSIZ6_PID_M  (USB_OTGHS_HCTSIZ6_PID_V << USB_OTGHS_HCTSIZ6_PID_S)
#define USB_OTGHS_HCTSIZ6_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ6_PID_S  29
/** USB_OTGHS_HCTSIZ6_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ6_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ6_DOPNG_M  (USB_OTGHS_HCTSIZ6_DOPNG_V << USB_OTGHS_HCTSIZ6_DOPNG_S)
#define USB_OTGHS_HCTSIZ6_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ6_DOPNG_S  31

/** USB_OTGHS_HCDMA6_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA6_REG (DR_REG_USB_OTGHS_BASE + 0x5d4)
/** USB_OTGHS_HCDMA6_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA6_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA6_DMAADDR_M  (USB_OTGHS_HCDMA6_DMAADDR_V << USB_OTGHS_HCDMA6_DMAADDR_S)
#define USB_OTGHS_HCDMA6_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA6_DMAADDR_S  0

/** USB_OTGHS_HCDMAB6_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB6_REG (DR_REG_USB_OTGHS_BASE + 0x5dc)
/** USB_OTGHS_HCDMAB6_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB6_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB6_HCDMAB_M  (USB_OTGHS_HCDMAB6_HCDMAB_V << USB_OTGHS_HCDMAB6_HCDMAB_S)
#define USB_OTGHS_HCDMAB6_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB6_HCDMAB_S  0

/** USB_OTGHS_HCCHAR7_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR7_REG (DR_REG_USB_OTGHS_BASE + 0x5e0)
/** USB_OTGHS_HCCHAR7_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR7_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR7_MPS_M  (USB_OTGHS_HCCHAR7_MPS_V << USB_OTGHS_HCCHAR7_MPS_S)
#define USB_OTGHS_HCCHAR7_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR7_MPS_S  0
/** USB_OTGHS_HCCHAR7_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR7_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR7_EPNUM_M  (USB_OTGHS_HCCHAR7_EPNUM_V << USB_OTGHS_HCCHAR7_EPNUM_S)
#define USB_OTGHS_HCCHAR7_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR7_EPNUM_S  11
/** USB_OTGHS_HCCHAR7_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR7_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR7_EPDIR_M  (USB_OTGHS_HCCHAR7_EPDIR_V << USB_OTGHS_HCCHAR7_EPDIR_S)
#define USB_OTGHS_HCCHAR7_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR7_EPDIR_S  15
/** USB_OTGHS_HCCHAR7_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR7_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR7_LSPDDEV_M  (USB_OTGHS_HCCHAR7_LSPDDEV_V << USB_OTGHS_HCCHAR7_LSPDDEV_S)
#define USB_OTGHS_HCCHAR7_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR7_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR7_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR7_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR7_EPTYPE_M  (USB_OTGHS_HCCHAR7_EPTYPE_V << USB_OTGHS_HCCHAR7_EPTYPE_S)
#define USB_OTGHS_HCCHAR7_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR7_EPTYPE_S  18
/** USB_OTGHS_HCCHAR7_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR7_EC    0x00000003U
#define USB_OTGHS_HCCHAR7_EC_M  (USB_OTGHS_HCCHAR7_EC_V << USB_OTGHS_HCCHAR7_EC_S)
#define USB_OTGHS_HCCHAR7_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR7_EC_S  20
/** USB_OTGHS_HCCHAR7_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR7_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR7_DEVADDR_M  (USB_OTGHS_HCCHAR7_DEVADDR_V << USB_OTGHS_HCCHAR7_DEVADDR_S)
#define USB_OTGHS_HCCHAR7_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR7_DEVADDR_S  22
/** USB_OTGHS_HCCHAR7_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR7_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR7_ODDFRM_M  (USB_OTGHS_HCCHAR7_ODDFRM_V << USB_OTGHS_HCCHAR7_ODDFRM_S)
#define USB_OTGHS_HCCHAR7_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR7_ODDFRM_S  29
/** USB_OTGHS_HCCHAR7_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR7_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR7_CHDIS_M  (USB_OTGHS_HCCHAR7_CHDIS_V << USB_OTGHS_HCCHAR7_CHDIS_S)
#define USB_OTGHS_HCCHAR7_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR7_CHDIS_S  30
/** USB_OTGHS_HCCHAR7_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR7_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR7_CHENA_M  (USB_OTGHS_HCCHAR7_CHENA_V << USB_OTGHS_HCCHAR7_CHENA_S)
#define USB_OTGHS_HCCHAR7_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR7_CHENA_S  31

/** USB_OTGHS_HCSPLT7_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT7_REG (DR_REG_USB_OTGHS_BASE + 0x5e4)
/** USB_OTGHS_HCSPLT7_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT7_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT7_PRTADDR_M  (USB_OTGHS_HCSPLT7_PRTADDR_V << USB_OTGHS_HCSPLT7_PRTADDR_S)
#define USB_OTGHS_HCSPLT7_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT7_PRTADDR_S  0
/** USB_OTGHS_HCSPLT7_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT7_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT7_HUBADDR_M  (USB_OTGHS_HCSPLT7_HUBADDR_V << USB_OTGHS_HCSPLT7_HUBADDR_S)
#define USB_OTGHS_HCSPLT7_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT7_HUBADDR_S  7
/** USB_OTGHS_HCSPLT7_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT7_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT7_XACTPOS_M  (USB_OTGHS_HCSPLT7_XACTPOS_V << USB_OTGHS_HCSPLT7_XACTPOS_S)
#define USB_OTGHS_HCSPLT7_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT7_XACTPOS_S  14
/** USB_OTGHS_HCSPLT7_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT7_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT7_COMPSPLT_M  (USB_OTGHS_HCSPLT7_COMPSPLT_V << USB_OTGHS_HCSPLT7_COMPSPLT_S)
#define USB_OTGHS_HCSPLT7_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT7_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT7_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT7_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT7_SPLTENA_M  (USB_OTGHS_HCSPLT7_SPLTENA_V << USB_OTGHS_HCSPLT7_SPLTENA_S)
#define USB_OTGHS_HCSPLT7_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT7_SPLTENA_S  31

/** USB_OTGHS_HCINT7_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT7_REG (DR_REG_USB_OTGHS_BASE + 0x5e8)
/** USB_OTGHS_HCINT7_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT7_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT7_XFERCOMPL_M  (USB_OTGHS_HCINT7_XFERCOMPL_V << USB_OTGHS_HCINT7_XFERCOMPL_S)
#define USB_OTGHS_HCINT7_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT7_XFERCOMPL_S  0
/** USB_OTGHS_HCINT7_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT7_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT7_CHHLTD_M  (USB_OTGHS_HCINT7_CHHLTD_V << USB_OTGHS_HCINT7_CHHLTD_S)
#define USB_OTGHS_HCINT7_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT7_CHHLTD_S  1
/** USB_OTGHS_HCINT7_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT7_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT7_AHBERR_M  (USB_OTGHS_HCINT7_AHBERR_V << USB_OTGHS_HCINT7_AHBERR_S)
#define USB_OTGHS_HCINT7_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT7_AHBERR_S  2
/** USB_OTGHS_HCINT7_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT7_STALL    (BIT(3))
#define USB_OTGHS_HCINT7_STALL_M  (USB_OTGHS_HCINT7_STALL_V << USB_OTGHS_HCINT7_STALL_S)
#define USB_OTGHS_HCINT7_STALL_V  0x00000001U
#define USB_OTGHS_HCINT7_STALL_S  3
/** USB_OTGHS_HCINT7_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT7_NAK    (BIT(4))
#define USB_OTGHS_HCINT7_NAK_M  (USB_OTGHS_HCINT7_NAK_V << USB_OTGHS_HCINT7_NAK_S)
#define USB_OTGHS_HCINT7_NAK_V  0x00000001U
#define USB_OTGHS_HCINT7_NAK_S  4
/** USB_OTGHS_HCINT7_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT7_ACK    (BIT(5))
#define USB_OTGHS_HCINT7_ACK_M  (USB_OTGHS_HCINT7_ACK_V << USB_OTGHS_HCINT7_ACK_S)
#define USB_OTGHS_HCINT7_ACK_V  0x00000001U
#define USB_OTGHS_HCINT7_ACK_S  5
/** USB_OTGHS_HCINT7_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT7_NYET    (BIT(6))
#define USB_OTGHS_HCINT7_NYET_M  (USB_OTGHS_HCINT7_NYET_V << USB_OTGHS_HCINT7_NYET_S)
#define USB_OTGHS_HCINT7_NYET_V  0x00000001U
#define USB_OTGHS_HCINT7_NYET_S  6
/** USB_OTGHS_HCINT7_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT7_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT7_XACTERR_M  (USB_OTGHS_HCINT7_XACTERR_V << USB_OTGHS_HCINT7_XACTERR_S)
#define USB_OTGHS_HCINT7_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT7_XACTERR_S  7
/** USB_OTGHS_HCINT7_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT7_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT7_BBLERR_M  (USB_OTGHS_HCINT7_BBLERR_V << USB_OTGHS_HCINT7_BBLERR_S)
#define USB_OTGHS_HCINT7_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT7_BBLERR_S  8
/** USB_OTGHS_HCINT7_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT7_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT7_FRMOVRUN_M  (USB_OTGHS_HCINT7_FRMOVRUN_V << USB_OTGHS_HCINT7_FRMOVRUN_S)
#define USB_OTGHS_HCINT7_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT7_FRMOVRUN_S  9
/** USB_OTGHS_HCINT7_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT7_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT7_DATATGLERR_M  (USB_OTGHS_HCINT7_DATATGLERR_V << USB_OTGHS_HCINT7_DATATGLERR_S)
#define USB_OTGHS_HCINT7_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT7_DATATGLERR_S  10
/** USB_OTGHS_HCINT7_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT7_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT7_BNAINTR_M  (USB_OTGHS_HCINT7_BNAINTR_V << USB_OTGHS_HCINT7_BNAINTR_S)
#define USB_OTGHS_HCINT7_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT7_BNAINTR_S  11
/** USB_OTGHS_HCINT7_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT7_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT7_XCS_XACT_ERR_M  (USB_OTGHS_HCINT7_XCS_XACT_ERR_V << USB_OTGHS_HCINT7_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT7_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT7_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT7_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT7_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT7_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT7_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT7_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT7_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT7_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK7_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK7_REG (DR_REG_USB_OTGHS_BASE + 0x5ec)
/** USB_OTGHS_HCINTMSK7_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK7_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK7_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK7_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK7_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK7_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK7_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK7_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK7_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK7_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK7_CHHLTDMSK_V << USB_OTGHS_HCINTMSK7_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK7_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK7_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK7_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK7_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK7_AHBERRMSK_M  (USB_OTGHS_HCINTMSK7_AHBERRMSK_V << USB_OTGHS_HCINTMSK7_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK7_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK7_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK7_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK7_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK7_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK7_BNAINTRMSK_V << USB_OTGHS_HCINTMSK7_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK7_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK7_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK7_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK7_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK7_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK7_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK7_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK7_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK7_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ7_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ7_REG (DR_REG_USB_OTGHS_BASE + 0x5f0)
/** USB_OTGHS_HCTSIZ7_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ7_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ7_XFERSIZE_M  (USB_OTGHS_HCTSIZ7_XFERSIZE_V << USB_OTGHS_HCTSIZ7_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ7_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ7_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ7_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ7_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ7_PKTCNT_M  (USB_OTGHS_HCTSIZ7_PKTCNT_V << USB_OTGHS_HCTSIZ7_PKTCNT_S)
#define USB_OTGHS_HCTSIZ7_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ7_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ7_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ7_PID    0x00000003U
#define USB_OTGHS_HCTSIZ7_PID_M  (USB_OTGHS_HCTSIZ7_PID_V << USB_OTGHS_HCTSIZ7_PID_S)
#define USB_OTGHS_HCTSIZ7_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ7_PID_S  29
/** USB_OTGHS_HCTSIZ7_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ7_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ7_DOPNG_M  (USB_OTGHS_HCTSIZ7_DOPNG_V << USB_OTGHS_HCTSIZ7_DOPNG_S)
#define USB_OTGHS_HCTSIZ7_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ7_DOPNG_S  31

/** USB_OTGHS_HCDMA7_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA7_REG (DR_REG_USB_OTGHS_BASE + 0x5f4)
/** USB_OTGHS_HCDMA7_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA7_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA7_DMAADDR_M  (USB_OTGHS_HCDMA7_DMAADDR_V << USB_OTGHS_HCDMA7_DMAADDR_S)
#define USB_OTGHS_HCDMA7_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA7_DMAADDR_S  0

/** USB_OTGHS_HCDMAB7_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB7_REG (DR_REG_USB_OTGHS_BASE + 0x5fc)
/** USB_OTGHS_HCDMAB7_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB7_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB7_HCDMAB_M  (USB_OTGHS_HCDMAB7_HCDMAB_V << USB_OTGHS_HCDMAB7_HCDMAB_S)
#define USB_OTGHS_HCDMAB7_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB7_HCDMAB_S  0

/** USB_OTGHS_HCCHAR8_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR8_REG (DR_REG_USB_OTGHS_BASE + 0x600)
/** USB_OTGHS_HCCHAR8_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR8_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR8_MPS_M  (USB_OTGHS_HCCHAR8_MPS_V << USB_OTGHS_HCCHAR8_MPS_S)
#define USB_OTGHS_HCCHAR8_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR8_MPS_S  0
/** USB_OTGHS_HCCHAR8_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR8_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR8_EPNUM_M  (USB_OTGHS_HCCHAR8_EPNUM_V << USB_OTGHS_HCCHAR8_EPNUM_S)
#define USB_OTGHS_HCCHAR8_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR8_EPNUM_S  11
/** USB_OTGHS_HCCHAR8_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR8_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR8_EPDIR_M  (USB_OTGHS_HCCHAR8_EPDIR_V << USB_OTGHS_HCCHAR8_EPDIR_S)
#define USB_OTGHS_HCCHAR8_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR8_EPDIR_S  15
/** USB_OTGHS_HCCHAR8_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR8_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR8_LSPDDEV_M  (USB_OTGHS_HCCHAR8_LSPDDEV_V << USB_OTGHS_HCCHAR8_LSPDDEV_S)
#define USB_OTGHS_HCCHAR8_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR8_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR8_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR8_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR8_EPTYPE_M  (USB_OTGHS_HCCHAR8_EPTYPE_V << USB_OTGHS_HCCHAR8_EPTYPE_S)
#define USB_OTGHS_HCCHAR8_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR8_EPTYPE_S  18
/** USB_OTGHS_HCCHAR8_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR8_EC    0x00000003U
#define USB_OTGHS_HCCHAR8_EC_M  (USB_OTGHS_HCCHAR8_EC_V << USB_OTGHS_HCCHAR8_EC_S)
#define USB_OTGHS_HCCHAR8_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR8_EC_S  20
/** USB_OTGHS_HCCHAR8_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR8_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR8_DEVADDR_M  (USB_OTGHS_HCCHAR8_DEVADDR_V << USB_OTGHS_HCCHAR8_DEVADDR_S)
#define USB_OTGHS_HCCHAR8_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR8_DEVADDR_S  22
/** USB_OTGHS_HCCHAR8_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR8_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR8_ODDFRM_M  (USB_OTGHS_HCCHAR8_ODDFRM_V << USB_OTGHS_HCCHAR8_ODDFRM_S)
#define USB_OTGHS_HCCHAR8_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR8_ODDFRM_S  29
/** USB_OTGHS_HCCHAR8_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR8_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR8_CHDIS_M  (USB_OTGHS_HCCHAR8_CHDIS_V << USB_OTGHS_HCCHAR8_CHDIS_S)
#define USB_OTGHS_HCCHAR8_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR8_CHDIS_S  30
/** USB_OTGHS_HCCHAR8_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR8_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR8_CHENA_M  (USB_OTGHS_HCCHAR8_CHENA_V << USB_OTGHS_HCCHAR8_CHENA_S)
#define USB_OTGHS_HCCHAR8_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR8_CHENA_S  31

/** USB_OTGHS_HCSPLT8_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT8_REG (DR_REG_USB_OTGHS_BASE + 0x604)
/** USB_OTGHS_HCSPLT8_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT8_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT8_PRTADDR_M  (USB_OTGHS_HCSPLT8_PRTADDR_V << USB_OTGHS_HCSPLT8_PRTADDR_S)
#define USB_OTGHS_HCSPLT8_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT8_PRTADDR_S  0
/** USB_OTGHS_HCSPLT8_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT8_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT8_HUBADDR_M  (USB_OTGHS_HCSPLT8_HUBADDR_V << USB_OTGHS_HCSPLT8_HUBADDR_S)
#define USB_OTGHS_HCSPLT8_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT8_HUBADDR_S  7
/** USB_OTGHS_HCSPLT8_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT8_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT8_XACTPOS_M  (USB_OTGHS_HCSPLT8_XACTPOS_V << USB_OTGHS_HCSPLT8_XACTPOS_S)
#define USB_OTGHS_HCSPLT8_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT8_XACTPOS_S  14
/** USB_OTGHS_HCSPLT8_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT8_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT8_COMPSPLT_M  (USB_OTGHS_HCSPLT8_COMPSPLT_V << USB_OTGHS_HCSPLT8_COMPSPLT_S)
#define USB_OTGHS_HCSPLT8_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT8_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT8_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT8_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT8_SPLTENA_M  (USB_OTGHS_HCSPLT8_SPLTENA_V << USB_OTGHS_HCSPLT8_SPLTENA_S)
#define USB_OTGHS_HCSPLT8_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT8_SPLTENA_S  31

/** USB_OTGHS_HCINT8_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT8_REG (DR_REG_USB_OTGHS_BASE + 0x608)
/** USB_OTGHS_HCINT8_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT8_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT8_XFERCOMPL_M  (USB_OTGHS_HCINT8_XFERCOMPL_V << USB_OTGHS_HCINT8_XFERCOMPL_S)
#define USB_OTGHS_HCINT8_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT8_XFERCOMPL_S  0
/** USB_OTGHS_HCINT8_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT8_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT8_CHHLTD_M  (USB_OTGHS_HCINT8_CHHLTD_V << USB_OTGHS_HCINT8_CHHLTD_S)
#define USB_OTGHS_HCINT8_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT8_CHHLTD_S  1
/** USB_OTGHS_HCINT8_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT8_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT8_AHBERR_M  (USB_OTGHS_HCINT8_AHBERR_V << USB_OTGHS_HCINT8_AHBERR_S)
#define USB_OTGHS_HCINT8_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT8_AHBERR_S  2
/** USB_OTGHS_HCINT8_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT8_STALL    (BIT(3))
#define USB_OTGHS_HCINT8_STALL_M  (USB_OTGHS_HCINT8_STALL_V << USB_OTGHS_HCINT8_STALL_S)
#define USB_OTGHS_HCINT8_STALL_V  0x00000001U
#define USB_OTGHS_HCINT8_STALL_S  3
/** USB_OTGHS_HCINT8_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT8_NAK    (BIT(4))
#define USB_OTGHS_HCINT8_NAK_M  (USB_OTGHS_HCINT8_NAK_V << USB_OTGHS_HCINT8_NAK_S)
#define USB_OTGHS_HCINT8_NAK_V  0x00000001U
#define USB_OTGHS_HCINT8_NAK_S  4
/** USB_OTGHS_HCINT8_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT8_ACK    (BIT(5))
#define USB_OTGHS_HCINT8_ACK_M  (USB_OTGHS_HCINT8_ACK_V << USB_OTGHS_HCINT8_ACK_S)
#define USB_OTGHS_HCINT8_ACK_V  0x00000001U
#define USB_OTGHS_HCINT8_ACK_S  5
/** USB_OTGHS_HCINT8_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT8_NYET    (BIT(6))
#define USB_OTGHS_HCINT8_NYET_M  (USB_OTGHS_HCINT8_NYET_V << USB_OTGHS_HCINT8_NYET_S)
#define USB_OTGHS_HCINT8_NYET_V  0x00000001U
#define USB_OTGHS_HCINT8_NYET_S  6
/** USB_OTGHS_HCINT8_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT8_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT8_XACTERR_M  (USB_OTGHS_HCINT8_XACTERR_V << USB_OTGHS_HCINT8_XACTERR_S)
#define USB_OTGHS_HCINT8_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT8_XACTERR_S  7
/** USB_OTGHS_HCINT8_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT8_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT8_BBLERR_M  (USB_OTGHS_HCINT8_BBLERR_V << USB_OTGHS_HCINT8_BBLERR_S)
#define USB_OTGHS_HCINT8_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT8_BBLERR_S  8
/** USB_OTGHS_HCINT8_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT8_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT8_FRMOVRUN_M  (USB_OTGHS_HCINT8_FRMOVRUN_V << USB_OTGHS_HCINT8_FRMOVRUN_S)
#define USB_OTGHS_HCINT8_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT8_FRMOVRUN_S  9
/** USB_OTGHS_HCINT8_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT8_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT8_DATATGLERR_M  (USB_OTGHS_HCINT8_DATATGLERR_V << USB_OTGHS_HCINT8_DATATGLERR_S)
#define USB_OTGHS_HCINT8_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT8_DATATGLERR_S  10
/** USB_OTGHS_HCINT8_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT8_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT8_BNAINTR_M  (USB_OTGHS_HCINT8_BNAINTR_V << USB_OTGHS_HCINT8_BNAINTR_S)
#define USB_OTGHS_HCINT8_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT8_BNAINTR_S  11
/** USB_OTGHS_HCINT8_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT8_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT8_XCS_XACT_ERR_M  (USB_OTGHS_HCINT8_XCS_XACT_ERR_V << USB_OTGHS_HCINT8_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT8_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT8_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT8_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT8_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT8_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT8_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT8_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT8_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT8_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK8_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK8_REG (DR_REG_USB_OTGHS_BASE + 0x60c)
/** USB_OTGHS_HCINTMSK8_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK8_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK8_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK8_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK8_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK8_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK8_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK8_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK8_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK8_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK8_CHHLTDMSK_V << USB_OTGHS_HCINTMSK8_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK8_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK8_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK8_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK8_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK8_AHBERRMSK_M  (USB_OTGHS_HCINTMSK8_AHBERRMSK_V << USB_OTGHS_HCINTMSK8_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK8_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK8_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK8_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK8_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK8_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK8_BNAINTRMSK_V << USB_OTGHS_HCINTMSK8_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK8_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK8_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK8_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK8_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK8_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK8_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK8_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK8_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK8_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ8_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ8_REG (DR_REG_USB_OTGHS_BASE + 0x610)
/** USB_OTGHS_HCTSIZ8_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ8_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ8_XFERSIZE_M  (USB_OTGHS_HCTSIZ8_XFERSIZE_V << USB_OTGHS_HCTSIZ8_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ8_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ8_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ8_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ8_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ8_PKTCNT_M  (USB_OTGHS_HCTSIZ8_PKTCNT_V << USB_OTGHS_HCTSIZ8_PKTCNT_S)
#define USB_OTGHS_HCTSIZ8_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ8_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ8_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ8_PID    0x00000003U
#define USB_OTGHS_HCTSIZ8_PID_M  (USB_OTGHS_HCTSIZ8_PID_V << USB_OTGHS_HCTSIZ8_PID_S)
#define USB_OTGHS_HCTSIZ8_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ8_PID_S  29
/** USB_OTGHS_HCTSIZ8_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ8_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ8_DOPNG_M  (USB_OTGHS_HCTSIZ8_DOPNG_V << USB_OTGHS_HCTSIZ8_DOPNG_S)
#define USB_OTGHS_HCTSIZ8_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ8_DOPNG_S  31

/** USB_OTGHS_HCDMA8_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA8_REG (DR_REG_USB_OTGHS_BASE + 0x614)
/** USB_OTGHS_HCDMA8_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA8_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA8_DMAADDR_M  (USB_OTGHS_HCDMA8_DMAADDR_V << USB_OTGHS_HCDMA8_DMAADDR_S)
#define USB_OTGHS_HCDMA8_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA8_DMAADDR_S  0

/** USB_OTGHS_HCDMAB8_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB8_REG (DR_REG_USB_OTGHS_BASE + 0x61c)
/** USB_OTGHS_HCDMAB8_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB8_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB8_HCDMAB_M  (USB_OTGHS_HCDMAB8_HCDMAB_V << USB_OTGHS_HCDMAB8_HCDMAB_S)
#define USB_OTGHS_HCDMAB8_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB8_HCDMAB_S  0

/** USB_OTGHS_HCCHAR9_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR9_REG (DR_REG_USB_OTGHS_BASE + 0x620)
/** USB_OTGHS_HCCHAR9_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR9_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR9_MPS_M  (USB_OTGHS_HCCHAR9_MPS_V << USB_OTGHS_HCCHAR9_MPS_S)
#define USB_OTGHS_HCCHAR9_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR9_MPS_S  0
/** USB_OTGHS_HCCHAR9_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR9_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR9_EPNUM_M  (USB_OTGHS_HCCHAR9_EPNUM_V << USB_OTGHS_HCCHAR9_EPNUM_S)
#define USB_OTGHS_HCCHAR9_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR9_EPNUM_S  11
/** USB_OTGHS_HCCHAR9_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR9_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR9_EPDIR_M  (USB_OTGHS_HCCHAR9_EPDIR_V << USB_OTGHS_HCCHAR9_EPDIR_S)
#define USB_OTGHS_HCCHAR9_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR9_EPDIR_S  15
/** USB_OTGHS_HCCHAR9_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR9_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR9_LSPDDEV_M  (USB_OTGHS_HCCHAR9_LSPDDEV_V << USB_OTGHS_HCCHAR9_LSPDDEV_S)
#define USB_OTGHS_HCCHAR9_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR9_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR9_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR9_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR9_EPTYPE_M  (USB_OTGHS_HCCHAR9_EPTYPE_V << USB_OTGHS_HCCHAR9_EPTYPE_S)
#define USB_OTGHS_HCCHAR9_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR9_EPTYPE_S  18
/** USB_OTGHS_HCCHAR9_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR9_EC    0x00000003U
#define USB_OTGHS_HCCHAR9_EC_M  (USB_OTGHS_HCCHAR9_EC_V << USB_OTGHS_HCCHAR9_EC_S)
#define USB_OTGHS_HCCHAR9_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR9_EC_S  20
/** USB_OTGHS_HCCHAR9_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR9_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR9_DEVADDR_M  (USB_OTGHS_HCCHAR9_DEVADDR_V << USB_OTGHS_HCCHAR9_DEVADDR_S)
#define USB_OTGHS_HCCHAR9_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR9_DEVADDR_S  22
/** USB_OTGHS_HCCHAR9_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR9_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR9_ODDFRM_M  (USB_OTGHS_HCCHAR9_ODDFRM_V << USB_OTGHS_HCCHAR9_ODDFRM_S)
#define USB_OTGHS_HCCHAR9_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR9_ODDFRM_S  29
/** USB_OTGHS_HCCHAR9_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR9_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR9_CHDIS_M  (USB_OTGHS_HCCHAR9_CHDIS_V << USB_OTGHS_HCCHAR9_CHDIS_S)
#define USB_OTGHS_HCCHAR9_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR9_CHDIS_S  30
/** USB_OTGHS_HCCHAR9_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR9_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR9_CHENA_M  (USB_OTGHS_HCCHAR9_CHENA_V << USB_OTGHS_HCCHAR9_CHENA_S)
#define USB_OTGHS_HCCHAR9_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR9_CHENA_S  31

/** USB_OTGHS_HCSPLT9_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT9_REG (DR_REG_USB_OTGHS_BASE + 0x624)
/** USB_OTGHS_HCSPLT9_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT9_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT9_PRTADDR_M  (USB_OTGHS_HCSPLT9_PRTADDR_V << USB_OTGHS_HCSPLT9_PRTADDR_S)
#define USB_OTGHS_HCSPLT9_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT9_PRTADDR_S  0
/** USB_OTGHS_HCSPLT9_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT9_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT9_HUBADDR_M  (USB_OTGHS_HCSPLT9_HUBADDR_V << USB_OTGHS_HCSPLT9_HUBADDR_S)
#define USB_OTGHS_HCSPLT9_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT9_HUBADDR_S  7
/** USB_OTGHS_HCSPLT9_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT9_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT9_XACTPOS_M  (USB_OTGHS_HCSPLT9_XACTPOS_V << USB_OTGHS_HCSPLT9_XACTPOS_S)
#define USB_OTGHS_HCSPLT9_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT9_XACTPOS_S  14
/** USB_OTGHS_HCSPLT9_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT9_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT9_COMPSPLT_M  (USB_OTGHS_HCSPLT9_COMPSPLT_V << USB_OTGHS_HCSPLT9_COMPSPLT_S)
#define USB_OTGHS_HCSPLT9_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT9_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT9_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT9_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT9_SPLTENA_M  (USB_OTGHS_HCSPLT9_SPLTENA_V << USB_OTGHS_HCSPLT9_SPLTENA_S)
#define USB_OTGHS_HCSPLT9_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT9_SPLTENA_S  31

/** USB_OTGHS_HCINT9_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT9_REG (DR_REG_USB_OTGHS_BASE + 0x628)
/** USB_OTGHS_HCINT9_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT9_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT9_XFERCOMPL_M  (USB_OTGHS_HCINT9_XFERCOMPL_V << USB_OTGHS_HCINT9_XFERCOMPL_S)
#define USB_OTGHS_HCINT9_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT9_XFERCOMPL_S  0
/** USB_OTGHS_HCINT9_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT9_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT9_CHHLTD_M  (USB_OTGHS_HCINT9_CHHLTD_V << USB_OTGHS_HCINT9_CHHLTD_S)
#define USB_OTGHS_HCINT9_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT9_CHHLTD_S  1
/** USB_OTGHS_HCINT9_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT9_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT9_AHBERR_M  (USB_OTGHS_HCINT9_AHBERR_V << USB_OTGHS_HCINT9_AHBERR_S)
#define USB_OTGHS_HCINT9_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT9_AHBERR_S  2
/** USB_OTGHS_HCINT9_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT9_STALL    (BIT(3))
#define USB_OTGHS_HCINT9_STALL_M  (USB_OTGHS_HCINT9_STALL_V << USB_OTGHS_HCINT9_STALL_S)
#define USB_OTGHS_HCINT9_STALL_V  0x00000001U
#define USB_OTGHS_HCINT9_STALL_S  3
/** USB_OTGHS_HCINT9_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT9_NAK    (BIT(4))
#define USB_OTGHS_HCINT9_NAK_M  (USB_OTGHS_HCINT9_NAK_V << USB_OTGHS_HCINT9_NAK_S)
#define USB_OTGHS_HCINT9_NAK_V  0x00000001U
#define USB_OTGHS_HCINT9_NAK_S  4
/** USB_OTGHS_HCINT9_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT9_ACK    (BIT(5))
#define USB_OTGHS_HCINT9_ACK_M  (USB_OTGHS_HCINT9_ACK_V << USB_OTGHS_HCINT9_ACK_S)
#define USB_OTGHS_HCINT9_ACK_V  0x00000001U
#define USB_OTGHS_HCINT9_ACK_S  5
/** USB_OTGHS_HCINT9_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT9_NYET    (BIT(6))
#define USB_OTGHS_HCINT9_NYET_M  (USB_OTGHS_HCINT9_NYET_V << USB_OTGHS_HCINT9_NYET_S)
#define USB_OTGHS_HCINT9_NYET_V  0x00000001U
#define USB_OTGHS_HCINT9_NYET_S  6
/** USB_OTGHS_HCINT9_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT9_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT9_XACTERR_M  (USB_OTGHS_HCINT9_XACTERR_V << USB_OTGHS_HCINT9_XACTERR_S)
#define USB_OTGHS_HCINT9_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT9_XACTERR_S  7
/** USB_OTGHS_HCINT9_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT9_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT9_BBLERR_M  (USB_OTGHS_HCINT9_BBLERR_V << USB_OTGHS_HCINT9_BBLERR_S)
#define USB_OTGHS_HCINT9_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT9_BBLERR_S  8
/** USB_OTGHS_HCINT9_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT9_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT9_FRMOVRUN_M  (USB_OTGHS_HCINT9_FRMOVRUN_V << USB_OTGHS_HCINT9_FRMOVRUN_S)
#define USB_OTGHS_HCINT9_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT9_FRMOVRUN_S  9
/** USB_OTGHS_HCINT9_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT9_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT9_DATATGLERR_M  (USB_OTGHS_HCINT9_DATATGLERR_V << USB_OTGHS_HCINT9_DATATGLERR_S)
#define USB_OTGHS_HCINT9_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT9_DATATGLERR_S  10
/** USB_OTGHS_HCINT9_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT9_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT9_BNAINTR_M  (USB_OTGHS_HCINT9_BNAINTR_V << USB_OTGHS_HCINT9_BNAINTR_S)
#define USB_OTGHS_HCINT9_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT9_BNAINTR_S  11
/** USB_OTGHS_HCINT9_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT9_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT9_XCS_XACT_ERR_M  (USB_OTGHS_HCINT9_XCS_XACT_ERR_V << USB_OTGHS_HCINT9_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT9_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT9_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT9_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT9_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT9_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT9_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT9_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT9_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT9_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK9_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK9_REG (DR_REG_USB_OTGHS_BASE + 0x62c)
/** USB_OTGHS_HCINTMSK9_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK9_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK9_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK9_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK9_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK9_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK9_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK9_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK9_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK9_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK9_CHHLTDMSK_V << USB_OTGHS_HCINTMSK9_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK9_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK9_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK9_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK9_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK9_AHBERRMSK_M  (USB_OTGHS_HCINTMSK9_AHBERRMSK_V << USB_OTGHS_HCINTMSK9_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK9_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK9_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK9_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK9_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK9_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK9_BNAINTRMSK_V << USB_OTGHS_HCINTMSK9_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK9_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK9_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK9_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK9_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK9_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK9_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK9_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK9_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK9_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ9_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ9_REG (DR_REG_USB_OTGHS_BASE + 0x630)
/** USB_OTGHS_HCTSIZ9_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ9_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ9_XFERSIZE_M  (USB_OTGHS_HCTSIZ9_XFERSIZE_V << USB_OTGHS_HCTSIZ9_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ9_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ9_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ9_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ9_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ9_PKTCNT_M  (USB_OTGHS_HCTSIZ9_PKTCNT_V << USB_OTGHS_HCTSIZ9_PKTCNT_S)
#define USB_OTGHS_HCTSIZ9_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ9_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ9_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ9_PID    0x00000003U
#define USB_OTGHS_HCTSIZ9_PID_M  (USB_OTGHS_HCTSIZ9_PID_V << USB_OTGHS_HCTSIZ9_PID_S)
#define USB_OTGHS_HCTSIZ9_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ9_PID_S  29
/** USB_OTGHS_HCTSIZ9_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ9_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ9_DOPNG_M  (USB_OTGHS_HCTSIZ9_DOPNG_V << USB_OTGHS_HCTSIZ9_DOPNG_S)
#define USB_OTGHS_HCTSIZ9_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ9_DOPNG_S  31

/** USB_OTGHS_HCDMA9_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA9_REG (DR_REG_USB_OTGHS_BASE + 0x634)
/** USB_OTGHS_HCDMA9_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA9_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA9_DMAADDR_M  (USB_OTGHS_HCDMA9_DMAADDR_V << USB_OTGHS_HCDMA9_DMAADDR_S)
#define USB_OTGHS_HCDMA9_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA9_DMAADDR_S  0

/** USB_OTGHS_HCDMAB9_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB9_REG (DR_REG_USB_OTGHS_BASE + 0x63c)
/** USB_OTGHS_HCDMAB9_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB9_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB9_HCDMAB_M  (USB_OTGHS_HCDMAB9_HCDMAB_V << USB_OTGHS_HCDMAB9_HCDMAB_S)
#define USB_OTGHS_HCDMAB9_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB9_HCDMAB_S  0

/** USB_OTGHS_HCCHAR10_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR10_REG (DR_REG_USB_OTGHS_BASE + 0x640)
/** USB_OTGHS_HCCHAR10_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR10_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR10_MPS_M  (USB_OTGHS_HCCHAR10_MPS_V << USB_OTGHS_HCCHAR10_MPS_S)
#define USB_OTGHS_HCCHAR10_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR10_MPS_S  0
/** USB_OTGHS_HCCHAR10_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR10_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR10_EPNUM_M  (USB_OTGHS_HCCHAR10_EPNUM_V << USB_OTGHS_HCCHAR10_EPNUM_S)
#define USB_OTGHS_HCCHAR10_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR10_EPNUM_S  11
/** USB_OTGHS_HCCHAR10_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR10_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR10_EPDIR_M  (USB_OTGHS_HCCHAR10_EPDIR_V << USB_OTGHS_HCCHAR10_EPDIR_S)
#define USB_OTGHS_HCCHAR10_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR10_EPDIR_S  15
/** USB_OTGHS_HCCHAR10_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR10_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR10_LSPDDEV_M  (USB_OTGHS_HCCHAR10_LSPDDEV_V << USB_OTGHS_HCCHAR10_LSPDDEV_S)
#define USB_OTGHS_HCCHAR10_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR10_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR10_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR10_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR10_EPTYPE_M  (USB_OTGHS_HCCHAR10_EPTYPE_V << USB_OTGHS_HCCHAR10_EPTYPE_S)
#define USB_OTGHS_HCCHAR10_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR10_EPTYPE_S  18
/** USB_OTGHS_HCCHAR10_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR10_EC    0x00000003U
#define USB_OTGHS_HCCHAR10_EC_M  (USB_OTGHS_HCCHAR10_EC_V << USB_OTGHS_HCCHAR10_EC_S)
#define USB_OTGHS_HCCHAR10_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR10_EC_S  20
/** USB_OTGHS_HCCHAR10_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR10_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR10_DEVADDR_M  (USB_OTGHS_HCCHAR10_DEVADDR_V << USB_OTGHS_HCCHAR10_DEVADDR_S)
#define USB_OTGHS_HCCHAR10_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR10_DEVADDR_S  22
/** USB_OTGHS_HCCHAR10_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR10_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR10_ODDFRM_M  (USB_OTGHS_HCCHAR10_ODDFRM_V << USB_OTGHS_HCCHAR10_ODDFRM_S)
#define USB_OTGHS_HCCHAR10_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR10_ODDFRM_S  29
/** USB_OTGHS_HCCHAR10_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR10_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR10_CHDIS_M  (USB_OTGHS_HCCHAR10_CHDIS_V << USB_OTGHS_HCCHAR10_CHDIS_S)
#define USB_OTGHS_HCCHAR10_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR10_CHDIS_S  30
/** USB_OTGHS_HCCHAR10_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR10_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR10_CHENA_M  (USB_OTGHS_HCCHAR10_CHENA_V << USB_OTGHS_HCCHAR10_CHENA_S)
#define USB_OTGHS_HCCHAR10_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR10_CHENA_S  31

/** USB_OTGHS_HCSPLT10_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT10_REG (DR_REG_USB_OTGHS_BASE + 0x644)
/** USB_OTGHS_HCSPLT10_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT10_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT10_PRTADDR_M  (USB_OTGHS_HCSPLT10_PRTADDR_V << USB_OTGHS_HCSPLT10_PRTADDR_S)
#define USB_OTGHS_HCSPLT10_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT10_PRTADDR_S  0
/** USB_OTGHS_HCSPLT10_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT10_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT10_HUBADDR_M  (USB_OTGHS_HCSPLT10_HUBADDR_V << USB_OTGHS_HCSPLT10_HUBADDR_S)
#define USB_OTGHS_HCSPLT10_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT10_HUBADDR_S  7
/** USB_OTGHS_HCSPLT10_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT10_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT10_XACTPOS_M  (USB_OTGHS_HCSPLT10_XACTPOS_V << USB_OTGHS_HCSPLT10_XACTPOS_S)
#define USB_OTGHS_HCSPLT10_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT10_XACTPOS_S  14
/** USB_OTGHS_HCSPLT10_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT10_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT10_COMPSPLT_M  (USB_OTGHS_HCSPLT10_COMPSPLT_V << USB_OTGHS_HCSPLT10_COMPSPLT_S)
#define USB_OTGHS_HCSPLT10_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT10_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT10_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT10_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT10_SPLTENA_M  (USB_OTGHS_HCSPLT10_SPLTENA_V << USB_OTGHS_HCSPLT10_SPLTENA_S)
#define USB_OTGHS_HCSPLT10_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT10_SPLTENA_S  31

/** USB_OTGHS_HCINT10_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT10_REG (DR_REG_USB_OTGHS_BASE + 0x648)
/** USB_OTGHS_HCINT10_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT10_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT10_XFERCOMPL_M  (USB_OTGHS_HCINT10_XFERCOMPL_V << USB_OTGHS_HCINT10_XFERCOMPL_S)
#define USB_OTGHS_HCINT10_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT10_XFERCOMPL_S  0
/** USB_OTGHS_HCINT10_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT10_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT10_CHHLTD_M  (USB_OTGHS_HCINT10_CHHLTD_V << USB_OTGHS_HCINT10_CHHLTD_S)
#define USB_OTGHS_HCINT10_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT10_CHHLTD_S  1
/** USB_OTGHS_HCINT10_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT10_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT10_AHBERR_M  (USB_OTGHS_HCINT10_AHBERR_V << USB_OTGHS_HCINT10_AHBERR_S)
#define USB_OTGHS_HCINT10_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT10_AHBERR_S  2
/** USB_OTGHS_HCINT10_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT10_STALL    (BIT(3))
#define USB_OTGHS_HCINT10_STALL_M  (USB_OTGHS_HCINT10_STALL_V << USB_OTGHS_HCINT10_STALL_S)
#define USB_OTGHS_HCINT10_STALL_V  0x00000001U
#define USB_OTGHS_HCINT10_STALL_S  3
/** USB_OTGHS_HCINT10_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT10_NAK    (BIT(4))
#define USB_OTGHS_HCINT10_NAK_M  (USB_OTGHS_HCINT10_NAK_V << USB_OTGHS_HCINT10_NAK_S)
#define USB_OTGHS_HCINT10_NAK_V  0x00000001U
#define USB_OTGHS_HCINT10_NAK_S  4
/** USB_OTGHS_HCINT10_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT10_ACK    (BIT(5))
#define USB_OTGHS_HCINT10_ACK_M  (USB_OTGHS_HCINT10_ACK_V << USB_OTGHS_HCINT10_ACK_S)
#define USB_OTGHS_HCINT10_ACK_V  0x00000001U
#define USB_OTGHS_HCINT10_ACK_S  5
/** USB_OTGHS_HCINT10_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT10_NYET    (BIT(6))
#define USB_OTGHS_HCINT10_NYET_M  (USB_OTGHS_HCINT10_NYET_V << USB_OTGHS_HCINT10_NYET_S)
#define USB_OTGHS_HCINT10_NYET_V  0x00000001U
#define USB_OTGHS_HCINT10_NYET_S  6
/** USB_OTGHS_HCINT10_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT10_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT10_XACTERR_M  (USB_OTGHS_HCINT10_XACTERR_V << USB_OTGHS_HCINT10_XACTERR_S)
#define USB_OTGHS_HCINT10_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT10_XACTERR_S  7
/** USB_OTGHS_HCINT10_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT10_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT10_BBLERR_M  (USB_OTGHS_HCINT10_BBLERR_V << USB_OTGHS_HCINT10_BBLERR_S)
#define USB_OTGHS_HCINT10_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT10_BBLERR_S  8
/** USB_OTGHS_HCINT10_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT10_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT10_FRMOVRUN_M  (USB_OTGHS_HCINT10_FRMOVRUN_V << USB_OTGHS_HCINT10_FRMOVRUN_S)
#define USB_OTGHS_HCINT10_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT10_FRMOVRUN_S  9
/** USB_OTGHS_HCINT10_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT10_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT10_DATATGLERR_M  (USB_OTGHS_HCINT10_DATATGLERR_V << USB_OTGHS_HCINT10_DATATGLERR_S)
#define USB_OTGHS_HCINT10_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT10_DATATGLERR_S  10
/** USB_OTGHS_HCINT10_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT10_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT10_BNAINTR_M  (USB_OTGHS_HCINT10_BNAINTR_V << USB_OTGHS_HCINT10_BNAINTR_S)
#define USB_OTGHS_HCINT10_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT10_BNAINTR_S  11
/** USB_OTGHS_HCINT10_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT10_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT10_XCS_XACT_ERR_M  (USB_OTGHS_HCINT10_XCS_XACT_ERR_V << USB_OTGHS_HCINT10_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT10_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT10_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT10_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT10_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT10_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT10_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT10_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT10_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT10_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK10_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK10_REG (DR_REG_USB_OTGHS_BASE + 0x64c)
/** USB_OTGHS_HCINTMSK10_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK10_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK10_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK10_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK10_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK10_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK10_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK10_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK10_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK10_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK10_CHHLTDMSK_V << USB_OTGHS_HCINTMSK10_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK10_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK10_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK10_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK10_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK10_AHBERRMSK_M  (USB_OTGHS_HCINTMSK10_AHBERRMSK_V << USB_OTGHS_HCINTMSK10_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK10_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK10_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK10_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK10_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK10_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK10_BNAINTRMSK_V << USB_OTGHS_HCINTMSK10_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK10_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK10_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK10_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK10_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK10_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK10_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK10_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK10_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK10_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ10_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ10_REG (DR_REG_USB_OTGHS_BASE + 0x650)
/** USB_OTGHS_HCTSIZ10_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ10_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ10_XFERSIZE_M  (USB_OTGHS_HCTSIZ10_XFERSIZE_V << USB_OTGHS_HCTSIZ10_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ10_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ10_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ10_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ10_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ10_PKTCNT_M  (USB_OTGHS_HCTSIZ10_PKTCNT_V << USB_OTGHS_HCTSIZ10_PKTCNT_S)
#define USB_OTGHS_HCTSIZ10_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ10_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ10_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ10_PID    0x00000003U
#define USB_OTGHS_HCTSIZ10_PID_M  (USB_OTGHS_HCTSIZ10_PID_V << USB_OTGHS_HCTSIZ10_PID_S)
#define USB_OTGHS_HCTSIZ10_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ10_PID_S  29
/** USB_OTGHS_HCTSIZ10_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ10_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ10_DOPNG_M  (USB_OTGHS_HCTSIZ10_DOPNG_V << USB_OTGHS_HCTSIZ10_DOPNG_S)
#define USB_OTGHS_HCTSIZ10_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ10_DOPNG_S  31

/** USB_OTGHS_HCDMA10_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA10_REG (DR_REG_USB_OTGHS_BASE + 0x654)
/** USB_OTGHS_HCDMA10_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA10_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA10_DMAADDR_M  (USB_OTGHS_HCDMA10_DMAADDR_V << USB_OTGHS_HCDMA10_DMAADDR_S)
#define USB_OTGHS_HCDMA10_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA10_DMAADDR_S  0

/** USB_OTGHS_HCDMAB10_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB10_REG (DR_REG_USB_OTGHS_BASE + 0x65c)
/** USB_OTGHS_HCDMAB10_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB10_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB10_HCDMAB_M  (USB_OTGHS_HCDMAB10_HCDMAB_V << USB_OTGHS_HCDMAB10_HCDMAB_S)
#define USB_OTGHS_HCDMAB10_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB10_HCDMAB_S  0

/** USB_OTGHS_HCCHAR11_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR11_REG (DR_REG_USB_OTGHS_BASE + 0x660)
/** USB_OTGHS_HCCHAR11_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR11_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR11_MPS_M  (USB_OTGHS_HCCHAR11_MPS_V << USB_OTGHS_HCCHAR11_MPS_S)
#define USB_OTGHS_HCCHAR11_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR11_MPS_S  0
/** USB_OTGHS_HCCHAR11_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR11_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR11_EPNUM_M  (USB_OTGHS_HCCHAR11_EPNUM_V << USB_OTGHS_HCCHAR11_EPNUM_S)
#define USB_OTGHS_HCCHAR11_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR11_EPNUM_S  11
/** USB_OTGHS_HCCHAR11_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR11_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR11_EPDIR_M  (USB_OTGHS_HCCHAR11_EPDIR_V << USB_OTGHS_HCCHAR11_EPDIR_S)
#define USB_OTGHS_HCCHAR11_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR11_EPDIR_S  15
/** USB_OTGHS_HCCHAR11_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR11_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR11_LSPDDEV_M  (USB_OTGHS_HCCHAR11_LSPDDEV_V << USB_OTGHS_HCCHAR11_LSPDDEV_S)
#define USB_OTGHS_HCCHAR11_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR11_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR11_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR11_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR11_EPTYPE_M  (USB_OTGHS_HCCHAR11_EPTYPE_V << USB_OTGHS_HCCHAR11_EPTYPE_S)
#define USB_OTGHS_HCCHAR11_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR11_EPTYPE_S  18
/** USB_OTGHS_HCCHAR11_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR11_EC    0x00000003U
#define USB_OTGHS_HCCHAR11_EC_M  (USB_OTGHS_HCCHAR11_EC_V << USB_OTGHS_HCCHAR11_EC_S)
#define USB_OTGHS_HCCHAR11_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR11_EC_S  20
/** USB_OTGHS_HCCHAR11_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR11_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR11_DEVADDR_M  (USB_OTGHS_HCCHAR11_DEVADDR_V << USB_OTGHS_HCCHAR11_DEVADDR_S)
#define USB_OTGHS_HCCHAR11_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR11_DEVADDR_S  22
/** USB_OTGHS_HCCHAR11_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR11_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR11_ODDFRM_M  (USB_OTGHS_HCCHAR11_ODDFRM_V << USB_OTGHS_HCCHAR11_ODDFRM_S)
#define USB_OTGHS_HCCHAR11_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR11_ODDFRM_S  29
/** USB_OTGHS_HCCHAR11_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR11_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR11_CHDIS_M  (USB_OTGHS_HCCHAR11_CHDIS_V << USB_OTGHS_HCCHAR11_CHDIS_S)
#define USB_OTGHS_HCCHAR11_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR11_CHDIS_S  30
/** USB_OTGHS_HCCHAR11_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR11_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR11_CHENA_M  (USB_OTGHS_HCCHAR11_CHENA_V << USB_OTGHS_HCCHAR11_CHENA_S)
#define USB_OTGHS_HCCHAR11_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR11_CHENA_S  31

/** USB_OTGHS_HCSPLT11_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT11_REG (DR_REG_USB_OTGHS_BASE + 0x664)
/** USB_OTGHS_HCSPLT11_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT11_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT11_PRTADDR_M  (USB_OTGHS_HCSPLT11_PRTADDR_V << USB_OTGHS_HCSPLT11_PRTADDR_S)
#define USB_OTGHS_HCSPLT11_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT11_PRTADDR_S  0
/** USB_OTGHS_HCSPLT11_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT11_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT11_HUBADDR_M  (USB_OTGHS_HCSPLT11_HUBADDR_V << USB_OTGHS_HCSPLT11_HUBADDR_S)
#define USB_OTGHS_HCSPLT11_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT11_HUBADDR_S  7
/** USB_OTGHS_HCSPLT11_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT11_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT11_XACTPOS_M  (USB_OTGHS_HCSPLT11_XACTPOS_V << USB_OTGHS_HCSPLT11_XACTPOS_S)
#define USB_OTGHS_HCSPLT11_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT11_XACTPOS_S  14
/** USB_OTGHS_HCSPLT11_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT11_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT11_COMPSPLT_M  (USB_OTGHS_HCSPLT11_COMPSPLT_V << USB_OTGHS_HCSPLT11_COMPSPLT_S)
#define USB_OTGHS_HCSPLT11_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT11_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT11_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT11_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT11_SPLTENA_M  (USB_OTGHS_HCSPLT11_SPLTENA_V << USB_OTGHS_HCSPLT11_SPLTENA_S)
#define USB_OTGHS_HCSPLT11_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT11_SPLTENA_S  31

/** USB_OTGHS_HCINT11_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT11_REG (DR_REG_USB_OTGHS_BASE + 0x668)
/** USB_OTGHS_HCINT11_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT11_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT11_XFERCOMPL_M  (USB_OTGHS_HCINT11_XFERCOMPL_V << USB_OTGHS_HCINT11_XFERCOMPL_S)
#define USB_OTGHS_HCINT11_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT11_XFERCOMPL_S  0
/** USB_OTGHS_HCINT11_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT11_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT11_CHHLTD_M  (USB_OTGHS_HCINT11_CHHLTD_V << USB_OTGHS_HCINT11_CHHLTD_S)
#define USB_OTGHS_HCINT11_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT11_CHHLTD_S  1
/** USB_OTGHS_HCINT11_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT11_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT11_AHBERR_M  (USB_OTGHS_HCINT11_AHBERR_V << USB_OTGHS_HCINT11_AHBERR_S)
#define USB_OTGHS_HCINT11_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT11_AHBERR_S  2
/** USB_OTGHS_HCINT11_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT11_STALL    (BIT(3))
#define USB_OTGHS_HCINT11_STALL_M  (USB_OTGHS_HCINT11_STALL_V << USB_OTGHS_HCINT11_STALL_S)
#define USB_OTGHS_HCINT11_STALL_V  0x00000001U
#define USB_OTGHS_HCINT11_STALL_S  3
/** USB_OTGHS_HCINT11_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT11_NAK    (BIT(4))
#define USB_OTGHS_HCINT11_NAK_M  (USB_OTGHS_HCINT11_NAK_V << USB_OTGHS_HCINT11_NAK_S)
#define USB_OTGHS_HCINT11_NAK_V  0x00000001U
#define USB_OTGHS_HCINT11_NAK_S  4
/** USB_OTGHS_HCINT11_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT11_ACK    (BIT(5))
#define USB_OTGHS_HCINT11_ACK_M  (USB_OTGHS_HCINT11_ACK_V << USB_OTGHS_HCINT11_ACK_S)
#define USB_OTGHS_HCINT11_ACK_V  0x00000001U
#define USB_OTGHS_HCINT11_ACK_S  5
/** USB_OTGHS_HCINT11_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT11_NYET    (BIT(6))
#define USB_OTGHS_HCINT11_NYET_M  (USB_OTGHS_HCINT11_NYET_V << USB_OTGHS_HCINT11_NYET_S)
#define USB_OTGHS_HCINT11_NYET_V  0x00000001U
#define USB_OTGHS_HCINT11_NYET_S  6
/** USB_OTGHS_HCINT11_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT11_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT11_XACTERR_M  (USB_OTGHS_HCINT11_XACTERR_V << USB_OTGHS_HCINT11_XACTERR_S)
#define USB_OTGHS_HCINT11_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT11_XACTERR_S  7
/** USB_OTGHS_HCINT11_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT11_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT11_BBLERR_M  (USB_OTGHS_HCINT11_BBLERR_V << USB_OTGHS_HCINT11_BBLERR_S)
#define USB_OTGHS_HCINT11_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT11_BBLERR_S  8
/** USB_OTGHS_HCINT11_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT11_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT11_FRMOVRUN_M  (USB_OTGHS_HCINT11_FRMOVRUN_V << USB_OTGHS_HCINT11_FRMOVRUN_S)
#define USB_OTGHS_HCINT11_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT11_FRMOVRUN_S  9
/** USB_OTGHS_HCINT11_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT11_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT11_DATATGLERR_M  (USB_OTGHS_HCINT11_DATATGLERR_V << USB_OTGHS_HCINT11_DATATGLERR_S)
#define USB_OTGHS_HCINT11_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT11_DATATGLERR_S  10
/** USB_OTGHS_HCINT11_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT11_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT11_BNAINTR_M  (USB_OTGHS_HCINT11_BNAINTR_V << USB_OTGHS_HCINT11_BNAINTR_S)
#define USB_OTGHS_HCINT11_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT11_BNAINTR_S  11
/** USB_OTGHS_HCINT11_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT11_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT11_XCS_XACT_ERR_M  (USB_OTGHS_HCINT11_XCS_XACT_ERR_V << USB_OTGHS_HCINT11_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT11_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT11_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT11_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT11_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT11_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT11_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT11_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT11_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT11_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK11_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK11_REG (DR_REG_USB_OTGHS_BASE + 0x66c)
/** USB_OTGHS_HCINTMSK11_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK11_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK11_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK11_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK11_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK11_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK11_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK11_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK11_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK11_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK11_CHHLTDMSK_V << USB_OTGHS_HCINTMSK11_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK11_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK11_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK11_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK11_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK11_AHBERRMSK_M  (USB_OTGHS_HCINTMSK11_AHBERRMSK_V << USB_OTGHS_HCINTMSK11_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK11_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK11_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK11_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK11_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK11_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK11_BNAINTRMSK_V << USB_OTGHS_HCINTMSK11_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK11_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK11_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK11_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK11_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK11_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK11_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK11_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK11_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK11_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ11_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ11_REG (DR_REG_USB_OTGHS_BASE + 0x670)
/** USB_OTGHS_HCTSIZ11_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ11_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ11_XFERSIZE_M  (USB_OTGHS_HCTSIZ11_XFERSIZE_V << USB_OTGHS_HCTSIZ11_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ11_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ11_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ11_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ11_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ11_PKTCNT_M  (USB_OTGHS_HCTSIZ11_PKTCNT_V << USB_OTGHS_HCTSIZ11_PKTCNT_S)
#define USB_OTGHS_HCTSIZ11_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ11_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ11_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ11_PID    0x00000003U
#define USB_OTGHS_HCTSIZ11_PID_M  (USB_OTGHS_HCTSIZ11_PID_V << USB_OTGHS_HCTSIZ11_PID_S)
#define USB_OTGHS_HCTSIZ11_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ11_PID_S  29
/** USB_OTGHS_HCTSIZ11_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ11_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ11_DOPNG_M  (USB_OTGHS_HCTSIZ11_DOPNG_V << USB_OTGHS_HCTSIZ11_DOPNG_S)
#define USB_OTGHS_HCTSIZ11_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ11_DOPNG_S  31

/** USB_OTGHS_HCDMA11_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA11_REG (DR_REG_USB_OTGHS_BASE + 0x674)
/** USB_OTGHS_HCDMA11_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA11_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA11_DMAADDR_M  (USB_OTGHS_HCDMA11_DMAADDR_V << USB_OTGHS_HCDMA11_DMAADDR_S)
#define USB_OTGHS_HCDMA11_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA11_DMAADDR_S  0

/** USB_OTGHS_HCDMAB11_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB11_REG (DR_REG_USB_OTGHS_BASE + 0x67c)
/** USB_OTGHS_HCDMAB11_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB11_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB11_HCDMAB_M  (USB_OTGHS_HCDMAB11_HCDMAB_V << USB_OTGHS_HCDMAB11_HCDMAB_S)
#define USB_OTGHS_HCDMAB11_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB11_HCDMAB_S  0

/** USB_OTGHS_HCCHAR12_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR12_REG (DR_REG_USB_OTGHS_BASE + 0x680)
/** USB_OTGHS_HCCHAR12_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR12_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR12_MPS_M  (USB_OTGHS_HCCHAR12_MPS_V << USB_OTGHS_HCCHAR12_MPS_S)
#define USB_OTGHS_HCCHAR12_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR12_MPS_S  0
/** USB_OTGHS_HCCHAR12_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR12_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR12_EPNUM_M  (USB_OTGHS_HCCHAR12_EPNUM_V << USB_OTGHS_HCCHAR12_EPNUM_S)
#define USB_OTGHS_HCCHAR12_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR12_EPNUM_S  11
/** USB_OTGHS_HCCHAR12_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR12_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR12_EPDIR_M  (USB_OTGHS_HCCHAR12_EPDIR_V << USB_OTGHS_HCCHAR12_EPDIR_S)
#define USB_OTGHS_HCCHAR12_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR12_EPDIR_S  15
/** USB_OTGHS_HCCHAR12_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR12_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR12_LSPDDEV_M  (USB_OTGHS_HCCHAR12_LSPDDEV_V << USB_OTGHS_HCCHAR12_LSPDDEV_S)
#define USB_OTGHS_HCCHAR12_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR12_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR12_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR12_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR12_EPTYPE_M  (USB_OTGHS_HCCHAR12_EPTYPE_V << USB_OTGHS_HCCHAR12_EPTYPE_S)
#define USB_OTGHS_HCCHAR12_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR12_EPTYPE_S  18
/** USB_OTGHS_HCCHAR12_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR12_EC    0x00000003U
#define USB_OTGHS_HCCHAR12_EC_M  (USB_OTGHS_HCCHAR12_EC_V << USB_OTGHS_HCCHAR12_EC_S)
#define USB_OTGHS_HCCHAR12_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR12_EC_S  20
/** USB_OTGHS_HCCHAR12_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR12_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR12_DEVADDR_M  (USB_OTGHS_HCCHAR12_DEVADDR_V << USB_OTGHS_HCCHAR12_DEVADDR_S)
#define USB_OTGHS_HCCHAR12_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR12_DEVADDR_S  22
/** USB_OTGHS_HCCHAR12_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR12_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR12_ODDFRM_M  (USB_OTGHS_HCCHAR12_ODDFRM_V << USB_OTGHS_HCCHAR12_ODDFRM_S)
#define USB_OTGHS_HCCHAR12_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR12_ODDFRM_S  29
/** USB_OTGHS_HCCHAR12_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR12_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR12_CHDIS_M  (USB_OTGHS_HCCHAR12_CHDIS_V << USB_OTGHS_HCCHAR12_CHDIS_S)
#define USB_OTGHS_HCCHAR12_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR12_CHDIS_S  30
/** USB_OTGHS_HCCHAR12_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR12_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR12_CHENA_M  (USB_OTGHS_HCCHAR12_CHENA_V << USB_OTGHS_HCCHAR12_CHENA_S)
#define USB_OTGHS_HCCHAR12_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR12_CHENA_S  31

/** USB_OTGHS_HCSPLT12_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT12_REG (DR_REG_USB_OTGHS_BASE + 0x684)
/** USB_OTGHS_HCSPLT12_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT12_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT12_PRTADDR_M  (USB_OTGHS_HCSPLT12_PRTADDR_V << USB_OTGHS_HCSPLT12_PRTADDR_S)
#define USB_OTGHS_HCSPLT12_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT12_PRTADDR_S  0
/** USB_OTGHS_HCSPLT12_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT12_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT12_HUBADDR_M  (USB_OTGHS_HCSPLT12_HUBADDR_V << USB_OTGHS_HCSPLT12_HUBADDR_S)
#define USB_OTGHS_HCSPLT12_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT12_HUBADDR_S  7
/** USB_OTGHS_HCSPLT12_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT12_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT12_XACTPOS_M  (USB_OTGHS_HCSPLT12_XACTPOS_V << USB_OTGHS_HCSPLT12_XACTPOS_S)
#define USB_OTGHS_HCSPLT12_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT12_XACTPOS_S  14
/** USB_OTGHS_HCSPLT12_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT12_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT12_COMPSPLT_M  (USB_OTGHS_HCSPLT12_COMPSPLT_V << USB_OTGHS_HCSPLT12_COMPSPLT_S)
#define USB_OTGHS_HCSPLT12_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT12_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT12_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT12_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT12_SPLTENA_M  (USB_OTGHS_HCSPLT12_SPLTENA_V << USB_OTGHS_HCSPLT12_SPLTENA_S)
#define USB_OTGHS_HCSPLT12_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT12_SPLTENA_S  31

/** USB_OTGHS_HCINT12_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT12_REG (DR_REG_USB_OTGHS_BASE + 0x688)
/** USB_OTGHS_HCINT12_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT12_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT12_XFERCOMPL_M  (USB_OTGHS_HCINT12_XFERCOMPL_V << USB_OTGHS_HCINT12_XFERCOMPL_S)
#define USB_OTGHS_HCINT12_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT12_XFERCOMPL_S  0
/** USB_OTGHS_HCINT12_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT12_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT12_CHHLTD_M  (USB_OTGHS_HCINT12_CHHLTD_V << USB_OTGHS_HCINT12_CHHLTD_S)
#define USB_OTGHS_HCINT12_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT12_CHHLTD_S  1
/** USB_OTGHS_HCINT12_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT12_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT12_AHBERR_M  (USB_OTGHS_HCINT12_AHBERR_V << USB_OTGHS_HCINT12_AHBERR_S)
#define USB_OTGHS_HCINT12_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT12_AHBERR_S  2
/** USB_OTGHS_HCINT12_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT12_STALL    (BIT(3))
#define USB_OTGHS_HCINT12_STALL_M  (USB_OTGHS_HCINT12_STALL_V << USB_OTGHS_HCINT12_STALL_S)
#define USB_OTGHS_HCINT12_STALL_V  0x00000001U
#define USB_OTGHS_HCINT12_STALL_S  3
/** USB_OTGHS_HCINT12_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT12_NAK    (BIT(4))
#define USB_OTGHS_HCINT12_NAK_M  (USB_OTGHS_HCINT12_NAK_V << USB_OTGHS_HCINT12_NAK_S)
#define USB_OTGHS_HCINT12_NAK_V  0x00000001U
#define USB_OTGHS_HCINT12_NAK_S  4
/** USB_OTGHS_HCINT12_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT12_ACK    (BIT(5))
#define USB_OTGHS_HCINT12_ACK_M  (USB_OTGHS_HCINT12_ACK_V << USB_OTGHS_HCINT12_ACK_S)
#define USB_OTGHS_HCINT12_ACK_V  0x00000001U
#define USB_OTGHS_HCINT12_ACK_S  5
/** USB_OTGHS_HCINT12_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT12_NYET    (BIT(6))
#define USB_OTGHS_HCINT12_NYET_M  (USB_OTGHS_HCINT12_NYET_V << USB_OTGHS_HCINT12_NYET_S)
#define USB_OTGHS_HCINT12_NYET_V  0x00000001U
#define USB_OTGHS_HCINT12_NYET_S  6
/** USB_OTGHS_HCINT12_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT12_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT12_XACTERR_M  (USB_OTGHS_HCINT12_XACTERR_V << USB_OTGHS_HCINT12_XACTERR_S)
#define USB_OTGHS_HCINT12_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT12_XACTERR_S  7
/** USB_OTGHS_HCINT12_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT12_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT12_BBLERR_M  (USB_OTGHS_HCINT12_BBLERR_V << USB_OTGHS_HCINT12_BBLERR_S)
#define USB_OTGHS_HCINT12_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT12_BBLERR_S  8
/** USB_OTGHS_HCINT12_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT12_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT12_FRMOVRUN_M  (USB_OTGHS_HCINT12_FRMOVRUN_V << USB_OTGHS_HCINT12_FRMOVRUN_S)
#define USB_OTGHS_HCINT12_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT12_FRMOVRUN_S  9
/** USB_OTGHS_HCINT12_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT12_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT12_DATATGLERR_M  (USB_OTGHS_HCINT12_DATATGLERR_V << USB_OTGHS_HCINT12_DATATGLERR_S)
#define USB_OTGHS_HCINT12_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT12_DATATGLERR_S  10
/** USB_OTGHS_HCINT12_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT12_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT12_BNAINTR_M  (USB_OTGHS_HCINT12_BNAINTR_V << USB_OTGHS_HCINT12_BNAINTR_S)
#define USB_OTGHS_HCINT12_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT12_BNAINTR_S  11
/** USB_OTGHS_HCINT12_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT12_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT12_XCS_XACT_ERR_M  (USB_OTGHS_HCINT12_XCS_XACT_ERR_V << USB_OTGHS_HCINT12_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT12_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT12_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT12_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT12_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT12_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT12_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT12_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT12_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT12_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK12_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK12_REG (DR_REG_USB_OTGHS_BASE + 0x68c)
/** USB_OTGHS_HCINTMSK12_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK12_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK12_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK12_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK12_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK12_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK12_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK12_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK12_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK12_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK12_CHHLTDMSK_V << USB_OTGHS_HCINTMSK12_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK12_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK12_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK12_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK12_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK12_AHBERRMSK_M  (USB_OTGHS_HCINTMSK12_AHBERRMSK_V << USB_OTGHS_HCINTMSK12_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK12_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK12_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK12_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK12_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK12_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK12_BNAINTRMSK_V << USB_OTGHS_HCINTMSK12_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK12_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK12_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK12_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK12_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK12_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK12_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK12_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK12_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK12_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ12_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ12_REG (DR_REG_USB_OTGHS_BASE + 0x690)
/** USB_OTGHS_HCTSIZ12_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ12_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ12_XFERSIZE_M  (USB_OTGHS_HCTSIZ12_XFERSIZE_V << USB_OTGHS_HCTSIZ12_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ12_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ12_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ12_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ12_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ12_PKTCNT_M  (USB_OTGHS_HCTSIZ12_PKTCNT_V << USB_OTGHS_HCTSIZ12_PKTCNT_S)
#define USB_OTGHS_HCTSIZ12_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ12_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ12_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ12_PID    0x00000003U
#define USB_OTGHS_HCTSIZ12_PID_M  (USB_OTGHS_HCTSIZ12_PID_V << USB_OTGHS_HCTSIZ12_PID_S)
#define USB_OTGHS_HCTSIZ12_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ12_PID_S  29
/** USB_OTGHS_HCTSIZ12_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ12_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ12_DOPNG_M  (USB_OTGHS_HCTSIZ12_DOPNG_V << USB_OTGHS_HCTSIZ12_DOPNG_S)
#define USB_OTGHS_HCTSIZ12_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ12_DOPNG_S  31

/** USB_OTGHS_HCDMA12_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA12_REG (DR_REG_USB_OTGHS_BASE + 0x694)
/** USB_OTGHS_HCDMA12_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA12_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA12_DMAADDR_M  (USB_OTGHS_HCDMA12_DMAADDR_V << USB_OTGHS_HCDMA12_DMAADDR_S)
#define USB_OTGHS_HCDMA12_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA12_DMAADDR_S  0

/** USB_OTGHS_HCDMAB12_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB12_REG (DR_REG_USB_OTGHS_BASE + 0x69c)
/** USB_OTGHS_HCDMAB12_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB12_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB12_HCDMAB_M  (USB_OTGHS_HCDMAB12_HCDMAB_V << USB_OTGHS_HCDMAB12_HCDMAB_S)
#define USB_OTGHS_HCDMAB12_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB12_HCDMAB_S  0

/** USB_OTGHS_HCCHAR13_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR13_REG (DR_REG_USB_OTGHS_BASE + 0x6a0)
/** USB_OTGHS_HCCHAR13_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR13_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR13_MPS_M  (USB_OTGHS_HCCHAR13_MPS_V << USB_OTGHS_HCCHAR13_MPS_S)
#define USB_OTGHS_HCCHAR13_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR13_MPS_S  0
/** USB_OTGHS_HCCHAR13_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR13_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR13_EPNUM_M  (USB_OTGHS_HCCHAR13_EPNUM_V << USB_OTGHS_HCCHAR13_EPNUM_S)
#define USB_OTGHS_HCCHAR13_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR13_EPNUM_S  11
/** USB_OTGHS_HCCHAR13_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR13_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR13_EPDIR_M  (USB_OTGHS_HCCHAR13_EPDIR_V << USB_OTGHS_HCCHAR13_EPDIR_S)
#define USB_OTGHS_HCCHAR13_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR13_EPDIR_S  15
/** USB_OTGHS_HCCHAR13_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR13_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR13_LSPDDEV_M  (USB_OTGHS_HCCHAR13_LSPDDEV_V << USB_OTGHS_HCCHAR13_LSPDDEV_S)
#define USB_OTGHS_HCCHAR13_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR13_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR13_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR13_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR13_EPTYPE_M  (USB_OTGHS_HCCHAR13_EPTYPE_V << USB_OTGHS_HCCHAR13_EPTYPE_S)
#define USB_OTGHS_HCCHAR13_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR13_EPTYPE_S  18
/** USB_OTGHS_HCCHAR13_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR13_EC    0x00000003U
#define USB_OTGHS_HCCHAR13_EC_M  (USB_OTGHS_HCCHAR13_EC_V << USB_OTGHS_HCCHAR13_EC_S)
#define USB_OTGHS_HCCHAR13_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR13_EC_S  20
/** USB_OTGHS_HCCHAR13_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR13_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR13_DEVADDR_M  (USB_OTGHS_HCCHAR13_DEVADDR_V << USB_OTGHS_HCCHAR13_DEVADDR_S)
#define USB_OTGHS_HCCHAR13_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR13_DEVADDR_S  22
/** USB_OTGHS_HCCHAR13_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR13_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR13_ODDFRM_M  (USB_OTGHS_HCCHAR13_ODDFRM_V << USB_OTGHS_HCCHAR13_ODDFRM_S)
#define USB_OTGHS_HCCHAR13_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR13_ODDFRM_S  29
/** USB_OTGHS_HCCHAR13_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR13_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR13_CHDIS_M  (USB_OTGHS_HCCHAR13_CHDIS_V << USB_OTGHS_HCCHAR13_CHDIS_S)
#define USB_OTGHS_HCCHAR13_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR13_CHDIS_S  30
/** USB_OTGHS_HCCHAR13_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR13_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR13_CHENA_M  (USB_OTGHS_HCCHAR13_CHENA_V << USB_OTGHS_HCCHAR13_CHENA_S)
#define USB_OTGHS_HCCHAR13_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR13_CHENA_S  31

/** USB_OTGHS_HCSPLT13_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT13_REG (DR_REG_USB_OTGHS_BASE + 0x6a4)
/** USB_OTGHS_HCSPLT13_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT13_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT13_PRTADDR_M  (USB_OTGHS_HCSPLT13_PRTADDR_V << USB_OTGHS_HCSPLT13_PRTADDR_S)
#define USB_OTGHS_HCSPLT13_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT13_PRTADDR_S  0
/** USB_OTGHS_HCSPLT13_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT13_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT13_HUBADDR_M  (USB_OTGHS_HCSPLT13_HUBADDR_V << USB_OTGHS_HCSPLT13_HUBADDR_S)
#define USB_OTGHS_HCSPLT13_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT13_HUBADDR_S  7
/** USB_OTGHS_HCSPLT13_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT13_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT13_XACTPOS_M  (USB_OTGHS_HCSPLT13_XACTPOS_V << USB_OTGHS_HCSPLT13_XACTPOS_S)
#define USB_OTGHS_HCSPLT13_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT13_XACTPOS_S  14
/** USB_OTGHS_HCSPLT13_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT13_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT13_COMPSPLT_M  (USB_OTGHS_HCSPLT13_COMPSPLT_V << USB_OTGHS_HCSPLT13_COMPSPLT_S)
#define USB_OTGHS_HCSPLT13_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT13_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT13_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT13_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT13_SPLTENA_M  (USB_OTGHS_HCSPLT13_SPLTENA_V << USB_OTGHS_HCSPLT13_SPLTENA_S)
#define USB_OTGHS_HCSPLT13_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT13_SPLTENA_S  31

/** USB_OTGHS_HCINT13_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT13_REG (DR_REG_USB_OTGHS_BASE + 0x6a8)
/** USB_OTGHS_HCINT13_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT13_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT13_XFERCOMPL_M  (USB_OTGHS_HCINT13_XFERCOMPL_V << USB_OTGHS_HCINT13_XFERCOMPL_S)
#define USB_OTGHS_HCINT13_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT13_XFERCOMPL_S  0
/** USB_OTGHS_HCINT13_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT13_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT13_CHHLTD_M  (USB_OTGHS_HCINT13_CHHLTD_V << USB_OTGHS_HCINT13_CHHLTD_S)
#define USB_OTGHS_HCINT13_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT13_CHHLTD_S  1
/** USB_OTGHS_HCINT13_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT13_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT13_AHBERR_M  (USB_OTGHS_HCINT13_AHBERR_V << USB_OTGHS_HCINT13_AHBERR_S)
#define USB_OTGHS_HCINT13_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT13_AHBERR_S  2
/** USB_OTGHS_HCINT13_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT13_STALL    (BIT(3))
#define USB_OTGHS_HCINT13_STALL_M  (USB_OTGHS_HCINT13_STALL_V << USB_OTGHS_HCINT13_STALL_S)
#define USB_OTGHS_HCINT13_STALL_V  0x00000001U
#define USB_OTGHS_HCINT13_STALL_S  3
/** USB_OTGHS_HCINT13_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT13_NAK    (BIT(4))
#define USB_OTGHS_HCINT13_NAK_M  (USB_OTGHS_HCINT13_NAK_V << USB_OTGHS_HCINT13_NAK_S)
#define USB_OTGHS_HCINT13_NAK_V  0x00000001U
#define USB_OTGHS_HCINT13_NAK_S  4
/** USB_OTGHS_HCINT13_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT13_ACK    (BIT(5))
#define USB_OTGHS_HCINT13_ACK_M  (USB_OTGHS_HCINT13_ACK_V << USB_OTGHS_HCINT13_ACK_S)
#define USB_OTGHS_HCINT13_ACK_V  0x00000001U
#define USB_OTGHS_HCINT13_ACK_S  5
/** USB_OTGHS_HCINT13_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT13_NYET    (BIT(6))
#define USB_OTGHS_HCINT13_NYET_M  (USB_OTGHS_HCINT13_NYET_V << USB_OTGHS_HCINT13_NYET_S)
#define USB_OTGHS_HCINT13_NYET_V  0x00000001U
#define USB_OTGHS_HCINT13_NYET_S  6
/** USB_OTGHS_HCINT13_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT13_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT13_XACTERR_M  (USB_OTGHS_HCINT13_XACTERR_V << USB_OTGHS_HCINT13_XACTERR_S)
#define USB_OTGHS_HCINT13_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT13_XACTERR_S  7
/** USB_OTGHS_HCINT13_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT13_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT13_BBLERR_M  (USB_OTGHS_HCINT13_BBLERR_V << USB_OTGHS_HCINT13_BBLERR_S)
#define USB_OTGHS_HCINT13_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT13_BBLERR_S  8
/** USB_OTGHS_HCINT13_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT13_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT13_FRMOVRUN_M  (USB_OTGHS_HCINT13_FRMOVRUN_V << USB_OTGHS_HCINT13_FRMOVRUN_S)
#define USB_OTGHS_HCINT13_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT13_FRMOVRUN_S  9
/** USB_OTGHS_HCINT13_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT13_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT13_DATATGLERR_M  (USB_OTGHS_HCINT13_DATATGLERR_V << USB_OTGHS_HCINT13_DATATGLERR_S)
#define USB_OTGHS_HCINT13_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT13_DATATGLERR_S  10
/** USB_OTGHS_HCINT13_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT13_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT13_BNAINTR_M  (USB_OTGHS_HCINT13_BNAINTR_V << USB_OTGHS_HCINT13_BNAINTR_S)
#define USB_OTGHS_HCINT13_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT13_BNAINTR_S  11
/** USB_OTGHS_HCINT13_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT13_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT13_XCS_XACT_ERR_M  (USB_OTGHS_HCINT13_XCS_XACT_ERR_V << USB_OTGHS_HCINT13_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT13_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT13_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT13_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT13_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT13_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT13_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT13_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT13_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT13_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK13_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK13_REG (DR_REG_USB_OTGHS_BASE + 0x6ac)
/** USB_OTGHS_HCINTMSK13_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK13_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK13_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK13_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK13_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK13_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK13_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK13_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK13_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK13_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK13_CHHLTDMSK_V << USB_OTGHS_HCINTMSK13_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK13_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK13_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK13_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK13_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK13_AHBERRMSK_M  (USB_OTGHS_HCINTMSK13_AHBERRMSK_V << USB_OTGHS_HCINTMSK13_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK13_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK13_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK13_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK13_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK13_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK13_BNAINTRMSK_V << USB_OTGHS_HCINTMSK13_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK13_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK13_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK13_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK13_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK13_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK13_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK13_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK13_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK13_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ13_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ13_REG (DR_REG_USB_OTGHS_BASE + 0x6b0)
/** USB_OTGHS_HCTSIZ13_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ13_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ13_XFERSIZE_M  (USB_OTGHS_HCTSIZ13_XFERSIZE_V << USB_OTGHS_HCTSIZ13_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ13_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ13_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ13_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ13_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ13_PKTCNT_M  (USB_OTGHS_HCTSIZ13_PKTCNT_V << USB_OTGHS_HCTSIZ13_PKTCNT_S)
#define USB_OTGHS_HCTSIZ13_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ13_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ13_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ13_PID    0x00000003U
#define USB_OTGHS_HCTSIZ13_PID_M  (USB_OTGHS_HCTSIZ13_PID_V << USB_OTGHS_HCTSIZ13_PID_S)
#define USB_OTGHS_HCTSIZ13_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ13_PID_S  29
/** USB_OTGHS_HCTSIZ13_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ13_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ13_DOPNG_M  (USB_OTGHS_HCTSIZ13_DOPNG_V << USB_OTGHS_HCTSIZ13_DOPNG_S)
#define USB_OTGHS_HCTSIZ13_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ13_DOPNG_S  31

/** USB_OTGHS_HCDMA13_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA13_REG (DR_REG_USB_OTGHS_BASE + 0x6b4)
/** USB_OTGHS_HCDMA13_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA13_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA13_DMAADDR_M  (USB_OTGHS_HCDMA13_DMAADDR_V << USB_OTGHS_HCDMA13_DMAADDR_S)
#define USB_OTGHS_HCDMA13_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA13_DMAADDR_S  0

/** USB_OTGHS_HCDMAB13_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB13_REG (DR_REG_USB_OTGHS_BASE + 0x6bc)
/** USB_OTGHS_HCDMAB13_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB13_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB13_HCDMAB_M  (USB_OTGHS_HCDMAB13_HCDMAB_V << USB_OTGHS_HCDMAB13_HCDMAB_S)
#define USB_OTGHS_HCDMAB13_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB13_HCDMAB_S  0

/** USB_OTGHS_HCCHAR14_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR14_REG (DR_REG_USB_OTGHS_BASE + 0x6c0)
/** USB_OTGHS_HCCHAR14_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR14_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR14_MPS_M  (USB_OTGHS_HCCHAR14_MPS_V << USB_OTGHS_HCCHAR14_MPS_S)
#define USB_OTGHS_HCCHAR14_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR14_MPS_S  0
/** USB_OTGHS_HCCHAR14_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR14_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR14_EPNUM_M  (USB_OTGHS_HCCHAR14_EPNUM_V << USB_OTGHS_HCCHAR14_EPNUM_S)
#define USB_OTGHS_HCCHAR14_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR14_EPNUM_S  11
/** USB_OTGHS_HCCHAR14_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR14_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR14_EPDIR_M  (USB_OTGHS_HCCHAR14_EPDIR_V << USB_OTGHS_HCCHAR14_EPDIR_S)
#define USB_OTGHS_HCCHAR14_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR14_EPDIR_S  15
/** USB_OTGHS_HCCHAR14_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR14_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR14_LSPDDEV_M  (USB_OTGHS_HCCHAR14_LSPDDEV_V << USB_OTGHS_HCCHAR14_LSPDDEV_S)
#define USB_OTGHS_HCCHAR14_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR14_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR14_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR14_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR14_EPTYPE_M  (USB_OTGHS_HCCHAR14_EPTYPE_V << USB_OTGHS_HCCHAR14_EPTYPE_S)
#define USB_OTGHS_HCCHAR14_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR14_EPTYPE_S  18
/** USB_OTGHS_HCCHAR14_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR14_EC    0x00000003U
#define USB_OTGHS_HCCHAR14_EC_M  (USB_OTGHS_HCCHAR14_EC_V << USB_OTGHS_HCCHAR14_EC_S)
#define USB_OTGHS_HCCHAR14_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR14_EC_S  20
/** USB_OTGHS_HCCHAR14_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR14_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR14_DEVADDR_M  (USB_OTGHS_HCCHAR14_DEVADDR_V << USB_OTGHS_HCCHAR14_DEVADDR_S)
#define USB_OTGHS_HCCHAR14_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR14_DEVADDR_S  22
/** USB_OTGHS_HCCHAR14_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR14_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR14_ODDFRM_M  (USB_OTGHS_HCCHAR14_ODDFRM_V << USB_OTGHS_HCCHAR14_ODDFRM_S)
#define USB_OTGHS_HCCHAR14_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR14_ODDFRM_S  29
/** USB_OTGHS_HCCHAR14_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR14_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR14_CHDIS_M  (USB_OTGHS_HCCHAR14_CHDIS_V << USB_OTGHS_HCCHAR14_CHDIS_S)
#define USB_OTGHS_HCCHAR14_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR14_CHDIS_S  30
/** USB_OTGHS_HCCHAR14_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR14_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR14_CHENA_M  (USB_OTGHS_HCCHAR14_CHENA_V << USB_OTGHS_HCCHAR14_CHENA_S)
#define USB_OTGHS_HCCHAR14_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR14_CHENA_S  31

/** USB_OTGHS_HCSPLT14_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT14_REG (DR_REG_USB_OTGHS_BASE + 0x6c4)
/** USB_OTGHS_HCSPLT14_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT14_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT14_PRTADDR_M  (USB_OTGHS_HCSPLT14_PRTADDR_V << USB_OTGHS_HCSPLT14_PRTADDR_S)
#define USB_OTGHS_HCSPLT14_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT14_PRTADDR_S  0
/** USB_OTGHS_HCSPLT14_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT14_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT14_HUBADDR_M  (USB_OTGHS_HCSPLT14_HUBADDR_V << USB_OTGHS_HCSPLT14_HUBADDR_S)
#define USB_OTGHS_HCSPLT14_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT14_HUBADDR_S  7
/** USB_OTGHS_HCSPLT14_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT14_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT14_XACTPOS_M  (USB_OTGHS_HCSPLT14_XACTPOS_V << USB_OTGHS_HCSPLT14_XACTPOS_S)
#define USB_OTGHS_HCSPLT14_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT14_XACTPOS_S  14
/** USB_OTGHS_HCSPLT14_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT14_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT14_COMPSPLT_M  (USB_OTGHS_HCSPLT14_COMPSPLT_V << USB_OTGHS_HCSPLT14_COMPSPLT_S)
#define USB_OTGHS_HCSPLT14_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT14_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT14_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT14_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT14_SPLTENA_M  (USB_OTGHS_HCSPLT14_SPLTENA_V << USB_OTGHS_HCSPLT14_SPLTENA_S)
#define USB_OTGHS_HCSPLT14_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT14_SPLTENA_S  31

/** USB_OTGHS_HCINT14_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT14_REG (DR_REG_USB_OTGHS_BASE + 0x6c8)
/** USB_OTGHS_HCINT14_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT14_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT14_XFERCOMPL_M  (USB_OTGHS_HCINT14_XFERCOMPL_V << USB_OTGHS_HCINT14_XFERCOMPL_S)
#define USB_OTGHS_HCINT14_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT14_XFERCOMPL_S  0
/** USB_OTGHS_HCINT14_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT14_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT14_CHHLTD_M  (USB_OTGHS_HCINT14_CHHLTD_V << USB_OTGHS_HCINT14_CHHLTD_S)
#define USB_OTGHS_HCINT14_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT14_CHHLTD_S  1
/** USB_OTGHS_HCINT14_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT14_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT14_AHBERR_M  (USB_OTGHS_HCINT14_AHBERR_V << USB_OTGHS_HCINT14_AHBERR_S)
#define USB_OTGHS_HCINT14_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT14_AHBERR_S  2
/** USB_OTGHS_HCINT14_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT14_STALL    (BIT(3))
#define USB_OTGHS_HCINT14_STALL_M  (USB_OTGHS_HCINT14_STALL_V << USB_OTGHS_HCINT14_STALL_S)
#define USB_OTGHS_HCINT14_STALL_V  0x00000001U
#define USB_OTGHS_HCINT14_STALL_S  3
/** USB_OTGHS_HCINT14_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT14_NAK    (BIT(4))
#define USB_OTGHS_HCINT14_NAK_M  (USB_OTGHS_HCINT14_NAK_V << USB_OTGHS_HCINT14_NAK_S)
#define USB_OTGHS_HCINT14_NAK_V  0x00000001U
#define USB_OTGHS_HCINT14_NAK_S  4
/** USB_OTGHS_HCINT14_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT14_ACK    (BIT(5))
#define USB_OTGHS_HCINT14_ACK_M  (USB_OTGHS_HCINT14_ACK_V << USB_OTGHS_HCINT14_ACK_S)
#define USB_OTGHS_HCINT14_ACK_V  0x00000001U
#define USB_OTGHS_HCINT14_ACK_S  5
/** USB_OTGHS_HCINT14_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT14_NYET    (BIT(6))
#define USB_OTGHS_HCINT14_NYET_M  (USB_OTGHS_HCINT14_NYET_V << USB_OTGHS_HCINT14_NYET_S)
#define USB_OTGHS_HCINT14_NYET_V  0x00000001U
#define USB_OTGHS_HCINT14_NYET_S  6
/** USB_OTGHS_HCINT14_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT14_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT14_XACTERR_M  (USB_OTGHS_HCINT14_XACTERR_V << USB_OTGHS_HCINT14_XACTERR_S)
#define USB_OTGHS_HCINT14_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT14_XACTERR_S  7
/** USB_OTGHS_HCINT14_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT14_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT14_BBLERR_M  (USB_OTGHS_HCINT14_BBLERR_V << USB_OTGHS_HCINT14_BBLERR_S)
#define USB_OTGHS_HCINT14_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT14_BBLERR_S  8
/** USB_OTGHS_HCINT14_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT14_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT14_FRMOVRUN_M  (USB_OTGHS_HCINT14_FRMOVRUN_V << USB_OTGHS_HCINT14_FRMOVRUN_S)
#define USB_OTGHS_HCINT14_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT14_FRMOVRUN_S  9
/** USB_OTGHS_HCINT14_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT14_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT14_DATATGLERR_M  (USB_OTGHS_HCINT14_DATATGLERR_V << USB_OTGHS_HCINT14_DATATGLERR_S)
#define USB_OTGHS_HCINT14_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT14_DATATGLERR_S  10
/** USB_OTGHS_HCINT14_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT14_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT14_BNAINTR_M  (USB_OTGHS_HCINT14_BNAINTR_V << USB_OTGHS_HCINT14_BNAINTR_S)
#define USB_OTGHS_HCINT14_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT14_BNAINTR_S  11
/** USB_OTGHS_HCINT14_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT14_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT14_XCS_XACT_ERR_M  (USB_OTGHS_HCINT14_XCS_XACT_ERR_V << USB_OTGHS_HCINT14_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT14_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT14_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT14_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT14_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT14_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT14_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT14_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT14_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT14_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK14_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK14_REG (DR_REG_USB_OTGHS_BASE + 0x6cc)
/** USB_OTGHS_HCINTMSK14_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK14_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK14_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK14_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK14_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK14_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK14_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK14_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK14_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK14_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK14_CHHLTDMSK_V << USB_OTGHS_HCINTMSK14_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK14_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK14_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK14_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK14_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK14_AHBERRMSK_M  (USB_OTGHS_HCINTMSK14_AHBERRMSK_V << USB_OTGHS_HCINTMSK14_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK14_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK14_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK14_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK14_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK14_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK14_BNAINTRMSK_V << USB_OTGHS_HCINTMSK14_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK14_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK14_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK14_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK14_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK14_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK14_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK14_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK14_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK14_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ14_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ14_REG (DR_REG_USB_OTGHS_BASE + 0x6d0)
/** USB_OTGHS_HCTSIZ14_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ14_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ14_XFERSIZE_M  (USB_OTGHS_HCTSIZ14_XFERSIZE_V << USB_OTGHS_HCTSIZ14_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ14_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ14_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ14_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ14_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ14_PKTCNT_M  (USB_OTGHS_HCTSIZ14_PKTCNT_V << USB_OTGHS_HCTSIZ14_PKTCNT_S)
#define USB_OTGHS_HCTSIZ14_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ14_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ14_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ14_PID    0x00000003U
#define USB_OTGHS_HCTSIZ14_PID_M  (USB_OTGHS_HCTSIZ14_PID_V << USB_OTGHS_HCTSIZ14_PID_S)
#define USB_OTGHS_HCTSIZ14_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ14_PID_S  29
/** USB_OTGHS_HCTSIZ14_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ14_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ14_DOPNG_M  (USB_OTGHS_HCTSIZ14_DOPNG_V << USB_OTGHS_HCTSIZ14_DOPNG_S)
#define USB_OTGHS_HCTSIZ14_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ14_DOPNG_S  31

/** USB_OTGHS_HCDMA14_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA14_REG (DR_REG_USB_OTGHS_BASE + 0x6d4)
/** USB_OTGHS_HCDMA14_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA14_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA14_DMAADDR_M  (USB_OTGHS_HCDMA14_DMAADDR_V << USB_OTGHS_HCDMA14_DMAADDR_S)
#define USB_OTGHS_HCDMA14_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA14_DMAADDR_S  0

/** USB_OTGHS_HCDMAB14_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB14_REG (DR_REG_USB_OTGHS_BASE + 0x6dc)
/** USB_OTGHS_HCDMAB14_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB14_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB14_HCDMAB_M  (USB_OTGHS_HCDMAB14_HCDMAB_V << USB_OTGHS_HCDMAB14_HCDMAB_S)
#define USB_OTGHS_HCDMAB14_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB14_HCDMAB_S  0

/** USB_OTGHS_HCCHAR15_REG register
 *  This register contains the characteristics of the Host Channel.
 */
#define USB_OTGHS_HCCHAR15_REG (DR_REG_USB_OTGHS_BASE + 0x6e0)
/** USB_OTGHS_HCCHAR15_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Indicates the maximum packet size of the associated endpoint.
 */
#define USB_OTGHS_HCCHAR15_MPS    0x000007FFU
#define USB_OTGHS_HCCHAR15_MPS_M  (USB_OTGHS_HCCHAR15_MPS_V << USB_OTGHS_HCCHAR15_MPS_S)
#define USB_OTGHS_HCCHAR15_MPS_V  0x000007FFU
#define USB_OTGHS_HCCHAR15_MPS_S  0
/** USB_OTGHS_HCCHAR15_EPNUM : R/W; bitpos: [14:11]; default: 0;
 *  Endpoint Number (EPNum)
 *
 *  Indicates the endpoint number on the device serving as the data source or sink.
 */
#define USB_OTGHS_HCCHAR15_EPNUM    0x0000000FU
#define USB_OTGHS_HCCHAR15_EPNUM_M  (USB_OTGHS_HCCHAR15_EPNUM_V << USB_OTGHS_HCCHAR15_EPNUM_S)
#define USB_OTGHS_HCCHAR15_EPNUM_V  0x0000000FU
#define USB_OTGHS_HCCHAR15_EPNUM_S  11
/** USB_OTGHS_HCCHAR15_EPDIR : R/W; bitpos: [15]; default: 0;
 *  Endpoint Direction (EPDir)
 *
 *  Indicates whether the transaction is IN or OUT.
 *  - 1'b0: OUT
 *  - 1'b1: IN
 */
#define USB_OTGHS_HCCHAR15_EPDIR    (BIT(15))
#define USB_OTGHS_HCCHAR15_EPDIR_M  (USB_OTGHS_HCCHAR15_EPDIR_V << USB_OTGHS_HCCHAR15_EPDIR_S)
#define USB_OTGHS_HCCHAR15_EPDIR_V  0x00000001U
#define USB_OTGHS_HCCHAR15_EPDIR_S  15
/** USB_OTGHS_HCCHAR15_LSPDDEV : R/W; bitpos: [17]; default: 0;
 *  Low-Speed Device (LSpdDev)
 *
 *  This field is Set by the application to indicate that this channel is communicating
 *  to a low-speed device.
 *
 *  The application must program this bit when a low speed device is connected to the
 *  host through an FS HUB. The DWC_otg Host core uses this field to drive the
 *  XCVR_SELECT signal to 2'b11 while communicating to the LS Device through the FS hub.
 *
 *  Note: In a peer to peer setup, the DWC_otg Host core ignores this bit even if it is
 *  set by the application software.
 */
#define USB_OTGHS_HCCHAR15_LSPDDEV    (BIT(17))
#define USB_OTGHS_HCCHAR15_LSPDDEV_M  (USB_OTGHS_HCCHAR15_LSPDDEV_V << USB_OTGHS_HCCHAR15_LSPDDEV_S)
#define USB_OTGHS_HCCHAR15_LSPDDEV_V  0x00000001U
#define USB_OTGHS_HCCHAR15_LSPDDEV_S  17
/** USB_OTGHS_HCCHAR15_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Indicates the transfer type selected.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_HCCHAR15_EPTYPE    0x00000003U
#define USB_OTGHS_HCCHAR15_EPTYPE_M  (USB_OTGHS_HCCHAR15_EPTYPE_V << USB_OTGHS_HCCHAR15_EPTYPE_S)
#define USB_OTGHS_HCCHAR15_EPTYPE_V  0x00000003U
#define USB_OTGHS_HCCHAR15_EPTYPE_S  18
/** USB_OTGHS_HCCHAR15_EC : R/W; bitpos: [21:20]; default: 0;
 *  Multi Count (MC) / Error Count (EC)
 *
 *  When the Split Enable bit of the Host Channel-n Split Control
 *  register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates to
 *  the host the number of transactions that must be executed per
 *  microframe for this periodic endpoint. For non periodic transfers,
 *  this field is used only in DMA mode, and specifies the number
 *  packets to be fetched for this channel before the internal DMA
 *  engine changes arbitration.
 *  - 2'b00: Reserved This field yields undefined results.
 *  - 2'b01: 1 transaction
 *  - 2'b10: 2 transactions to be issued for this endpoint per microframe
 *  - 2'b11: 3 transactions to be issued for this endpoint per microframe
 *  When HCSPLTn.SpltEna is Set (1'b1), this field indicates the
 *  number of immediate retries to be performed for a periodic split
 *  transactions on transaction errors. This field must be Set to at
 *  least 2'b01.
 */
#define USB_OTGHS_HCCHAR15_EC    0x00000003U
#define USB_OTGHS_HCCHAR15_EC_M  (USB_OTGHS_HCCHAR15_EC_V << USB_OTGHS_HCCHAR15_EC_S)
#define USB_OTGHS_HCCHAR15_EC_V  0x00000003U
#define USB_OTGHS_HCCHAR15_EC_S  20
/** USB_OTGHS_HCCHAR15_DEVADDR : R/W; bitpos: [28:22]; default: 0;
 *  Device Address (DevAddr)
 *
 *  This field selects the specific device serving as the data source
 *  or sink.
 */
#define USB_OTGHS_HCCHAR15_DEVADDR    0x0000007FU
#define USB_OTGHS_HCCHAR15_DEVADDR_M  (USB_OTGHS_HCCHAR15_DEVADDR_V << USB_OTGHS_HCCHAR15_DEVADDR_S)
#define USB_OTGHS_HCCHAR15_DEVADDR_V  0x0000007FU
#define USB_OTGHS_HCCHAR15_DEVADDR_S  22
/** USB_OTGHS_HCCHAR15_ODDFRM : R/W; bitpos: [29]; default: 0;
 *  Odd Frame (OddFrm)
 *
 *  This field is set (reset) by the application to indicate that the OTG host must
 *  perform
 *  a transfer in an odd (micro)Frame. This field is applicable for only periodic
 *  (isochronous and interrupt) transactions.
 *  - 1'b0: Even (micro)Frame
 *  - 1'b1: Odd (micro)Frame
 */
#define USB_OTGHS_HCCHAR15_ODDFRM    (BIT(29))
#define USB_OTGHS_HCCHAR15_ODDFRM_M  (USB_OTGHS_HCCHAR15_ODDFRM_V << USB_OTGHS_HCCHAR15_ODDFRM_S)
#define USB_OTGHS_HCCHAR15_ODDFRM_V  0x00000001U
#define USB_OTGHS_HCCHAR15_ODDFRM_S  29
/** USB_OTGHS_HCCHAR15_CHDIS : R/W; bitpos: [30]; default: 0;
 *  Channel Disable (ChDis)
 *
 *  The application sets this bit to stop transmitting/receiving data
 *  on a channel, even before the transfer for that channel is
 *  complete. The application must wait for the Channel Disabled
 *  interrupt before treating the channel as disabled.
 */
#define USB_OTGHS_HCCHAR15_CHDIS    (BIT(30))
#define USB_OTGHS_HCCHAR15_CHDIS_M  (USB_OTGHS_HCCHAR15_CHDIS_V << USB_OTGHS_HCCHAR15_CHDIS_S)
#define USB_OTGHS_HCCHAR15_CHDIS_V  0x00000001U
#define USB_OTGHS_HCCHAR15_CHDIS_S  30
/** USB_OTGHS_HCCHAR15_CHENA : R/W; bitpos: [31]; default: 0;
 *  Channel Enable (ChEna)
 *
 *  When Scatter/Gather mode is enabled
 *  - 1'b0: Indicates that the descriptor structure is not yet ready.
 *  - 1'b1:  Indicates  that  the  descriptor  structure  and  data  buffer  with data
 *  is setup and this channel can access the descriptor.
 *  When Scatter/Gather mode is disabled
 *
 *  This field is set by the application and cleared by the OTG host.
 *  - 1'b0: Channel disabled
 *  - 1'b1: Channel enabled
 */
#define USB_OTGHS_HCCHAR15_CHENA    (BIT(31))
#define USB_OTGHS_HCCHAR15_CHENA_M  (USB_OTGHS_HCCHAR15_CHENA_V << USB_OTGHS_HCCHAR15_CHENA_S)
#define USB_OTGHS_HCCHAR15_CHENA_V  0x00000001U
#define USB_OTGHS_HCCHAR15_CHENA_S  31

/** USB_OTGHS_HCSPLT15_REG register
 *  This register contains the Split characteristics of the Host Channel.
 */
#define USB_OTGHS_HCSPLT15_REG (DR_REG_USB_OTGHS_BASE + 0x6e4)
/** USB_OTGHS_HCSPLT15_PRTADDR : R/W; bitpos: [6:0]; default: 0;
 *  Port Address (PrtAddr)
 *
 *  This field is the port number of the recipient transaction translator.
 */
#define USB_OTGHS_HCSPLT15_PRTADDR    0x0000007FU
#define USB_OTGHS_HCSPLT15_PRTADDR_M  (USB_OTGHS_HCSPLT15_PRTADDR_V << USB_OTGHS_HCSPLT15_PRTADDR_S)
#define USB_OTGHS_HCSPLT15_PRTADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT15_PRTADDR_S  0
/** USB_OTGHS_HCSPLT15_HUBADDR : R/W; bitpos: [13:7]; default: 0;
 *  Hub Address (HubAddr)
 *
 *  This field holds the device address of the transaction translator's hub.
 */
#define USB_OTGHS_HCSPLT15_HUBADDR    0x0000007FU
#define USB_OTGHS_HCSPLT15_HUBADDR_M  (USB_OTGHS_HCSPLT15_HUBADDR_V << USB_OTGHS_HCSPLT15_HUBADDR_S)
#define USB_OTGHS_HCSPLT15_HUBADDR_V  0x0000007FU
#define USB_OTGHS_HCSPLT15_HUBADDR_S  7
/** USB_OTGHS_HCSPLT15_XACTPOS : R/W; bitpos: [15:14]; default: 0;
 *  Transaction Position (XactPos)
 *
 *  This field is used to determine whether to send all, first, middle, or last
 *  payloads with each OUT transaction.
 *  - 2'b11: All. This is the entire data payload is of this transaction (which is less
 *  than or equal to 188 bytes).
 *  - 2'b10: Begin. This is the first data payload of this transaction (which is larger
 *  than 188 bytes).
 *  - 2'b00: Mid. This is the middle payload of this transaction (which is larger than
 *  188 bytes).
 *  - 2'b01: End. This is the last payload of this transaction (which is larger than
 *  188 bytes).
 */
#define USB_OTGHS_HCSPLT15_XACTPOS    0x00000003U
#define USB_OTGHS_HCSPLT15_XACTPOS_M  (USB_OTGHS_HCSPLT15_XACTPOS_V << USB_OTGHS_HCSPLT15_XACTPOS_S)
#define USB_OTGHS_HCSPLT15_XACTPOS_V  0x00000003U
#define USB_OTGHS_HCSPLT15_XACTPOS_S  14
/** USB_OTGHS_HCSPLT15_COMPSPLT : R/W; bitpos: [16]; default: 0;
 *  Do Complete Split (CompSplt)
 *
 *  The application sets this field to request the OTG host to perform a complete split
 *  transaction.
 */
#define USB_OTGHS_HCSPLT15_COMPSPLT    (BIT(16))
#define USB_OTGHS_HCSPLT15_COMPSPLT_M  (USB_OTGHS_HCSPLT15_COMPSPLT_V << USB_OTGHS_HCSPLT15_COMPSPLT_S)
#define USB_OTGHS_HCSPLT15_COMPSPLT_V  0x00000001U
#define USB_OTGHS_HCSPLT15_COMPSPLT_S  16
/** USB_OTGHS_HCSPLT15_SPLTENA : R/W; bitpos: [31]; default: 0;
 *  Split Enable (SpltEna)
 *
 *  The application sets this field to indicate that this channel is enabled to perform
 *  split transactions.
 */
#define USB_OTGHS_HCSPLT15_SPLTENA    (BIT(31))
#define USB_OTGHS_HCSPLT15_SPLTENA_M  (USB_OTGHS_HCSPLT15_SPLTENA_V << USB_OTGHS_HCSPLT15_SPLTENA_S)
#define USB_OTGHS_HCSPLT15_SPLTENA_V  0x00000001U
#define USB_OTGHS_HCSPLT15_SPLTENA_S  31

/** USB_OTGHS_HCINT15_REG register
 *  This register indicates the status of a channel with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the Host Channels Interrupt bit of the
 *  Core Interrupt register (GINTSTS.HChInt) is set. Before the application can read
 *  this register, it must first read the Host All Channels Interrupt (HAINT) register
 *  to get the exact channel number for the Host Channel-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the HAINT and GINTSTS registers.
 */
#define USB_OTGHS_HCINT15_REG (DR_REG_USB_OTGHS_BASE + 0x6e8)
/** USB_OTGHS_HCINT15_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed (XferCompl)
 *
 *  Transfer completed normally without any errors.This bit can be set only by the core
 *  and the application must write 1 to clear it.
 *  - For Scatter/Gather DMA mode, it indicates that current descriptor processing got
 *  completed with IOC bit set in its descriptor.
 *  - In non Scatter/Gather DMA mode, it indicates that Transfer completed normally
 *  without any errors.
 */
#define USB_OTGHS_HCINT15_XFERCOMPL    (BIT(0))
#define USB_OTGHS_HCINT15_XFERCOMPL_M  (USB_OTGHS_HCINT15_XFERCOMPL_V << USB_OTGHS_HCINT15_XFERCOMPL_S)
#define USB_OTGHS_HCINT15_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_HCINT15_XFERCOMPL_S  0
/** USB_OTGHS_HCINT15_CHHLTD : R/W; bitpos: [1]; default: 0;
 *  Channel Halted (ChHltd)
 *
 *  In non Scatter/Gather DMA mode, it indicates the transfer completed abnormally
 *  either because of any USB transaction error or in response to disable request by
 *  the application or because of a completed transfer.
 *
 *  In Scatter/gather DMA mode, this indicates that transfer completed due to any of
 *  the following
 *  - EOL being set in descriptor
 *  - AHB error
 *  - Excessive transaction errors
 *  - Babble
 *  - Stall
 */
#define USB_OTGHS_HCINT15_CHHLTD    (BIT(1))
#define USB_OTGHS_HCINT15_CHHLTD_M  (USB_OTGHS_HCINT15_CHHLTD_V << USB_OTGHS_HCINT15_CHHLTD_S)
#define USB_OTGHS_HCINT15_CHHLTD_V  0x00000001U
#define USB_OTGHS_HCINT15_CHHLTD_S  1
/** USB_OTGHS_HCINT15_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during AHB
 *  read/write. The application can read the corresponding channel's DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_HCINT15_AHBERR    (BIT(2))
#define USB_OTGHS_HCINT15_AHBERR_M  (USB_OTGHS_HCINT15_AHBERR_V << USB_OTGHS_HCINT15_AHBERR_S)
#define USB_OTGHS_HCINT15_AHBERR_V  0x00000001U
#define USB_OTGHS_HCINT15_AHBERR_S  2
/** USB_OTGHS_HCINT15_STALL : R/W; bitpos: [3]; default: 0;
 *  STALL Response Received Interrupt (STALL)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT15_STALL    (BIT(3))
#define USB_OTGHS_HCINT15_STALL_M  (USB_OTGHS_HCINT15_STALL_V << USB_OTGHS_HCINT15_STALL_S)
#define USB_OTGHS_HCINT15_STALL_V  0x00000001U
#define USB_OTGHS_HCINT15_STALL_S  3
/** USB_OTGHS_HCINT15_NAK : R/W; bitpos: [4]; default: 0;
 *  NAK Response Received Interrupt (NAK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT15_NAK    (BIT(4))
#define USB_OTGHS_HCINT15_NAK_M  (USB_OTGHS_HCINT15_NAK_V << USB_OTGHS_HCINT15_NAK_S)
#define USB_OTGHS_HCINT15_NAK_V  0x00000001U
#define USB_OTGHS_HCINT15_NAK_S  4
/** USB_OTGHS_HCINT15_ACK : R/W; bitpos: [5]; default: 0;
 *  ACK Response Received/Transmitted Interrupt (ACK)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT15_ACK    (BIT(5))
#define USB_OTGHS_HCINT15_ACK_M  (USB_OTGHS_HCINT15_ACK_V << USB_OTGHS_HCINT15_ACK_S)
#define USB_OTGHS_HCINT15_ACK_V  0x00000001U
#define USB_OTGHS_HCINT15_ACK_S  5
/** USB_OTGHS_HCINT15_NYET : R/W; bitpos: [6]; default: 0;
 *  NYET Response Received Interrupt (NYET)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT15_NYET    (BIT(6))
#define USB_OTGHS_HCINT15_NYET_M  (USB_OTGHS_HCINT15_NYET_V << USB_OTGHS_HCINT15_NYET_S)
#define USB_OTGHS_HCINT15_NYET_V  0x00000001U
#define USB_OTGHS_HCINT15_NYET_S  6
/** USB_OTGHS_HCINT15_XACTERR : R/W; bitpos: [7]; default: 0;
 *  Transaction Error (XactErr)
 *
 *  Indicates one of the following errors occurred on the USB.
 *  - CRC check failure
 *  - Timeout
 *  - Bit stuff error
 *  - False EOP
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the
 *  core.This bit can be set only by the core and the application must write 1 to clear
 *  it.
 */
#define USB_OTGHS_HCINT15_XACTERR    (BIT(7))
#define USB_OTGHS_HCINT15_XACTERR_M  (USB_OTGHS_HCINT15_XACTERR_V << USB_OTGHS_HCINT15_XACTERR_S)
#define USB_OTGHS_HCINT15_XACTERR_V  0x00000001U
#define USB_OTGHS_HCINT15_XACTERR_S  7
/** USB_OTGHS_HCINT15_BBLERR : R/W; bitpos: [8]; default: 0;
 *  Babble Error (BblErr)
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked in the core.
 *  This bit can be set only by the core and the application must write 1 to clear it.
 */
#define USB_OTGHS_HCINT15_BBLERR    (BIT(8))
#define USB_OTGHS_HCINT15_BBLERR_M  (USB_OTGHS_HCINT15_BBLERR_V << USB_OTGHS_HCINT15_BBLERR_S)
#define USB_OTGHS_HCINT15_BBLERR_V  0x00000001U
#define USB_OTGHS_HCINT15_BBLERR_S  8
/** USB_OTGHS_HCINT15_FRMOVRUN : R/W; bitpos: [9]; default: 0;
 *  Frame Overrun (FrmOvrun).
 *
 *  In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core. This bit can be set only by the core and the application must write 1
 *  to clear
 *  it.
 */
#define USB_OTGHS_HCINT15_FRMOVRUN    (BIT(9))
#define USB_OTGHS_HCINT15_FRMOVRUN_M  (USB_OTGHS_HCINT15_FRMOVRUN_V << USB_OTGHS_HCINT15_FRMOVRUN_S)
#define USB_OTGHS_HCINT15_FRMOVRUN_V  0x00000001U
#define USB_OTGHS_HCINT15_FRMOVRUN_S  9
/** USB_OTGHS_HCINT15_DATATGLERR : R/W; bitpos: [10]; default: 0;
 *
 *  Data Toggle Error (DataTglErr).This bit can be set only by the core and the
 *  application must write 1 to clear
 *  it.In Scatter/Gather DMA mode, the interrupt due to this bit is masked
 *  in the core.
 */
#define USB_OTGHS_HCINT15_DATATGLERR    (BIT(10))
#define USB_OTGHS_HCINT15_DATATGLERR_M  (USB_OTGHS_HCINT15_DATATGLERR_V << USB_OTGHS_HCINT15_DATATGLERR_S)
#define USB_OTGHS_HCINT15_DATATGLERR_V  0x00000001U
#define USB_OTGHS_HCINT15_DATATGLERR_S  10
/** USB_OTGHS_HCINT15_BNAINTR : R/W; bitpos: [11]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process. BNA is not generated
 *  for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT15_BNAINTR    (BIT(11))
#define USB_OTGHS_HCINT15_BNAINTR_M  (USB_OTGHS_HCINT15_BNAINTR_V << USB_OTGHS_HCINT15_BNAINTR_S)
#define USB_OTGHS_HCINT15_BNAINTR_V  0x00000001U
#define USB_OTGHS_HCINT15_BNAINTR_S  11
/** USB_OTGHS_HCINT15_XCS_XACT_ERR : R/W; bitpos: [12]; default: 0;
 *  Excessive Transaction Error (XCS_XACT_ERR)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when 3 consecutive transaction errors occurred on the USB bus. XCS_XACT_ERR
 *  is not generated for Isochronous channels.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT15_XCS_XACT_ERR    (BIT(12))
#define USB_OTGHS_HCINT15_XCS_XACT_ERR_M  (USB_OTGHS_HCINT15_XCS_XACT_ERR_V << USB_OTGHS_HCINT15_XCS_XACT_ERR_S)
#define USB_OTGHS_HCINT15_XCS_XACT_ERR_V  0x00000001U
#define USB_OTGHS_HCINT15_XCS_XACT_ERR_S  12
/** USB_OTGHS_HCINT15_DESC_LST_ROLLINTR : R/W; bitpos: [13]; default: 0;
 *  Descriptor rollover interrupt (DESC_LST_ROLLIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core sets this
 *  bit
 *  when the corresponding channel's descriptor list rolls over.
 *  For non Scatter/Gather DMA mode, this bit is reserved.
 */
#define USB_OTGHS_HCINT15_DESC_LST_ROLLINTR    (BIT(13))
#define USB_OTGHS_HCINT15_DESC_LST_ROLLINTR_M  (USB_OTGHS_HCINT15_DESC_LST_ROLLINTR_V << USB_OTGHS_HCINT15_DESC_LST_ROLLINTR_S)
#define USB_OTGHS_HCINT15_DESC_LST_ROLLINTR_V  0x00000001U
#define USB_OTGHS_HCINT15_DESC_LST_ROLLINTR_S  13

/** USB_OTGHS_HCINTMSK15_REG register
 *  This register reflects the mask for each channel status described in the previous
 *  section.
 */
#define USB_OTGHS_HCINTMSK15_REG (DR_REG_USB_OTGHS_BASE + 0x6ec)
/** USB_OTGHS_HCINTMSK15_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *
 *  Transfer Completed Mask (XferComplMsk)
 */
#define USB_OTGHS_HCINTMSK15_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_HCINTMSK15_XFERCOMPLMSK_M  (USB_OTGHS_HCINTMSK15_XFERCOMPLMSK_V << USB_OTGHS_HCINTMSK15_XFERCOMPLMSK_S)
#define USB_OTGHS_HCINTMSK15_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK15_XFERCOMPLMSK_S  0
/** USB_OTGHS_HCINTMSK15_CHHLTDMSK : R/W; bitpos: [1]; default: 0;
 *
 *  Channel Halted Mask (ChHltdMsk)
 */
#define USB_OTGHS_HCINTMSK15_CHHLTDMSK    (BIT(1))
#define USB_OTGHS_HCINTMSK15_CHHLTDMSK_M  (USB_OTGHS_HCINTMSK15_CHHLTDMSK_V << USB_OTGHS_HCINTMSK15_CHHLTDMSK_S)
#define USB_OTGHS_HCINTMSK15_CHHLTDMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK15_CHHLTDMSK_S  1
/** USB_OTGHS_HCINTMSK15_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *
 *  AHB Error Mask (AHBErrMsk)
 *  In  scatter/gather  DMA  mode  for  host,
 *  interrupts are not generated due to the corresponding bits set in
 *  HCINTn.
 */
#define USB_OTGHS_HCINTMSK15_AHBERRMSK    (BIT(2))
#define USB_OTGHS_HCINTMSK15_AHBERRMSK_M  (USB_OTGHS_HCINTMSK15_AHBERRMSK_V << USB_OTGHS_HCINTMSK15_AHBERRMSK_S)
#define USB_OTGHS_HCINTMSK15_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK15_AHBERRMSK_S  2
/** USB_OTGHS_HCINTMSK15_BNAINTRMSK : R/W; bitpos: [11]; default: 0;
 *
 *  BNA  (Buffer  Not  Available)  Interrupt  mask  register  (BNAIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK15_BNAINTRMSK    (BIT(11))
#define USB_OTGHS_HCINTMSK15_BNAINTRMSK_M  (USB_OTGHS_HCINTMSK15_BNAINTRMSK_V << USB_OTGHS_HCINTMSK15_BNAINTRMSK_S)
#define USB_OTGHS_HCINTMSK15_BNAINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK15_BNAINTRMSK_S  11
/** USB_OTGHS_HCINTMSK15_DESC_LST_ROLLINTRMSK : R/W; bitpos: [13]; default: 0;
 *
 *  Descriptor List rollover interrupt Mask register(DESC_LST_ROLLIntrMsk)
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 */
#define USB_OTGHS_HCINTMSK15_DESC_LST_ROLLINTRMSK    (BIT(13))
#define USB_OTGHS_HCINTMSK15_DESC_LST_ROLLINTRMSK_M  (USB_OTGHS_HCINTMSK15_DESC_LST_ROLLINTRMSK_V << USB_OTGHS_HCINTMSK15_DESC_LST_ROLLINTRMSK_S)
#define USB_OTGHS_HCINTMSK15_DESC_LST_ROLLINTRMSK_V  0x00000001U
#define USB_OTGHS_HCINTMSK15_DESC_LST_ROLLINTRMSK_S  13

/** USB_OTGHS_HCTSIZ15_REG register
 *  This register reflects the transfer size for the Host Channel.
 */
#define USB_OTGHS_HCTSIZ15_REG (DR_REG_USB_OTGHS_BASE + 0x6f0)
/** USB_OTGHS_HCTSIZ15_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Transfer Size (XferSize)
 *
 *  For an OUT, this field is the number of data bytes the host sends during the
 *  transfer.
 *
 *  For an IN, this field is the buffer size that the application has Reserved for the
 *  transfer. The application is expected to program this field as an integer multiple
 *  of the maximum packet size for IN transactions (periodic and non-periodic).
 *
 *  The width of this counter is specified as Width of Transfer Size Counters during
 *  coreConsultant configuration (parameter OTG_TRANS_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [18:16]: Reserved
 *
 *  [15:8]: NTD (Number of Transfer Descriptors)
 *
 *  (Non Isochronous)
 *
 *  This value is in terms of number of descriptors. Maximum number of descriptor that
 *  can be present in the list is 64. The values can be from 0 to 63.
 *  - 0: 1 descriptor
 *  - 63: 64 descriptors
 *  This field indicates the total number of descriptors present in that list. The core
 *  wraps around after servicing NTD number of descriptors for that list.
 *
 *  (Isochronous)
 *
 *  This field indicates the number of descriptors present in that list microframe.
 *
 *  The possible values for FS are
 *  - 1: 2 descriptors
 *  - 3: 4 descriptors
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  The possible values for HS are
 *  - 7: 8 descriptors
 *  - 15: 16 descriptors
 *  - 31: 32 descriptors
 *  - 63: 64 descriptors
 *  - 127: 128 descriptors
 *  - 255: 256 descriptors
 *  [7:0]: SCHED_INFO (Schedule information)
 *
 *  Every bit in this 8 bit register indicates scheduling for that microframe.
 *
 *  Bit 0 indicates scheduling for 1st microframe and bit 7 indicates scheduling for
 *  8th microframe in that frame.
 *
 *  A value of 8'b11111111 indicates that the corresponding interrupt channel is
 *  scheduled to issue a token every microframe in that frame. A value of 8'b10101010
 *  indicates that the corresponding interrupt channel is scheduled to issue a token
 *  every alternate microframe starting with second microframe. Note that this field is
 *  applicable only for periodic (Isochronous and Interrupt) channels.
 */
#define USB_OTGHS_HCTSIZ15_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_HCTSIZ15_XFERSIZE_M  (USB_OTGHS_HCTSIZ15_XFERSIZE_V << USB_OTGHS_HCTSIZ15_XFERSIZE_S)
#define USB_OTGHS_HCTSIZ15_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_HCTSIZ15_XFERSIZE_S  0
/** USB_OTGHS_HCTSIZ15_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Non-Scatter/Gather DMA Mode:
 *
 *  Packet Count (PktCnt)
 *
 *  This field is programmed by the application with the expected number of packets to
 *  be transmitted (OUT) or received (IN).
 *
 *  The host decrements this count on every successful transmission or reception of an
 *  OUT/IN packet. Once this count reaches zero, the application is interrupted to
 *  indicate normal completion.
 *
 *  The width of this counter is specified as Width of Packet Counters during
 *  coreConsultant configuration (parameter OTG_PACKET_COUNT_WIDTH).
 *
 *  Scatter/Gather DMA Mode:
 *
 *  [28:19]: Reserved
 */
#define USB_OTGHS_HCTSIZ15_PKTCNT    0x000003FFU
#define USB_OTGHS_HCTSIZ15_PKTCNT_M  (USB_OTGHS_HCTSIZ15_PKTCNT_V << USB_OTGHS_HCTSIZ15_PKTCNT_S)
#define USB_OTGHS_HCTSIZ15_PKTCNT_V  0x000003FFU
#define USB_OTGHS_HCTSIZ15_PKTCNT_S  19
/** USB_OTGHS_HCTSIZ15_PID : R/W; bitpos: [30:29]; default: 0;
 *  PID (Pid)
 *
 *  The application programs this field with the type of PID to use for the initial
 *  transaction. The host maintains this field for the rest of the transfer.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA (non-control)/SETUP (control)
 */
#define USB_OTGHS_HCTSIZ15_PID    0x00000003U
#define USB_OTGHS_HCTSIZ15_PID_M  (USB_OTGHS_HCTSIZ15_PID_V << USB_OTGHS_HCTSIZ15_PID_S)
#define USB_OTGHS_HCTSIZ15_PID_V  0x00000003U
#define USB_OTGHS_HCTSIZ15_PID_S  29
/** USB_OTGHS_HCTSIZ15_DOPNG : R/W; bitpos: [31]; default: 0;
 *  Do Ping (DoPng)
 *
 *  This bit is used only for OUT transfers.
 *  Setting this field to 1 directs the host to do PING protocol.
 *
 *  Note: Do not set this bit for IN transfers. If this bit is set for IN transfers it
 *  disables the channel.
 */
#define USB_OTGHS_HCTSIZ15_DOPNG    (BIT(31))
#define USB_OTGHS_HCTSIZ15_DOPNG_M  (USB_OTGHS_HCTSIZ15_DOPNG_V << USB_OTGHS_HCTSIZ15_DOPNG_S)
#define USB_OTGHS_HCTSIZ15_DOPNG_V  0x00000001U
#define USB_OTGHS_HCTSIZ15_DOPNG_S  31

/** USB_OTGHS_HCDMA15_REG register
 *  This register is used by the OTG host in the internal DMA mode to maintain the
 *  current buffer pointer for IN/OUT transactions. The starting DMA address must be
 *  DWORD-aligned.
 */
#define USB_OTGHS_HCDMA15_REG (DR_REG_USB_OTGHS_BASE + 0x6f4)
/** USB_OTGHS_HCDMA15_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  In Buffer DMA Mode:
 *
 *  [31:0]: DMA Address (DMAAddr)
 *
 *  This field holds the start address in the external memory from which the data for
 *  the endpoint must be fetched or to which it must be stored. This register is
 *  incremented on every AHB transaction.
 *
 *  Reset: X if not programmed as the register is in SPRAM.
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Non-Isochronous:
 *
 *  [31:9]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the start address of the 512 bytes page. The first descriptor in
 *  the list must be located in this address. The first descriptor may be or may not be
 *  ready. The core starts processing the list from the CTD value.
 *
 *  [8:3]: Current Transfer Desc(CTD)
 *
 *  This value is in terms of number of descriptors. The values can be from 0 to 63.
 *  - 0 -  1 descriptor.
 *  - 63 - 64 descriptors.
 *  This field indicates the current descriptor processed in the list. This field is
 *  updated both by application and the core. For example, if the application enables
 *  the channel after programming CTD=5, then the core starts processing the sixth
 *  descriptor. The address is obtained by adding a value of (8bytes*5=) 40(decimal) to
 *  DMAAddr.
 *
 *  Reset: 6'h0
 *
 *  [2:0]: Reserved
 *
 *  In Scatter-Gather DMA (DescDMA) Mode for Isochronous:
 *
 *  [31:N]: DMA Address (DMAAddr)
 *
 *  The start address must be 512-bytes aligned.
 *
 *  This field holds the address of the 2*(nTD+1) bytes of locations in which the
 *  isochronous descriptors are present where N is based on nTD as follows:
 *  - [31:N]: Base Address
 *  - [N-1:3]: Offset
 *  - [2:0]: 000
 *  For HS ISOC, if nTD is,
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  - 127, N=10
 *  - 255, N=11
 *  For FS ISOC, if nTD is,
 *  - 1, N=4
 *  - 3, N=5
 *  - 7, N=6
 *  - 15, N=7
 *  - 31, N=8
 *  - 63, N=9
 *  [N-1:3]: Current Transfer Desc(CTD)
 *
 *  CTD for isochronous is based on the current frame/(micro)frame value. Need to be
 *  set to zero by application.
 *
 *  Reset: (N+1:3)'h0
 *
 *  [2:0]: Reserved
 */
#define USB_OTGHS_HCDMA15_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_HCDMA15_DMAADDR_M  (USB_OTGHS_HCDMA15_DMAADDR_V << USB_OTGHS_HCDMA15_DMAADDR_S)
#define USB_OTGHS_HCDMA15_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMA15_DMAADDR_S  0

/** USB_OTGHS_HCDMAB15_REG register
 *  This register is present only in case of Scatter/Gather DMA. It is implemented in
 *  RAM instead of flop-based implementation. This register holds the current buffer
 *  address.
 */
#define USB_OTGHS_HCDMAB15_REG (DR_REG_USB_OTGHS_BASE + 0x6fc)
/** USB_OTGHS_HCDMAB15_HCDMAB : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.
 *  This register is updated as and when the data transfer for the corresponding end
 *  point
 *  is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise
 *  this
 *  field is reserved.
 */
#define USB_OTGHS_HCDMAB15_HCDMAB    0xFFFFFFFFU
#define USB_OTGHS_HCDMAB15_HCDMAB_M  (USB_OTGHS_HCDMAB15_HCDMAB_V << USB_OTGHS_HCDMAB15_HCDMAB_S)
#define USB_OTGHS_HCDMAB15_HCDMAB_V  0xFFFFFFFFU
#define USB_OTGHS_HCDMAB15_HCDMAB_S  0

/** USB_OTGHS_DCFG_REG register
 *  This register configures the core in Device mode after power-on or after certain
 *  control commands or enumeration. Do not make changes to this register after initial
 *  programming.
 */
#define USB_OTGHS_DCFG_REG (DR_REG_USB_OTGHS_BASE + 0x800)
/** USB_OTGHS_DCFG_DEVSPD : R/W; bitpos: [1:0]; default: 0;
 *  Device Speed (DevSpd)
 *
 *  Indicates the speed at which the application requires the core to
 *  enumerate, or the maximum speed the application can support.
 *  However, the actual bus speed is determined only after the connect
 *  sequence is completed, and is based on the speed of the USB
 *  host to which the core is connected.
 */
#define USB_OTGHS_DCFG_DEVSPD    0x00000003U
#define USB_OTGHS_DCFG_DEVSPD_M  (USB_OTGHS_DCFG_DEVSPD_V << USB_OTGHS_DCFG_DEVSPD_S)
#define USB_OTGHS_DCFG_DEVSPD_V  0x00000003U
#define USB_OTGHS_DCFG_DEVSPD_S  0
/** USB_OTGHS_DCFG_NZSTSOUTHSHK : R/W; bitpos: [2]; default: 0;
 *  Non-Zero-Length Status OUT Handshake (NZStsOUTHShk)
 *
 *  The application can use this field to select the handshake the core sends on
 *  receiving a nonzero-length data packet during the OUT transaction of a control
 *  transfer's Status stage.
 *  - 1'b1: Send a STALL handshake on a nonzero-length status OUT transaction and do
 *  not send the received OUT packet to the application.
 *  - 1'b0: Send the received OUT packet to the application (zerolength or
 *  nonzero-length) and send a handshake based on the NAK and STALL bits for the
 *  endpoint in the Device Endpoint Control register.
 */
#define USB_OTGHS_DCFG_NZSTSOUTHSHK    (BIT(2))
#define USB_OTGHS_DCFG_NZSTSOUTHSHK_M  (USB_OTGHS_DCFG_NZSTSOUTHSHK_V << USB_OTGHS_DCFG_NZSTSOUTHSHK_S)
#define USB_OTGHS_DCFG_NZSTSOUTHSHK_V  0x00000001U
#define USB_OTGHS_DCFG_NZSTSOUTHSHK_S  2
/** USB_OTGHS_DCFG_ENA32KHZSUSP : R/W; bitpos: [3]; default: 0;
 *  Enable 32 KHz Suspend mode (Ena32KHzSusp)
 *
 *  This bit can be set only if FS PHY interface is selected. Otherwise, this bit needs
 *  to be set to zero. If FS PHY interface is chosen and this bit is set, the PHY clock
 *  during Suspend must be switched from 48 MHz to 32 KHz.
 */
#define USB_OTGHS_DCFG_ENA32KHZSUSP    (BIT(3))
#define USB_OTGHS_DCFG_ENA32KHZSUSP_M  (USB_OTGHS_DCFG_ENA32KHZSUSP_V << USB_OTGHS_DCFG_ENA32KHZSUSP_S)
#define USB_OTGHS_DCFG_ENA32KHZSUSP_V  0x00000001U
#define USB_OTGHS_DCFG_ENA32KHZSUSP_S  3
/** USB_OTGHS_DCFG_DEVADDR : R/W; bitpos: [10:4]; default: 0;
 *  Device Address (DevAddr)
 *
 *  The application must program this field after every SetAddress control command.
 */
#define USB_OTGHS_DCFG_DEVADDR    0x0000007FU
#define USB_OTGHS_DCFG_DEVADDR_M  (USB_OTGHS_DCFG_DEVADDR_V << USB_OTGHS_DCFG_DEVADDR_S)
#define USB_OTGHS_DCFG_DEVADDR_V  0x0000007FU
#define USB_OTGHS_DCFG_DEVADDR_S  4
/** USB_OTGHS_DCFG_PERFRINT : R/W; bitpos: [12:11]; default: 0;
 *  Periodic Frame Interval (PerFrInt)
 *
 *  Indicates the time within a (micro)Frame at which the application
 *  must be notified using the End Of Periodic Frame Interrupt. This
 *  can be used to determine If all the isochronous traffic for that
 *  (micro)Frame is complete.
 *  - 2'b00: 80% of the (micro)Frame interval
 *  - 2'b01: 85% of the (micro)Frame interval
 *  - 2'b10: 90% of the (micro)Frame interval
 *  - 2'b11: 95% of the (micro)Frame interval
 */
#define USB_OTGHS_DCFG_PERFRINT    0x00000003U
#define USB_OTGHS_DCFG_PERFRINT_M  (USB_OTGHS_DCFG_PERFRINT_V << USB_OTGHS_DCFG_PERFRINT_S)
#define USB_OTGHS_DCFG_PERFRINT_V  0x00000003U
#define USB_OTGHS_DCFG_PERFRINT_S  11
/** USB_OTGHS_DCFG_ENDEVOUTNAK : R/W; bitpos: [13]; default: 0;
 *  Enable Device OUT NAK (EnDevOutNak)
 *
 *  This bit enables setting NAK for Bulk OUT endpoints after the transfer is completed
 *  for Device mode Descriptor DMA
 *  - 1'b0 : The core does not set NAK after Bulk OUT transfer complete
 *  - 1'b1  :  The core sets NAK after Bulk OUT transfer complete
 *  This bit is one time programmable after reset like any other DCFG register bits.
 */
#define USB_OTGHS_DCFG_ENDEVOUTNAK    (BIT(13))
#define USB_OTGHS_DCFG_ENDEVOUTNAK_M  (USB_OTGHS_DCFG_ENDEVOUTNAK_V << USB_OTGHS_DCFG_ENDEVOUTNAK_S)
#define USB_OTGHS_DCFG_ENDEVOUTNAK_V  0x00000001U
#define USB_OTGHS_DCFG_ENDEVOUTNAK_S  13
/** USB_OTGHS_DCFG_XCVRDLY : R/W; bitpos: [14]; default: 0;
 *  XCVRDLY
 *
 *  Enables or disables delay between xcvr_sel and txvalid during device chirp
 */
#define USB_OTGHS_DCFG_XCVRDLY    (BIT(14))
#define USB_OTGHS_DCFG_XCVRDLY_M  (USB_OTGHS_DCFG_XCVRDLY_V << USB_OTGHS_DCFG_XCVRDLY_S)
#define USB_OTGHS_DCFG_XCVRDLY_V  0x00000001U
#define USB_OTGHS_DCFG_XCVRDLY_S  14
/** USB_OTGHS_DCFG_ERRATICINTMSK : R/W; bitpos: [15]; default: 0;
 *  Erratic Error Interrupt Mask
 */
#define USB_OTGHS_DCFG_ERRATICINTMSK    (BIT(15))
#define USB_OTGHS_DCFG_ERRATICINTMSK_M  (USB_OTGHS_DCFG_ERRATICINTMSK_V << USB_OTGHS_DCFG_ERRATICINTMSK_S)
#define USB_OTGHS_DCFG_ERRATICINTMSK_V  0x00000001U
#define USB_OTGHS_DCFG_ERRATICINTMSK_S  15
/** USB_OTGHS_DCFG_IPGISOCSUPT : R/W; bitpos: [17]; default: 1;
 *  Worst-Case Inter-Packet Gap ISOC OUT Support (ipgisocSupt)
 *
 *  This bit indicates that the controller supports the worst-case scenario of Rx
 *  followed by Rx Inter-Packet Gap (IPG) (32 bit times) as per the UTMI Specification
 *  for any token following an ISOC OUT token. Without this support, when any token
 *  follows an ISOC OUT token with the worst-case IPG, the controller does not detect
 *  the followed token. The worst-case IPG of the controller without this support
 *  depends on the AHB and PHY clock frequency.
 */
#define USB_OTGHS_DCFG_IPGISOCSUPT    (BIT(17))
#define USB_OTGHS_DCFG_IPGISOCSUPT_M  (USB_OTGHS_DCFG_IPGISOCSUPT_V << USB_OTGHS_DCFG_IPGISOCSUPT_S)
#define USB_OTGHS_DCFG_IPGISOCSUPT_V  0x00000001U
#define USB_OTGHS_DCFG_IPGISOCSUPT_S  17
/** USB_OTGHS_DCFG_DESCDMA : R/W; bitpos: [23]; default: 0;
 *  Enable Scatter/gather DMA in device mode (DescDMA).
 *
 *  When the Scatter/Gather DMA option selected during configuration of the RTL, the
 *  application can Set this bit during initialization to enable the Scatter/Gather DMA
 *  operation.
 *
 *  Note: This bit must be modified only once after a reset. The following combinations
 *  are available for programming:
 *  - GAHBCFG.DMAEn=0,DCFG.DescDMA=0 => Slave mode
 *  - GAHBCFG.DMAEn=0,DCFG.DescDMA=1 => Invalid
 *  - GAHBCFG.DMAEn=1,DCFG.DescDMA=0 => Buffered DMA mode
 *  - GAHBCFG.DMAEn=1,DCFG.DescDMA=1 => Scatter/Gather DMA mode
 */
#define USB_OTGHS_DCFG_DESCDMA    (BIT(23))
#define USB_OTGHS_DCFG_DESCDMA_M  (USB_OTGHS_DCFG_DESCDMA_V << USB_OTGHS_DCFG_DESCDMA_S)
#define USB_OTGHS_DCFG_DESCDMA_V  0x00000001U
#define USB_OTGHS_DCFG_DESCDMA_S  23
/** USB_OTGHS_DCFG_PERSCHINTVL : R/W; bitpos: [25:24]; default: 0;
 *  Periodic Scheduling Interval (PerSchIntvl)
 *
 *  PerSchIntvl must be programmed for Scatter/Gather DMA mode.
 *
 *  This field specifies the amount of time the Internal
 *  DMA engine must allocate for fetching periodic IN endpoint data.
 *  Based on the number of periodic endpoints, this value must be
 *  specified as 25,50 or 75% of (micro)Frame.
 *  - When any periodic endpoints are active, the internal DMA engine allocates the
 *  specified amount of time in fetching periodic IN endpoint data .
 *  - When no periodic endpoints are active, Then the internal DMA engine services
 *  non-periodic endpoints, ignoring this field.
 *  - After the specified time within a (micro)Frame, the DMA switches to fetching for
 *  non-periodic endpoints.
 *  -- 2'b00: 25% of (micro)Frame.
 *  -- 2'b01: 50% of (micro)Frame.
 *  -- 2'b10: 75% of (micro)Frame.
 *  -- 2'b11: Reserved.
 *  Reset: 2'b00
 */
#define USB_OTGHS_DCFG_PERSCHINTVL    0x00000003U
#define USB_OTGHS_DCFG_PERSCHINTVL_M  (USB_OTGHS_DCFG_PERSCHINTVL_V << USB_OTGHS_DCFG_PERSCHINTVL_S)
#define USB_OTGHS_DCFG_PERSCHINTVL_V  0x00000003U
#define USB_OTGHS_DCFG_PERSCHINTVL_S  24
/** USB_OTGHS_DCFG_RESVALID : R/W; bitpos: [31:26]; default: 2;
 *  Resume Validation Period (ResValid)
 *
 *  This field is effective only when DCFG.Ena32KHzSusp is set.
 *  It controls the resume period when the core resumes from
 *  suspend. The core counts for ResValid number of clock cycles
 *  to detect a valid resume when this bit is set
 */
#define USB_OTGHS_DCFG_RESVALID    0x0000003FU
#define USB_OTGHS_DCFG_RESVALID_M  (USB_OTGHS_DCFG_RESVALID_V << USB_OTGHS_DCFG_RESVALID_S)
#define USB_OTGHS_DCFG_RESVALID_V  0x0000003FU
#define USB_OTGHS_DCFG_RESVALID_S  26

/** USB_OTGHS_DCTL_REG register
 *  This register is used to control the characteristics of the Device controller.
 */
#define USB_OTGHS_DCTL_REG (DR_REG_USB_OTGHS_BASE + 0x804)
/** USB_OTGHS_DCTL_RMTWKUPSIG : R/W; bitpos: [0]; default: 0;
 *  Remote Wakeup Signaling (RmtWkUpSig)
 *
 *  When the application sets this bit, the core initiates remote
 *  signaling to wake up the USB host. The application must Set this
 *  bit to instruct the core to exit the Suspend state. As specified in
 *  the USB 2.0 specification, the application must clear this bit
 *  1-15 ms after setting it.
 *
 *
 *  If LPM is enabled and the core is in the L1 (Sleep) state, when the application
 *  sets this bit, the core initiates L1 remote signaling to wake up the USB host. The
 *  application must set this bit to instruct the core to exit the Sleep state. As
 *  specified in the LPM specification, the hardware automatically clears this bit 50
 *  microseconds (TL1DevDrvResume) after being set by the application. The application
 *  must not set this bit when GLPMCFG bRemoteWake from the previous LPM transaction is
 *  zero.
 */
#define USB_OTGHS_DCTL_RMTWKUPSIG    (BIT(0))
#define USB_OTGHS_DCTL_RMTWKUPSIG_M  (USB_OTGHS_DCTL_RMTWKUPSIG_V << USB_OTGHS_DCTL_RMTWKUPSIG_S)
#define USB_OTGHS_DCTL_RMTWKUPSIG_V  0x00000001U
#define USB_OTGHS_DCTL_RMTWKUPSIG_S  0
/** USB_OTGHS_DCTL_SFTDISCON : R/W; bitpos: [1]; default: 1;
 *  Soft Disconnect (SftDiscon)
 *
 *  The application uses this bit to signal the controller to do a soft disconnect. As
 *  long as this bit is set, the host does not see that the device is connected, and
 *  the device does not receive
 *  signals on the USB. The core stays in the disconnected state until the application
 *  clears this bit.
 *  - 1'b0: Normal operation. When this bit is cleared after a soft disconnect, the
 *  core drives the phy_opmode_o signal on the
 *  UTMI+ to 2'b00, which generates a device connect event to the USB host. When the
 *  device is reconnected, the USB host restarts device enumeration.
 *  - 1'b1: The core drives the phy_opmode_o signal on the UTMI+ to 2'b01, which
 *  generates a device disconnect event to the USB host.
 *  The following is the minimum duration under various conditions for which this bit
 *  must be set for the USB host to detect a device disconnect. To accommodate clock
 *  jitter, it is
 *  recommended that the application adds some extra delay to the specified minimum
 *  duration.
 *
 *  For high speed, if the device state is,
 *  - Suspended, the minimum duration is 1ms + 2.5us
 *  - Idle, the minimum duration is 3ms + 2.5us
 *  - Not Idle or Suspended (performing transactions), the minimum duration 125 us
 *  For full speed/low speed, if the device state is,
 *  - Suspended, the minimum duration is 1ms + 2.5us
 *  - Idle, the minimum duration is 2.5us
 *  - Not Idle or Suspended (performing transactions), the minimum duration 125 us
 *  Note:
 *  - This bit can be also used for ULPI/FS Serial interfaces.
 *  - This bit is not impacted by a soft reset.
 */
#define USB_OTGHS_DCTL_SFTDISCON    (BIT(1))
#define USB_OTGHS_DCTL_SFTDISCON_M  (USB_OTGHS_DCTL_SFTDISCON_V << USB_OTGHS_DCTL_SFTDISCON_S)
#define USB_OTGHS_DCTL_SFTDISCON_V  0x00000001U
#define USB_OTGHS_DCTL_SFTDISCON_S  1
/** USB_OTGHS_DCTL_GNPINNAKSTS : RO; bitpos: [2]; default: 0;
 *  Global Non-periodic IN NAK Status (GNPINNakSts)
 *  - 1'b0: A handshake is sent out based on the data availability in the transmit FIFO.
 *  - 1'b1: A NAK handshake is sent out on all non-periodic IN endpoints, irrespective
 *  of the data availability in the transmit FIFO.
 */
#define USB_OTGHS_DCTL_GNPINNAKSTS    (BIT(2))
#define USB_OTGHS_DCTL_GNPINNAKSTS_M  (USB_OTGHS_DCTL_GNPINNAKSTS_V << USB_OTGHS_DCTL_GNPINNAKSTS_S)
#define USB_OTGHS_DCTL_GNPINNAKSTS_V  0x00000001U
#define USB_OTGHS_DCTL_GNPINNAKSTS_S  2
/** USB_OTGHS_DCTL_GOUTNAKSTS : RO; bitpos: [3]; default: 0;
 *  Global OUT NAK Status (GOUTNakSts)
 *  - 1'b0: A handshake is sent based on the FIFO Status and the NAK and STALL bit
 *  settings.
 *  - 1'b1: No data is written to the RxFIFO, irrespective of space availability. Sends
 *  a NAK handshake on all packets, except on SETUP transactions. All isochronous OUT
 *  packets are dropped.
 */
#define USB_OTGHS_DCTL_GOUTNAKSTS    (BIT(3))
#define USB_OTGHS_DCTL_GOUTNAKSTS_M  (USB_OTGHS_DCTL_GOUTNAKSTS_V << USB_OTGHS_DCTL_GOUTNAKSTS_S)
#define USB_OTGHS_DCTL_GOUTNAKSTS_V  0x00000001U
#define USB_OTGHS_DCTL_GOUTNAKSTS_S  3
/** USB_OTGHS_DCTL_TSTCTL : R/W; bitpos: [6:4]; default: 0;
 *  Test Control (TstCtl)
 *  - 3'b000: Test mode disabled
 *  - 3'b001: Test_J mode
 *  - 3'b010: Test_K mode
 *  - 3'b011: Test_SE0_NAK mode
 *  - 3'b100: Test_Packet mode
 *  - 3'b101: Test_Force_Enable
 *  - Others: Reserved
 */
#define USB_OTGHS_DCTL_TSTCTL    0x00000007U
#define USB_OTGHS_DCTL_TSTCTL_M  (USB_OTGHS_DCTL_TSTCTL_V << USB_OTGHS_DCTL_TSTCTL_S)
#define USB_OTGHS_DCTL_TSTCTL_V  0x00000007U
#define USB_OTGHS_DCTL_TSTCTL_S  4
/** USB_OTGHS_DCTL_SGNPINNAK : R/W; bitpos: [7]; default: 0;
 *  Set Global Non-periodic IN NAK (SGNPInNak)
 *
 *  A write to this field sets the Global Non-periodic IN NAK.The application uses this
 *  bit to send a NAK handshake on all non-periodic IN endpoints.
 *  The core can also Set this bit when a timeout condition is detected on a
 *  non-periodic endpoint in shared FIFO operation.
 *  The application must Set this bit only after making sure that the Global IN NAK
 *  Effective bit in the Core Interrupt Register (GINTSTS.GINNakEff) is cleared
 */
#define USB_OTGHS_DCTL_SGNPINNAK    (BIT(7))
#define USB_OTGHS_DCTL_SGNPINNAK_M  (USB_OTGHS_DCTL_SGNPINNAK_V << USB_OTGHS_DCTL_SGNPINNAK_S)
#define USB_OTGHS_DCTL_SGNPINNAK_V  0x00000001U
#define USB_OTGHS_DCTL_SGNPINNAK_S  7
/** USB_OTGHS_DCTL_CGNPINNAK : R/W; bitpos: [8]; default: 0;
 *  Clear Global Non-periodic IN NAK (CGNPInNak)
 *
 *  A write to this field clears the Global Non-periodic IN NAK.
 */
#define USB_OTGHS_DCTL_CGNPINNAK    (BIT(8))
#define USB_OTGHS_DCTL_CGNPINNAK_M  (USB_OTGHS_DCTL_CGNPINNAK_V << USB_OTGHS_DCTL_CGNPINNAK_S)
#define USB_OTGHS_DCTL_CGNPINNAK_V  0x00000001U
#define USB_OTGHS_DCTL_CGNPINNAK_S  8
/** USB_OTGHS_DCTL_SGOUTNAK : R/W; bitpos: [9]; default: 0;
 *  Set Global OUT NAK (SGOUTNak)
 *
 *  A write to this field sets the Global OUT NAK. The application uses this bit to
 *  send a NAK handshake on all OUT endpoints.
 *  The application must set the this bit only after making sure that the Global OUT
 *  NAK Effective bit in the Core Interrupt Register (GINTSTS.GOUTNakEff) is cleared.
 */
#define USB_OTGHS_DCTL_SGOUTNAK    (BIT(9))
#define USB_OTGHS_DCTL_SGOUTNAK_M  (USB_OTGHS_DCTL_SGOUTNAK_V << USB_OTGHS_DCTL_SGOUTNAK_S)
#define USB_OTGHS_DCTL_SGOUTNAK_V  0x00000001U
#define USB_OTGHS_DCTL_SGOUTNAK_S  9
/** USB_OTGHS_DCTL_CGOUTNAK : R/W; bitpos: [10]; default: 0;
 *  Clear Global OUT NAK (CGOUTNak)
 *
 *  A write to this field clears the Global OUT NAK.
 */
#define USB_OTGHS_DCTL_CGOUTNAK    (BIT(10))
#define USB_OTGHS_DCTL_CGOUTNAK_M  (USB_OTGHS_DCTL_CGOUTNAK_V << USB_OTGHS_DCTL_CGOUTNAK_S)
#define USB_OTGHS_DCTL_CGOUTNAK_V  0x00000001U
#define USB_OTGHS_DCTL_CGOUTNAK_S  10
/** USB_OTGHS_DCTL_PWRONPRGDONE : R/W; bitpos: [11]; default: 0;
 *  Power-On Programming Done (PWROnPrgDone)
 *
 *  The application uses this bit to indicate that register programming is completed
 *  after a wake-up from Power Down mode.
 */
#define USB_OTGHS_DCTL_PWRONPRGDONE    (BIT(11))
#define USB_OTGHS_DCTL_PWRONPRGDONE_M  (USB_OTGHS_DCTL_PWRONPRGDONE_V << USB_OTGHS_DCTL_PWRONPRGDONE_S)
#define USB_OTGHS_DCTL_PWRONPRGDONE_V  0x00000001U
#define USB_OTGHS_DCTL_PWRONPRGDONE_S  11
/** USB_OTGHS_DCTL_GMC : R/W; bitpos: [14:13]; default: 0;
 *  Global Multi Count (GMC)
 *
 *  GMC must be programmed only once after initialization.
 *  Applicable only for Scatter/Gather DMA mode. This indicates the number of packets
 *  to be serviced for that end point before moving to the next end point. It is only
 *  for non-periodic endpoints.
 *  - 2'b00: Invalid.
 *  - 2'b01: 1 packet.
 *  - 2'b10: 2 packets.
 *  - 2'b11: 3 packets.
 *  The value of this field automatically changes to 2'h1 when DCFG.DescDMA is set to
 *  1. When Scatter/Gather DMA mode is disabled, this field is reserved. and reads
 *  2'b00.
 */
#define USB_OTGHS_DCTL_GMC    0x00000003U
#define USB_OTGHS_DCTL_GMC_M  (USB_OTGHS_DCTL_GMC_V << USB_OTGHS_DCTL_GMC_S)
#define USB_OTGHS_DCTL_GMC_V  0x00000003U
#define USB_OTGHS_DCTL_GMC_S  13
/** USB_OTGHS_DCTL_IGNRFRMNUM : R/W; bitpos: [15]; default: 0;
 *  Ignore Frame Number Feature for Isochronous Endpoints (IgnrFrmNum)
 *
 *  This field is also used to control the Periodic Transfer Interrupt (PTI) feature.
 *
 *  Note: Do not program IgnrFrmNum bit to 1'b1 when the core is operating in threshold
 *  mode.
 *
 *  Slave Mode (GAHBCFG.DMAEn=0):
 *
 *  This bit is not valid in Slave mode and must not be programmed to 1.
 *
 *  Scatter/Gather DMA Mode (GAHBCFG.DMAEn=1,DCFG.DescDMA=1):
 *
 *  Note: When Scatter/Gather DMA mode is enabled this feature is not applicable to
 *  High Speed, High bandwidth transfers.
 *
 *  When this bit is enabled, there must be only one packet per descriptor.
 *  - 0: The core transmits the packets only in the frame number in which they are
 *  intended to be transmitted.
 *  - 1: The core ignores the frame number, sending packets immediately as the packets
 *  are ready.
 *  In Scatter/Gather DMA mode, if this bit is enabled, the packets are not flushed
 *  when a ISOC IN token is received for an elapsed frame.
 *
 *  Non-Scatter/Gather DMA Mode, that is, Buffer DMA Mode
 *  (GAHBCFG.DMAEn=1,DCFG.DescDMA=0):
 *
 *  When Scatter/Gather DMA mode is disabled, this field is used by the application to
 *  enable Periodic Transfer Interrupt (PTI) Mode.
 *
 *  The application can program Periodic Endpoint transfers for multiple (micro)Frames.
 *  - 0: Periodic Transfer Interrupt feature is disabled, application needs to program
 *  transfers for periodic endpoints every (micro)Frame
 *  - 1: Periodic Transfer Interrupt feature is enabled, application can program
 *  transfers for multiple (micro)Frames for periodic endpoints.
 *  In the PTI mode, the application receives Transfer Complete Interrupt after
 *  transfers for multiple (micro)Frames are completed.
 */
#define USB_OTGHS_DCTL_IGNRFRMNUM    (BIT(15))
#define USB_OTGHS_DCTL_IGNRFRMNUM_M  (USB_OTGHS_DCTL_IGNRFRMNUM_V << USB_OTGHS_DCTL_IGNRFRMNUM_S)
#define USB_OTGHS_DCTL_IGNRFRMNUM_V  0x00000001U
#define USB_OTGHS_DCTL_IGNRFRMNUM_S  15
/** USB_OTGHS_DCTL_NAKONBBLE : R/W; bitpos: [16]; default: 0;
 *  NAK on Babble Error (NakOnBble)
 *
 *  Set NAK automatically on babble (NakOnBble). The core sets NAK automatically for
 *  the endpoint on which babble is received.
 */
#define USB_OTGHS_DCTL_NAKONBBLE    (BIT(16))
#define USB_OTGHS_DCTL_NAKONBBLE_M  (USB_OTGHS_DCTL_NAKONBBLE_V << USB_OTGHS_DCTL_NAKONBBLE_S)
#define USB_OTGHS_DCTL_NAKONBBLE_V  0x00000001U
#define USB_OTGHS_DCTL_NAKONBBLE_S  16
/** USB_OTGHS_DCTL_ENCONTONBNA : R/W; bitpos: [17]; default: 0;
 *  Enable Continue on BNA (EnContOnBNA)
 *
 *  This bit enables the core to continue on BNA for Bulk OUT endpoints.
 *  With this feature enabled, when a Bulk OUT or INTR OUT endpoint receives a BNA
 *  interrupt
 *  the core starts processing the descriptor that caused the BNA interrupt after
 *  the endpoint re-enables the endpoint.
 *  - 1'b0: After receiving BNA interrupt,the core disables the endpoint. When the
 *  endpoint is re-enabled by the application, the core starts processing from the
 *  DOEPDMA descriptor.
 *  - 1'b1: After receiving BNA interrupt, the core disables the endpoint. When the
 *  endpoint is re-enabled by the application, the core starts processing from the
 *  descriptor that received the BNA interrupt.
 *  This bit is valid only when OTG_EN_DESC_DMA == 1'b1. It is a one-time programmable
 *  after reset bit like any other DCTL register bits.
 */
#define USB_OTGHS_DCTL_ENCONTONBNA    (BIT(17))
#define USB_OTGHS_DCTL_ENCONTONBNA_M  (USB_OTGHS_DCTL_ENCONTONBNA_V << USB_OTGHS_DCTL_ENCONTONBNA_S)
#define USB_OTGHS_DCTL_ENCONTONBNA_V  0x00000001U
#define USB_OTGHS_DCTL_ENCONTONBNA_S  17
/** USB_OTGHS_DCTL_SERVINT : R/W; bitpos: [19]; default: 0;
 *  Service Interval based scheduling for Isochronous IN Endpoints
 *
 *  This field is used to enable service interval based scheduling feature for ISOC IN
 *  EPs.
 *
 *  Note: This bit is applicable only in device mode and when Scatter/Gather DMA mode
 *  is used. This feature must not be enabled along with DCTL.IgnrFrmNum.
 *
 *  Scatter/Gather DMA Mode (GAHBCFG.DMAEn=1,DCFG.DescDMA=1):
 *
 *  When this bit is enabled, the frame number field in the ISOC IN descriptor
 *  structure is interpreted as the last frame of the service interval.
 *  In Scatter/Gather DMA mode, if this bit is enabled, the pending packets are flushed
 *  by the controller at the last frame of the service interval.
 */
#define USB_OTGHS_DCTL_SERVINT    (BIT(19))
#define USB_OTGHS_DCTL_SERVINT_M  (USB_OTGHS_DCTL_SERVINT_V << USB_OTGHS_DCTL_SERVINT_S)
#define USB_OTGHS_DCTL_SERVINT_V  0x00000001U
#define USB_OTGHS_DCTL_SERVINT_S  19
/** USB_OTGHS_DCTL_UTMI_TXVLD_CORR_DIS : R/W; bitpos: [30]; default: 0;
 *  Disable the correction to OpMode/XcvrSel/TermSel on UTMI Interface.
 *
 *  When Soft disconnect (DCTL.SftDiscon=1'b1) is set by the application, the Device
 *  controller immediately changes the Opmode to Non-Driving (2'b01), XcvrSel to
 *  FS_XCVR (2'b01) and TermSel to HS_TERM (1'b1). If the Device controller is
 *  disconnected (DCTL.SftDiscon=1'b1) while transmitting a packet or a chirp, then the
 *  Device controller immediately changes the Opmode to Non-Driving (2'b01) while
 *  TxValid being High (1'b1). Certain PHYs may not respond to the TxValid by
 *  interpreting the change in OpMode to Non-Driving. The behavior of OpMode, XcvrSel
 *  and TermSel have been corrected to handle Soft disconnect during transmission. The
 *  application can set this register bit to 1'b1 to fall back to the original behavior
 *  of OpMode, XcvrSel, TermSel when Soft disconnect is set during transmission.
 *
 *  - 1'b0: Opmode, XcvrSel, TermSel are changed by the Device Controller after TxValid
 *  goes LOW (1'b0). When this bit is set to 1'b0, the Device controller changes
 *  Opmode, XcvrSel and TermSel when TxVlaid is low after assertion of Soft Disconnect.
 *  - 1'b1: Opmode, XcvrSel, TermSel are changed by the Device Controller immediately.
 *  When this bit is set to 1'b1, the Device controller changes Opmode, XcvrSel and
 *  TermSel immediately after assertion of Soft Disconnect.
 *
 *  Note: The application must program this register during Device Initialization
 *  before USB Reset and this value cannot be changed afterwards.
 */
#define USB_OTGHS_DCTL_UTMI_TXVLD_CORR_DIS    (BIT(30))
#define USB_OTGHS_DCTL_UTMI_TXVLD_CORR_DIS_M  (USB_OTGHS_DCTL_UTMI_TXVLD_CORR_DIS_V << USB_OTGHS_DCTL_UTMI_TXVLD_CORR_DIS_S)
#define USB_OTGHS_DCTL_UTMI_TXVLD_CORR_DIS_V  0x00000001U
#define USB_OTGHS_DCTL_UTMI_TXVLD_CORR_DIS_S  30
/** USB_OTGHS_DCTL_UTMI_TERMSEL_CORR_DIS : R/W; bitpos: [31]; default: 0;
 *  Disable the correction of TermSel on UTMI Interface.
 *
 *  When the application sets Soft disconnect (DCTL.SftDiscon=1'b1), the behavior of
 *  TermSel has been corrected to drive the valid combination of XcvrSel (FS_XCVR) and
 *  TermSel (FS_TERM). The application can set this register bit to 1'b1 to fall back
 *  to the original behavior of the Device controller driving XcvrSel (FS_XCVR) and
 *  TermSel (HS_TERM) when Soft disconnect is set (DCTL.SftDiscon=1'b1).
 *
 *  - 1'b0: Valid Combination of XcvrSel and TermSel is driven by the Device
 *  Controller. When this bit is set to 1'b0, the Device controller drives TermSel to 1
 *  upon assertion of Soft Disconnect which enables FS Termination.
 *  - 1'b1: Invalid Combination of XcvrSel and TermSel is driven by the Device
 *  Controller. When this bit is set to 1'b1, the Device controller drives TermSel to 0
 *  upon assertion of Soft Disconnect which enables HS Termination.
 *
 *  Note: The application must program this register during Device Initialization
 *  before USB Reset and this value cannot be changed afterwards.
 */
#define USB_OTGHS_DCTL_UTMI_TERMSEL_CORR_DIS    (BIT(31))
#define USB_OTGHS_DCTL_UTMI_TERMSEL_CORR_DIS_M  (USB_OTGHS_DCTL_UTMI_TERMSEL_CORR_DIS_V << USB_OTGHS_DCTL_UTMI_TERMSEL_CORR_DIS_S)
#define USB_OTGHS_DCTL_UTMI_TERMSEL_CORR_DIS_V  0x00000001U
#define USB_OTGHS_DCTL_UTMI_TERMSEL_CORR_DIS_S  31

/** USB_OTGHS_DSTS_REG register
 *  This register indicates the status of the core with respect to USB-related events.
 *  It must be read on interrupts from Device All Interrupts (DAINT) register.
 */
#define USB_OTGHS_DSTS_REG (DR_REG_USB_OTGHS_BASE + 0x808)
/** USB_OTGHS_DSTS_SUSPSTS : RO; bitpos: [0]; default: 0;
 *  Suspend Status (SuspSts)
 *
 *  In Device mode, this bit is set as long as a Suspend condition is
 *  detected on the USB. The core enters the Suspend state
 *  when there is no activity on the phy_line_state_i signal for an
 *  extended period of time. The core comes out of the suspend under the following
 *  conditions :
 *  - If there is any activity on the phy_line_state_i signal, or
 *  - If the application writes to the Remote Wakeup Signaling bit in the Device
 *  Control register (DCTL.RmtWkUpSig).
 *  When the core comes out of the suspend, this bit is set to 1'b0.
 */
#define USB_OTGHS_DSTS_SUSPSTS    (BIT(0))
#define USB_OTGHS_DSTS_SUSPSTS_M  (USB_OTGHS_DSTS_SUSPSTS_V << USB_OTGHS_DSTS_SUSPSTS_S)
#define USB_OTGHS_DSTS_SUSPSTS_V  0x00000001U
#define USB_OTGHS_DSTS_SUSPSTS_S  0
/** USB_OTGHS_DSTS_ENUMSPD : RO; bitpos: [2:1]; default: 1;
 *  Enumerated Speed (EnumSpd)
 *
 *  Indicates the speed at which the controller has come up
 *  after speed detection through a connect or reset sequence.
 *  - 2'b00: High speed (PHY clock is running at 30 or 60 MHz)
 *  - 2'b01: Full speed (PHY clock is running at 30 or 60 MHz)
 *  - 2'b10: Low speed (PHY clock is running at 6 MHz)
 *  - 2'b11: Full speed (PHY clock is running at 48 MHz)
 *  Low speed is not supported for devices using a UTMI+ PHY.
 */
#define USB_OTGHS_DSTS_ENUMSPD    0x00000003U
#define USB_OTGHS_DSTS_ENUMSPD_M  (USB_OTGHS_DSTS_ENUMSPD_V << USB_OTGHS_DSTS_ENUMSPD_S)
#define USB_OTGHS_DSTS_ENUMSPD_V  0x00000003U
#define USB_OTGHS_DSTS_ENUMSPD_S  1
/** USB_OTGHS_DSTS_ERRTICERR : RO; bitpos: [3]; default: 0;
 *  Erratic Error (ErrticErr)
 *
 *  The core sets this bit to report any erratic errors
 *  (phy_rxvalid_i/phy_rxvldh_i or phy_rxactive_i is asserted for at least 2 ms, due to
 *  PHY error) seen on the UTMI+.
 *  Due to erratic errors, the core goes into Suspended state and an interrupt is
 *  generated to the application with Early Suspend bit of the Core Interrupt register
 *  (GINTSTS.ErlySusp).
 *  If the early suspend is asserted due to an erratic error, the application must
 *  perform a PHY reset followed by a soft reset to controller.
 */
#define USB_OTGHS_DSTS_ERRTICERR    (BIT(3))
#define USB_OTGHS_DSTS_ERRTICERR_M  (USB_OTGHS_DSTS_ERRTICERR_V << USB_OTGHS_DSTS_ERRTICERR_S)
#define USB_OTGHS_DSTS_ERRTICERR_V  0x00000001U
#define USB_OTGHS_DSTS_ERRTICERR_S  3
/** USB_OTGHS_DSTS_SOFFN : RO; bitpos: [21:8]; default: 0;
 *  Frame or Microframe Number of the Received SOF  (SOFFN)
 *
 *  When the core is operating at high speed, this field contains a microframe number.
 *  When the core is operating at full or low speed, this field contains a Frame number.
 *
 *  Note: This register may return a non-zero value if read immediately after power-on
 *  reset.
 *  In case the register bit reads non-zero immediately after power-on reset, it does
 *  not
 *  indicate that SOF has been received from the host. The read value of this interrupt
 *  is
 *  valid only after a valid connection between host and device is established.
 */
#define USB_OTGHS_DSTS_SOFFN    0x00003FFFU
#define USB_OTGHS_DSTS_SOFFN_M  (USB_OTGHS_DSTS_SOFFN_V << USB_OTGHS_DSTS_SOFFN_S)
#define USB_OTGHS_DSTS_SOFFN_V  0x00003FFFU
#define USB_OTGHS_DSTS_SOFFN_S  8
/** USB_OTGHS_DSTS_DEVLNSTS : RO; bitpos: [23:22]; default: 0;
 *  Device Line Status (DevLnSts)
 *
 *  Indicates the current logic level USB data lines
 *  - DevLnSts[1]: Logic level of D+
 *  - DevLnSts[0]: Logic level of D-
 */
#define USB_OTGHS_DSTS_DEVLNSTS    0x00000003U
#define USB_OTGHS_DSTS_DEVLNSTS_M  (USB_OTGHS_DSTS_DEVLNSTS_V << USB_OTGHS_DSTS_DEVLNSTS_S)
#define USB_OTGHS_DSTS_DEVLNSTS_V  0x00000003U
#define USB_OTGHS_DSTS_DEVLNSTS_S  22

/** USB_OTGHS_DIEPMSK_REG register
 *  This register works with each of the Device IN Endpoint Interrupt (DIEPINTn)
 *  registers for all endpoints to generate an interrupt per IN endpoint. The IN
 *  endpoint interrupt for a specific status in the DIEPINTn register can be masked by
 *  writing to the corresponding bit in this register. Status bits are masked by
 *  default.
 */
#define USB_OTGHS_DIEPMSK_REG (DR_REG_USB_OTGHS_BASE + 0x810)
/** USB_OTGHS_DIEPMSK_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPMSK_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPMSK_XFERCOMPLMSK_M  (USB_OTGHS_DIEPMSK_XFERCOMPLMSK_V << USB_OTGHS_DIEPMSK_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPMSK_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPMSK_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPMSK_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPMSK_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPMSK_EPDISBLDMSK_M  (USB_OTGHS_DIEPMSK_EPDISBLDMSK_V << USB_OTGHS_DIEPMSK_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPMSK_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPMSK_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPMSK_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPMSK_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPMSK_AHBERRMSK_M  (USB_OTGHS_DIEPMSK_AHBERRMSK_V << USB_OTGHS_DIEPMSK_AHBERRMSK_S)
#define USB_OTGHS_DIEPMSK_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPMSK_AHBERRMSK_S  2
/** USB_OTGHS_DIEPMSK_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk) (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPMSK_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPMSK_TIMEOUTMSK_M  (USB_OTGHS_DIEPMSK_TIMEOUTMSK_V << USB_OTGHS_DIEPMSK_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPMSK_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPMSK_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPMSK_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask (INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPMSK_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPMSK_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPMSK_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPMSK_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPMSK_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPMSK_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPMSK_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPMSK_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPMSK_INTKNEPMISMSK_M  (USB_OTGHS_DIEPMSK_INTKNEPMISMSK_V << USB_OTGHS_DIEPMSK_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPMSK_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPMSK_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPMSK_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPMSK_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPMSK_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPMSK_INEPNAKEFFMSK_V << USB_OTGHS_DIEPMSK_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPMSK_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPMSK_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPMSK_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPMSK_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPMSK_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPMSK_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPMSK_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPMSK_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPMSK_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPMSK_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPMSK_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPMSK_BNAININTRMSK_M  (USB_OTGHS_DIEPMSK_BNAININTRMSK_V << USB_OTGHS_DIEPMSK_BNAININTRMSK_S)
#define USB_OTGHS_DIEPMSK_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPMSK_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPMSK_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPMSK_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPMSK_NAKMSK_M  (USB_OTGHS_DIEPMSK_NAKMSK_V << USB_OTGHS_DIEPMSK_NAKMSK_S)
#define USB_OTGHS_DIEPMSK_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPMSK_NAKMSK_S  13

/** USB_OTGHS_DOEPMSK_REG register
 *  This register works with each of the Device OUT Endpoint Interrupt (DOEPINTn)
 *  registers for all endpoints to generate an interrupt per OUT endpoint. The OUT
 *  endpoint interrupt for a specific status in the DOEPINTn register can be masked by
 *  writing into the corresponding bit in this register. Status bits are masked by
 *  default.
 */
#define USB_OTGHS_DOEPMSK_REG (DR_REG_USB_OTGHS_BASE + 0x814)
/** USB_OTGHS_DOEPMSK_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPMSK_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPMSK_XFERCOMPLMSK_M  (USB_OTGHS_DOEPMSK_XFERCOMPLMSK_V << USB_OTGHS_DOEPMSK_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPMSK_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPMSK_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPMSK_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPMSK_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPMSK_EPDISBLDMSK_M  (USB_OTGHS_DOEPMSK_EPDISBLDMSK_V << USB_OTGHS_DOEPMSK_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPMSK_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPMSK_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPMSK_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPMSK_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPMSK_AHBERRMSK_M  (USB_OTGHS_DOEPMSK_AHBERRMSK_V << USB_OTGHS_DOEPMSK_AHBERRMSK_S)
#define USB_OTGHS_DOEPMSK_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPMSK_AHBERRMSK_S  2
/** USB_OTGHS_DOEPMSK_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPMSK_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPMSK_SETUPMSK_M  (USB_OTGHS_DOEPMSK_SETUPMSK_V << USB_OTGHS_DOEPMSK_SETUPMSK_S)
#define USB_OTGHS_DOEPMSK_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPMSK_SETUPMSK_S  3
/** USB_OTGHS_DOEPMSK_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPMSK_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPMSK_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPMSK_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPMSK_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPMSK_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPMSK_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPMSK_STSPHSERCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhseRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPMSK_STSPHSERCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPMSK_STSPHSERCVDMSK_M  (USB_OTGHS_DOEPMSK_STSPHSERCVDMSK_V << USB_OTGHS_DOEPMSK_STSPHSERCVDMSK_S)
#define USB_OTGHS_DOEPMSK_STSPHSERCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPMSK_STSPHSERCVDMSK_S  5
/** USB_OTGHS_DOEPMSK_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPMSK_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPMSK_BACK2BACKSETUP_M  (USB_OTGHS_DOEPMSK_BACK2BACKSETUP_V << USB_OTGHS_DOEPMSK_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPMSK_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPMSK_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPMSK_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPMSK_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPMSK_OUTPKTERRMSK_M  (USB_OTGHS_DOEPMSK_OUTPKTERRMSK_V << USB_OTGHS_DOEPMSK_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPMSK_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPMSK_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPMSK_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPMSK_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPMSK_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPMSK_BNAOUTINTRMSK_V << USB_OTGHS_DOEPMSK_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPMSK_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPMSK_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPMSK_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPMSK_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPMSK_BBLEERRMSK_M  (USB_OTGHS_DOEPMSK_BBLEERRMSK_V << USB_OTGHS_DOEPMSK_BBLEERRMSK_S)
#define USB_OTGHS_DOEPMSK_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPMSK_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPMSK_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPMSK_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPMSK_NAKMSK_M  (USB_OTGHS_DOEPMSK_NAKMSK_V << USB_OTGHS_DOEPMSK_NAKMSK_S)
#define USB_OTGHS_DOEPMSK_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPMSK_NAKMSK_S  13
/** USB_OTGHS_DOEPMSK_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPMSK_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPMSK_NYETMSK_M  (USB_OTGHS_DOEPMSK_NYETMSK_V << USB_OTGHS_DOEPMSK_NYETMSK_S)
#define USB_OTGHS_DOEPMSK_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPMSK_NYETMSK_S  14

/** USB_OTGHS_DAINT_REG register
 *  When a significant event occurs on an endpoint, a Device All Endpoints Interrupt
 *  register interrupts the application using the Device OUT Endpoints Interrupt bit or
 *  Device IN Endpoints Interrupt bit of the Core Interrupt register (GINTSTS.OEPInt or
 *  GINTSTS.IEPInt, respectively). This is shown in Figure 5-2. There is one interrupt
 *  bit per endpoint, up to a maximum of 16 bits for OUT endpoints and 16 bits for IN
 *  endpoints. For a bidirectional endpoint, the corresponding IN and OUT interrupt
 *  bits are used. Bits in this register are set and cleared when the application sets
 *  and clears bits in the corresponding Device Endpoint-n Interrupt register
 *  (DIEPINTn/DOEPINTn).
 */
#define USB_OTGHS_DAINT_REG (DR_REG_USB_OTGHS_BASE + 0x818)
/** USB_OTGHS_DAINT_INEPINT0 : RO; bitpos: [0]; default: 0;
 *  IN Endpoint 0 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT0    (BIT(0))
#define USB_OTGHS_DAINT_INEPINT0_M  (USB_OTGHS_DAINT_INEPINT0_V << USB_OTGHS_DAINT_INEPINT0_S)
#define USB_OTGHS_DAINT_INEPINT0_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT0_S  0
/** USB_OTGHS_DAINT_INEPINT1 : RO; bitpos: [1]; default: 0;
 *  IN Endpoint 1 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT1    (BIT(1))
#define USB_OTGHS_DAINT_INEPINT1_M  (USB_OTGHS_DAINT_INEPINT1_V << USB_OTGHS_DAINT_INEPINT1_S)
#define USB_OTGHS_DAINT_INEPINT1_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT1_S  1
/** USB_OTGHS_DAINT_INEPINT2 : RO; bitpos: [2]; default: 0;
 *  IN Endpoint 2 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT2    (BIT(2))
#define USB_OTGHS_DAINT_INEPINT2_M  (USB_OTGHS_DAINT_INEPINT2_V << USB_OTGHS_DAINT_INEPINT2_S)
#define USB_OTGHS_DAINT_INEPINT2_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT2_S  2
/** USB_OTGHS_DAINT_INEPINT3 : RO; bitpos: [3]; default: 0;
 *  IN Endpoint 3 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT3    (BIT(3))
#define USB_OTGHS_DAINT_INEPINT3_M  (USB_OTGHS_DAINT_INEPINT3_V << USB_OTGHS_DAINT_INEPINT3_S)
#define USB_OTGHS_DAINT_INEPINT3_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT3_S  3
/** USB_OTGHS_DAINT_INEPINT4 : RO; bitpos: [4]; default: 0;
 *  IN Endpoint 4 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT4    (BIT(4))
#define USB_OTGHS_DAINT_INEPINT4_M  (USB_OTGHS_DAINT_INEPINT4_V << USB_OTGHS_DAINT_INEPINT4_S)
#define USB_OTGHS_DAINT_INEPINT4_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT4_S  4
/** USB_OTGHS_DAINT_INEPINT5 : RO; bitpos: [5]; default: 0;
 *  IN Endpoint 5 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT5    (BIT(5))
#define USB_OTGHS_DAINT_INEPINT5_M  (USB_OTGHS_DAINT_INEPINT5_V << USB_OTGHS_DAINT_INEPINT5_S)
#define USB_OTGHS_DAINT_INEPINT5_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT5_S  5
/** USB_OTGHS_DAINT_INEPINT6 : RO; bitpos: [6]; default: 0;
 *  IN Endpoint 6 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT6    (BIT(6))
#define USB_OTGHS_DAINT_INEPINT6_M  (USB_OTGHS_DAINT_INEPINT6_V << USB_OTGHS_DAINT_INEPINT6_S)
#define USB_OTGHS_DAINT_INEPINT6_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT6_S  6
/** USB_OTGHS_DAINT_INEPINT7 : RO; bitpos: [7]; default: 0;
 *  IN Endpoint 7 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT7    (BIT(7))
#define USB_OTGHS_DAINT_INEPINT7_M  (USB_OTGHS_DAINT_INEPINT7_V << USB_OTGHS_DAINT_INEPINT7_S)
#define USB_OTGHS_DAINT_INEPINT7_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT7_S  7
/** USB_OTGHS_DAINT_INEPINT8 : RO; bitpos: [8]; default: 0;
 *  IN Endpoint 8 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT8    (BIT(8))
#define USB_OTGHS_DAINT_INEPINT8_M  (USB_OTGHS_DAINT_INEPINT8_V << USB_OTGHS_DAINT_INEPINT8_S)
#define USB_OTGHS_DAINT_INEPINT8_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT8_S  8
/** USB_OTGHS_DAINT_INEPINT9 : RO; bitpos: [9]; default: 0;
 *  IN Endpoint 9 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT9    (BIT(9))
#define USB_OTGHS_DAINT_INEPINT9_M  (USB_OTGHS_DAINT_INEPINT9_V << USB_OTGHS_DAINT_INEPINT9_S)
#define USB_OTGHS_DAINT_INEPINT9_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT9_S  9
/** USB_OTGHS_DAINT_INEPINT10 : RO; bitpos: [10]; default: 0;
 *  IN Endpoint 10 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT10    (BIT(10))
#define USB_OTGHS_DAINT_INEPINT10_M  (USB_OTGHS_DAINT_INEPINT10_V << USB_OTGHS_DAINT_INEPINT10_S)
#define USB_OTGHS_DAINT_INEPINT10_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT10_S  10
/** USB_OTGHS_DAINT_INEPINT11 : RO; bitpos: [11]; default: 0;
 *  IN Endpoint 11 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT11    (BIT(11))
#define USB_OTGHS_DAINT_INEPINT11_M  (USB_OTGHS_DAINT_INEPINT11_V << USB_OTGHS_DAINT_INEPINT11_S)
#define USB_OTGHS_DAINT_INEPINT11_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT11_S  11
/** USB_OTGHS_DAINT_INEPINT12 : RO; bitpos: [12]; default: 0;
 *  IN Endpoint 12 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT12    (BIT(12))
#define USB_OTGHS_DAINT_INEPINT12_M  (USB_OTGHS_DAINT_INEPINT12_V << USB_OTGHS_DAINT_INEPINT12_S)
#define USB_OTGHS_DAINT_INEPINT12_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT12_S  12
/** USB_OTGHS_DAINT_INEPINT13 : RO; bitpos: [13]; default: 0;
 *  IN Endpoint 13 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT13    (BIT(13))
#define USB_OTGHS_DAINT_INEPINT13_M  (USB_OTGHS_DAINT_INEPINT13_V << USB_OTGHS_DAINT_INEPINT13_S)
#define USB_OTGHS_DAINT_INEPINT13_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT13_S  13
/** USB_OTGHS_DAINT_INEPINT14 : RO; bitpos: [14]; default: 0;
 *  IN Endpoint 14 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT14    (BIT(14))
#define USB_OTGHS_DAINT_INEPINT14_M  (USB_OTGHS_DAINT_INEPINT14_V << USB_OTGHS_DAINT_INEPINT14_S)
#define USB_OTGHS_DAINT_INEPINT14_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT14_S  14
/** USB_OTGHS_DAINT_INEPINT15 : RO; bitpos: [15]; default: 0;
 *  IN Endpoint 15 Interrupt Bit
 */
#define USB_OTGHS_DAINT_INEPINT15    (BIT(15))
#define USB_OTGHS_DAINT_INEPINT15_M  (USB_OTGHS_DAINT_INEPINT15_V << USB_OTGHS_DAINT_INEPINT15_S)
#define USB_OTGHS_DAINT_INEPINT15_V  0x00000001U
#define USB_OTGHS_DAINT_INEPINT15_S  15
/** USB_OTGHS_DAINT_OUTEPINT0 : RO; bitpos: [16]; default: 0;
 *  OUT Endpoint 0 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT0    (BIT(16))
#define USB_OTGHS_DAINT_OUTEPINT0_M  (USB_OTGHS_DAINT_OUTEPINT0_V << USB_OTGHS_DAINT_OUTEPINT0_S)
#define USB_OTGHS_DAINT_OUTEPINT0_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT0_S  16
/** USB_OTGHS_DAINT_OUTEPINT1 : RO; bitpos: [17]; default: 0;
 *  OUT Endpoint 1 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT1    (BIT(17))
#define USB_OTGHS_DAINT_OUTEPINT1_M  (USB_OTGHS_DAINT_OUTEPINT1_V << USB_OTGHS_DAINT_OUTEPINT1_S)
#define USB_OTGHS_DAINT_OUTEPINT1_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT1_S  17
/** USB_OTGHS_DAINT_OUTEPINT2 : RO; bitpos: [18]; default: 0;
 *  OUT Endpoint 2 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT2    (BIT(18))
#define USB_OTGHS_DAINT_OUTEPINT2_M  (USB_OTGHS_DAINT_OUTEPINT2_V << USB_OTGHS_DAINT_OUTEPINT2_S)
#define USB_OTGHS_DAINT_OUTEPINT2_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT2_S  18
/** USB_OTGHS_DAINT_OUTEPINT3 : RO; bitpos: [19]; default: 0;
 *  OUT Endpoint 3 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT3    (BIT(19))
#define USB_OTGHS_DAINT_OUTEPINT3_M  (USB_OTGHS_DAINT_OUTEPINT3_V << USB_OTGHS_DAINT_OUTEPINT3_S)
#define USB_OTGHS_DAINT_OUTEPINT3_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT3_S  19
/** USB_OTGHS_DAINT_OUTEPINT4 : RO; bitpos: [20]; default: 0;
 *  OUT Endpoint 4 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT4    (BIT(20))
#define USB_OTGHS_DAINT_OUTEPINT4_M  (USB_OTGHS_DAINT_OUTEPINT4_V << USB_OTGHS_DAINT_OUTEPINT4_S)
#define USB_OTGHS_DAINT_OUTEPINT4_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT4_S  20
/** USB_OTGHS_DAINT_OUTEPINT5 : RO; bitpos: [21]; default: 0;
 *  OUT Endpoint 5 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT5    (BIT(21))
#define USB_OTGHS_DAINT_OUTEPINT5_M  (USB_OTGHS_DAINT_OUTEPINT5_V << USB_OTGHS_DAINT_OUTEPINT5_S)
#define USB_OTGHS_DAINT_OUTEPINT5_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT5_S  21
/** USB_OTGHS_DAINT_OUTEPINT6 : RO; bitpos: [22]; default: 0;
 *  OUT Endpoint 6 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT6    (BIT(22))
#define USB_OTGHS_DAINT_OUTEPINT6_M  (USB_OTGHS_DAINT_OUTEPINT6_V << USB_OTGHS_DAINT_OUTEPINT6_S)
#define USB_OTGHS_DAINT_OUTEPINT6_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT6_S  22
/** USB_OTGHS_DAINT_OUTEPINT7 : RO; bitpos: [23]; default: 0;
 *  OUT Endpoint 7 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT7    (BIT(23))
#define USB_OTGHS_DAINT_OUTEPINT7_M  (USB_OTGHS_DAINT_OUTEPINT7_V << USB_OTGHS_DAINT_OUTEPINT7_S)
#define USB_OTGHS_DAINT_OUTEPINT7_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT7_S  23
/** USB_OTGHS_DAINT_OUTEPINT8 : RO; bitpos: [24]; default: 0;
 *  OUT Endpoint 8 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT8    (BIT(24))
#define USB_OTGHS_DAINT_OUTEPINT8_M  (USB_OTGHS_DAINT_OUTEPINT8_V << USB_OTGHS_DAINT_OUTEPINT8_S)
#define USB_OTGHS_DAINT_OUTEPINT8_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT8_S  24
/** USB_OTGHS_DAINT_OUTEPINT9 : RO; bitpos: [25]; default: 0;
 *  OUT Endpoint 9 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT9    (BIT(25))
#define USB_OTGHS_DAINT_OUTEPINT9_M  (USB_OTGHS_DAINT_OUTEPINT9_V << USB_OTGHS_DAINT_OUTEPINT9_S)
#define USB_OTGHS_DAINT_OUTEPINT9_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT9_S  25
/** USB_OTGHS_DAINT_OUTEPINT10 : RO; bitpos: [26]; default: 0;
 *  OUT Endpoint 10 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT10    (BIT(26))
#define USB_OTGHS_DAINT_OUTEPINT10_M  (USB_OTGHS_DAINT_OUTEPINT10_V << USB_OTGHS_DAINT_OUTEPINT10_S)
#define USB_OTGHS_DAINT_OUTEPINT10_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT10_S  26
/** USB_OTGHS_DAINT_OUTEPINT11 : RO; bitpos: [27]; default: 0;
 *  OUT Endpoint 11 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT11    (BIT(27))
#define USB_OTGHS_DAINT_OUTEPINT11_M  (USB_OTGHS_DAINT_OUTEPINT11_V << USB_OTGHS_DAINT_OUTEPINT11_S)
#define USB_OTGHS_DAINT_OUTEPINT11_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT11_S  27
/** USB_OTGHS_DAINT_OUTEPINT12 : RO; bitpos: [28]; default: 0;
 *  OUT Endpoint 12 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT12    (BIT(28))
#define USB_OTGHS_DAINT_OUTEPINT12_M  (USB_OTGHS_DAINT_OUTEPINT12_V << USB_OTGHS_DAINT_OUTEPINT12_S)
#define USB_OTGHS_DAINT_OUTEPINT12_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT12_S  28
/** USB_OTGHS_DAINT_OUTEPINT13 : RO; bitpos: [29]; default: 0;
 *  OUT Endpoint 13 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT13    (BIT(29))
#define USB_OTGHS_DAINT_OUTEPINT13_M  (USB_OTGHS_DAINT_OUTEPINT13_V << USB_OTGHS_DAINT_OUTEPINT13_S)
#define USB_OTGHS_DAINT_OUTEPINT13_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT13_S  29
/** USB_OTGHS_DAINT_OUTEPINT14 : RO; bitpos: [30]; default: 0;
 *  OUT Endpoint 14 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT14    (BIT(30))
#define USB_OTGHS_DAINT_OUTEPINT14_M  (USB_OTGHS_DAINT_OUTEPINT14_V << USB_OTGHS_DAINT_OUTEPINT14_S)
#define USB_OTGHS_DAINT_OUTEPINT14_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT14_S  30
/** USB_OTGHS_DAINT_OUTEPINT15 : RO; bitpos: [31]; default: 0;
 *  OUT Endpoint 15 Interrupt Bit
 */
#define USB_OTGHS_DAINT_OUTEPINT15    (BIT(31))
#define USB_OTGHS_DAINT_OUTEPINT15_M  (USB_OTGHS_DAINT_OUTEPINT15_V << USB_OTGHS_DAINT_OUTEPINT15_S)
#define USB_OTGHS_DAINT_OUTEPINT15_V  0x00000001U
#define USB_OTGHS_DAINT_OUTEPINT15_S  31

/** USB_OTGHS_DAINTMSK_REG register
 *  The Device Endpoint Interrupt Mask register works with the Device Endpoint
 *  Interrupt register to interrupt the application when an event occurs on a device
 *  endpoint. However, the Device All Endpoints Interrupt (DAINT) register bit
 *  corresponding to that interrupt is still set.
 */
#define USB_OTGHS_DAINTMSK_REG (DR_REG_USB_OTGHS_BASE + 0x81c)
/** USB_OTGHS_DAINTMSK_INEPMSK0 : R/W; bitpos: [0]; default: 0;
 *  IN Endpoint 0 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK0    (BIT(0))
#define USB_OTGHS_DAINTMSK_INEPMSK0_M  (USB_OTGHS_DAINTMSK_INEPMSK0_V << USB_OTGHS_DAINTMSK_INEPMSK0_S)
#define USB_OTGHS_DAINTMSK_INEPMSK0_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK0_S  0
/** USB_OTGHS_DAINTMSK_INEPMSK1 : R/W; bitpos: [1]; default: 0;
 *  IN Endpoint 1 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK1    (BIT(1))
#define USB_OTGHS_DAINTMSK_INEPMSK1_M  (USB_OTGHS_DAINTMSK_INEPMSK1_V << USB_OTGHS_DAINTMSK_INEPMSK1_S)
#define USB_OTGHS_DAINTMSK_INEPMSK1_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK1_S  1
/** USB_OTGHS_DAINTMSK_INEPMSK2 : R/W; bitpos: [2]; default: 0;
 *  IN Endpoint 2 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK2    (BIT(2))
#define USB_OTGHS_DAINTMSK_INEPMSK2_M  (USB_OTGHS_DAINTMSK_INEPMSK2_V << USB_OTGHS_DAINTMSK_INEPMSK2_S)
#define USB_OTGHS_DAINTMSK_INEPMSK2_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK2_S  2
/** USB_OTGHS_DAINTMSK_INEPMSK3 : R/W; bitpos: [3]; default: 0;
 *  IN Endpoint 3 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK3    (BIT(3))
#define USB_OTGHS_DAINTMSK_INEPMSK3_M  (USB_OTGHS_DAINTMSK_INEPMSK3_V << USB_OTGHS_DAINTMSK_INEPMSK3_S)
#define USB_OTGHS_DAINTMSK_INEPMSK3_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK3_S  3
/** USB_OTGHS_DAINTMSK_INEPMSK4 : R/W; bitpos: [4]; default: 0;
 *  IN Endpoint 4 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK4    (BIT(4))
#define USB_OTGHS_DAINTMSK_INEPMSK4_M  (USB_OTGHS_DAINTMSK_INEPMSK4_V << USB_OTGHS_DAINTMSK_INEPMSK4_S)
#define USB_OTGHS_DAINTMSK_INEPMSK4_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK4_S  4
/** USB_OTGHS_DAINTMSK_INEPMSK5 : R/W; bitpos: [5]; default: 0;
 *  IN Endpoint 5 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK5    (BIT(5))
#define USB_OTGHS_DAINTMSK_INEPMSK5_M  (USB_OTGHS_DAINTMSK_INEPMSK5_V << USB_OTGHS_DAINTMSK_INEPMSK5_S)
#define USB_OTGHS_DAINTMSK_INEPMSK5_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK5_S  5
/** USB_OTGHS_DAINTMSK_INEPMSK6 : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint 6 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK6    (BIT(6))
#define USB_OTGHS_DAINTMSK_INEPMSK6_M  (USB_OTGHS_DAINTMSK_INEPMSK6_V << USB_OTGHS_DAINTMSK_INEPMSK6_S)
#define USB_OTGHS_DAINTMSK_INEPMSK6_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK6_S  6
/** USB_OTGHS_DAINTMSK_INEPMSK7 : R/W; bitpos: [7]; default: 0;
 *  IN Endpoint 7 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK7    (BIT(7))
#define USB_OTGHS_DAINTMSK_INEPMSK7_M  (USB_OTGHS_DAINTMSK_INEPMSK7_V << USB_OTGHS_DAINTMSK_INEPMSK7_S)
#define USB_OTGHS_DAINTMSK_INEPMSK7_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK7_S  7
/** USB_OTGHS_DAINTMSK_INEPMSK8 : R/W; bitpos: [8]; default: 0;
 *  IN Endpoint 8 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK8    (BIT(8))
#define USB_OTGHS_DAINTMSK_INEPMSK8_M  (USB_OTGHS_DAINTMSK_INEPMSK8_V << USB_OTGHS_DAINTMSK_INEPMSK8_S)
#define USB_OTGHS_DAINTMSK_INEPMSK8_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK8_S  8
/** USB_OTGHS_DAINTMSK_INEPMSK9 : R/W; bitpos: [9]; default: 0;
 *  IN Endpoint 9 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK9    (BIT(9))
#define USB_OTGHS_DAINTMSK_INEPMSK9_M  (USB_OTGHS_DAINTMSK_INEPMSK9_V << USB_OTGHS_DAINTMSK_INEPMSK9_S)
#define USB_OTGHS_DAINTMSK_INEPMSK9_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK9_S  9
/** USB_OTGHS_DAINTMSK_INEPMSK10 : R/W; bitpos: [10]; default: 0;
 *  IN Endpoint 10 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK10    (BIT(10))
#define USB_OTGHS_DAINTMSK_INEPMSK10_M  (USB_OTGHS_DAINTMSK_INEPMSK10_V << USB_OTGHS_DAINTMSK_INEPMSK10_S)
#define USB_OTGHS_DAINTMSK_INEPMSK10_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK10_S  10
/** USB_OTGHS_DAINTMSK_INEPMSK11 : R/W; bitpos: [11]; default: 0;
 *  IN Endpoint 11 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK11    (BIT(11))
#define USB_OTGHS_DAINTMSK_INEPMSK11_M  (USB_OTGHS_DAINTMSK_INEPMSK11_V << USB_OTGHS_DAINTMSK_INEPMSK11_S)
#define USB_OTGHS_DAINTMSK_INEPMSK11_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK11_S  11
/** USB_OTGHS_DAINTMSK_INEPMSK12 : R/W; bitpos: [12]; default: 0;
 *  IN Endpoint 12 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK12    (BIT(12))
#define USB_OTGHS_DAINTMSK_INEPMSK12_M  (USB_OTGHS_DAINTMSK_INEPMSK12_V << USB_OTGHS_DAINTMSK_INEPMSK12_S)
#define USB_OTGHS_DAINTMSK_INEPMSK12_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK12_S  12
/** USB_OTGHS_DAINTMSK_INEPMSK13 : R/W; bitpos: [13]; default: 0;
 *  IN Endpoint 13 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK13    (BIT(13))
#define USB_OTGHS_DAINTMSK_INEPMSK13_M  (USB_OTGHS_DAINTMSK_INEPMSK13_V << USB_OTGHS_DAINTMSK_INEPMSK13_S)
#define USB_OTGHS_DAINTMSK_INEPMSK13_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK13_S  13
/** USB_OTGHS_DAINTMSK_INEPMSK14 : R/W; bitpos: [14]; default: 0;
 *  IN Endpoint 14 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK14    (BIT(14))
#define USB_OTGHS_DAINTMSK_INEPMSK14_M  (USB_OTGHS_DAINTMSK_INEPMSK14_V << USB_OTGHS_DAINTMSK_INEPMSK14_S)
#define USB_OTGHS_DAINTMSK_INEPMSK14_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK14_S  14
/** USB_OTGHS_DAINTMSK_INEPMSK15 : R/W; bitpos: [15]; default: 0;
 *  IN Endpoint 15 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_INEPMSK15    (BIT(15))
#define USB_OTGHS_DAINTMSK_INEPMSK15_M  (USB_OTGHS_DAINTMSK_INEPMSK15_V << USB_OTGHS_DAINTMSK_INEPMSK15_S)
#define USB_OTGHS_DAINTMSK_INEPMSK15_V  0x00000001U
#define USB_OTGHS_DAINTMSK_INEPMSK15_S  15
/** USB_OTGHS_DAINTMSK_OUTEPMSK0 : R/W; bitpos: [16]; default: 0;
 *  OUT Endpoint 0 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK0    (BIT(16))
#define USB_OTGHS_DAINTMSK_OUTEPMSK0_M  (USB_OTGHS_DAINTMSK_OUTEPMSK0_V << USB_OTGHS_DAINTMSK_OUTEPMSK0_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK0_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK0_S  16
/** USB_OTGHS_DAINTMSK_OUTEPMSK1 : R/W; bitpos: [17]; default: 0;
 *  OUT Endpoint 1 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK1    (BIT(17))
#define USB_OTGHS_DAINTMSK_OUTEPMSK1_M  (USB_OTGHS_DAINTMSK_OUTEPMSK1_V << USB_OTGHS_DAINTMSK_OUTEPMSK1_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK1_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK1_S  17
/** USB_OTGHS_DAINTMSK_OUTEPMSK2 : R/W; bitpos: [18]; default: 0;
 *  OUT Endpoint 2 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK2    (BIT(18))
#define USB_OTGHS_DAINTMSK_OUTEPMSK2_M  (USB_OTGHS_DAINTMSK_OUTEPMSK2_V << USB_OTGHS_DAINTMSK_OUTEPMSK2_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK2_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK2_S  18
/** USB_OTGHS_DAINTMSK_OUTEPMSK3 : R/W; bitpos: [19]; default: 0;
 *  OUT Endpoint 3 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK3    (BIT(19))
#define USB_OTGHS_DAINTMSK_OUTEPMSK3_M  (USB_OTGHS_DAINTMSK_OUTEPMSK3_V << USB_OTGHS_DAINTMSK_OUTEPMSK3_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK3_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK3_S  19
/** USB_OTGHS_DAINTMSK_OUTEPMSK4 : R/W; bitpos: [20]; default: 0;
 *  OUT Endpoint 4 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK4    (BIT(20))
#define USB_OTGHS_DAINTMSK_OUTEPMSK4_M  (USB_OTGHS_DAINTMSK_OUTEPMSK4_V << USB_OTGHS_DAINTMSK_OUTEPMSK4_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK4_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK4_S  20
/** USB_OTGHS_DAINTMSK_OUTEPMSK5 : R/W; bitpos: [21]; default: 0;
 *  OUT Endpoint 5 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK5    (BIT(21))
#define USB_OTGHS_DAINTMSK_OUTEPMSK5_M  (USB_OTGHS_DAINTMSK_OUTEPMSK5_V << USB_OTGHS_DAINTMSK_OUTEPMSK5_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK5_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK5_S  21
/** USB_OTGHS_DAINTMSK_OUTEPMSK6 : R/W; bitpos: [22]; default: 0;
 *  OUT Endpoint 6 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK6    (BIT(22))
#define USB_OTGHS_DAINTMSK_OUTEPMSK6_M  (USB_OTGHS_DAINTMSK_OUTEPMSK6_V << USB_OTGHS_DAINTMSK_OUTEPMSK6_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK6_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK6_S  22
/** USB_OTGHS_DAINTMSK_OUTEPMSK7 : R/W; bitpos: [23]; default: 0;
 *  OUT Endpoint 7 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK7    (BIT(23))
#define USB_OTGHS_DAINTMSK_OUTEPMSK7_M  (USB_OTGHS_DAINTMSK_OUTEPMSK7_V << USB_OTGHS_DAINTMSK_OUTEPMSK7_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK7_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK7_S  23
/** USB_OTGHS_DAINTMSK_OUTEPMSK8 : R/W; bitpos: [24]; default: 0;
 *  OUT Endpoint 8 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK8    (BIT(24))
#define USB_OTGHS_DAINTMSK_OUTEPMSK8_M  (USB_OTGHS_DAINTMSK_OUTEPMSK8_V << USB_OTGHS_DAINTMSK_OUTEPMSK8_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK8_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK8_S  24
/** USB_OTGHS_DAINTMSK_OUTEPMSK9 : R/W; bitpos: [25]; default: 0;
 *  OUT Endpoint 9 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK9    (BIT(25))
#define USB_OTGHS_DAINTMSK_OUTEPMSK9_M  (USB_OTGHS_DAINTMSK_OUTEPMSK9_V << USB_OTGHS_DAINTMSK_OUTEPMSK9_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK9_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK9_S  25
/** USB_OTGHS_DAINTMSK_OUTEPMSK10 : R/W; bitpos: [26]; default: 0;
 *  OUT Endpoint 10 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK10    (BIT(26))
#define USB_OTGHS_DAINTMSK_OUTEPMSK10_M  (USB_OTGHS_DAINTMSK_OUTEPMSK10_V << USB_OTGHS_DAINTMSK_OUTEPMSK10_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK10_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK10_S  26
/** USB_OTGHS_DAINTMSK_OUTEPMSK11 : R/W; bitpos: [27]; default: 0;
 *  OUT Endpoint 11 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK11    (BIT(27))
#define USB_OTGHS_DAINTMSK_OUTEPMSK11_M  (USB_OTGHS_DAINTMSK_OUTEPMSK11_V << USB_OTGHS_DAINTMSK_OUTEPMSK11_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK11_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK11_S  27
/** USB_OTGHS_DAINTMSK_OUTEPMSK12 : R/W; bitpos: [28]; default: 0;
 *  OUT Endpoint 12 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK12    (BIT(28))
#define USB_OTGHS_DAINTMSK_OUTEPMSK12_M  (USB_OTGHS_DAINTMSK_OUTEPMSK12_V << USB_OTGHS_DAINTMSK_OUTEPMSK12_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK12_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK12_S  28
/** USB_OTGHS_DAINTMSK_OUTEPMSK13 : R/W; bitpos: [29]; default: 0;
 *  OUT Endpoint 13 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK13    (BIT(29))
#define USB_OTGHS_DAINTMSK_OUTEPMSK13_M  (USB_OTGHS_DAINTMSK_OUTEPMSK13_V << USB_OTGHS_DAINTMSK_OUTEPMSK13_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK13_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK13_S  29
/** USB_OTGHS_DAINTMSK_OUTEPMSK14 : R/W; bitpos: [30]; default: 0;
 *  OUT Endpoint 14 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK14    (BIT(30))
#define USB_OTGHS_DAINTMSK_OUTEPMSK14_M  (USB_OTGHS_DAINTMSK_OUTEPMSK14_V << USB_OTGHS_DAINTMSK_OUTEPMSK14_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK14_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK14_S  30
/** USB_OTGHS_DAINTMSK_OUTEPMSK15 : R/W; bitpos: [31]; default: 0;
 *  OUT Endpoint 15 Interrupt mask Bit
 */
#define USB_OTGHS_DAINTMSK_OUTEPMSK15    (BIT(31))
#define USB_OTGHS_DAINTMSK_OUTEPMSK15_M  (USB_OTGHS_DAINTMSK_OUTEPMSK15_V << USB_OTGHS_DAINTMSK_OUTEPMSK15_S)
#define USB_OTGHS_DAINTMSK_OUTEPMSK15_V  0x00000001U
#define USB_OTGHS_DAINTMSK_OUTEPMSK15_S  31

/** USB_OTGHS_DVBUSDIS_REG register
 *  This register specifies the VBUS discharge time after VBUS pulsing during SRP.
 */
#define USB_OTGHS_DVBUSDIS_REG (DR_REG_USB_OTGHS_BASE + 0x828)
/** USB_OTGHS_DVBUSDIS_DVBUSDIS : R/W; bitpos: [15:0]; default: 6103;
 *  Device VBUS Discharge Time (DVBUSDis)
 *
 *  Specifies the VBUS discharge time after VBUS pulsing during SRP. This value equals
 *  (VBUS discharge time in PHY clocks) / 1, 024.
 *
 *  The value you use depends whether the PHY is operating at 30MHz (16-bit data width)
 *  or 60 MHz (8-bit data width).
 *
 *  Depending on your VBUS load, this value can need adjustment.
 */
#define USB_OTGHS_DVBUSDIS_DVBUSDIS    0x0000FFFFU
#define USB_OTGHS_DVBUSDIS_DVBUSDIS_M  (USB_OTGHS_DVBUSDIS_DVBUSDIS_V << USB_OTGHS_DVBUSDIS_DVBUSDIS_S)
#define USB_OTGHS_DVBUSDIS_DVBUSDIS_V  0x0000FFFFU
#define USB_OTGHS_DVBUSDIS_DVBUSDIS_S  0

/** USB_OTGHS_DVBUSPULSE_REG register
 *  This register contains the VBUS pulsing time during SRP.
 */
#define USB_OTGHS_DVBUSPULSE_REG (DR_REG_USB_OTGHS_BASE + 0x82c)
/** USB_OTGHS_DVBUSPULSE_DVBUSPULSE : R/W; bitpos: [11:0]; default: 1464;
 *  Device VBUS Pulsing Time (DVBUSPulse)
 *
 *  Specifies the VBUS pulsing time during SRP. This value equals (VBUS pulsing time in
 *  PHY clocks) / 1, 024
 *
 *  The value you use depends whether the PHY is operating at 30MHz (16-bit data width)
 *  or 60 MHz (8-bit data width).
 */
#define USB_OTGHS_DVBUSPULSE_DVBUSPULSE    0x00000FFFU
#define USB_OTGHS_DVBUSPULSE_DVBUSPULSE_M  (USB_OTGHS_DVBUSPULSE_DVBUSPULSE_V << USB_OTGHS_DVBUSPULSE_DVBUSPULSE_S)
#define USB_OTGHS_DVBUSPULSE_DVBUSPULSE_V  0x00000FFFU
#define USB_OTGHS_DVBUSPULSE_DVBUSPULSE_S  0

/** USB_OTGHS_DTHRCTL_REG register
 *  This register contains the Receive and Transmit Threshold characteristics of the
 *  Device controller.
 */
#define USB_OTGHS_DTHRCTL_REG (DR_REG_USB_OTGHS_BASE + 0x830)
/** USB_OTGHS_DTHRCTL_NONISOTHREN : R/W; bitpos: [0]; default: 0;
 *  Non-ISO IN Endpoints Threshold Enable. (NonISOThrEn)
 *
 *  When this bit is Set, the core enables thresholding for Non Isochronous IN
 *  endpoints.
 */
#define USB_OTGHS_DTHRCTL_NONISOTHREN    (BIT(0))
#define USB_OTGHS_DTHRCTL_NONISOTHREN_M  (USB_OTGHS_DTHRCTL_NONISOTHREN_V << USB_OTGHS_DTHRCTL_NONISOTHREN_S)
#define USB_OTGHS_DTHRCTL_NONISOTHREN_V  0x00000001U
#define USB_OTGHS_DTHRCTL_NONISOTHREN_S  0
/** USB_OTGHS_DTHRCTL_ISOTHREN : R/W; bitpos: [1]; default: 0;
 *
 *  ISO IN Endpoints Threshold Enable. (ISOThrEn)
 *
 *  When this bit is Set, the core enables thresholding for isochronous IN
 *  endpoints.
 */
#define USB_OTGHS_DTHRCTL_ISOTHREN    (BIT(1))
#define USB_OTGHS_DTHRCTL_ISOTHREN_M  (USB_OTGHS_DTHRCTL_ISOTHREN_V << USB_OTGHS_DTHRCTL_ISOTHREN_S)
#define USB_OTGHS_DTHRCTL_ISOTHREN_V  0x00000001U
#define USB_OTGHS_DTHRCTL_ISOTHREN_S  1
/** USB_OTGHS_DTHRCTL_TXTHRLEN : R/W; bitpos: [10:2]; default: 8;
 *  Transmit Threshold Length (TxThrLen)
 *
 *  This field specifies Transmit thresholding size in DWORDS. This also forms
 *  the MAC threshold and specifies the amount of data in bytes to be in the
 *  corresponding endpoint transmit FIFO, before the core can start transmit
 *  on the USB. The threshold length has to be at least eight DWORDS when the
 *  value of AHBThrRatio is 2'h00. In case the AHBThrRatio is non zero the
 *  application needs to ensure that the AHB Threshold value does not go below
 *  the recommended eight DWORD.  This field controls both isochronous and
 *  non-isochronous IN endpoint thresholds. The recommended value for ThrLen
 *  is to be the same as the programmed AHB Burst Length (GAHBCFG.HBstLen).
 *
 *  Note:
 *  - When OTG_ARCHITECTURE=0, the reset value of this register field is 0.
 *  - When OTG_ARCHITECTURE=2, the reset value of this register field is 8.
 */
#define USB_OTGHS_DTHRCTL_TXTHRLEN    0x000001FFU
#define USB_OTGHS_DTHRCTL_TXTHRLEN_M  (USB_OTGHS_DTHRCTL_TXTHRLEN_V << USB_OTGHS_DTHRCTL_TXTHRLEN_S)
#define USB_OTGHS_DTHRCTL_TXTHRLEN_V  0x000001FFU
#define USB_OTGHS_DTHRCTL_TXTHRLEN_S  2
/** USB_OTGHS_DTHRCTL_AHBTHRRATIO : R/W; bitpos: [12:11]; default: 0;
 *  AHB Threshold Ratio (AHBThrRatio)
 *
 *  These bits define the ratio between the AHB threshold and the MAC threshold for the
 *  transmit path only. The AHB threshold always remains less than or equal to the USB
 *  threshold, because this does not increase overhead. Both the AHB and the MAC
 *  threshold must be DWORD-aligned. The application needs to program TxThrLen and the
 *  AHBThrRatio to make the AHB Threshold value DWORD aligned. If the AHB threshold
 *  value is not DWORD aligned, the core might not behave correctly. When programming
 *  the TxThrLen and AHBThrRatio, the application must ensure that the minimum AHB
 *  threshold value does not go below 8 DWORDS to meet the USB turnaround time
 *  requirements.
 *  - 2'b00: AHB threshold = MAC threshold
 *  - 2'b01: AHB threshold = MAC threshold / 2
 *  - 2'b10: AHB threshold = MAC threshold / 4
 *  - 2'b11: AHB threshold = MAC threshold / 8
 */
#define USB_OTGHS_DTHRCTL_AHBTHRRATIO    0x00000003U
#define USB_OTGHS_DTHRCTL_AHBTHRRATIO_M  (USB_OTGHS_DTHRCTL_AHBTHRRATIO_V << USB_OTGHS_DTHRCTL_AHBTHRRATIO_S)
#define USB_OTGHS_DTHRCTL_AHBTHRRATIO_V  0x00000003U
#define USB_OTGHS_DTHRCTL_AHBTHRRATIO_S  11
/** USB_OTGHS_DTHRCTL_RXTHREN : R/W; bitpos: [16]; default: 0;
 *  Receive Threshold Enable (RxThrEn)
 *
 *  When this bit is set, the core enables thresholding in the receive direction.
 *
 *  Note: We recommends that you do not enable RxThrEn, because it may cause issues in
 *  the RxFIFO especially during error conditions such as RxError and Babble.
 */
#define USB_OTGHS_DTHRCTL_RXTHREN    (BIT(16))
#define USB_OTGHS_DTHRCTL_RXTHREN_M  (USB_OTGHS_DTHRCTL_RXTHREN_V << USB_OTGHS_DTHRCTL_RXTHREN_S)
#define USB_OTGHS_DTHRCTL_RXTHREN_V  0x00000001U
#define USB_OTGHS_DTHRCTL_RXTHREN_S  16
/** USB_OTGHS_DTHRCTL_RXTHRLEN : R/W; bitpos: [25:17]; default: 8;
 *  Receive Threshold Length (RxThrLen)
 *
 *  This field specifies Receive thresholding size in DWORDS.
 *  This field also specifies the amount of data received on the USB before the core
 *  can start transmitting on the AHB.
 *  The threshold length has to be at least eight DWORDS.
 *  The recommended value for ThrLen is to be the same as the programmed
 *  AHB Burst Length (GAHBCFG.HBstLen).
 */
#define USB_OTGHS_DTHRCTL_RXTHRLEN    0x000001FFU
#define USB_OTGHS_DTHRCTL_RXTHRLEN_M  (USB_OTGHS_DTHRCTL_RXTHRLEN_V << USB_OTGHS_DTHRCTL_RXTHRLEN_S)
#define USB_OTGHS_DTHRCTL_RXTHRLEN_V  0x000001FFU
#define USB_OTGHS_DTHRCTL_RXTHRLEN_S  17
/** USB_OTGHS_DTHRCTL_ARBPRKEN : R/W; bitpos: [27]; default: 1;
 *  Arbiter Parking Enable (ArbPrkEn)
 *
 *  This bit controls internal DMA arbiter parking for IN endpoints. If thresholding is
 *  enabled and this bit is set to one, then the arbiter parks on the IN endpoint for
 *  which there is a token received on the USB. This is done to avoid getting into
 *  underrun conditions. By default, arbiter parking is enabled.
 */
#define USB_OTGHS_DTHRCTL_ARBPRKEN    (BIT(27))
#define USB_OTGHS_DTHRCTL_ARBPRKEN_M  (USB_OTGHS_DTHRCTL_ARBPRKEN_V << USB_OTGHS_DTHRCTL_ARBPRKEN_S)
#define USB_OTGHS_DTHRCTL_ARBPRKEN_V  0x00000001U
#define USB_OTGHS_DTHRCTL_ARBPRKEN_S  27

/** USB_OTGHS_DIEPEMPMSK_REG register
 *  This register is valid only in Dedicated FIFO operation (OTG_EN_DED_TX_FIFO = 1).
 *  This register is used to control the IN endpoint FIFO empty interrupt generation
 *  (DIEPINTn.TxfEmp).
 */
#define USB_OTGHS_DIEPEMPMSK_REG (DR_REG_USB_OTGHS_BASE + 0x834)
/** USB_OTGHS_DIEPEMPMSK_INEPTXFEMPMSK : R/W; bitpos: [15:0]; default: 0;
 *  IN EP Tx FIFO Empty Interrupt Mask Bits (InEpTxfEmpMsk)
 *
 *  These bits acts as mask bits for DIEPINTn.TxFEmp interrupt, one bit per IN Endpoint:
 *
 *  Bit 0 for IN EP 0, bit 15 for IN EP 15
 */
#define USB_OTGHS_DIEPEMPMSK_INEPTXFEMPMSK    0x0000FFFFU
#define USB_OTGHS_DIEPEMPMSK_INEPTXFEMPMSK_M  (USB_OTGHS_DIEPEMPMSK_INEPTXFEMPMSK_V << USB_OTGHS_DIEPEMPMSK_INEPTXFEMPMSK_S)
#define USB_OTGHS_DIEPEMPMSK_INEPTXFEMPMSK_V  0x0000FFFFU
#define USB_OTGHS_DIEPEMPMSK_INEPTXFEMPMSK_S  0

/** USB_OTGHS_DEACHINT_REG register
 *  This register is available in device mode and only when parameter
 *  OTG_MULTI_PROC_INTRPT on page 121=1. There is one interrupt bit per endpoint, up to
 *  a maximum of 16 bits for OUT endpoints and 16 bits for IN endpoints. For a
 *  bidirectional endpoint, the corresponding IN and OUT interrupt bits are used. Bits
 *  in this register are set and cleared when the application sets and clears bits in
 *  the corresponding Device Endpoint-n Interrupt register (DIEPINTn/DOEPINTn). The
 *  interrupt is automatically cleared once the DOEPINTn/DIEPINTn interrupt is cleared
 *  by the application.
 */
#define USB_OTGHS_DEACHINT_REG (DR_REG_USB_OTGHS_BASE + 0x838)
/** USB_OTGHS_DEACHINT_ECHINEPINT : RO; bitpos: [15:0]; default: 0;
 *  Each IN Endpoint Interrupt Bits (EchInEpInt)
 *
 *  One bit per IN Endpoint:
 *
 *  Bit 0 for IN endpoint 0, bit 15 for endpoint 15
 */
#define USB_OTGHS_DEACHINT_ECHINEPINT    0x0000FFFFU
#define USB_OTGHS_DEACHINT_ECHINEPINT_M  (USB_OTGHS_DEACHINT_ECHINEPINT_V << USB_OTGHS_DEACHINT_ECHINEPINT_S)
#define USB_OTGHS_DEACHINT_ECHINEPINT_V  0x0000FFFFU
#define USB_OTGHS_DEACHINT_ECHINEPINT_S  0
/** USB_OTGHS_DEACHINT_ECHOUTEPINT : RO; bitpos: [31:16]; default: 0;
 *  Each OUT Endpoint Interrupt Bits (EchOutEPInt)
 *
 *  One bit per OUT endpoint:
 *
 *  Bit 16 for OUT endpoint 0, bit 31 for OUT endpoint 15
 */
#define USB_OTGHS_DEACHINT_ECHOUTEPINT    0x0000FFFFU
#define USB_OTGHS_DEACHINT_ECHOUTEPINT_M  (USB_OTGHS_DEACHINT_ECHOUTEPINT_V << USB_OTGHS_DEACHINT_ECHOUTEPINT_S)
#define USB_OTGHS_DEACHINT_ECHOUTEPINT_V  0x0000FFFFU
#define USB_OTGHS_DEACHINT_ECHOUTEPINT_S  16

/** USB_OTGHS_DEACHINTMSK_REG register
 *  This register is available only when parameter OTG_MULTI_PROC_INTRPT=1. The Device
 *  Each Endpoint Interrupt Mask register works with the Device Each Endpoint Interrupt
 *  register to interrupt the application when an event occurs on a device endpoint.
 *  However, the Device Each Endpoints Interrupt (DEACHINT) register bit corresponding
 *  to that interrupt remains set.
 */
#define USB_OTGHS_DEACHINTMSK_REG (DR_REG_USB_OTGHS_BASE + 0x83c)
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK0 : R/W; bitpos: [0]; default: 0;
 *  IN EP0 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK0    (BIT(0))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK0_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK0_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK0_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK0_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK0_S  0
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK1 : R/W; bitpos: [1]; default: 0;
 *  IN EP1 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK1    (BIT(1))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK1_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK1_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK1_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK1_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK1_S  1
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK2 : R/W; bitpos: [2]; default: 0;
 *  IN EP2 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK2    (BIT(2))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK2_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK2_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK2_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK2_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK2_S  2
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK3 : R/W; bitpos: [3]; default: 0;
 *  IN EP3 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK3    (BIT(3))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK3_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK3_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK3_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK3_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK3_S  3
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK4 : R/W; bitpos: [4]; default: 0;
 *  IN EP4 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK4    (BIT(4))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK4_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK4_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK4_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK4_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK4_S  4
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK5 : R/W; bitpos: [5]; default: 0;
 *  IN EP5 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK5    (BIT(5))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK5_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK5_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK5_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK5_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK5_S  5
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK6 : R/W; bitpos: [6]; default: 0;
 *  IN EP6 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK6    (BIT(6))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK6_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK6_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK6_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK6_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK6_S  6
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK7 : R/W; bitpos: [7]; default: 0;
 *  IN EP7 Interrupt Mask Bits
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK7    (BIT(7))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK7_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK7_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK7_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK7_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK7_S  7
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK8 : R/W; bitpos: [8]; default: 0;
 *  IN EP8 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK8    (BIT(8))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK8_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK8_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK8_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK8_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK8_S  8
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK9 : R/W; bitpos: [9]; default: 0;
 *  IN EP9 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK9    (BIT(9))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK9_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK9_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK9_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK9_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK9_S  9
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK10 : R/W; bitpos: [10]; default: 0;
 *  IN EP10 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK10    (BIT(10))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK10_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK10_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK10_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK10_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK10_S  10
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK11 : R/W; bitpos: [11]; default: 0;
 *  IN EP11 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK11    (BIT(11))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK11_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK11_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK11_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK11_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK11_S  11
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK12 : R/W; bitpos: [12]; default: 0;
 *  IN EP12 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK12    (BIT(12))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK12_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK12_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK12_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK12_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK12_S  12
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK13 : R/W; bitpos: [13]; default: 0;
 *  IN EP13 Interrupt Mask Bits
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK13    (BIT(13))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK13_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK13_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK13_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK13_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK13_S  13
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK14 : R/W; bitpos: [14]; default: 0;
 *  IN EP14 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK14    (BIT(14))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK14_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK14_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK14_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK14_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK14_S  14
/** USB_OTGHS_DEACHINTMSK_ECHINEPMSK15 : R/W; bitpos: [15]; default: 0;
 *  IN EP15 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK15    (BIT(15))
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK15_M  (USB_OTGHS_DEACHINTMSK_ECHINEPMSK15_V << USB_OTGHS_DEACHINTMSK_ECHINEPMSK15_S)
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK15_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHINEPMSK15_S  15
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK0 : R/W; bitpos: [16]; default: 0;
 *  OUT EP0 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK0    (BIT(16))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK0_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK0_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK0_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK0_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK0_S  16
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK1 : R/W; bitpos: [17]; default: 0;
 *  OUT EP1 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK1    (BIT(17))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK1_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK1_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK1_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK1_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK1_S  17
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK2 : R/W; bitpos: [18]; default: 0;
 *  OUT EP2 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK2    (BIT(18))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK2_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK2_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK2_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK2_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK2_S  18
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK3 : R/W; bitpos: [19]; default: 0;
 *  OUT EP3 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK3    (BIT(19))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK3_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK3_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK3_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK3_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK3_S  19
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK4 : R/W; bitpos: [20]; default: 0;
 *  OUT EP4 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK4    (BIT(20))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK4_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK4_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK4_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK4_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK4_S  20
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK5 : R/W; bitpos: [21]; default: 0;
 *  OUT EP5 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK5    (BIT(21))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK5_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK5_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK5_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK5_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK5_S  21
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK6 : R/W; bitpos: [22]; default: 0;
 *  OUT EP6 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK6    (BIT(22))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK6_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK6_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK6_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK6_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK6_S  22
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK7 : R/W; bitpos: [23]; default: 0;
 *  OUT EP7 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK7    (BIT(23))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK7_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK7_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK7_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK7_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK7_S  23
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK8 : R/W; bitpos: [24]; default: 0;
 *  OUT EP8 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK8    (BIT(24))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK8_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK8_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK8_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK8_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK8_S  24
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK9 : R/W; bitpos: [25]; default: 0;
 *  OUT EP9 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK9    (BIT(25))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK9_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK9_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK9_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK9_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK9_S  25
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK10 : R/W; bitpos: [26]; default: 0;
 *  OUT EP10 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK10    (BIT(26))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK10_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK10_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK10_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK10_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK10_S  26
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK11 : R/W; bitpos: [27]; default: 0;
 *  OUT EP11 Interrupt Mask Bits
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK11    (BIT(27))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK11_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK11_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK11_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK11_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK11_S  27
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK12 : R/W; bitpos: [28]; default: 0;
 *  OUT EP12 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK12    (BIT(28))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK12_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK12_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK12_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK12_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK12_S  28
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK13 : R/W; bitpos: [29]; default: 0;
 *  OUT EP13 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK13    (BIT(29))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK13_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK13_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK13_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK13_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK13_S  29
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK14 : R/W; bitpos: [30]; default: 0;
 *  OUT EP14 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK14    (BIT(30))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK14_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK14_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK14_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK14_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK14_S  30
/** USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK15 : R/W; bitpos: [31]; default: 0;
 *  OUT EP15 Interrupt Mask Bit
 */
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK15    (BIT(31))
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK15_M  (USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK15_V << USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK15_S)
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK15_V  0x00000001U
#define USB_OTGHS_DEACHINTMSK_ECHOUTEPMSK15_S  31

/** USB_OTGHS_DIEPEACHMSK0_REG register
 *  This register is available in device mode and only when parameter
 *  OTG_MULTI_PROC_INTRPT on page 121=1. These registers are endpoint-specific mask
 *  registers for (DIEPINTn). The IN endpoint interrupt for a specific status in the
 *  DIEPINTn register can be masked by writing 0 to the corresponding bit in this
 *  register. Status bits are masked by default.  - Mask interrupt: 1'b0  - Unmask
 *  interrupt: 1'b1
 */
#define USB_OTGHS_DIEPEACHMSK0_REG (DR_REG_USB_OTGHS_BASE + 0x840)
/** USB_OTGHS_DIEPEACHMSK0_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK0_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK0_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK0_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK0_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK0_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK0_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK0_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK0_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK0_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK0_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK0_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK0_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK0_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK0_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK0_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK0_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK0_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK0_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK0_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK0_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK0_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk) (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK0_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK0_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK0_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK0_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK0_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK0_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK0_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask (INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK0_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK0_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK0_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK0_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK0_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK0_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK0_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK0_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK0_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK0_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK0_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK0_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK0_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK0_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK0_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK0_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK0_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK0_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK0_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK0_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK0_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK0_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK0_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK0_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK0_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK0_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK0_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK0_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK0_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK0_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK0_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK0_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK0_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK0_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK0_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK0_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK0_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK0_NAKMSK_V << USB_OTGHS_DIEPEACHMSK0_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK0_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK0_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK1_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK1_REG (DR_REG_USB_OTGHS_BASE + 0x844)
/** USB_OTGHS_DIEPEACHMSK1_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK1_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK1_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK1_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK1_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK1_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK1_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK1_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK1_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK1_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK1_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK1_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK1_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK1_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK1_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK1_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK1_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK1_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK1_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK1_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK1_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK1_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK1_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK1_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK1_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK1_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK1_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK1_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK1_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK1_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK1_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK1_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK1_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK1_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK1_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK1_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK1_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK1_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK1_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK1_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK1_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK1_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK1_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK1_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK1_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK1_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK1_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK1_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK1_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK1_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK1_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK1_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK1_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK1_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK1_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK1_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK1_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK1_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK1_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK1_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK1_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK1_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK1_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK1_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK1_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK1_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK1_NAKMSK_V << USB_OTGHS_DIEPEACHMSK1_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK1_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK1_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK2_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK2_REG (DR_REG_USB_OTGHS_BASE + 0x848)
/** USB_OTGHS_DIEPEACHMSK2_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK2_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK2_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK2_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK2_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK2_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK2_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK2_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK2_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK2_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK2_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK2_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK2_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK2_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK2_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK2_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK2_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK2_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK2_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK2_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK2_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK2_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK2_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK2_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK2_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK2_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK2_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK2_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK2_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK2_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK2_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK2_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK2_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK2_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK2_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK2_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK2_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK2_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK2_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK2_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK2_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK2_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK2_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK2_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK2_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK2_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK2_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK2_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK2_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK2_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK2_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK2_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK2_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK2_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK2_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK2_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK2_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK2_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK2_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK2_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK2_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK2_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK2_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK2_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK2_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK2_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK2_NAKMSK_V << USB_OTGHS_DIEPEACHMSK2_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK2_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK2_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK3_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK3_REG (DR_REG_USB_OTGHS_BASE + 0x84c)
/** USB_OTGHS_DIEPEACHMSK3_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK3_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK3_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK3_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK3_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK3_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK3_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK3_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK3_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK3_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK3_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK3_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK3_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK3_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK3_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK3_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK3_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK3_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK3_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK3_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK3_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK3_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK3_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK3_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK3_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK3_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK3_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK3_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK3_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK3_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK3_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK3_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK3_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK3_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK3_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK3_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK3_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK3_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK3_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK3_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK3_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK3_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK3_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK3_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK3_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK3_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK3_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK3_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK3_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK3_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK3_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK3_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK3_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK3_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK3_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK3_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK3_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK3_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK3_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK3_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK3_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK3_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK3_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK3_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK3_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK3_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK3_NAKMSK_V << USB_OTGHS_DIEPEACHMSK3_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK3_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK3_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK4_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK4_REG (DR_REG_USB_OTGHS_BASE + 0x850)
/** USB_OTGHS_DIEPEACHMSK4_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK4_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK4_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK4_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK4_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK4_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK4_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK4_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK4_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK4_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK4_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK4_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK4_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK4_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK4_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK4_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK4_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK4_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK4_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK4_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK4_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK4_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK4_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK4_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK4_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK4_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK4_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK4_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK4_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK4_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK4_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK4_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK4_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK4_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK4_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK4_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK4_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK4_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK4_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK4_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK4_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK4_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK4_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK4_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK4_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK4_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK4_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK4_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK4_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK4_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK4_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK4_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK4_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK4_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK4_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK4_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK4_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK4_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK4_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK4_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK4_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK4_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK4_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK4_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK4_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK4_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK4_NAKMSK_V << USB_OTGHS_DIEPEACHMSK4_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK4_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK4_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK5_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK5_REG (DR_REG_USB_OTGHS_BASE + 0x854)
/** USB_OTGHS_DIEPEACHMSK5_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK5_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK5_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK5_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK5_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK5_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK5_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK5_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK5_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK5_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK5_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK5_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK5_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK5_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK5_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK5_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK5_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK5_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK5_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK5_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK5_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK5_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK5_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK5_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK5_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK5_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK5_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK5_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK5_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK5_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK5_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK5_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK5_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK5_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK5_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK5_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK5_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK5_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK5_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK5_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK5_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK5_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK5_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK5_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK5_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK5_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK5_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK5_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK5_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK5_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK5_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK5_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK5_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK5_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK5_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK5_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK5_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK5_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK5_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK5_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK5_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK5_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK5_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK5_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK5_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK5_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK5_NAKMSK_V << USB_OTGHS_DIEPEACHMSK5_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK5_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK5_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK6_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK6_REG (DR_REG_USB_OTGHS_BASE + 0x858)
/** USB_OTGHS_DIEPEACHMSK6_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK6_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK6_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK6_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK6_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK6_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK6_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK6_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK6_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK6_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK6_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK6_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK6_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK6_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK6_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK6_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK6_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK6_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK6_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK6_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK6_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK6_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK6_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK6_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK6_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK6_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK6_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK6_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK6_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK6_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK6_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK6_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK6_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK6_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK6_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK6_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK6_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK6_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK6_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK6_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK6_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK6_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK6_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK6_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK6_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK6_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK6_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK6_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK6_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK6_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK6_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK6_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK6_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK6_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK6_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK6_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK6_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK6_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK6_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK6_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK6_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK6_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK6_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK6_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK6_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK6_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK6_NAKMSK_V << USB_OTGHS_DIEPEACHMSK6_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK6_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK6_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK7_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK7_REG (DR_REG_USB_OTGHS_BASE + 0x85c)
/** USB_OTGHS_DIEPEACHMSK7_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK7_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK7_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK7_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK7_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK7_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK7_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK7_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK7_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK7_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK7_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK7_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK7_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK7_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK7_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK7_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK7_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK7_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK7_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK7_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK7_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK7_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK7_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK7_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK7_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK7_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK7_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK7_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK7_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK7_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK7_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK7_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK7_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK7_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK7_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK7_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK7_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK7_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK7_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK7_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK7_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK7_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK7_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK7_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK7_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK7_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK7_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK7_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK7_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK7_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK7_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK7_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK7_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK7_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK7_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK7_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK7_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK7_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK7_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK7_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK7_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK7_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK7_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK7_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK7_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK7_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK7_NAKMSK_V << USB_OTGHS_DIEPEACHMSK7_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK7_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK7_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK8_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK8_REG (DR_REG_USB_OTGHS_BASE + 0x860)
/** USB_OTGHS_DIEPEACHMSK8_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK8_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK8_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK8_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK8_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK8_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK8_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK8_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK8_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK8_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK8_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK8_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK8_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK8_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK8_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK8_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK8_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK8_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK8_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK8_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK8_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK8_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK8_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK8_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK8_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK8_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK8_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK8_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK8_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK8_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK8_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK8_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK8_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK8_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK8_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK8_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK8_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK8_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK8_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK8_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK8_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK8_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK8_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK8_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK8_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK8_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK8_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK8_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK8_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK8_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK8_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK8_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK8_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK8_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK8_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK8_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK8_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK8_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK8_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK8_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK8_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK8_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK8_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK8_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK8_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK8_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK8_NAKMSK_V << USB_OTGHS_DIEPEACHMSK8_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK8_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK8_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK9_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK9_REG (DR_REG_USB_OTGHS_BASE + 0x864)
/** USB_OTGHS_DIEPEACHMSK9_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK9_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK9_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK9_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK9_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK9_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK9_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK9_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK9_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK9_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK9_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK9_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK9_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK9_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK9_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK9_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK9_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK9_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK9_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK9_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK9_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK9_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK9_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK9_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK9_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK9_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK9_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK9_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK9_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK9_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK9_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK9_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK9_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK9_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK9_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK9_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK9_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK9_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK9_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK9_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK9_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK9_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK9_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK9_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK9_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK9_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK9_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK9_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK9_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK9_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK9_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK9_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK9_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK9_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK9_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK9_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK9_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK9_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK9_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK9_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK9_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK9_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK9_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK9_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK9_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK9_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK9_NAKMSK_V << USB_OTGHS_DIEPEACHMSK9_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK9_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK9_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK10_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK10_REG (DR_REG_USB_OTGHS_BASE + 0x868)
/** USB_OTGHS_DIEPEACHMSK10_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK10_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK10_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK10_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK10_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK10_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK10_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK10_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK10_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK10_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK10_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK10_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK10_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK10_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK10_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK10_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK10_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK10_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK10_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK10_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK10_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK10_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK10_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK10_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK10_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK10_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK10_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK10_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK10_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK10_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK10_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK10_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK10_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK10_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK10_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK10_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK10_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK10_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK10_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK10_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK10_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK10_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK10_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK10_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK10_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK10_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK10_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK10_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK10_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK10_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK10_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK10_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK10_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK10_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK10_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK10_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK10_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK10_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK10_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK10_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK10_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK10_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK10_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK10_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK10_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK10_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK10_NAKMSK_V << USB_OTGHS_DIEPEACHMSK10_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK10_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK10_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK11_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK11_REG (DR_REG_USB_OTGHS_BASE + 0x86c)
/** USB_OTGHS_DIEPEACHMSK11_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK11_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK11_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK11_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK11_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK11_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK11_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK11_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK11_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK11_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK11_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK11_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK11_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK11_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK11_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK11_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK11_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK11_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK11_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK11_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK11_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK11_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK11_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK11_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK11_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK11_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK11_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK11_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK11_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK11_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK11_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK11_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK11_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK11_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK11_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK11_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK11_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK11_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK11_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK11_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK11_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK11_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK11_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK11_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK11_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK11_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK11_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK11_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK11_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK11_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK11_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK11_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK11_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK11_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK11_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK11_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK11_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK11_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK11_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK11_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK11_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK11_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK11_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK11_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK11_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK11_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK11_NAKMSK_V << USB_OTGHS_DIEPEACHMSK11_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK11_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK11_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK12_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK12_REG (DR_REG_USB_OTGHS_BASE + 0x870)
/** USB_OTGHS_DIEPEACHMSK12_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK12_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK12_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK12_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK12_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK12_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK12_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK12_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK12_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK12_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK12_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK12_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK12_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK12_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK12_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK12_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK12_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK12_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK12_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK12_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK12_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK12_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK12_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK12_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK12_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK12_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK12_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK12_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK12_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK12_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK12_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK12_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK12_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK12_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK12_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK12_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK12_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK12_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK12_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK12_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK12_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK12_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK12_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK12_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK12_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK12_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK12_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK12_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK12_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK12_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK12_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK12_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK12_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK12_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK12_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK12_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK12_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK12_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK12_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK12_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK12_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK12_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK12_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK12_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK12_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK12_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK12_NAKMSK_V << USB_OTGHS_DIEPEACHMSK12_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK12_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK12_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK13_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK13_REG (DR_REG_USB_OTGHS_BASE + 0x874)
/** USB_OTGHS_DIEPEACHMSK13_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK13_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK13_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK13_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK13_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK13_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK13_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK13_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK13_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK13_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK13_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK13_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK13_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK13_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK13_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK13_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK13_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK13_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK13_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK13_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK13_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK13_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK13_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK13_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK13_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK13_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK13_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK13_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK13_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK13_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK13_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK13_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK13_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK13_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK13_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK13_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK13_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK13_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK13_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK13_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK13_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK13_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK13_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK13_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK13_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK13_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK13_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK13_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK13_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK13_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK13_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK13_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK13_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK13_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK13_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK13_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK13_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK13_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK13_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK13_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK13_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK13_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK13_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK13_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK13_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK13_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK13_NAKMSK_V << USB_OTGHS_DIEPEACHMSK13_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK13_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK13_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK14_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK14_REG (DR_REG_USB_OTGHS_BASE + 0x878)
/** USB_OTGHS_DIEPEACHMSK14_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK14_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK14_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK14_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK14_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK14_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK14_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK14_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK14_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK14_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK14_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK14_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK14_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK14_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK14_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK14_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK14_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK14_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK14_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK14_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK14_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK14_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK14_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK14_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK14_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK14_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK14_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK14_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK14_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK14_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK14_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK14_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK14_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK14_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK14_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK14_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK14_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK14_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK14_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK14_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK14_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK14_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK14_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK14_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK14_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK14_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK14_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK14_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK14_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK14_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK14_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK14_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK14_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK14_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK14_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK14_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK14_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK14_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK14_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK14_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK14_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK14_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK14_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK14_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK14_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK14_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK14_NAKMSK_V << USB_OTGHS_DIEPEACHMSK14_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK14_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK14_NAKMSK_S  13

/** USB_OTGHS_DIEPEACHMSK15_REG register
 *  This register contains the interrupts for the IN Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPEACHMSK15_REG (DR_REG_USB_OTGHS_BASE + 0x87c)
/** USB_OTGHS_DIEPEACHMSK15_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DIEPEACHMSK15_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DIEPEACHMSK15_XFERCOMPLMSK_M  (USB_OTGHS_DIEPEACHMSK15_XFERCOMPLMSK_V << USB_OTGHS_DIEPEACHMSK15_XFERCOMPLMSK_S)
#define USB_OTGHS_DIEPEACHMSK15_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK15_XFERCOMPLMSK_S  0
/** USB_OTGHS_DIEPEACHMSK15_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DIEPEACHMSK15_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DIEPEACHMSK15_EPDISBLDMSK_M  (USB_OTGHS_DIEPEACHMSK15_EPDISBLDMSK_V << USB_OTGHS_DIEPEACHMSK15_EPDISBLDMSK_S)
#define USB_OTGHS_DIEPEACHMSK15_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK15_EPDISBLDMSK_S  1
/** USB_OTGHS_DIEPEACHMSK15_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error Mask (AHBErrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK15_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DIEPEACHMSK15_AHBERRMSK_M  (USB_OTGHS_DIEPEACHMSK15_AHBERRMSK_V << USB_OTGHS_DIEPEACHMSK15_AHBERRMSK_S)
#define USB_OTGHS_DIEPEACHMSK15_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK15_AHBERRMSK_S  2
/** USB_OTGHS_DIEPEACHMSK15_TIMEOUTMSK : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition Mask (TimeOUTMsk)
 *  (Non-isochronous endpoints)
 */
#define USB_OTGHS_DIEPEACHMSK15_TIMEOUTMSK    (BIT(3))
#define USB_OTGHS_DIEPEACHMSK15_TIMEOUTMSK_M  (USB_OTGHS_DIEPEACHMSK15_TIMEOUTMSK_V << USB_OTGHS_DIEPEACHMSK15_TIMEOUTMSK_S)
#define USB_OTGHS_DIEPEACHMSK15_TIMEOUTMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK15_TIMEOUTMSK_S  3
/** USB_OTGHS_DIEPEACHMSK15_INTKNTXFEMPMSK : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO Empty Mask(INTknTXFEmpMsk)
 */
#define USB_OTGHS_DIEPEACHMSK15_INTKNTXFEMPMSK    (BIT(4))
#define USB_OTGHS_DIEPEACHMSK15_INTKNTXFEMPMSK_M  (USB_OTGHS_DIEPEACHMSK15_INTKNTXFEMPMSK_V << USB_OTGHS_DIEPEACHMSK15_INTKNTXFEMPMSK_S)
#define USB_OTGHS_DIEPEACHMSK15_INTKNTXFEMPMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK15_INTKNTXFEMPMSK_S  4
/** USB_OTGHS_DIEPEACHMSK15_INTKNEPMISMSK : R/W; bitpos: [5]; default: 0;
 *  IN Token received with EP Mismatch Mask (INTknEPMisMsk)
 */
#define USB_OTGHS_DIEPEACHMSK15_INTKNEPMISMSK    (BIT(5))
#define USB_OTGHS_DIEPEACHMSK15_INTKNEPMISMSK_M  (USB_OTGHS_DIEPEACHMSK15_INTKNEPMISMSK_V << USB_OTGHS_DIEPEACHMSK15_INTKNEPMISMSK_S)
#define USB_OTGHS_DIEPEACHMSK15_INTKNEPMISMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK15_INTKNEPMISMSK_S  5
/** USB_OTGHS_DIEPEACHMSK15_INEPNAKEFFMSK : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective Mask (INEPNakEffMsk)
 */
#define USB_OTGHS_DIEPEACHMSK15_INEPNAKEFFMSK    (BIT(6))
#define USB_OTGHS_DIEPEACHMSK15_INEPNAKEFFMSK_M  (USB_OTGHS_DIEPEACHMSK15_INEPNAKEFFMSK_V << USB_OTGHS_DIEPEACHMSK15_INEPNAKEFFMSK_S)
#define USB_OTGHS_DIEPEACHMSK15_INEPNAKEFFMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK15_INEPNAKEFFMSK_S  6
/** USB_OTGHS_DIEPEACHMSK15_TXFIFOUNDRNMSK : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun Mask (TxfifoUndrnMsk)
 */
#define USB_OTGHS_DIEPEACHMSK15_TXFIFOUNDRNMSK    (BIT(8))
#define USB_OTGHS_DIEPEACHMSK15_TXFIFOUNDRNMSK_M  (USB_OTGHS_DIEPEACHMSK15_TXFIFOUNDRNMSK_V << USB_OTGHS_DIEPEACHMSK15_TXFIFOUNDRNMSK_S)
#define USB_OTGHS_DIEPEACHMSK15_TXFIFOUNDRNMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK15_TXFIFOUNDRNMSK_S  8
/** USB_OTGHS_DIEPEACHMSK15_BNAININTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BNAInIntrMsk)
 */
#define USB_OTGHS_DIEPEACHMSK15_BNAININTRMSK    (BIT(9))
#define USB_OTGHS_DIEPEACHMSK15_BNAININTRMSK_M  (USB_OTGHS_DIEPEACHMSK15_BNAININTRMSK_V << USB_OTGHS_DIEPEACHMSK15_BNAININTRMSK_S)
#define USB_OTGHS_DIEPEACHMSK15_BNAININTRMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK15_BNAININTRMSK_S  9
/** USB_OTGHS_DIEPEACHMSK15_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DIEPEACHMSK15_NAKMSK    (BIT(13))
#define USB_OTGHS_DIEPEACHMSK15_NAKMSK_M  (USB_OTGHS_DIEPEACHMSK15_NAKMSK_V << USB_OTGHS_DIEPEACHMSK15_NAKMSK_S)
#define USB_OTGHS_DIEPEACHMSK15_NAKMSK_V  0x00000001U
#define USB_OTGHS_DIEPEACHMSK15_NAKMSK_S  13

/** USB_OTGHS_DOEPEACHMSK0_REG register
 *  This register is available in device mode and only when parameter
 *  OTG_MULTI_PROC_INTRPT=1. These registers are endpoint specific mask registers for
 *  (DOEPINTn). The OUT endpoint interrupt for a specific status in the DOEPINTn
 *  register can be masked by writing 0 to the corresponding bit in this register.
 *  Status bits are masked by default.
 */
#define USB_OTGHS_DOEPEACHMSK0_REG (DR_REG_USB_OTGHS_BASE + 0x880)
/** USB_OTGHS_DOEPEACHMSK0_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK0_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK0_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK0_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK0_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK0_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK0_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK0_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK0_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK0_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK0_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK0_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK0_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK0_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK0_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK0_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK0_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK0_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK0_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK0_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK0_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK0_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK0_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK0_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK0_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK0_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK0_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK0_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK0_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK0_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK0_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK0_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK0_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK0_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK0_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK0_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK0_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK0_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK0_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK0_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK0_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK0_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK0_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK0_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK0_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK0_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK0_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK0_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK0_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK0_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK0_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK0_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK0_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK0_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK0_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK0_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK0_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK0_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK0_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK0_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK0_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK0_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK0_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK0_NAKMSK_V << USB_OTGHS_DOEPEACHMSK0_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK0_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK0_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK0_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK0_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK0_NYETMSK_V << USB_OTGHS_DOEPEACHMSK0_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK0_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK0_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK1_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK1_REG (DR_REG_USB_OTGHS_BASE + 0x884)
/** USB_OTGHS_DOEPEACHMSK1_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK1_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK1_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK1_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK1_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK1_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK1_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK1_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK1_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK1_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK1_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK1_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK1_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK1_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK1_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK1_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK1_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK1_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK1_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK1_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK1_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK1_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK1_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK1_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK1_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK1_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK1_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK1_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK1_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK1_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK1_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK1_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK1_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK1_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK1_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK1_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK1_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK1_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK1_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK1_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK1_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK1_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK1_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK1_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK1_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK1_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK1_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK1_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK1_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK1_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK1_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK1_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK1_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK1_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK1_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK1_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK1_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK1_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK1_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK1_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK1_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK1_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK1_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK1_NAKMSK_V << USB_OTGHS_DOEPEACHMSK1_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK1_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK1_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK1_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK1_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK1_NYETMSK_V << USB_OTGHS_DOEPEACHMSK1_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK1_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK1_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK2_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK2_REG (DR_REG_USB_OTGHS_BASE + 0x888)
/** USB_OTGHS_DOEPEACHMSK2_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK2_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK2_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK2_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK2_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK2_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK2_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK2_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK2_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK2_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK2_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK2_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK2_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK2_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK2_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK2_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK2_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK2_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK2_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK2_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK2_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK2_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK2_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK2_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK2_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK2_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK2_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK2_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK2_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK2_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK2_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK2_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK2_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK2_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK2_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK2_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK2_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK2_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK2_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK2_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK2_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK2_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK2_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK2_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK2_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK2_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK2_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK2_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK2_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK2_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK2_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK2_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK2_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK2_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK2_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK2_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK2_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK2_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK2_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK2_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK2_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK2_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK2_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK2_NAKMSK_V << USB_OTGHS_DOEPEACHMSK2_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK2_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK2_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK2_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK2_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK2_NYETMSK_V << USB_OTGHS_DOEPEACHMSK2_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK2_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK2_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK3_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK3_REG (DR_REG_USB_OTGHS_BASE + 0x88c)
/** USB_OTGHS_DOEPEACHMSK3_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK3_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK3_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK3_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK3_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK3_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK3_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK3_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK3_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK3_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK3_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK3_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK3_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK3_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK3_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK3_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK3_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK3_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK3_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK3_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK3_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK3_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK3_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK3_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK3_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK3_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK3_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK3_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK3_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK3_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK3_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK3_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK3_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK3_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK3_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK3_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK3_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK3_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK3_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK3_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK3_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK3_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK3_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK3_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK3_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK3_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK3_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK3_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK3_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK3_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK3_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK3_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK3_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK3_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK3_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK3_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK3_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK3_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK3_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK3_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK3_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK3_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK3_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK3_NAKMSK_V << USB_OTGHS_DOEPEACHMSK3_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK3_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK3_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK3_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK3_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK3_NYETMSK_V << USB_OTGHS_DOEPEACHMSK3_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK3_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK3_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK4_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK4_REG (DR_REG_USB_OTGHS_BASE + 0x890)
/** USB_OTGHS_DOEPEACHMSK4_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK4_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK4_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK4_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK4_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK4_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK4_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK4_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK4_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK4_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK4_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK4_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK4_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK4_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK4_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK4_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK4_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK4_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK4_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK4_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK4_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK4_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK4_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK4_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK4_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK4_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK4_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK4_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK4_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK4_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK4_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK4_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK4_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK4_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK4_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK4_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK4_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK4_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK4_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK4_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK4_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK4_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK4_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK4_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK4_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK4_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK4_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK4_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK4_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK4_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK4_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK4_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK4_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK4_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK4_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK4_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK4_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK4_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK4_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK4_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK4_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK4_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK4_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK4_NAKMSK_V << USB_OTGHS_DOEPEACHMSK4_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK4_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK4_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK4_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK4_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK4_NYETMSK_V << USB_OTGHS_DOEPEACHMSK4_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK4_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK4_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK5_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK5_REG (DR_REG_USB_OTGHS_BASE + 0x894)
/** USB_OTGHS_DOEPEACHMSK5_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK5_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK5_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK5_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK5_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK5_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK5_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK5_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK5_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK5_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK5_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK5_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK5_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK5_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK5_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK5_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK5_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK5_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK5_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK5_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK5_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK5_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK5_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK5_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK5_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK5_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK5_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK5_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK5_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK5_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK5_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK5_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK5_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK5_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK5_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK5_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK5_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK5_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK5_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK5_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK5_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK5_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK5_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK5_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK5_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK5_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK5_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK5_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK5_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK5_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK5_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK5_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK5_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK5_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK5_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK5_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK5_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK5_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK5_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK5_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK5_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK5_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK5_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK5_NAKMSK_V << USB_OTGHS_DOEPEACHMSK5_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK5_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK5_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK5_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK5_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK5_NYETMSK_V << USB_OTGHS_DOEPEACHMSK5_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK5_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK5_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK6_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK6_REG (DR_REG_USB_OTGHS_BASE + 0x898)
/** USB_OTGHS_DOEPEACHMSK6_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK6_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK6_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK6_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK6_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK6_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK6_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK6_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK6_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK6_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK6_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK6_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK6_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK6_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK6_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK6_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK6_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK6_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK6_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK6_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK6_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK6_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK6_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK6_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK6_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK6_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK6_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK6_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK6_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK6_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK6_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK6_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK6_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK6_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK6_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK6_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK6_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK6_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK6_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK6_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK6_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK6_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK6_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK6_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK6_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK6_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK6_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK6_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK6_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK6_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK6_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK6_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK6_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK6_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK6_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK6_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK6_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK6_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK6_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK6_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK6_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK6_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK6_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK6_NAKMSK_V << USB_OTGHS_DOEPEACHMSK6_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK6_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK6_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK6_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK6_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK6_NYETMSK_V << USB_OTGHS_DOEPEACHMSK6_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK6_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK6_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK7_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK7_REG (DR_REG_USB_OTGHS_BASE + 0x89c)
/** USB_OTGHS_DOEPEACHMSK7_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK7_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK7_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK7_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK7_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK7_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK7_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK7_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK7_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK7_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK7_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK7_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK7_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK7_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK7_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK7_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK7_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK7_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK7_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK7_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK7_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK7_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK7_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK7_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK7_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK7_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK7_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK7_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK7_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK7_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK7_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK7_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK7_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK7_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK7_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK7_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK7_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK7_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK7_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK7_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK7_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK7_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK7_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK7_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK7_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK7_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK7_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK7_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK7_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK7_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK7_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK7_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK7_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK7_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK7_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK7_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK7_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK7_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK7_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK7_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK7_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK7_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK7_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK7_NAKMSK_V << USB_OTGHS_DOEPEACHMSK7_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK7_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK7_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK7_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK7_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK7_NYETMSK_V << USB_OTGHS_DOEPEACHMSK7_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK7_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK7_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK8_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK8_REG (DR_REG_USB_OTGHS_BASE + 0x8a0)
/** USB_OTGHS_DOEPEACHMSK8_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK8_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK8_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK8_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK8_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK8_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK8_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK8_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK8_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK8_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK8_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK8_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK8_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK8_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK8_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK8_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK8_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK8_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK8_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK8_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK8_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK8_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK8_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK8_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK8_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK8_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK8_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK8_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK8_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK8_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK8_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK8_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK8_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK8_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK8_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK8_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK8_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK8_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK8_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK8_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK8_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK8_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK8_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK8_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK8_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK8_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK8_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK8_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK8_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK8_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK8_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK8_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK8_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK8_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK8_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK8_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK8_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK8_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK8_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK8_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK8_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK8_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK8_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK8_NAKMSK_V << USB_OTGHS_DOEPEACHMSK8_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK8_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK8_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK8_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK8_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK8_NYETMSK_V << USB_OTGHS_DOEPEACHMSK8_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK8_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK8_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK9_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK9_REG (DR_REG_USB_OTGHS_BASE + 0x8a4)
/** USB_OTGHS_DOEPEACHMSK9_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK9_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK9_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK9_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK9_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK9_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK9_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK9_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK9_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK9_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK9_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK9_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK9_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK9_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK9_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK9_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK9_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK9_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK9_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK9_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK9_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK9_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK9_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK9_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK9_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK9_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK9_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK9_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK9_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK9_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK9_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK9_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK9_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK9_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK9_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK9_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK9_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK9_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK9_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK9_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK9_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK9_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK9_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK9_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK9_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK9_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK9_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK9_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK9_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK9_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK9_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK9_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK9_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK9_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK9_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK9_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK9_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK9_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK9_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK9_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK9_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK9_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK9_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK9_NAKMSK_V << USB_OTGHS_DOEPEACHMSK9_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK9_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK9_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK9_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK9_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK9_NYETMSK_V << USB_OTGHS_DOEPEACHMSK9_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK9_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK9_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK10_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK10_REG (DR_REG_USB_OTGHS_BASE + 0x8a8)
/** USB_OTGHS_DOEPEACHMSK10_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK10_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK10_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK10_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK10_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK10_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK10_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK10_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK10_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK10_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK10_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK10_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK10_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK10_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK10_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK10_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK10_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK10_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK10_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK10_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK10_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK10_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK10_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK10_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK10_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK10_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK10_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK10_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK10_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK10_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK10_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK10_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK10_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK10_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK10_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK10_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK10_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK10_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK10_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK10_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK10_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK10_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK10_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK10_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK10_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK10_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK10_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK10_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK10_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK10_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK10_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK10_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK10_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK10_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK10_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK10_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK10_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK10_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK10_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK10_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK10_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK10_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK10_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK10_NAKMSK_V << USB_OTGHS_DOEPEACHMSK10_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK10_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK10_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK10_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK10_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK10_NYETMSK_V << USB_OTGHS_DOEPEACHMSK10_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK10_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK10_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK11_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK11_REG (DR_REG_USB_OTGHS_BASE + 0x8ac)
/** USB_OTGHS_DOEPEACHMSK11_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK11_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK11_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK11_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK11_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK11_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK11_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK11_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK11_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK11_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK11_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK11_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK11_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK11_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK11_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK11_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK11_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK11_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK11_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK11_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK11_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK11_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK11_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK11_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK11_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK11_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK11_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK11_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK11_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK11_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK11_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK11_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK11_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK11_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK11_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK11_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK11_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK11_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK11_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK11_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK11_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK11_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK11_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK11_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK11_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK11_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK11_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK11_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK11_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK11_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK11_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK11_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK11_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK11_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK11_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK11_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK11_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK11_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK11_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK11_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK11_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK11_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK11_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK11_NAKMSK_V << USB_OTGHS_DOEPEACHMSK11_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK11_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK11_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK11_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK11_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK11_NYETMSK_V << USB_OTGHS_DOEPEACHMSK11_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK11_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK11_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK12_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK12_REG (DR_REG_USB_OTGHS_BASE + 0x8b0)
/** USB_OTGHS_DOEPEACHMSK12_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK12_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK12_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK12_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK12_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK12_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK12_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK12_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK12_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK12_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK12_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK12_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK12_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK12_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK12_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK12_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK12_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK12_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK12_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK12_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK12_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK12_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK12_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK12_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK12_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK12_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK12_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK12_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK12_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK12_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK12_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK12_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK12_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK12_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK12_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK12_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK12_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK12_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK12_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK12_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK12_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK12_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK12_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK12_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK12_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK12_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK12_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK12_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK12_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK12_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK12_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK12_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK12_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK12_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK12_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK12_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK12_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK12_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK12_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK12_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK12_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK12_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK12_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK12_NAKMSK_V << USB_OTGHS_DOEPEACHMSK12_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK12_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK12_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK12_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK12_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK12_NYETMSK_V << USB_OTGHS_DOEPEACHMSK12_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK12_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK12_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK13_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK13_REG (DR_REG_USB_OTGHS_BASE + 0x8b4)
/** USB_OTGHS_DOEPEACHMSK13_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK13_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK13_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK13_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK13_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK13_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK13_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK13_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK13_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK13_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK13_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK13_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK13_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK13_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK13_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK13_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK13_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK13_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK13_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK13_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK13_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK13_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK13_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK13_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK13_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK13_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK13_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK13_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK13_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK13_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK13_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK13_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK13_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK13_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK13_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK13_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK13_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK13_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK13_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK13_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK13_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK13_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK13_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK13_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK13_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK13_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK13_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK13_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK13_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK13_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK13_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK13_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK13_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK13_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK13_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK13_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK13_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK13_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK13_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK13_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK13_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK13_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK13_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK13_NAKMSK_V << USB_OTGHS_DOEPEACHMSK13_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK13_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK13_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK13_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK13_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK13_NYETMSK_V << USB_OTGHS_DOEPEACHMSK13_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK13_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK13_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK14_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK14_REG (DR_REG_USB_OTGHS_BASE + 0x8b8)
/** USB_OTGHS_DOEPEACHMSK14_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK14_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK14_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK14_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK14_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK14_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK14_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK14_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK14_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK14_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK14_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK14_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK14_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK14_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK14_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK14_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK14_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK14_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK14_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK14_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK14_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK14_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK14_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK14_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK14_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK14_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK14_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK14_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK14_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK14_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK14_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK14_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK14_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK14_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK14_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK14_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK14_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK14_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK14_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK14_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK14_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK14_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK14_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK14_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK14_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK14_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK14_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK14_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK14_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK14_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK14_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK14_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK14_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK14_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK14_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK14_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK14_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK14_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK14_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK14_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK14_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK14_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK14_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK14_NAKMSK_V << USB_OTGHS_DOEPEACHMSK14_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK14_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK14_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK14_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK14_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK14_NYETMSK_V << USB_OTGHS_DOEPEACHMSK14_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK14_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK14_NYETMSK_S  14

/** USB_OTGHS_DOEPEACHMSK15_REG register
 *  This register contains the interrupts for the OUT Endpoints of the Device
 *  controller. Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DOEPEACHMSK15_REG (DR_REG_USB_OTGHS_BASE + 0x8bc)
/** USB_OTGHS_DOEPEACHMSK15_XFERCOMPLMSK : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt Mask (XferComplMsk)
 */
#define USB_OTGHS_DOEPEACHMSK15_XFERCOMPLMSK    (BIT(0))
#define USB_OTGHS_DOEPEACHMSK15_XFERCOMPLMSK_M  (USB_OTGHS_DOEPEACHMSK15_XFERCOMPLMSK_V << USB_OTGHS_DOEPEACHMSK15_XFERCOMPLMSK_S)
#define USB_OTGHS_DOEPEACHMSK15_XFERCOMPLMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_XFERCOMPLMSK_S  0
/** USB_OTGHS_DOEPEACHMSK15_EPDISBLDMSK : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt Mask (EPDisbldMsk)
 */
#define USB_OTGHS_DOEPEACHMSK15_EPDISBLDMSK    (BIT(1))
#define USB_OTGHS_DOEPEACHMSK15_EPDISBLDMSK_M  (USB_OTGHS_DOEPEACHMSK15_EPDISBLDMSK_V << USB_OTGHS_DOEPEACHMSK15_EPDISBLDMSK_S)
#define USB_OTGHS_DOEPEACHMSK15_EPDISBLDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_EPDISBLDMSK_S  1
/** USB_OTGHS_DOEPEACHMSK15_AHBERRMSK : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK15_AHBERRMSK    (BIT(2))
#define USB_OTGHS_DOEPEACHMSK15_AHBERRMSK_M  (USB_OTGHS_DOEPEACHMSK15_AHBERRMSK_V << USB_OTGHS_DOEPEACHMSK15_AHBERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK15_AHBERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_AHBERRMSK_S  2
/** USB_OTGHS_DOEPEACHMSK15_SETUPMSK : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done Mask (SetUPMsk)
 *
 *  Applies to control endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK15_SETUPMSK    (BIT(3))
#define USB_OTGHS_DOEPEACHMSK15_SETUPMSK_M  (USB_OTGHS_DOEPEACHMSK15_SETUPMSK_V << USB_OTGHS_DOEPEACHMSK15_SETUPMSK_S)
#define USB_OTGHS_DOEPEACHMSK15_SETUPMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_SETUPMSK_S  3
/** USB_OTGHS_DOEPEACHMSK15_OUTTKNEPDISMSK : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK15_OUTTKNEPDISMSK    (BIT(4))
#define USB_OTGHS_DOEPEACHMSK15_OUTTKNEPDISMSK_M  (USB_OTGHS_DOEPEACHMSK15_OUTTKNEPDISMSK_V << USB_OTGHS_DOEPEACHMSK15_OUTTKNEPDISMSK_S)
#define USB_OTGHS_DOEPEACHMSK15_OUTTKNEPDISMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_OUTTKNEPDISMSK_S  4
/** USB_OTGHS_DOEPEACHMSK15_STSPHSRCVDMSK : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received Mask (StsPhsRcvdMsk)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK15_STSPHSRCVDMSK    (BIT(5))
#define USB_OTGHS_DOEPEACHMSK15_STSPHSRCVDMSK_M  (USB_OTGHS_DOEPEACHMSK15_STSPHSRCVDMSK_V << USB_OTGHS_DOEPEACHMSK15_STSPHSRCVDMSK_S)
#define USB_OTGHS_DOEPEACHMSK15_STSPHSRCVDMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_STSPHSRCVDMSK_S  5
/** USB_OTGHS_DOEPEACHMSK15_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
 *
 *  Applies to control OUT endpoints only.
 */
#define USB_OTGHS_DOEPEACHMSK15_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPEACHMSK15_BACK2BACKSETUP_M  (USB_OTGHS_DOEPEACHMSK15_BACK2BACKSETUP_V << USB_OTGHS_DOEPEACHMSK15_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPEACHMSK15_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPEACHMSK15_OUTPKTERRMSK : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error Mask (OutPktErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK15_OUTPKTERRMSK    (BIT(8))
#define USB_OTGHS_DOEPEACHMSK15_OUTPKTERRMSK_M  (USB_OTGHS_DOEPEACHMSK15_OUTPKTERRMSK_V << USB_OTGHS_DOEPEACHMSK15_OUTPKTERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK15_OUTPKTERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_OUTPKTERRMSK_S  8
/** USB_OTGHS_DOEPEACHMSK15_BNAOUTINTRMSK : R/W; bitpos: [9]; default: 0;
 *  BNA interrupt Mask (BnaOutIntrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK15_BNAOUTINTRMSK    (BIT(9))
#define USB_OTGHS_DOEPEACHMSK15_BNAOUTINTRMSK_M  (USB_OTGHS_DOEPEACHMSK15_BNAOUTINTRMSK_V << USB_OTGHS_DOEPEACHMSK15_BNAOUTINTRMSK_S)
#define USB_OTGHS_DOEPEACHMSK15_BNAOUTINTRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_BNAOUTINTRMSK_S  9
/** USB_OTGHS_DOEPEACHMSK15_BBLEERRMSK : R/W; bitpos: [12]; default: 0;
 *  Babble Error interrupt Mask (BbleErrMsk)
 */
#define USB_OTGHS_DOEPEACHMSK15_BBLEERRMSK    (BIT(12))
#define USB_OTGHS_DOEPEACHMSK15_BBLEERRMSK_M  (USB_OTGHS_DOEPEACHMSK15_BBLEERRMSK_V << USB_OTGHS_DOEPEACHMSK15_BBLEERRMSK_S)
#define USB_OTGHS_DOEPEACHMSK15_BBLEERRMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_BBLEERRMSK_S  12
/** USB_OTGHS_DOEPEACHMSK15_NAKMSK : R/W; bitpos: [13]; default: 0;
 *  NAK interrupt Mask (NAKMsk)
 */
#define USB_OTGHS_DOEPEACHMSK15_NAKMSK    (BIT(13))
#define USB_OTGHS_DOEPEACHMSK15_NAKMSK_M  (USB_OTGHS_DOEPEACHMSK15_NAKMSK_V << USB_OTGHS_DOEPEACHMSK15_NAKMSK_S)
#define USB_OTGHS_DOEPEACHMSK15_NAKMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_NAKMSK_S  13
/** USB_OTGHS_DOEPEACHMSK15_NYETMSK : R/W; bitpos: [14]; default: 0;
 *  NYET interrupt Mask (NYETMsk)
 */
#define USB_OTGHS_DOEPEACHMSK15_NYETMSK    (BIT(14))
#define USB_OTGHS_DOEPEACHMSK15_NYETMSK_M  (USB_OTGHS_DOEPEACHMSK15_NYETMSK_V << USB_OTGHS_DOEPEACHMSK15_NYETMSK_S)
#define USB_OTGHS_DOEPEACHMSK15_NYETMSK_V  0x00000001U
#define USB_OTGHS_DOEPEACHMSK15_NYETMSK_S  14

/** USB_OTGHS_DIEPCTL0_REG register
 *  This register is used to control the characteristics of the IN Endpoint 0 of the
 *  Device controller.
 */
#define USB_OTGHS_DIEPCTL0_REG (DR_REG_USB_OTGHS_BASE + 0x900)
/** USB_OTGHS_DIEPCTL0_MPS : R/W; bitpos: [1:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint.
 *  - 2'b00: 64 bytes
 *  - 2'b01: 32 bytes
 *  - 2'b10: 16 bytes
 *  - 2'b11: 8 bytes
 */
#define USB_OTGHS_DIEPCTL0_MPS    0x00000003U
#define USB_OTGHS_DIEPCTL0_MPS_M  (USB_OTGHS_DIEPCTL0_MPS_V << USB_OTGHS_DIEPCTL0_MPS_S)
#define USB_OTGHS_DIEPCTL0_MPS_V  0x00000003U
#define USB_OTGHS_DIEPCTL0_MPS_S  0
/** USB_OTGHS_DIEPCTL0_USBACTEP : RO; bitpos: [15]; default: 1;
 *  USB Active Endpoint (USBActEP)
 *
 *  This bit is always SET to 1, indicating that control endpoint 0 is always active in
 *  all configurations and interfaces.
 */
#define USB_OTGHS_DIEPCTL0_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL0_USBACTEP_M  (USB_OTGHS_DIEPCTL0_USBACTEP_V << USB_OTGHS_DIEPCTL0_USBACTEP_S)
#define USB_OTGHS_DIEPCTL0_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL0_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL0_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When this bit is set, either by the application or core, the core stops
 *  transmitting data, even If there is data available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data
 *  packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL0_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL0_NAKSTS_M  (USB_OTGHS_DIEPCTL0_NAKSTS_V << USB_OTGHS_DIEPCTL0_NAKSTS_S)
#define USB_OTGHS_DIEPCTL0_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL0_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL0_EPTYPE : RO; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Hardcoded to 00 for control.
 */
#define USB_OTGHS_DIEPCTL0_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL0_EPTYPE_M  (USB_OTGHS_DIEPCTL0_EPTYPE_V << USB_OTGHS_DIEPCTL0_EPTYPE_S)
#define USB_OTGHS_DIEPCTL0_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL0_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL0_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  The application can only set this bit, and the core clears it, when a
 *  SETUP token is received for this endpoint. If a NAK bit, Global Nonperiodic
 *  IN NAK, or Global OUT NAK is set along with this bit, the STALL
 *  bit takes priority.
 */
#define USB_OTGHS_DIEPCTL0_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL0_STALL_M  (USB_OTGHS_DIEPCTL0_STALL_V << USB_OTGHS_DIEPCTL0_STALL_S)
#define USB_OTGHS_DIEPCTL0_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL0_STALL_S  21
/** USB_OTGHS_DIEPCTL0_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *  - For Shared FIFO operation, this value is always set to 0, indicating that control
 *  IN endpoint 0 data is always written in the Non-Periodic Transmit FIFO.
 *  - For Dedicated FIFO operation, this value is set to the FIFO number that is
 *  assigned to IN Endpoint.
 */
#define USB_OTGHS_DIEPCTL0_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL0_TXFNUM_M  (USB_OTGHS_DIEPCTL0_TXFNUM_V << USB_OTGHS_DIEPCTL0_TXFNUM_S)
#define USB_OTGHS_DIEPCTL0_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL0_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL0_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL0_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL0_CNAK_M  (USB_OTGHS_DIEPCTL0_CNAK_V << USB_OTGHS_DIEPCTL0_CNAK_S)
#define USB_OTGHS_DIEPCTL0_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL0_CNAK_S  26
/** USB_OTGHS_DIEPCTL0_SNAK : R/W; bitpos: [27]; default: 0;
 *
 *  Set NAK (SNAK)
 *  A write to this bit sets the NAK bit for the endpoint.
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL0_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL0_SNAK_M  (USB_OTGHS_DIEPCTL0_SNAK_V << USB_OTGHS_DIEPCTL0_SNAK_S)
#define USB_OTGHS_DIEPCTL0_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL0_SNAK_S  27
/** USB_OTGHS_DIEPCTL0_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  The application sets this bit to stop transmitting data on an endpoint,
 *  even before the transfer for that endpoint is complete. The application
 *  must wait for the Endpoint Disabled interrupt before treating the endpoint
 *  as disabled. The core clears this bit before setting the Endpoint Disabled
 *  Interrupt. The application must Set this bit only if Endpoint Enable is
 *  already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL0_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL0_EPDIS_M  (USB_OTGHS_DIEPCTL0_EPDIS_V << USB_OTGHS_DIEPCTL0_EPDIS_S)
#define USB_OTGHS_DIEPCTL0_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL0_EPDIS_S  30
/** USB_OTGHS_DIEPCTL0_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  When Scatter/Gather DMA mode is enabled for IN endpoints, this bit indicates that
 *  the descriptor structure and data buffer with data ready to transmit is setup.
 *
 *  When Scatter/Gather DMA mode is disabled (such as in buffer pointer based DMA mode)
 *  this bit indicates that data is ready to be transmitted on the endpoint.
 *  The core clears this bit before setting the following interrupts on this endpoint:
 *  - Endpoint Disabled
 *  - Transfer Completed
 */
#define USB_OTGHS_DIEPCTL0_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL0_EPENA_M  (USB_OTGHS_DIEPCTL0_EPENA_V << USB_OTGHS_DIEPCTL0_EPENA_S)
#define USB_OTGHS_DIEPCTL0_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL0_EPENA_S  31

/** USB_OTGHS_DIEPINT0_REG register
 *  This register indicates the status of an endpoint with respect to USB- and
 *  AHB-related events. It is shown in the Interrupt Hierarchy figure in the databook.
 *  The application must read this register when the OUT Endpoints Interrupt bit or IN
 *  Endpoints Interrupt bit of the Core Interrupt register (GINTSTS.OEPInt or
 *  GINTSTS.IEPInt, respectively) is set. Before the application can read this
 *  register, it must first read the Device All Endpoints Interrupt (DAINT) register to
 *  get the exact endpoint number for the Device Endpoint-n Interrupt register. The
 *  application must clear the appropriate bit in this register to clear the
 *  corresponding bits in the DAINT and GINTSTS registers
 */
#define USB_OTGHS_DIEPINT0_REG (DR_REG_USB_OTGHS_BASE + 0x908)
/** USB_OTGHS_DIEPINT0_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT0_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT0_XFERCOMPL_M  (USB_OTGHS_DIEPINT0_XFERCOMPL_V << USB_OTGHS_DIEPINT0_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT0_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT0_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT0_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT0_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT0_EPDISBLD_M  (USB_OTGHS_DIEPINT0_EPDISBLD_V << USB_OTGHS_DIEPINT0_EPDISBLD_S)
#define USB_OTGHS_DIEPINT0_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT0_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT0_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT0_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT0_AHBERR_M  (USB_OTGHS_DIEPINT0_AHBERR_V << USB_OTGHS_DIEPINT0_AHBERR_S)
#define USB_OTGHS_DIEPINT0_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT0_AHBERR_S  2
/** USB_OTGHS_DIEPINT0_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT0_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT0_TIMEOUT_M  (USB_OTGHS_DIEPINT0_TIMEOUT_V << USB_OTGHS_DIEPINT0_TIMEOUT_S)
#define USB_OTGHS_DIEPINT0_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT0_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT0_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT0_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT0_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT0_INTKNTXFEMP_V << USB_OTGHS_DIEPINT0_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT0_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT0_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT0_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT0_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT0_INTKNEPMIS_M  (USB_OTGHS_DIEPINT0_INTKNEPMIS_V << USB_OTGHS_DIEPINT0_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT0_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT0_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT0_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core).
 *
 *  The interrupt indicates that the IN endpoint NAK bit Set by the application has
 *  taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT0_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT0_INEPNAKEFF_M  (USB_OTGHS_DIEPINT0_INEPNAKEFF_V << USB_OTGHS_DIEPINT0_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT0_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT0_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT0_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN Endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is either half or
 *  completely empty. The half or completely empty status is determined by the TxFIFO
 *  Empty Level bit in the Core AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT0_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT0_TXFEMP_M  (USB_OTGHS_DIEPINT0_TXFEMP_V << USB_OTGHS_DIEPINT0_TXFEMP_S)
#define USB_OTGHS_DIEPINT0_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT0_TXFEMP_S  7
/** USB_OTGHS_DIEPINT0_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints only.
 *
 *  The core generates this interrupt when it detects a transmit FIFO underrun
 *  condition in threshold mode for this endpoint.
 */
#define USB_OTGHS_DIEPINT0_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT0_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT0_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT0_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT0_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT0_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT0_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled. The core generates
 *  this interrupt when the descriptor accessed is not ready for the Core to process,
 *  such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT0_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT0_BNAINTR_M  (USB_OTGHS_DIEPINT0_BNAINTR_V << USB_OTGHS_DIEPINT0_BNAINTR_S)
#define USB_OTGHS_DIEPINT0_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT0_BNAINTR_S  9
/** USB_OTGHS_DIEPINT0_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped.
 *  This bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT0_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT0_PKTDRPSTS_M  (USB_OTGHS_DIEPINT0_PKTDRPSTS_V << USB_OTGHS_DIEPINT0_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT0_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT0_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT0_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT0_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT0_BBLEERR_M  (USB_OTGHS_DIEPINT0_BBLEERR_V << USB_OTGHS_DIEPINT0_BBLEERR_S)
#define USB_OTGHS_DIEPINT0_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT0_BBLEERR_S  12
/** USB_OTGHS_DIEPINT0_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  <bring case of isochronous IN endpoints the interrupt gets generated when a zero
 *  length packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT0_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT0_NAKINTRPT_M  (USB_OTGHS_DIEPINT0_NAKINTRPT_V << USB_OTGHS_DIEPINT0_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT0_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT0_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT0_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT0_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT0_NYETINTRPT_M  (USB_OTGHS_DIEPINT0_NYETINTRPT_V << USB_OTGHS_DIEPINT0_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT0_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT0_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ0_REG register
 *  The application must modify this register before enabling endpoint 0. Once endpoint
 *  0 is enabled using Endpoint Enable bit of the Device Control Endpoint 0 Control
 *  registers (DIEPCTL0.EPEna/DOEPCTL0.EPEna), the core modifies this register. The
 *  application can only read this register once the core has cleared the Endpoint
 *  Enable bit. Nonzero endpoints use the registers for endpoints 115. When
 *  Scatter/Gather DMA mode is enabled, this register must not be programmed by the
 *  application. If the application reads this register when Scatter/Gather DMA mode is
 *  enabled, the core returns all zeros.
 */
#define USB_OTGHS_DIEPTSIZ0_REG (DR_REG_USB_OTGHS_BASE + 0x910)
/** USB_OTGHS_DIEPTSIZ0_XFERSIZE : R/W; bitpos: [6:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  This field contains the transfer size in bytes for the current endpoint. The
 *  transfer size (XferSize) = Sum of buffer sizes across all descriptors in the list
 *  for the endpoint.
 *  In Buffer DMA, the core only interrupts the application after it has exhausted the
 *  transfer size amount of data. The transfer size can be set to the maximum packet
 *  size of the endpoint, to be interrupted at the end of each packet.
 *  - IN Endpoints: The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 *  - OUT Endpoints: The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DIEPTSIZ0_XFERSIZE    0x0000007FU
#define USB_OTGHS_DIEPTSIZ0_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ0_XFERSIZE_V << USB_OTGHS_DIEPTSIZ0_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ0_XFERSIZE_V  0x0000007FU
#define USB_OTGHS_DIEPTSIZ0_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ0_PKTCNT : R/W; bitpos: [20:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the
 *
 *  Transfer Size amount of data for endpoint 0.
 *  - IN Endpoints : This field is decremented every time a packet (maximum size or
 *  short packet) is read from the TxFIFO.
 *  - OUT Endpoints: This field is decremented every time a packet (maximum size or
 *  short packet) is written to the RxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ0_PKTCNT    0x00000003U
#define USB_OTGHS_DIEPTSIZ0_PKTCNT_M  (USB_OTGHS_DIEPTSIZ0_PKTCNT_V << USB_OTGHS_DIEPTSIZ0_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ0_PKTCNT_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ0_PKTCNT_S  19

/** USB_OTGHS_DIEPDMA0_REG register
 *  This register contains the DMA Address for the IN Endpoint 0 of the Device
 *  controller.
 */
#define USB_OTGHS_DIEPDMA0_REG (DR_REG_USB_OTGHS_BASE + 0x914)
/** USB_OTGHS_DIEPDMA0_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  DMAAddr
 *
 *  This field holds the start address of the external memory for storing or fetching
 *  endpoint data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *
 *  When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *
 *  When Scatter/Gather DMA mode is enabled, this field indicates the base pointer for
 *  the descriptor list.
 */
#define USB_OTGHS_DIEPDMA0_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA0_DMAADDR_M  (USB_OTGHS_DIEPDMA0_DMAADDR_V << USB_OTGHS_DIEPDMA0_DMAADDR_S)
#define USB_OTGHS_DIEPDMA0_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA0_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS0_REG register
 *  This register contains information about the IN Endpoint Transmit FIFO of the
 *  Device controller.
 */
#define USB_OTGHS_DTXFSTS0_REG (DR_REG_USB_OTGHS_BASE + 0x918)
/** USB_OTGHS_DTXFSTS0_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic FIFO sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC = 1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS0_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS0_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS0_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS0_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS0_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS0_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB0_REG register
 *  This register contains the DMA Buffer Address for the IN Endpoint 0 of the Device
 *  controller.
 */
#define USB_OTGHS_DIEPDMAB0_REG (DR_REG_USB_OTGHS_BASE + 0x91c)
/** USB_OTGHS_DIEPDMAB0_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB0_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB0_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB0_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB0_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB0_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB0_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL1_REG register
 *  This register is used to control the characteristics of Endpoint 1.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL1_REG (DR_REG_USB_OTGHS_BASE + 0x920)
/** USB_OTGHS_DIEPCTL1_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL1_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL1_MPS_M  (USB_OTGHS_DIEPCTL1_MPS_V << USB_OTGHS_DIEPCTL1_MPS_S)
#define USB_OTGHS_DIEPCTL1_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL1_MPS_S  0
/** USB_OTGHS_DIEPCTL1_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL1_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL1_USBACTEP_M  (USB_OTGHS_DIEPCTL1_USBACTEP_V << USB_OTGHS_DIEPCTL1_USBACTEP_S)
#define USB_OTGHS_DIEPCTL1_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL1_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL1_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL1_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL1_DPID_M  (USB_OTGHS_DIEPCTL1_DPID_V << USB_OTGHS_DIEPCTL1_DPID_S)
#define USB_OTGHS_DIEPCTL1_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL1_DPID_S  16
/** USB_OTGHS_DIEPCTL1_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL1_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL1_NAKSTS_M  (USB_OTGHS_DIEPCTL1_NAKSTS_V << USB_OTGHS_DIEPCTL1_NAKSTS_S)
#define USB_OTGHS_DIEPCTL1_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL1_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL1_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL1_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL1_EPTYPE_M  (USB_OTGHS_DIEPCTL1_EPTYPE_V << USB_OTGHS_DIEPCTL1_EPTYPE_S)
#define USB_OTGHS_DIEPCTL1_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL1_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL1_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL1_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL1_STALL_M  (USB_OTGHS_DIEPCTL1_STALL_V << USB_OTGHS_DIEPCTL1_STALL_S)
#define USB_OTGHS_DIEPCTL1_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL1_STALL_S  21
/** USB_OTGHS_DIEPCTL1_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL1_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL1_TXFNUM_M  (USB_OTGHS_DIEPCTL1_TXFNUM_V << USB_OTGHS_DIEPCTL1_TXFNUM_S)
#define USB_OTGHS_DIEPCTL1_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL1_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL1_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL1_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL1_CNAK_M  (USB_OTGHS_DIEPCTL1_CNAK_V << USB_OTGHS_DIEPCTL1_CNAK_S)
#define USB_OTGHS_DIEPCTL1_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL1_CNAK_S  26
/** USB_OTGHS_DIEPCTL1_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL1_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL1_SNAK_M  (USB_OTGHS_DIEPCTL1_SNAK_V << USB_OTGHS_DIEPCTL1_SNAK_S)
#define USB_OTGHS_DIEPCTL1_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL1_SNAK_S  27
/** USB_OTGHS_DIEPCTL1_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL1_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL1_SETD0PID_M  (USB_OTGHS_DIEPCTL1_SETD0PID_V << USB_OTGHS_DIEPCTL1_SETD0PID_S)
#define USB_OTGHS_DIEPCTL1_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL1_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL1_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL1_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL1_SETD1PID_M  (USB_OTGHS_DIEPCTL1_SETD1PID_V << USB_OTGHS_DIEPCTL1_SETD1PID_S)
#define USB_OTGHS_DIEPCTL1_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL1_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL1_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL1_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL1_EPDIS_M  (USB_OTGHS_DIEPCTL1_EPDIS_V << USB_OTGHS_DIEPCTL1_EPDIS_S)
#define USB_OTGHS_DIEPCTL1_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL1_EPDIS_S  30
/** USB_OTGHS_DIEPCTL1_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL1_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL1_EPENA_M  (USB_OTGHS_DIEPCTL1_EPENA_V << USB_OTGHS_DIEPCTL1_EPENA_S)
#define USB_OTGHS_DIEPCTL1_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL1_EPENA_S  31

/** USB_OTGHS_DIEPINT1_REG register
 *  This register contains the interrupts for the IN Endpoint 1 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT1_REG (DR_REG_USB_OTGHS_BASE + 0x928)
/** USB_OTGHS_DIEPINT1_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT1_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT1_XFERCOMPL_M  (USB_OTGHS_DIEPINT1_XFERCOMPL_V << USB_OTGHS_DIEPINT1_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT1_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT1_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT1_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT1_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT1_EPDISBLD_M  (USB_OTGHS_DIEPINT1_EPDISBLD_V << USB_OTGHS_DIEPINT1_EPDISBLD_S)
#define USB_OTGHS_DIEPINT1_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT1_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT1_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT1_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT1_AHBERR_M  (USB_OTGHS_DIEPINT1_AHBERR_V << USB_OTGHS_DIEPINT1_AHBERR_S)
#define USB_OTGHS_DIEPINT1_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT1_AHBERR_S  2
/** USB_OTGHS_DIEPINT1_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT1_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT1_TIMEOUT_M  (USB_OTGHS_DIEPINT1_TIMEOUT_V << USB_OTGHS_DIEPINT1_TIMEOUT_S)
#define USB_OTGHS_DIEPINT1_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT1_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT1_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT1_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT1_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT1_INTKNTXFEMP_V << USB_OTGHS_DIEPINT1_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT1_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT1_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT1_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT1_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT1_INTKNEPMIS_M  (USB_OTGHS_DIEPINT1_INTKNEPMIS_V << USB_OTGHS_DIEPINT1_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT1_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT1_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT1_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT1_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT1_INEPNAKEFF_M  (USB_OTGHS_DIEPINT1_INEPNAKEFF_V << USB_OTGHS_DIEPINT1_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT1_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT1_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT1_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT1_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT1_TXFEMP_M  (USB_OTGHS_DIEPINT1_TXFEMP_V << USB_OTGHS_DIEPINT1_TXFEMP_S)
#define USB_OTGHS_DIEPINT1_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT1_TXFEMP_S  7
/** USB_OTGHS_DIEPINT1_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT1_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT1_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT1_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT1_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT1_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT1_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT1_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT1_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT1_BNAINTR_M  (USB_OTGHS_DIEPINT1_BNAINTR_V << USB_OTGHS_DIEPINT1_BNAINTR_S)
#define USB_OTGHS_DIEPINT1_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT1_BNAINTR_S  9
/** USB_OTGHS_DIEPINT1_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT1_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT1_PKTDRPSTS_M  (USB_OTGHS_DIEPINT1_PKTDRPSTS_V << USB_OTGHS_DIEPINT1_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT1_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT1_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT1_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT1_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT1_BBLEERR_M  (USB_OTGHS_DIEPINT1_BBLEERR_V << USB_OTGHS_DIEPINT1_BBLEERR_S)
#define USB_OTGHS_DIEPINT1_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT1_BBLEERR_S  12
/** USB_OTGHS_DIEPINT1_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT1_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT1_NAKINTRPT_M  (USB_OTGHS_DIEPINT1_NAKINTRPT_V << USB_OTGHS_DIEPINT1_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT1_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT1_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT1_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT1_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT1_NYETINTRPT_M  (USB_OTGHS_DIEPINT1_NYETINTRPT_V << USB_OTGHS_DIEPINT1_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT1_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT1_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ1_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 1 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ1_REG (DR_REG_USB_OTGHS_BASE + 0x930)
/** USB_OTGHS_DIEPTSIZ1_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ1_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ1_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ1_XFERSIZE_V << USB_OTGHS_DIEPTSIZ1_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ1_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ1_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ1_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ1_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ1_PKTCNT_M  (USB_OTGHS_DIEPTSIZ1_PKTCNT_V << USB_OTGHS_DIEPTSIZ1_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ1_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ1_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ1_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ1_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ1_MC_M  (USB_OTGHS_DIEPTSIZ1_MC_V << USB_OTGHS_DIEPTSIZ1_MC_S)
#define USB_OTGHS_DIEPTSIZ1_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ1_MC_S  29

/** USB_OTGHS_DIEPDMA1_REG register
 *  This register contains the DMA Address for the IN Endpoint 1 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA1_REG (DR_REG_USB_OTGHS_BASE + 0x934)
/** USB_OTGHS_DIEPDMA1_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA1_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA1_DMAADDR_M  (USB_OTGHS_DIEPDMA1_DMAADDR_V << USB_OTGHS_DIEPDMA1_DMAADDR_S)
#define USB_OTGHS_DIEPDMA1_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA1_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS1_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  1 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS1_REG (DR_REG_USB_OTGHS_BASE + 0x938)
/** USB_OTGHS_DTXFSTS1_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS1_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS1_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS1_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS1_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS1_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS1_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB1_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 1 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB1_REG (DR_REG_USB_OTGHS_BASE + 0x93c)
/** USB_OTGHS_DIEPDMAB1_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB1_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB1_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB1_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB1_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB1_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB1_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL2_REG register
 *  This register is used to control the characteristics of Endpoint 2.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL2_REG (DR_REG_USB_OTGHS_BASE + 0x940)
/** USB_OTGHS_DIEPCTL2_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL2_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL2_MPS_M  (USB_OTGHS_DIEPCTL2_MPS_V << USB_OTGHS_DIEPCTL2_MPS_S)
#define USB_OTGHS_DIEPCTL2_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL2_MPS_S  0
/** USB_OTGHS_DIEPCTL2_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL2_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL2_USBACTEP_M  (USB_OTGHS_DIEPCTL2_USBACTEP_V << USB_OTGHS_DIEPCTL2_USBACTEP_S)
#define USB_OTGHS_DIEPCTL2_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL2_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL2_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL2_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL2_DPID_M  (USB_OTGHS_DIEPCTL2_DPID_V << USB_OTGHS_DIEPCTL2_DPID_S)
#define USB_OTGHS_DIEPCTL2_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL2_DPID_S  16
/** USB_OTGHS_DIEPCTL2_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL2_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL2_NAKSTS_M  (USB_OTGHS_DIEPCTL2_NAKSTS_V << USB_OTGHS_DIEPCTL2_NAKSTS_S)
#define USB_OTGHS_DIEPCTL2_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL2_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL2_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL2_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL2_EPTYPE_M  (USB_OTGHS_DIEPCTL2_EPTYPE_V << USB_OTGHS_DIEPCTL2_EPTYPE_S)
#define USB_OTGHS_DIEPCTL2_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL2_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL2_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL2_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL2_STALL_M  (USB_OTGHS_DIEPCTL2_STALL_V << USB_OTGHS_DIEPCTL2_STALL_S)
#define USB_OTGHS_DIEPCTL2_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL2_STALL_S  21
/** USB_OTGHS_DIEPCTL2_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL2_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL2_TXFNUM_M  (USB_OTGHS_DIEPCTL2_TXFNUM_V << USB_OTGHS_DIEPCTL2_TXFNUM_S)
#define USB_OTGHS_DIEPCTL2_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL2_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL2_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL2_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL2_CNAK_M  (USB_OTGHS_DIEPCTL2_CNAK_V << USB_OTGHS_DIEPCTL2_CNAK_S)
#define USB_OTGHS_DIEPCTL2_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL2_CNAK_S  26
/** USB_OTGHS_DIEPCTL2_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL2_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL2_SNAK_M  (USB_OTGHS_DIEPCTL2_SNAK_V << USB_OTGHS_DIEPCTL2_SNAK_S)
#define USB_OTGHS_DIEPCTL2_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL2_SNAK_S  27
/** USB_OTGHS_DIEPCTL2_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL2_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL2_SETD0PID_M  (USB_OTGHS_DIEPCTL2_SETD0PID_V << USB_OTGHS_DIEPCTL2_SETD0PID_S)
#define USB_OTGHS_DIEPCTL2_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL2_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL2_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL2_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL2_SETD1PID_M  (USB_OTGHS_DIEPCTL2_SETD1PID_V << USB_OTGHS_DIEPCTL2_SETD1PID_S)
#define USB_OTGHS_DIEPCTL2_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL2_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL2_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL2_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL2_EPDIS_M  (USB_OTGHS_DIEPCTL2_EPDIS_V << USB_OTGHS_DIEPCTL2_EPDIS_S)
#define USB_OTGHS_DIEPCTL2_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL2_EPDIS_S  30
/** USB_OTGHS_DIEPCTL2_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL2_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL2_EPENA_M  (USB_OTGHS_DIEPCTL2_EPENA_V << USB_OTGHS_DIEPCTL2_EPENA_S)
#define USB_OTGHS_DIEPCTL2_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL2_EPENA_S  31

/** USB_OTGHS_DIEPINT2_REG register
 *  This register contains the interrupts for the IN Endpoint 2 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT2_REG (DR_REG_USB_OTGHS_BASE + 0x948)
/** USB_OTGHS_DIEPINT2_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT2_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT2_XFERCOMPL_M  (USB_OTGHS_DIEPINT2_XFERCOMPL_V << USB_OTGHS_DIEPINT2_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT2_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT2_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT2_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT2_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT2_EPDISBLD_M  (USB_OTGHS_DIEPINT2_EPDISBLD_V << USB_OTGHS_DIEPINT2_EPDISBLD_S)
#define USB_OTGHS_DIEPINT2_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT2_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT2_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT2_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT2_AHBERR_M  (USB_OTGHS_DIEPINT2_AHBERR_V << USB_OTGHS_DIEPINT2_AHBERR_S)
#define USB_OTGHS_DIEPINT2_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT2_AHBERR_S  2
/** USB_OTGHS_DIEPINT2_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT2_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT2_TIMEOUT_M  (USB_OTGHS_DIEPINT2_TIMEOUT_V << USB_OTGHS_DIEPINT2_TIMEOUT_S)
#define USB_OTGHS_DIEPINT2_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT2_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT2_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT2_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT2_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT2_INTKNTXFEMP_V << USB_OTGHS_DIEPINT2_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT2_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT2_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT2_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT2_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT2_INTKNEPMIS_M  (USB_OTGHS_DIEPINT2_INTKNEPMIS_V << USB_OTGHS_DIEPINT2_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT2_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT2_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT2_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT2_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT2_INEPNAKEFF_M  (USB_OTGHS_DIEPINT2_INEPNAKEFF_V << USB_OTGHS_DIEPINT2_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT2_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT2_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT2_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT2_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT2_TXFEMP_M  (USB_OTGHS_DIEPINT2_TXFEMP_V << USB_OTGHS_DIEPINT2_TXFEMP_S)
#define USB_OTGHS_DIEPINT2_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT2_TXFEMP_S  7
/** USB_OTGHS_DIEPINT2_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT2_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT2_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT2_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT2_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT2_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT2_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT2_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT2_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT2_BNAINTR_M  (USB_OTGHS_DIEPINT2_BNAINTR_V << USB_OTGHS_DIEPINT2_BNAINTR_S)
#define USB_OTGHS_DIEPINT2_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT2_BNAINTR_S  9
/** USB_OTGHS_DIEPINT2_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT2_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT2_PKTDRPSTS_M  (USB_OTGHS_DIEPINT2_PKTDRPSTS_V << USB_OTGHS_DIEPINT2_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT2_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT2_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT2_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT2_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT2_BBLEERR_M  (USB_OTGHS_DIEPINT2_BBLEERR_V << USB_OTGHS_DIEPINT2_BBLEERR_S)
#define USB_OTGHS_DIEPINT2_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT2_BBLEERR_S  12
/** USB_OTGHS_DIEPINT2_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT2_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT2_NAKINTRPT_M  (USB_OTGHS_DIEPINT2_NAKINTRPT_V << USB_OTGHS_DIEPINT2_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT2_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT2_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT2_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT2_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT2_NYETINTRPT_M  (USB_OTGHS_DIEPINT2_NYETINTRPT_V << USB_OTGHS_DIEPINT2_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT2_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT2_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ2_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 2 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ2_REG (DR_REG_USB_OTGHS_BASE + 0x950)
/** USB_OTGHS_DIEPTSIZ2_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ2_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ2_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ2_XFERSIZE_V << USB_OTGHS_DIEPTSIZ2_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ2_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ2_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ2_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ2_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ2_PKTCNT_M  (USB_OTGHS_DIEPTSIZ2_PKTCNT_V << USB_OTGHS_DIEPTSIZ2_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ2_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ2_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ2_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ2_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ2_MC_M  (USB_OTGHS_DIEPTSIZ2_MC_V << USB_OTGHS_DIEPTSIZ2_MC_S)
#define USB_OTGHS_DIEPTSIZ2_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ2_MC_S  29

/** USB_OTGHS_DIEPDMA2_REG register
 *  This register contains the DMA Address for the IN Endpoint 2 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA2_REG (DR_REG_USB_OTGHS_BASE + 0x954)
/** USB_OTGHS_DIEPDMA2_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA2_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA2_DMAADDR_M  (USB_OTGHS_DIEPDMA2_DMAADDR_V << USB_OTGHS_DIEPDMA2_DMAADDR_S)
#define USB_OTGHS_DIEPDMA2_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA2_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS2_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  2 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS2_REG (DR_REG_USB_OTGHS_BASE + 0x958)
/** USB_OTGHS_DTXFSTS2_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS2_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS2_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS2_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS2_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS2_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS2_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB2_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 2 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB2_REG (DR_REG_USB_OTGHS_BASE + 0x95c)
/** USB_OTGHS_DIEPDMAB2_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB2_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB2_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB2_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB2_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB2_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB2_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL3_REG register
 *  This register is used to control the characteristics of Endpoint 3.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL3_REG (DR_REG_USB_OTGHS_BASE + 0x960)
/** USB_OTGHS_DIEPCTL3_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL3_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL3_MPS_M  (USB_OTGHS_DIEPCTL3_MPS_V << USB_OTGHS_DIEPCTL3_MPS_S)
#define USB_OTGHS_DIEPCTL3_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL3_MPS_S  0
/** USB_OTGHS_DIEPCTL3_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL3_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL3_USBACTEP_M  (USB_OTGHS_DIEPCTL3_USBACTEP_V << USB_OTGHS_DIEPCTL3_USBACTEP_S)
#define USB_OTGHS_DIEPCTL3_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL3_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL3_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL3_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL3_DPID_M  (USB_OTGHS_DIEPCTL3_DPID_V << USB_OTGHS_DIEPCTL3_DPID_S)
#define USB_OTGHS_DIEPCTL3_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL3_DPID_S  16
/** USB_OTGHS_DIEPCTL3_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL3_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL3_NAKSTS_M  (USB_OTGHS_DIEPCTL3_NAKSTS_V << USB_OTGHS_DIEPCTL3_NAKSTS_S)
#define USB_OTGHS_DIEPCTL3_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL3_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL3_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL3_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL3_EPTYPE_M  (USB_OTGHS_DIEPCTL3_EPTYPE_V << USB_OTGHS_DIEPCTL3_EPTYPE_S)
#define USB_OTGHS_DIEPCTL3_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL3_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL3_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL3_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL3_STALL_M  (USB_OTGHS_DIEPCTL3_STALL_V << USB_OTGHS_DIEPCTL3_STALL_S)
#define USB_OTGHS_DIEPCTL3_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL3_STALL_S  21
/** USB_OTGHS_DIEPCTL3_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL3_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL3_TXFNUM_M  (USB_OTGHS_DIEPCTL3_TXFNUM_V << USB_OTGHS_DIEPCTL3_TXFNUM_S)
#define USB_OTGHS_DIEPCTL3_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL3_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL3_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL3_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL3_CNAK_M  (USB_OTGHS_DIEPCTL3_CNAK_V << USB_OTGHS_DIEPCTL3_CNAK_S)
#define USB_OTGHS_DIEPCTL3_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL3_CNAK_S  26
/** USB_OTGHS_DIEPCTL3_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL3_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL3_SNAK_M  (USB_OTGHS_DIEPCTL3_SNAK_V << USB_OTGHS_DIEPCTL3_SNAK_S)
#define USB_OTGHS_DIEPCTL3_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL3_SNAK_S  27
/** USB_OTGHS_DIEPCTL3_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL3_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL3_SETD0PID_M  (USB_OTGHS_DIEPCTL3_SETD0PID_V << USB_OTGHS_DIEPCTL3_SETD0PID_S)
#define USB_OTGHS_DIEPCTL3_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL3_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL3_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL3_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL3_SETD1PID_M  (USB_OTGHS_DIEPCTL3_SETD1PID_V << USB_OTGHS_DIEPCTL3_SETD1PID_S)
#define USB_OTGHS_DIEPCTL3_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL3_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL3_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL3_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL3_EPDIS_M  (USB_OTGHS_DIEPCTL3_EPDIS_V << USB_OTGHS_DIEPCTL3_EPDIS_S)
#define USB_OTGHS_DIEPCTL3_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL3_EPDIS_S  30
/** USB_OTGHS_DIEPCTL3_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL3_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL3_EPENA_M  (USB_OTGHS_DIEPCTL3_EPENA_V << USB_OTGHS_DIEPCTL3_EPENA_S)
#define USB_OTGHS_DIEPCTL3_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL3_EPENA_S  31

/** USB_OTGHS_DIEPINT3_REG register
 *  This register contains the interrupts for the IN Endpoint 3 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT3_REG (DR_REG_USB_OTGHS_BASE + 0x968)
/** USB_OTGHS_DIEPINT3_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT3_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT3_XFERCOMPL_M  (USB_OTGHS_DIEPINT3_XFERCOMPL_V << USB_OTGHS_DIEPINT3_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT3_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT3_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT3_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT3_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT3_EPDISBLD_M  (USB_OTGHS_DIEPINT3_EPDISBLD_V << USB_OTGHS_DIEPINT3_EPDISBLD_S)
#define USB_OTGHS_DIEPINT3_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT3_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT3_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT3_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT3_AHBERR_M  (USB_OTGHS_DIEPINT3_AHBERR_V << USB_OTGHS_DIEPINT3_AHBERR_S)
#define USB_OTGHS_DIEPINT3_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT3_AHBERR_S  2
/** USB_OTGHS_DIEPINT3_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT3_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT3_TIMEOUT_M  (USB_OTGHS_DIEPINT3_TIMEOUT_V << USB_OTGHS_DIEPINT3_TIMEOUT_S)
#define USB_OTGHS_DIEPINT3_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT3_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT3_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT3_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT3_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT3_INTKNTXFEMP_V << USB_OTGHS_DIEPINT3_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT3_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT3_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT3_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT3_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT3_INTKNEPMIS_M  (USB_OTGHS_DIEPINT3_INTKNEPMIS_V << USB_OTGHS_DIEPINT3_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT3_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT3_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT3_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT3_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT3_INEPNAKEFF_M  (USB_OTGHS_DIEPINT3_INEPNAKEFF_V << USB_OTGHS_DIEPINT3_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT3_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT3_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT3_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT3_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT3_TXFEMP_M  (USB_OTGHS_DIEPINT3_TXFEMP_V << USB_OTGHS_DIEPINT3_TXFEMP_S)
#define USB_OTGHS_DIEPINT3_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT3_TXFEMP_S  7
/** USB_OTGHS_DIEPINT3_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT3_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT3_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT3_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT3_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT3_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT3_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT3_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT3_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT3_BNAINTR_M  (USB_OTGHS_DIEPINT3_BNAINTR_V << USB_OTGHS_DIEPINT3_BNAINTR_S)
#define USB_OTGHS_DIEPINT3_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT3_BNAINTR_S  9
/** USB_OTGHS_DIEPINT3_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT3_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT3_PKTDRPSTS_M  (USB_OTGHS_DIEPINT3_PKTDRPSTS_V << USB_OTGHS_DIEPINT3_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT3_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT3_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT3_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT3_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT3_BBLEERR_M  (USB_OTGHS_DIEPINT3_BBLEERR_V << USB_OTGHS_DIEPINT3_BBLEERR_S)
#define USB_OTGHS_DIEPINT3_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT3_BBLEERR_S  12
/** USB_OTGHS_DIEPINT3_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT3_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT3_NAKINTRPT_M  (USB_OTGHS_DIEPINT3_NAKINTRPT_V << USB_OTGHS_DIEPINT3_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT3_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT3_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT3_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT3_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT3_NYETINTRPT_M  (USB_OTGHS_DIEPINT3_NYETINTRPT_V << USB_OTGHS_DIEPINT3_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT3_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT3_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ3_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 3 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ3_REG (DR_REG_USB_OTGHS_BASE + 0x970)
/** USB_OTGHS_DIEPTSIZ3_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ3_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ3_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ3_XFERSIZE_V << USB_OTGHS_DIEPTSIZ3_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ3_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ3_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ3_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ3_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ3_PKTCNT_M  (USB_OTGHS_DIEPTSIZ3_PKTCNT_V << USB_OTGHS_DIEPTSIZ3_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ3_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ3_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ3_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ3_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ3_MC_M  (USB_OTGHS_DIEPTSIZ3_MC_V << USB_OTGHS_DIEPTSIZ3_MC_S)
#define USB_OTGHS_DIEPTSIZ3_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ3_MC_S  29

/** USB_OTGHS_DIEPDMA3_REG register
 *  This register contains the DMA Address for the IN Endpoint 3 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA3_REG (DR_REG_USB_OTGHS_BASE + 0x974)
/** USB_OTGHS_DIEPDMA3_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA3_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA3_DMAADDR_M  (USB_OTGHS_DIEPDMA3_DMAADDR_V << USB_OTGHS_DIEPDMA3_DMAADDR_S)
#define USB_OTGHS_DIEPDMA3_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA3_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS3_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  3 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS3_REG (DR_REG_USB_OTGHS_BASE + 0x978)
/** USB_OTGHS_DTXFSTS3_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS3_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS3_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS3_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS3_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS3_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS3_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB3_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 3 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB3_REG (DR_REG_USB_OTGHS_BASE + 0x97c)
/** USB_OTGHS_DIEPDMAB3_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB3_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB3_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB3_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB3_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB3_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB3_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL4_REG register
 *  This register is used to control the characteristics of Endpoint 4.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL4_REG (DR_REG_USB_OTGHS_BASE + 0x980)
/** USB_OTGHS_DIEPCTL4_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL4_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL4_MPS_M  (USB_OTGHS_DIEPCTL4_MPS_V << USB_OTGHS_DIEPCTL4_MPS_S)
#define USB_OTGHS_DIEPCTL4_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL4_MPS_S  0
/** USB_OTGHS_DIEPCTL4_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL4_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL4_USBACTEP_M  (USB_OTGHS_DIEPCTL4_USBACTEP_V << USB_OTGHS_DIEPCTL4_USBACTEP_S)
#define USB_OTGHS_DIEPCTL4_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL4_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL4_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL4_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL4_DPID_M  (USB_OTGHS_DIEPCTL4_DPID_V << USB_OTGHS_DIEPCTL4_DPID_S)
#define USB_OTGHS_DIEPCTL4_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL4_DPID_S  16
/** USB_OTGHS_DIEPCTL4_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL4_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL4_NAKSTS_M  (USB_OTGHS_DIEPCTL4_NAKSTS_V << USB_OTGHS_DIEPCTL4_NAKSTS_S)
#define USB_OTGHS_DIEPCTL4_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL4_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL4_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL4_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL4_EPTYPE_M  (USB_OTGHS_DIEPCTL4_EPTYPE_V << USB_OTGHS_DIEPCTL4_EPTYPE_S)
#define USB_OTGHS_DIEPCTL4_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL4_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL4_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL4_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL4_STALL_M  (USB_OTGHS_DIEPCTL4_STALL_V << USB_OTGHS_DIEPCTL4_STALL_S)
#define USB_OTGHS_DIEPCTL4_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL4_STALL_S  21
/** USB_OTGHS_DIEPCTL4_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL4_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL4_TXFNUM_M  (USB_OTGHS_DIEPCTL4_TXFNUM_V << USB_OTGHS_DIEPCTL4_TXFNUM_S)
#define USB_OTGHS_DIEPCTL4_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL4_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL4_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL4_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL4_CNAK_M  (USB_OTGHS_DIEPCTL4_CNAK_V << USB_OTGHS_DIEPCTL4_CNAK_S)
#define USB_OTGHS_DIEPCTL4_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL4_CNAK_S  26
/** USB_OTGHS_DIEPCTL4_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL4_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL4_SNAK_M  (USB_OTGHS_DIEPCTL4_SNAK_V << USB_OTGHS_DIEPCTL4_SNAK_S)
#define USB_OTGHS_DIEPCTL4_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL4_SNAK_S  27
/** USB_OTGHS_DIEPCTL4_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL4_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL4_SETD0PID_M  (USB_OTGHS_DIEPCTL4_SETD0PID_V << USB_OTGHS_DIEPCTL4_SETD0PID_S)
#define USB_OTGHS_DIEPCTL4_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL4_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL4_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL4_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL4_SETD1PID_M  (USB_OTGHS_DIEPCTL4_SETD1PID_V << USB_OTGHS_DIEPCTL4_SETD1PID_S)
#define USB_OTGHS_DIEPCTL4_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL4_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL4_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL4_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL4_EPDIS_M  (USB_OTGHS_DIEPCTL4_EPDIS_V << USB_OTGHS_DIEPCTL4_EPDIS_S)
#define USB_OTGHS_DIEPCTL4_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL4_EPDIS_S  30
/** USB_OTGHS_DIEPCTL4_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL4_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL4_EPENA_M  (USB_OTGHS_DIEPCTL4_EPENA_V << USB_OTGHS_DIEPCTL4_EPENA_S)
#define USB_OTGHS_DIEPCTL4_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL4_EPENA_S  31

/** USB_OTGHS_DIEPINT4_REG register
 *  This register contains the interrupts for the IN Endpoint 4 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT4_REG (DR_REG_USB_OTGHS_BASE + 0x988)
/** USB_OTGHS_DIEPINT4_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT4_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT4_XFERCOMPL_M  (USB_OTGHS_DIEPINT4_XFERCOMPL_V << USB_OTGHS_DIEPINT4_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT4_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT4_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT4_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT4_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT4_EPDISBLD_M  (USB_OTGHS_DIEPINT4_EPDISBLD_V << USB_OTGHS_DIEPINT4_EPDISBLD_S)
#define USB_OTGHS_DIEPINT4_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT4_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT4_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT4_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT4_AHBERR_M  (USB_OTGHS_DIEPINT4_AHBERR_V << USB_OTGHS_DIEPINT4_AHBERR_S)
#define USB_OTGHS_DIEPINT4_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT4_AHBERR_S  2
/** USB_OTGHS_DIEPINT4_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT4_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT4_TIMEOUT_M  (USB_OTGHS_DIEPINT4_TIMEOUT_V << USB_OTGHS_DIEPINT4_TIMEOUT_S)
#define USB_OTGHS_DIEPINT4_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT4_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT4_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT4_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT4_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT4_INTKNTXFEMP_V << USB_OTGHS_DIEPINT4_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT4_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT4_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT4_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT4_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT4_INTKNEPMIS_M  (USB_OTGHS_DIEPINT4_INTKNEPMIS_V << USB_OTGHS_DIEPINT4_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT4_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT4_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT4_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT4_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT4_INEPNAKEFF_M  (USB_OTGHS_DIEPINT4_INEPNAKEFF_V << USB_OTGHS_DIEPINT4_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT4_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT4_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT4_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT4_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT4_TXFEMP_M  (USB_OTGHS_DIEPINT4_TXFEMP_V << USB_OTGHS_DIEPINT4_TXFEMP_S)
#define USB_OTGHS_DIEPINT4_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT4_TXFEMP_S  7
/** USB_OTGHS_DIEPINT4_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT4_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT4_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT4_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT4_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT4_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT4_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT4_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT4_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT4_BNAINTR_M  (USB_OTGHS_DIEPINT4_BNAINTR_V << USB_OTGHS_DIEPINT4_BNAINTR_S)
#define USB_OTGHS_DIEPINT4_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT4_BNAINTR_S  9
/** USB_OTGHS_DIEPINT4_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT4_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT4_PKTDRPSTS_M  (USB_OTGHS_DIEPINT4_PKTDRPSTS_V << USB_OTGHS_DIEPINT4_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT4_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT4_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT4_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT4_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT4_BBLEERR_M  (USB_OTGHS_DIEPINT4_BBLEERR_V << USB_OTGHS_DIEPINT4_BBLEERR_S)
#define USB_OTGHS_DIEPINT4_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT4_BBLEERR_S  12
/** USB_OTGHS_DIEPINT4_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT4_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT4_NAKINTRPT_M  (USB_OTGHS_DIEPINT4_NAKINTRPT_V << USB_OTGHS_DIEPINT4_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT4_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT4_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT4_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT4_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT4_NYETINTRPT_M  (USB_OTGHS_DIEPINT4_NYETINTRPT_V << USB_OTGHS_DIEPINT4_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT4_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT4_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ4_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 4 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ4_REG (DR_REG_USB_OTGHS_BASE + 0x990)
/** USB_OTGHS_DIEPTSIZ4_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ4_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ4_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ4_XFERSIZE_V << USB_OTGHS_DIEPTSIZ4_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ4_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ4_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ4_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ4_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ4_PKTCNT_M  (USB_OTGHS_DIEPTSIZ4_PKTCNT_V << USB_OTGHS_DIEPTSIZ4_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ4_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ4_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ4_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ4_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ4_MC_M  (USB_OTGHS_DIEPTSIZ4_MC_V << USB_OTGHS_DIEPTSIZ4_MC_S)
#define USB_OTGHS_DIEPTSIZ4_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ4_MC_S  29

/** USB_OTGHS_DIEPDMA4_REG register
 *  This register contains the DMA Address for the IN Endpoint 4 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA4_REG (DR_REG_USB_OTGHS_BASE + 0x994)
/** USB_OTGHS_DIEPDMA4_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA4_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA4_DMAADDR_M  (USB_OTGHS_DIEPDMA4_DMAADDR_V << USB_OTGHS_DIEPDMA4_DMAADDR_S)
#define USB_OTGHS_DIEPDMA4_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA4_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS4_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  4 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS4_REG (DR_REG_USB_OTGHS_BASE + 0x998)
/** USB_OTGHS_DTXFSTS4_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS4_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS4_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS4_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS4_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS4_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS4_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB4_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 4 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB4_REG (DR_REG_USB_OTGHS_BASE + 0x99c)
/** USB_OTGHS_DIEPDMAB4_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB4_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB4_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB4_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB4_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB4_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB4_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL5_REG register
 *  This register is used to control the characteristics of Endpoint 5.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL5_REG (DR_REG_USB_OTGHS_BASE + 0x9a0)
/** USB_OTGHS_DIEPCTL5_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL5_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL5_MPS_M  (USB_OTGHS_DIEPCTL5_MPS_V << USB_OTGHS_DIEPCTL5_MPS_S)
#define USB_OTGHS_DIEPCTL5_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL5_MPS_S  0
/** USB_OTGHS_DIEPCTL5_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL5_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL5_USBACTEP_M  (USB_OTGHS_DIEPCTL5_USBACTEP_V << USB_OTGHS_DIEPCTL5_USBACTEP_S)
#define USB_OTGHS_DIEPCTL5_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL5_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL5_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL5_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL5_DPID_M  (USB_OTGHS_DIEPCTL5_DPID_V << USB_OTGHS_DIEPCTL5_DPID_S)
#define USB_OTGHS_DIEPCTL5_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL5_DPID_S  16
/** USB_OTGHS_DIEPCTL5_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL5_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL5_NAKSTS_M  (USB_OTGHS_DIEPCTL5_NAKSTS_V << USB_OTGHS_DIEPCTL5_NAKSTS_S)
#define USB_OTGHS_DIEPCTL5_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL5_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL5_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL5_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL5_EPTYPE_M  (USB_OTGHS_DIEPCTL5_EPTYPE_V << USB_OTGHS_DIEPCTL5_EPTYPE_S)
#define USB_OTGHS_DIEPCTL5_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL5_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL5_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL5_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL5_STALL_M  (USB_OTGHS_DIEPCTL5_STALL_V << USB_OTGHS_DIEPCTL5_STALL_S)
#define USB_OTGHS_DIEPCTL5_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL5_STALL_S  21
/** USB_OTGHS_DIEPCTL5_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL5_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL5_TXFNUM_M  (USB_OTGHS_DIEPCTL5_TXFNUM_V << USB_OTGHS_DIEPCTL5_TXFNUM_S)
#define USB_OTGHS_DIEPCTL5_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL5_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL5_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL5_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL5_CNAK_M  (USB_OTGHS_DIEPCTL5_CNAK_V << USB_OTGHS_DIEPCTL5_CNAK_S)
#define USB_OTGHS_DIEPCTL5_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL5_CNAK_S  26
/** USB_OTGHS_DIEPCTL5_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL5_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL5_SNAK_M  (USB_OTGHS_DIEPCTL5_SNAK_V << USB_OTGHS_DIEPCTL5_SNAK_S)
#define USB_OTGHS_DIEPCTL5_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL5_SNAK_S  27
/** USB_OTGHS_DIEPCTL5_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL5_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL5_SETD0PID_M  (USB_OTGHS_DIEPCTL5_SETD0PID_V << USB_OTGHS_DIEPCTL5_SETD0PID_S)
#define USB_OTGHS_DIEPCTL5_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL5_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL5_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL5_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL5_SETD1PID_M  (USB_OTGHS_DIEPCTL5_SETD1PID_V << USB_OTGHS_DIEPCTL5_SETD1PID_S)
#define USB_OTGHS_DIEPCTL5_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL5_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL5_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL5_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL5_EPDIS_M  (USB_OTGHS_DIEPCTL5_EPDIS_V << USB_OTGHS_DIEPCTL5_EPDIS_S)
#define USB_OTGHS_DIEPCTL5_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL5_EPDIS_S  30
/** USB_OTGHS_DIEPCTL5_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL5_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL5_EPENA_M  (USB_OTGHS_DIEPCTL5_EPENA_V << USB_OTGHS_DIEPCTL5_EPENA_S)
#define USB_OTGHS_DIEPCTL5_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL5_EPENA_S  31

/** USB_OTGHS_DIEPINT5_REG register
 *  This register contains the interrupts for the IN Endpoint 5 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT5_REG (DR_REG_USB_OTGHS_BASE + 0x9a8)
/** USB_OTGHS_DIEPINT5_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT5_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT5_XFERCOMPL_M  (USB_OTGHS_DIEPINT5_XFERCOMPL_V << USB_OTGHS_DIEPINT5_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT5_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT5_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT5_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT5_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT5_EPDISBLD_M  (USB_OTGHS_DIEPINT5_EPDISBLD_V << USB_OTGHS_DIEPINT5_EPDISBLD_S)
#define USB_OTGHS_DIEPINT5_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT5_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT5_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT5_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT5_AHBERR_M  (USB_OTGHS_DIEPINT5_AHBERR_V << USB_OTGHS_DIEPINT5_AHBERR_S)
#define USB_OTGHS_DIEPINT5_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT5_AHBERR_S  2
/** USB_OTGHS_DIEPINT5_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT5_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT5_TIMEOUT_M  (USB_OTGHS_DIEPINT5_TIMEOUT_V << USB_OTGHS_DIEPINT5_TIMEOUT_S)
#define USB_OTGHS_DIEPINT5_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT5_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT5_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT5_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT5_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT5_INTKNTXFEMP_V << USB_OTGHS_DIEPINT5_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT5_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT5_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT5_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT5_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT5_INTKNEPMIS_M  (USB_OTGHS_DIEPINT5_INTKNEPMIS_V << USB_OTGHS_DIEPINT5_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT5_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT5_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT5_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT5_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT5_INEPNAKEFF_M  (USB_OTGHS_DIEPINT5_INEPNAKEFF_V << USB_OTGHS_DIEPINT5_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT5_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT5_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT5_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT5_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT5_TXFEMP_M  (USB_OTGHS_DIEPINT5_TXFEMP_V << USB_OTGHS_DIEPINT5_TXFEMP_S)
#define USB_OTGHS_DIEPINT5_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT5_TXFEMP_S  7
/** USB_OTGHS_DIEPINT5_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT5_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT5_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT5_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT5_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT5_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT5_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT5_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT5_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT5_BNAINTR_M  (USB_OTGHS_DIEPINT5_BNAINTR_V << USB_OTGHS_DIEPINT5_BNAINTR_S)
#define USB_OTGHS_DIEPINT5_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT5_BNAINTR_S  9
/** USB_OTGHS_DIEPINT5_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT5_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT5_PKTDRPSTS_M  (USB_OTGHS_DIEPINT5_PKTDRPSTS_V << USB_OTGHS_DIEPINT5_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT5_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT5_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT5_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT5_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT5_BBLEERR_M  (USB_OTGHS_DIEPINT5_BBLEERR_V << USB_OTGHS_DIEPINT5_BBLEERR_S)
#define USB_OTGHS_DIEPINT5_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT5_BBLEERR_S  12
/** USB_OTGHS_DIEPINT5_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT5_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT5_NAKINTRPT_M  (USB_OTGHS_DIEPINT5_NAKINTRPT_V << USB_OTGHS_DIEPINT5_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT5_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT5_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT5_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT5_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT5_NYETINTRPT_M  (USB_OTGHS_DIEPINT5_NYETINTRPT_V << USB_OTGHS_DIEPINT5_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT5_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT5_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ5_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 5 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ5_REG (DR_REG_USB_OTGHS_BASE + 0x9b0)
/** USB_OTGHS_DIEPTSIZ5_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ5_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ5_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ5_XFERSIZE_V << USB_OTGHS_DIEPTSIZ5_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ5_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ5_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ5_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ5_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ5_PKTCNT_M  (USB_OTGHS_DIEPTSIZ5_PKTCNT_V << USB_OTGHS_DIEPTSIZ5_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ5_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ5_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ5_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ5_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ5_MC_M  (USB_OTGHS_DIEPTSIZ5_MC_V << USB_OTGHS_DIEPTSIZ5_MC_S)
#define USB_OTGHS_DIEPTSIZ5_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ5_MC_S  29

/** USB_OTGHS_DIEPDMA5_REG register
 *  This register contains the DMA Address for the IN Endpoint 5 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA5_REG (DR_REG_USB_OTGHS_BASE + 0x9b4)
/** USB_OTGHS_DIEPDMA5_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA5_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA5_DMAADDR_M  (USB_OTGHS_DIEPDMA5_DMAADDR_V << USB_OTGHS_DIEPDMA5_DMAADDR_S)
#define USB_OTGHS_DIEPDMA5_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA5_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS5_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  5 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS5_REG (DR_REG_USB_OTGHS_BASE + 0x9b8)
/** USB_OTGHS_DTXFSTS5_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS5_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS5_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS5_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS5_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS5_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS5_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB5_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 5 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB5_REG (DR_REG_USB_OTGHS_BASE + 0x9bc)
/** USB_OTGHS_DIEPDMAB5_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB5_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB5_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB5_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB5_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB5_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB5_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL6_REG register
 *  This register is used to control the characteristics of Endpoint 6.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL6_REG (DR_REG_USB_OTGHS_BASE + 0x9c0)
/** USB_OTGHS_DIEPCTL6_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL6_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL6_MPS_M  (USB_OTGHS_DIEPCTL6_MPS_V << USB_OTGHS_DIEPCTL6_MPS_S)
#define USB_OTGHS_DIEPCTL6_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL6_MPS_S  0
/** USB_OTGHS_DIEPCTL6_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL6_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL6_USBACTEP_M  (USB_OTGHS_DIEPCTL6_USBACTEP_V << USB_OTGHS_DIEPCTL6_USBACTEP_S)
#define USB_OTGHS_DIEPCTL6_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL6_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL6_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL6_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL6_DPID_M  (USB_OTGHS_DIEPCTL6_DPID_V << USB_OTGHS_DIEPCTL6_DPID_S)
#define USB_OTGHS_DIEPCTL6_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL6_DPID_S  16
/** USB_OTGHS_DIEPCTL6_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL6_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL6_NAKSTS_M  (USB_OTGHS_DIEPCTL6_NAKSTS_V << USB_OTGHS_DIEPCTL6_NAKSTS_S)
#define USB_OTGHS_DIEPCTL6_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL6_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL6_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL6_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL6_EPTYPE_M  (USB_OTGHS_DIEPCTL6_EPTYPE_V << USB_OTGHS_DIEPCTL6_EPTYPE_S)
#define USB_OTGHS_DIEPCTL6_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL6_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL6_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL6_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL6_STALL_M  (USB_OTGHS_DIEPCTL6_STALL_V << USB_OTGHS_DIEPCTL6_STALL_S)
#define USB_OTGHS_DIEPCTL6_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL6_STALL_S  21
/** USB_OTGHS_DIEPCTL6_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL6_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL6_TXFNUM_M  (USB_OTGHS_DIEPCTL6_TXFNUM_V << USB_OTGHS_DIEPCTL6_TXFNUM_S)
#define USB_OTGHS_DIEPCTL6_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL6_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL6_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL6_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL6_CNAK_M  (USB_OTGHS_DIEPCTL6_CNAK_V << USB_OTGHS_DIEPCTL6_CNAK_S)
#define USB_OTGHS_DIEPCTL6_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL6_CNAK_S  26
/** USB_OTGHS_DIEPCTL6_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL6_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL6_SNAK_M  (USB_OTGHS_DIEPCTL6_SNAK_V << USB_OTGHS_DIEPCTL6_SNAK_S)
#define USB_OTGHS_DIEPCTL6_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL6_SNAK_S  27
/** USB_OTGHS_DIEPCTL6_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL6_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL6_SETD0PID_M  (USB_OTGHS_DIEPCTL6_SETD0PID_V << USB_OTGHS_DIEPCTL6_SETD0PID_S)
#define USB_OTGHS_DIEPCTL6_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL6_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL6_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL6_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL6_SETD1PID_M  (USB_OTGHS_DIEPCTL6_SETD1PID_V << USB_OTGHS_DIEPCTL6_SETD1PID_S)
#define USB_OTGHS_DIEPCTL6_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL6_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL6_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL6_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL6_EPDIS_M  (USB_OTGHS_DIEPCTL6_EPDIS_V << USB_OTGHS_DIEPCTL6_EPDIS_S)
#define USB_OTGHS_DIEPCTL6_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL6_EPDIS_S  30
/** USB_OTGHS_DIEPCTL6_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL6_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL6_EPENA_M  (USB_OTGHS_DIEPCTL6_EPENA_V << USB_OTGHS_DIEPCTL6_EPENA_S)
#define USB_OTGHS_DIEPCTL6_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL6_EPENA_S  31

/** USB_OTGHS_DIEPINT6_REG register
 *  This register contains the interrupts for the IN Endpoint 6 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT6_REG (DR_REG_USB_OTGHS_BASE + 0x9c8)
/** USB_OTGHS_DIEPINT6_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT6_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT6_XFERCOMPL_M  (USB_OTGHS_DIEPINT6_XFERCOMPL_V << USB_OTGHS_DIEPINT6_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT6_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT6_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT6_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT6_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT6_EPDISBLD_M  (USB_OTGHS_DIEPINT6_EPDISBLD_V << USB_OTGHS_DIEPINT6_EPDISBLD_S)
#define USB_OTGHS_DIEPINT6_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT6_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT6_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT6_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT6_AHBERR_M  (USB_OTGHS_DIEPINT6_AHBERR_V << USB_OTGHS_DIEPINT6_AHBERR_S)
#define USB_OTGHS_DIEPINT6_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT6_AHBERR_S  2
/** USB_OTGHS_DIEPINT6_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT6_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT6_TIMEOUT_M  (USB_OTGHS_DIEPINT6_TIMEOUT_V << USB_OTGHS_DIEPINT6_TIMEOUT_S)
#define USB_OTGHS_DIEPINT6_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT6_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT6_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT6_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT6_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT6_INTKNTXFEMP_V << USB_OTGHS_DIEPINT6_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT6_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT6_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT6_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT6_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT6_INTKNEPMIS_M  (USB_OTGHS_DIEPINT6_INTKNEPMIS_V << USB_OTGHS_DIEPINT6_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT6_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT6_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT6_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT6_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT6_INEPNAKEFF_M  (USB_OTGHS_DIEPINT6_INEPNAKEFF_V << USB_OTGHS_DIEPINT6_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT6_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT6_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT6_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT6_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT6_TXFEMP_M  (USB_OTGHS_DIEPINT6_TXFEMP_V << USB_OTGHS_DIEPINT6_TXFEMP_S)
#define USB_OTGHS_DIEPINT6_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT6_TXFEMP_S  7
/** USB_OTGHS_DIEPINT6_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT6_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT6_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT6_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT6_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT6_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT6_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT6_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT6_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT6_BNAINTR_M  (USB_OTGHS_DIEPINT6_BNAINTR_V << USB_OTGHS_DIEPINT6_BNAINTR_S)
#define USB_OTGHS_DIEPINT6_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT6_BNAINTR_S  9
/** USB_OTGHS_DIEPINT6_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT6_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT6_PKTDRPSTS_M  (USB_OTGHS_DIEPINT6_PKTDRPSTS_V << USB_OTGHS_DIEPINT6_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT6_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT6_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT6_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT6_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT6_BBLEERR_M  (USB_OTGHS_DIEPINT6_BBLEERR_V << USB_OTGHS_DIEPINT6_BBLEERR_S)
#define USB_OTGHS_DIEPINT6_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT6_BBLEERR_S  12
/** USB_OTGHS_DIEPINT6_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT6_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT6_NAKINTRPT_M  (USB_OTGHS_DIEPINT6_NAKINTRPT_V << USB_OTGHS_DIEPINT6_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT6_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT6_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT6_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT6_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT6_NYETINTRPT_M  (USB_OTGHS_DIEPINT6_NYETINTRPT_V << USB_OTGHS_DIEPINT6_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT6_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT6_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ6_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 6 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ6_REG (DR_REG_USB_OTGHS_BASE + 0x9d0)
/** USB_OTGHS_DIEPTSIZ6_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ6_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ6_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ6_XFERSIZE_V << USB_OTGHS_DIEPTSIZ6_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ6_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ6_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ6_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ6_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ6_PKTCNT_M  (USB_OTGHS_DIEPTSIZ6_PKTCNT_V << USB_OTGHS_DIEPTSIZ6_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ6_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ6_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ6_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ6_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ6_MC_M  (USB_OTGHS_DIEPTSIZ6_MC_V << USB_OTGHS_DIEPTSIZ6_MC_S)
#define USB_OTGHS_DIEPTSIZ6_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ6_MC_S  29

/** USB_OTGHS_DIEPDMA6_REG register
 *  This register contains the DMA Address for the IN Endpoint 6 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA6_REG (DR_REG_USB_OTGHS_BASE + 0x9d4)
/** USB_OTGHS_DIEPDMA6_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA6_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA6_DMAADDR_M  (USB_OTGHS_DIEPDMA6_DMAADDR_V << USB_OTGHS_DIEPDMA6_DMAADDR_S)
#define USB_OTGHS_DIEPDMA6_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA6_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS6_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  6 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS6_REG (DR_REG_USB_OTGHS_BASE + 0x9d8)
/** USB_OTGHS_DTXFSTS6_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS6_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS6_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS6_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS6_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS6_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS6_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB6_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 6 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB6_REG (DR_REG_USB_OTGHS_BASE + 0x9dc)
/** USB_OTGHS_DIEPDMAB6_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB6_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB6_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB6_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB6_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB6_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB6_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL7_REG register
 *  This register is used to control the characteristics of Endpoint 7.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL7_REG (DR_REG_USB_OTGHS_BASE + 0x9e0)
/** USB_OTGHS_DIEPCTL7_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL7_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL7_MPS_M  (USB_OTGHS_DIEPCTL7_MPS_V << USB_OTGHS_DIEPCTL7_MPS_S)
#define USB_OTGHS_DIEPCTL7_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL7_MPS_S  0
/** USB_OTGHS_DIEPCTL7_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL7_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL7_USBACTEP_M  (USB_OTGHS_DIEPCTL7_USBACTEP_V << USB_OTGHS_DIEPCTL7_USBACTEP_S)
#define USB_OTGHS_DIEPCTL7_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL7_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL7_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL7_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL7_DPID_M  (USB_OTGHS_DIEPCTL7_DPID_V << USB_OTGHS_DIEPCTL7_DPID_S)
#define USB_OTGHS_DIEPCTL7_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL7_DPID_S  16
/** USB_OTGHS_DIEPCTL7_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL7_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL7_NAKSTS_M  (USB_OTGHS_DIEPCTL7_NAKSTS_V << USB_OTGHS_DIEPCTL7_NAKSTS_S)
#define USB_OTGHS_DIEPCTL7_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL7_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL7_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL7_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL7_EPTYPE_M  (USB_OTGHS_DIEPCTL7_EPTYPE_V << USB_OTGHS_DIEPCTL7_EPTYPE_S)
#define USB_OTGHS_DIEPCTL7_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL7_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL7_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL7_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL7_STALL_M  (USB_OTGHS_DIEPCTL7_STALL_V << USB_OTGHS_DIEPCTL7_STALL_S)
#define USB_OTGHS_DIEPCTL7_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL7_STALL_S  21
/** USB_OTGHS_DIEPCTL7_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL7_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL7_TXFNUM_M  (USB_OTGHS_DIEPCTL7_TXFNUM_V << USB_OTGHS_DIEPCTL7_TXFNUM_S)
#define USB_OTGHS_DIEPCTL7_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL7_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL7_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL7_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL7_CNAK_M  (USB_OTGHS_DIEPCTL7_CNAK_V << USB_OTGHS_DIEPCTL7_CNAK_S)
#define USB_OTGHS_DIEPCTL7_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL7_CNAK_S  26
/** USB_OTGHS_DIEPCTL7_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL7_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL7_SNAK_M  (USB_OTGHS_DIEPCTL7_SNAK_V << USB_OTGHS_DIEPCTL7_SNAK_S)
#define USB_OTGHS_DIEPCTL7_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL7_SNAK_S  27
/** USB_OTGHS_DIEPCTL7_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL7_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL7_SETD0PID_M  (USB_OTGHS_DIEPCTL7_SETD0PID_V << USB_OTGHS_DIEPCTL7_SETD0PID_S)
#define USB_OTGHS_DIEPCTL7_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL7_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL7_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL7_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL7_SETD1PID_M  (USB_OTGHS_DIEPCTL7_SETD1PID_V << USB_OTGHS_DIEPCTL7_SETD1PID_S)
#define USB_OTGHS_DIEPCTL7_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL7_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL7_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL7_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL7_EPDIS_M  (USB_OTGHS_DIEPCTL7_EPDIS_V << USB_OTGHS_DIEPCTL7_EPDIS_S)
#define USB_OTGHS_DIEPCTL7_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL7_EPDIS_S  30
/** USB_OTGHS_DIEPCTL7_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL7_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL7_EPENA_M  (USB_OTGHS_DIEPCTL7_EPENA_V << USB_OTGHS_DIEPCTL7_EPENA_S)
#define USB_OTGHS_DIEPCTL7_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL7_EPENA_S  31

/** USB_OTGHS_DIEPINT7_REG register
 *  This register contains the interrupts for the IN Endpoint 7 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT7_REG (DR_REG_USB_OTGHS_BASE + 0x9e8)
/** USB_OTGHS_DIEPINT7_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT7_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT7_XFERCOMPL_M  (USB_OTGHS_DIEPINT7_XFERCOMPL_V << USB_OTGHS_DIEPINT7_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT7_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT7_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT7_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT7_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT7_EPDISBLD_M  (USB_OTGHS_DIEPINT7_EPDISBLD_V << USB_OTGHS_DIEPINT7_EPDISBLD_S)
#define USB_OTGHS_DIEPINT7_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT7_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT7_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT7_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT7_AHBERR_M  (USB_OTGHS_DIEPINT7_AHBERR_V << USB_OTGHS_DIEPINT7_AHBERR_S)
#define USB_OTGHS_DIEPINT7_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT7_AHBERR_S  2
/** USB_OTGHS_DIEPINT7_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT7_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT7_TIMEOUT_M  (USB_OTGHS_DIEPINT7_TIMEOUT_V << USB_OTGHS_DIEPINT7_TIMEOUT_S)
#define USB_OTGHS_DIEPINT7_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT7_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT7_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT7_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT7_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT7_INTKNTXFEMP_V << USB_OTGHS_DIEPINT7_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT7_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT7_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT7_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT7_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT7_INTKNEPMIS_M  (USB_OTGHS_DIEPINT7_INTKNEPMIS_V << USB_OTGHS_DIEPINT7_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT7_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT7_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT7_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT7_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT7_INEPNAKEFF_M  (USB_OTGHS_DIEPINT7_INEPNAKEFF_V << USB_OTGHS_DIEPINT7_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT7_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT7_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT7_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT7_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT7_TXFEMP_M  (USB_OTGHS_DIEPINT7_TXFEMP_V << USB_OTGHS_DIEPINT7_TXFEMP_S)
#define USB_OTGHS_DIEPINT7_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT7_TXFEMP_S  7
/** USB_OTGHS_DIEPINT7_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT7_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT7_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT7_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT7_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT7_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT7_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT7_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT7_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT7_BNAINTR_M  (USB_OTGHS_DIEPINT7_BNAINTR_V << USB_OTGHS_DIEPINT7_BNAINTR_S)
#define USB_OTGHS_DIEPINT7_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT7_BNAINTR_S  9
/** USB_OTGHS_DIEPINT7_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT7_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT7_PKTDRPSTS_M  (USB_OTGHS_DIEPINT7_PKTDRPSTS_V << USB_OTGHS_DIEPINT7_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT7_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT7_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT7_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT7_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT7_BBLEERR_M  (USB_OTGHS_DIEPINT7_BBLEERR_V << USB_OTGHS_DIEPINT7_BBLEERR_S)
#define USB_OTGHS_DIEPINT7_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT7_BBLEERR_S  12
/** USB_OTGHS_DIEPINT7_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT7_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT7_NAKINTRPT_M  (USB_OTGHS_DIEPINT7_NAKINTRPT_V << USB_OTGHS_DIEPINT7_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT7_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT7_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT7_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT7_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT7_NYETINTRPT_M  (USB_OTGHS_DIEPINT7_NYETINTRPT_V << USB_OTGHS_DIEPINT7_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT7_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT7_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ7_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 7 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ7_REG (DR_REG_USB_OTGHS_BASE + 0x9f0)
/** USB_OTGHS_DIEPTSIZ7_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ7_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ7_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ7_XFERSIZE_V << USB_OTGHS_DIEPTSIZ7_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ7_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ7_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ7_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ7_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ7_PKTCNT_M  (USB_OTGHS_DIEPTSIZ7_PKTCNT_V << USB_OTGHS_DIEPTSIZ7_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ7_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ7_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ7_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ7_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ7_MC_M  (USB_OTGHS_DIEPTSIZ7_MC_V << USB_OTGHS_DIEPTSIZ7_MC_S)
#define USB_OTGHS_DIEPTSIZ7_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ7_MC_S  29

/** USB_OTGHS_DIEPDMA7_REG register
 *  This register contains the DMA Address for the IN Endpoint 7 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA7_REG (DR_REG_USB_OTGHS_BASE + 0x9f4)
/** USB_OTGHS_DIEPDMA7_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA7_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA7_DMAADDR_M  (USB_OTGHS_DIEPDMA7_DMAADDR_V << USB_OTGHS_DIEPDMA7_DMAADDR_S)
#define USB_OTGHS_DIEPDMA7_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA7_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS7_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  7 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS7_REG (DR_REG_USB_OTGHS_BASE + 0x9f8)
/** USB_OTGHS_DTXFSTS7_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS7_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS7_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS7_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS7_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS7_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS7_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB7_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 7 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB7_REG (DR_REG_USB_OTGHS_BASE + 0x9fc)
/** USB_OTGHS_DIEPDMAB7_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB7_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB7_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB7_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB7_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB7_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB7_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL8_REG register
 *  This register is used to control the characteristics of Endpoint 8.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL8_REG (DR_REG_USB_OTGHS_BASE + 0xa00)
/** USB_OTGHS_DIEPCTL8_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL8_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL8_MPS_M  (USB_OTGHS_DIEPCTL8_MPS_V << USB_OTGHS_DIEPCTL8_MPS_S)
#define USB_OTGHS_DIEPCTL8_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL8_MPS_S  0
/** USB_OTGHS_DIEPCTL8_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL8_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL8_USBACTEP_M  (USB_OTGHS_DIEPCTL8_USBACTEP_V << USB_OTGHS_DIEPCTL8_USBACTEP_S)
#define USB_OTGHS_DIEPCTL8_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL8_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL8_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL8_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL8_DPID_M  (USB_OTGHS_DIEPCTL8_DPID_V << USB_OTGHS_DIEPCTL8_DPID_S)
#define USB_OTGHS_DIEPCTL8_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL8_DPID_S  16
/** USB_OTGHS_DIEPCTL8_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL8_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL8_NAKSTS_M  (USB_OTGHS_DIEPCTL8_NAKSTS_V << USB_OTGHS_DIEPCTL8_NAKSTS_S)
#define USB_OTGHS_DIEPCTL8_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL8_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL8_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL8_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL8_EPTYPE_M  (USB_OTGHS_DIEPCTL8_EPTYPE_V << USB_OTGHS_DIEPCTL8_EPTYPE_S)
#define USB_OTGHS_DIEPCTL8_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL8_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL8_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL8_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL8_STALL_M  (USB_OTGHS_DIEPCTL8_STALL_V << USB_OTGHS_DIEPCTL8_STALL_S)
#define USB_OTGHS_DIEPCTL8_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL8_STALL_S  21
/** USB_OTGHS_DIEPCTL8_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL8_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL8_TXFNUM_M  (USB_OTGHS_DIEPCTL8_TXFNUM_V << USB_OTGHS_DIEPCTL8_TXFNUM_S)
#define USB_OTGHS_DIEPCTL8_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL8_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL8_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL8_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL8_CNAK_M  (USB_OTGHS_DIEPCTL8_CNAK_V << USB_OTGHS_DIEPCTL8_CNAK_S)
#define USB_OTGHS_DIEPCTL8_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL8_CNAK_S  26
/** USB_OTGHS_DIEPCTL8_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL8_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL8_SNAK_M  (USB_OTGHS_DIEPCTL8_SNAK_V << USB_OTGHS_DIEPCTL8_SNAK_S)
#define USB_OTGHS_DIEPCTL8_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL8_SNAK_S  27
/** USB_OTGHS_DIEPCTL8_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL8_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL8_SETD0PID_M  (USB_OTGHS_DIEPCTL8_SETD0PID_V << USB_OTGHS_DIEPCTL8_SETD0PID_S)
#define USB_OTGHS_DIEPCTL8_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL8_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL8_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL8_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL8_SETD1PID_M  (USB_OTGHS_DIEPCTL8_SETD1PID_V << USB_OTGHS_DIEPCTL8_SETD1PID_S)
#define USB_OTGHS_DIEPCTL8_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL8_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL8_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL8_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL8_EPDIS_M  (USB_OTGHS_DIEPCTL8_EPDIS_V << USB_OTGHS_DIEPCTL8_EPDIS_S)
#define USB_OTGHS_DIEPCTL8_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL8_EPDIS_S  30
/** USB_OTGHS_DIEPCTL8_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL8_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL8_EPENA_M  (USB_OTGHS_DIEPCTL8_EPENA_V << USB_OTGHS_DIEPCTL8_EPENA_S)
#define USB_OTGHS_DIEPCTL8_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL8_EPENA_S  31

/** USB_OTGHS_DIEPINT8_REG register
 *  This register contains the interrupts for the IN Endpoint 8 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT8_REG (DR_REG_USB_OTGHS_BASE + 0xa08)
/** USB_OTGHS_DIEPINT8_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT8_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT8_XFERCOMPL_M  (USB_OTGHS_DIEPINT8_XFERCOMPL_V << USB_OTGHS_DIEPINT8_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT8_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT8_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT8_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT8_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT8_EPDISBLD_M  (USB_OTGHS_DIEPINT8_EPDISBLD_V << USB_OTGHS_DIEPINT8_EPDISBLD_S)
#define USB_OTGHS_DIEPINT8_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT8_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT8_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT8_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT8_AHBERR_M  (USB_OTGHS_DIEPINT8_AHBERR_V << USB_OTGHS_DIEPINT8_AHBERR_S)
#define USB_OTGHS_DIEPINT8_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT8_AHBERR_S  2
/** USB_OTGHS_DIEPINT8_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT8_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT8_TIMEOUT_M  (USB_OTGHS_DIEPINT8_TIMEOUT_V << USB_OTGHS_DIEPINT8_TIMEOUT_S)
#define USB_OTGHS_DIEPINT8_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT8_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT8_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT8_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT8_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT8_INTKNTXFEMP_V << USB_OTGHS_DIEPINT8_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT8_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT8_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT8_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT8_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT8_INTKNEPMIS_M  (USB_OTGHS_DIEPINT8_INTKNEPMIS_V << USB_OTGHS_DIEPINT8_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT8_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT8_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT8_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT8_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT8_INEPNAKEFF_M  (USB_OTGHS_DIEPINT8_INEPNAKEFF_V << USB_OTGHS_DIEPINT8_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT8_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT8_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT8_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT8_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT8_TXFEMP_M  (USB_OTGHS_DIEPINT8_TXFEMP_V << USB_OTGHS_DIEPINT8_TXFEMP_S)
#define USB_OTGHS_DIEPINT8_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT8_TXFEMP_S  7
/** USB_OTGHS_DIEPINT8_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT8_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT8_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT8_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT8_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT8_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT8_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT8_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT8_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT8_BNAINTR_M  (USB_OTGHS_DIEPINT8_BNAINTR_V << USB_OTGHS_DIEPINT8_BNAINTR_S)
#define USB_OTGHS_DIEPINT8_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT8_BNAINTR_S  9
/** USB_OTGHS_DIEPINT8_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT8_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT8_PKTDRPSTS_M  (USB_OTGHS_DIEPINT8_PKTDRPSTS_V << USB_OTGHS_DIEPINT8_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT8_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT8_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT8_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT8_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT8_BBLEERR_M  (USB_OTGHS_DIEPINT8_BBLEERR_V << USB_OTGHS_DIEPINT8_BBLEERR_S)
#define USB_OTGHS_DIEPINT8_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT8_BBLEERR_S  12
/** USB_OTGHS_DIEPINT8_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT8_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT8_NAKINTRPT_M  (USB_OTGHS_DIEPINT8_NAKINTRPT_V << USB_OTGHS_DIEPINT8_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT8_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT8_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT8_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT8_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT8_NYETINTRPT_M  (USB_OTGHS_DIEPINT8_NYETINTRPT_V << USB_OTGHS_DIEPINT8_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT8_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT8_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ8_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 8 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ8_REG (DR_REG_USB_OTGHS_BASE + 0xa10)
/** USB_OTGHS_DIEPTSIZ8_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ8_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ8_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ8_XFERSIZE_V << USB_OTGHS_DIEPTSIZ8_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ8_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ8_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ8_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ8_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ8_PKTCNT_M  (USB_OTGHS_DIEPTSIZ8_PKTCNT_V << USB_OTGHS_DIEPTSIZ8_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ8_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ8_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ8_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ8_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ8_MC_M  (USB_OTGHS_DIEPTSIZ8_MC_V << USB_OTGHS_DIEPTSIZ8_MC_S)
#define USB_OTGHS_DIEPTSIZ8_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ8_MC_S  29

/** USB_OTGHS_DIEPDMA8_REG register
 *  This register contains the DMA Address for the IN Endpoint 8 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA8_REG (DR_REG_USB_OTGHS_BASE + 0xa14)
/** USB_OTGHS_DIEPDMA8_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA8_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA8_DMAADDR_M  (USB_OTGHS_DIEPDMA8_DMAADDR_V << USB_OTGHS_DIEPDMA8_DMAADDR_S)
#define USB_OTGHS_DIEPDMA8_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA8_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS8_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  8 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS8_REG (DR_REG_USB_OTGHS_BASE + 0xa18)
/** USB_OTGHS_DTXFSTS8_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS8_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS8_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS8_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS8_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS8_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS8_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB8_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 8 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB8_REG (DR_REG_USB_OTGHS_BASE + 0xa1c)
/** USB_OTGHS_DIEPDMAB8_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB8_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB8_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB8_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB8_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB8_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB8_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL9_REG register
 *  This register is used to control the characteristics of Endpoint 9.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL9_REG (DR_REG_USB_OTGHS_BASE + 0xa20)
/** USB_OTGHS_DIEPCTL9_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL9_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL9_MPS_M  (USB_OTGHS_DIEPCTL9_MPS_V << USB_OTGHS_DIEPCTL9_MPS_S)
#define USB_OTGHS_DIEPCTL9_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL9_MPS_S  0
/** USB_OTGHS_DIEPCTL9_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL9_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL9_USBACTEP_M  (USB_OTGHS_DIEPCTL9_USBACTEP_V << USB_OTGHS_DIEPCTL9_USBACTEP_S)
#define USB_OTGHS_DIEPCTL9_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL9_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL9_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL9_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL9_DPID_M  (USB_OTGHS_DIEPCTL9_DPID_V << USB_OTGHS_DIEPCTL9_DPID_S)
#define USB_OTGHS_DIEPCTL9_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL9_DPID_S  16
/** USB_OTGHS_DIEPCTL9_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL9_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL9_NAKSTS_M  (USB_OTGHS_DIEPCTL9_NAKSTS_V << USB_OTGHS_DIEPCTL9_NAKSTS_S)
#define USB_OTGHS_DIEPCTL9_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL9_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL9_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL9_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL9_EPTYPE_M  (USB_OTGHS_DIEPCTL9_EPTYPE_V << USB_OTGHS_DIEPCTL9_EPTYPE_S)
#define USB_OTGHS_DIEPCTL9_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL9_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL9_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL9_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL9_STALL_M  (USB_OTGHS_DIEPCTL9_STALL_V << USB_OTGHS_DIEPCTL9_STALL_S)
#define USB_OTGHS_DIEPCTL9_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL9_STALL_S  21
/** USB_OTGHS_DIEPCTL9_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL9_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL9_TXFNUM_M  (USB_OTGHS_DIEPCTL9_TXFNUM_V << USB_OTGHS_DIEPCTL9_TXFNUM_S)
#define USB_OTGHS_DIEPCTL9_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL9_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL9_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL9_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL9_CNAK_M  (USB_OTGHS_DIEPCTL9_CNAK_V << USB_OTGHS_DIEPCTL9_CNAK_S)
#define USB_OTGHS_DIEPCTL9_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL9_CNAK_S  26
/** USB_OTGHS_DIEPCTL9_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL9_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL9_SNAK_M  (USB_OTGHS_DIEPCTL9_SNAK_V << USB_OTGHS_DIEPCTL9_SNAK_S)
#define USB_OTGHS_DIEPCTL9_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL9_SNAK_S  27
/** USB_OTGHS_DIEPCTL9_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL9_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL9_SETD0PID_M  (USB_OTGHS_DIEPCTL9_SETD0PID_V << USB_OTGHS_DIEPCTL9_SETD0PID_S)
#define USB_OTGHS_DIEPCTL9_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL9_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL9_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL9_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL9_SETD1PID_M  (USB_OTGHS_DIEPCTL9_SETD1PID_V << USB_OTGHS_DIEPCTL9_SETD1PID_S)
#define USB_OTGHS_DIEPCTL9_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL9_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL9_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL9_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL9_EPDIS_M  (USB_OTGHS_DIEPCTL9_EPDIS_V << USB_OTGHS_DIEPCTL9_EPDIS_S)
#define USB_OTGHS_DIEPCTL9_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL9_EPDIS_S  30
/** USB_OTGHS_DIEPCTL9_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL9_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL9_EPENA_M  (USB_OTGHS_DIEPCTL9_EPENA_V << USB_OTGHS_DIEPCTL9_EPENA_S)
#define USB_OTGHS_DIEPCTL9_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL9_EPENA_S  31

/** USB_OTGHS_DIEPINT9_REG register
 *  This register contains the interrupts for the IN Endpoint 9 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT9_REG (DR_REG_USB_OTGHS_BASE + 0xa28)
/** USB_OTGHS_DIEPINT9_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT9_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT9_XFERCOMPL_M  (USB_OTGHS_DIEPINT9_XFERCOMPL_V << USB_OTGHS_DIEPINT9_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT9_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT9_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT9_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT9_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT9_EPDISBLD_M  (USB_OTGHS_DIEPINT9_EPDISBLD_V << USB_OTGHS_DIEPINT9_EPDISBLD_S)
#define USB_OTGHS_DIEPINT9_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT9_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT9_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT9_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT9_AHBERR_M  (USB_OTGHS_DIEPINT9_AHBERR_V << USB_OTGHS_DIEPINT9_AHBERR_S)
#define USB_OTGHS_DIEPINT9_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT9_AHBERR_S  2
/** USB_OTGHS_DIEPINT9_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT9_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT9_TIMEOUT_M  (USB_OTGHS_DIEPINT9_TIMEOUT_V << USB_OTGHS_DIEPINT9_TIMEOUT_S)
#define USB_OTGHS_DIEPINT9_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT9_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT9_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT9_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT9_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT9_INTKNTXFEMP_V << USB_OTGHS_DIEPINT9_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT9_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT9_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT9_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT9_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT9_INTKNEPMIS_M  (USB_OTGHS_DIEPINT9_INTKNEPMIS_V << USB_OTGHS_DIEPINT9_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT9_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT9_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT9_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT9_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT9_INEPNAKEFF_M  (USB_OTGHS_DIEPINT9_INEPNAKEFF_V << USB_OTGHS_DIEPINT9_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT9_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT9_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT9_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT9_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT9_TXFEMP_M  (USB_OTGHS_DIEPINT9_TXFEMP_V << USB_OTGHS_DIEPINT9_TXFEMP_S)
#define USB_OTGHS_DIEPINT9_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT9_TXFEMP_S  7
/** USB_OTGHS_DIEPINT9_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT9_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT9_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT9_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT9_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT9_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT9_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT9_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT9_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT9_BNAINTR_M  (USB_OTGHS_DIEPINT9_BNAINTR_V << USB_OTGHS_DIEPINT9_BNAINTR_S)
#define USB_OTGHS_DIEPINT9_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT9_BNAINTR_S  9
/** USB_OTGHS_DIEPINT9_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT9_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT9_PKTDRPSTS_M  (USB_OTGHS_DIEPINT9_PKTDRPSTS_V << USB_OTGHS_DIEPINT9_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT9_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT9_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT9_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT9_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT9_BBLEERR_M  (USB_OTGHS_DIEPINT9_BBLEERR_V << USB_OTGHS_DIEPINT9_BBLEERR_S)
#define USB_OTGHS_DIEPINT9_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT9_BBLEERR_S  12
/** USB_OTGHS_DIEPINT9_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT9_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT9_NAKINTRPT_M  (USB_OTGHS_DIEPINT9_NAKINTRPT_V << USB_OTGHS_DIEPINT9_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT9_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT9_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT9_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT9_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT9_NYETINTRPT_M  (USB_OTGHS_DIEPINT9_NYETINTRPT_V << USB_OTGHS_DIEPINT9_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT9_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT9_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ9_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 9 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ9_REG (DR_REG_USB_OTGHS_BASE + 0xa30)
/** USB_OTGHS_DIEPTSIZ9_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ9_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ9_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ9_XFERSIZE_V << USB_OTGHS_DIEPTSIZ9_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ9_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ9_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ9_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ9_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ9_PKTCNT_M  (USB_OTGHS_DIEPTSIZ9_PKTCNT_V << USB_OTGHS_DIEPTSIZ9_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ9_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ9_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ9_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ9_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ9_MC_M  (USB_OTGHS_DIEPTSIZ9_MC_V << USB_OTGHS_DIEPTSIZ9_MC_S)
#define USB_OTGHS_DIEPTSIZ9_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ9_MC_S  29

/** USB_OTGHS_DIEPDMA9_REG register
 *  This register contains the DMA Address for the IN Endpoint 9 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA9_REG (DR_REG_USB_OTGHS_BASE + 0xa34)
/** USB_OTGHS_DIEPDMA9_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA9_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA9_DMAADDR_M  (USB_OTGHS_DIEPDMA9_DMAADDR_V << USB_OTGHS_DIEPDMA9_DMAADDR_S)
#define USB_OTGHS_DIEPDMA9_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA9_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS9_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  9 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS9_REG (DR_REG_USB_OTGHS_BASE + 0xa38)
/** USB_OTGHS_DTXFSTS9_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS9_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS9_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS9_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS9_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS9_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS9_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB9_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 9 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB9_REG (DR_REG_USB_OTGHS_BASE + 0xa3c)
/** USB_OTGHS_DIEPDMAB9_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB9_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB9_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB9_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB9_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB9_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB9_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL10_REG register
 *  This register is used to control the characteristics of Endpoint 10.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL10_REG (DR_REG_USB_OTGHS_BASE + 0xa40)
/** USB_OTGHS_DIEPCTL10_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL10_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL10_MPS_M  (USB_OTGHS_DIEPCTL10_MPS_V << USB_OTGHS_DIEPCTL10_MPS_S)
#define USB_OTGHS_DIEPCTL10_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL10_MPS_S  0
/** USB_OTGHS_DIEPCTL10_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL10_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL10_USBACTEP_M  (USB_OTGHS_DIEPCTL10_USBACTEP_V << USB_OTGHS_DIEPCTL10_USBACTEP_S)
#define USB_OTGHS_DIEPCTL10_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL10_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL10_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL10_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL10_DPID_M  (USB_OTGHS_DIEPCTL10_DPID_V << USB_OTGHS_DIEPCTL10_DPID_S)
#define USB_OTGHS_DIEPCTL10_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL10_DPID_S  16
/** USB_OTGHS_DIEPCTL10_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL10_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL10_NAKSTS_M  (USB_OTGHS_DIEPCTL10_NAKSTS_V << USB_OTGHS_DIEPCTL10_NAKSTS_S)
#define USB_OTGHS_DIEPCTL10_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL10_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL10_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL10_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL10_EPTYPE_M  (USB_OTGHS_DIEPCTL10_EPTYPE_V << USB_OTGHS_DIEPCTL10_EPTYPE_S)
#define USB_OTGHS_DIEPCTL10_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL10_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL10_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL10_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL10_STALL_M  (USB_OTGHS_DIEPCTL10_STALL_V << USB_OTGHS_DIEPCTL10_STALL_S)
#define USB_OTGHS_DIEPCTL10_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL10_STALL_S  21
/** USB_OTGHS_DIEPCTL10_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL10_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL10_TXFNUM_M  (USB_OTGHS_DIEPCTL10_TXFNUM_V << USB_OTGHS_DIEPCTL10_TXFNUM_S)
#define USB_OTGHS_DIEPCTL10_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL10_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL10_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL10_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL10_CNAK_M  (USB_OTGHS_DIEPCTL10_CNAK_V << USB_OTGHS_DIEPCTL10_CNAK_S)
#define USB_OTGHS_DIEPCTL10_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL10_CNAK_S  26
/** USB_OTGHS_DIEPCTL10_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL10_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL10_SNAK_M  (USB_OTGHS_DIEPCTL10_SNAK_V << USB_OTGHS_DIEPCTL10_SNAK_S)
#define USB_OTGHS_DIEPCTL10_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL10_SNAK_S  27
/** USB_OTGHS_DIEPCTL10_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL10_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL10_SETD0PID_M  (USB_OTGHS_DIEPCTL10_SETD0PID_V << USB_OTGHS_DIEPCTL10_SETD0PID_S)
#define USB_OTGHS_DIEPCTL10_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL10_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL10_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL10_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL10_SETD1PID_M  (USB_OTGHS_DIEPCTL10_SETD1PID_V << USB_OTGHS_DIEPCTL10_SETD1PID_S)
#define USB_OTGHS_DIEPCTL10_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL10_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL10_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL10_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL10_EPDIS_M  (USB_OTGHS_DIEPCTL10_EPDIS_V << USB_OTGHS_DIEPCTL10_EPDIS_S)
#define USB_OTGHS_DIEPCTL10_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL10_EPDIS_S  30
/** USB_OTGHS_DIEPCTL10_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL10_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL10_EPENA_M  (USB_OTGHS_DIEPCTL10_EPENA_V << USB_OTGHS_DIEPCTL10_EPENA_S)
#define USB_OTGHS_DIEPCTL10_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL10_EPENA_S  31

/** USB_OTGHS_DIEPINT10_REG register
 *  This register contains the interrupts for the IN Endpoint 10 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT10_REG (DR_REG_USB_OTGHS_BASE + 0xa48)
/** USB_OTGHS_DIEPINT10_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT10_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT10_XFERCOMPL_M  (USB_OTGHS_DIEPINT10_XFERCOMPL_V << USB_OTGHS_DIEPINT10_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT10_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT10_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT10_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT10_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT10_EPDISBLD_M  (USB_OTGHS_DIEPINT10_EPDISBLD_V << USB_OTGHS_DIEPINT10_EPDISBLD_S)
#define USB_OTGHS_DIEPINT10_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT10_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT10_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT10_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT10_AHBERR_M  (USB_OTGHS_DIEPINT10_AHBERR_V << USB_OTGHS_DIEPINT10_AHBERR_S)
#define USB_OTGHS_DIEPINT10_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT10_AHBERR_S  2
/** USB_OTGHS_DIEPINT10_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT10_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT10_TIMEOUT_M  (USB_OTGHS_DIEPINT10_TIMEOUT_V << USB_OTGHS_DIEPINT10_TIMEOUT_S)
#define USB_OTGHS_DIEPINT10_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT10_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT10_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT10_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT10_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT10_INTKNTXFEMP_V << USB_OTGHS_DIEPINT10_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT10_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT10_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT10_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT10_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT10_INTKNEPMIS_M  (USB_OTGHS_DIEPINT10_INTKNEPMIS_V << USB_OTGHS_DIEPINT10_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT10_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT10_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT10_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT10_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT10_INEPNAKEFF_M  (USB_OTGHS_DIEPINT10_INEPNAKEFF_V << USB_OTGHS_DIEPINT10_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT10_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT10_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT10_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT10_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT10_TXFEMP_M  (USB_OTGHS_DIEPINT10_TXFEMP_V << USB_OTGHS_DIEPINT10_TXFEMP_S)
#define USB_OTGHS_DIEPINT10_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT10_TXFEMP_S  7
/** USB_OTGHS_DIEPINT10_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT10_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT10_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT10_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT10_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT10_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT10_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT10_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT10_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT10_BNAINTR_M  (USB_OTGHS_DIEPINT10_BNAINTR_V << USB_OTGHS_DIEPINT10_BNAINTR_S)
#define USB_OTGHS_DIEPINT10_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT10_BNAINTR_S  9
/** USB_OTGHS_DIEPINT10_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT10_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT10_PKTDRPSTS_M  (USB_OTGHS_DIEPINT10_PKTDRPSTS_V << USB_OTGHS_DIEPINT10_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT10_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT10_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT10_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT10_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT10_BBLEERR_M  (USB_OTGHS_DIEPINT10_BBLEERR_V << USB_OTGHS_DIEPINT10_BBLEERR_S)
#define USB_OTGHS_DIEPINT10_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT10_BBLEERR_S  12
/** USB_OTGHS_DIEPINT10_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT10_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT10_NAKINTRPT_M  (USB_OTGHS_DIEPINT10_NAKINTRPT_V << USB_OTGHS_DIEPINT10_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT10_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT10_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT10_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT10_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT10_NYETINTRPT_M  (USB_OTGHS_DIEPINT10_NYETINTRPT_V << USB_OTGHS_DIEPINT10_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT10_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT10_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ10_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 10 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ10_REG (DR_REG_USB_OTGHS_BASE + 0xa50)
/** USB_OTGHS_DIEPTSIZ10_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ10_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ10_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ10_XFERSIZE_V << USB_OTGHS_DIEPTSIZ10_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ10_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ10_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ10_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ10_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ10_PKTCNT_M  (USB_OTGHS_DIEPTSIZ10_PKTCNT_V << USB_OTGHS_DIEPTSIZ10_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ10_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ10_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ10_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ10_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ10_MC_M  (USB_OTGHS_DIEPTSIZ10_MC_V << USB_OTGHS_DIEPTSIZ10_MC_S)
#define USB_OTGHS_DIEPTSIZ10_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ10_MC_S  29

/** USB_OTGHS_DIEPDMA10_REG register
 *  This register contains the DMA Address for the IN Endpoint 10 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA10_REG (DR_REG_USB_OTGHS_BASE + 0xa54)
/** USB_OTGHS_DIEPDMA10_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA10_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA10_DMAADDR_M  (USB_OTGHS_DIEPDMA10_DMAADDR_V << USB_OTGHS_DIEPDMA10_DMAADDR_S)
#define USB_OTGHS_DIEPDMA10_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA10_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS10_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  10 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS10_REG (DR_REG_USB_OTGHS_BASE + 0xa58)
/** USB_OTGHS_DTXFSTS10_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS10_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS10_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS10_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS10_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS10_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS10_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB10_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 10 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB10_REG (DR_REG_USB_OTGHS_BASE + 0xa5c)
/** USB_OTGHS_DIEPDMAB10_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB10_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB10_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB10_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB10_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB10_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB10_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL11_REG register
 *  This register is used to control the characteristics of Endpoint 11.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL11_REG (DR_REG_USB_OTGHS_BASE + 0xa60)
/** USB_OTGHS_DIEPCTL11_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL11_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL11_MPS_M  (USB_OTGHS_DIEPCTL11_MPS_V << USB_OTGHS_DIEPCTL11_MPS_S)
#define USB_OTGHS_DIEPCTL11_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL11_MPS_S  0
/** USB_OTGHS_DIEPCTL11_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL11_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL11_USBACTEP_M  (USB_OTGHS_DIEPCTL11_USBACTEP_V << USB_OTGHS_DIEPCTL11_USBACTEP_S)
#define USB_OTGHS_DIEPCTL11_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL11_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL11_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL11_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL11_DPID_M  (USB_OTGHS_DIEPCTL11_DPID_V << USB_OTGHS_DIEPCTL11_DPID_S)
#define USB_OTGHS_DIEPCTL11_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL11_DPID_S  16
/** USB_OTGHS_DIEPCTL11_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL11_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL11_NAKSTS_M  (USB_OTGHS_DIEPCTL11_NAKSTS_V << USB_OTGHS_DIEPCTL11_NAKSTS_S)
#define USB_OTGHS_DIEPCTL11_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL11_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL11_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL11_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL11_EPTYPE_M  (USB_OTGHS_DIEPCTL11_EPTYPE_V << USB_OTGHS_DIEPCTL11_EPTYPE_S)
#define USB_OTGHS_DIEPCTL11_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL11_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL11_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL11_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL11_STALL_M  (USB_OTGHS_DIEPCTL11_STALL_V << USB_OTGHS_DIEPCTL11_STALL_S)
#define USB_OTGHS_DIEPCTL11_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL11_STALL_S  21
/** USB_OTGHS_DIEPCTL11_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL11_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL11_TXFNUM_M  (USB_OTGHS_DIEPCTL11_TXFNUM_V << USB_OTGHS_DIEPCTL11_TXFNUM_S)
#define USB_OTGHS_DIEPCTL11_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL11_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL11_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL11_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL11_CNAK_M  (USB_OTGHS_DIEPCTL11_CNAK_V << USB_OTGHS_DIEPCTL11_CNAK_S)
#define USB_OTGHS_DIEPCTL11_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL11_CNAK_S  26
/** USB_OTGHS_DIEPCTL11_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL11_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL11_SNAK_M  (USB_OTGHS_DIEPCTL11_SNAK_V << USB_OTGHS_DIEPCTL11_SNAK_S)
#define USB_OTGHS_DIEPCTL11_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL11_SNAK_S  27
/** USB_OTGHS_DIEPCTL11_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL11_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL11_SETD0PID_M  (USB_OTGHS_DIEPCTL11_SETD0PID_V << USB_OTGHS_DIEPCTL11_SETD0PID_S)
#define USB_OTGHS_DIEPCTL11_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL11_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL11_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL11_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL11_SETD1PID_M  (USB_OTGHS_DIEPCTL11_SETD1PID_V << USB_OTGHS_DIEPCTL11_SETD1PID_S)
#define USB_OTGHS_DIEPCTL11_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL11_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL11_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL11_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL11_EPDIS_M  (USB_OTGHS_DIEPCTL11_EPDIS_V << USB_OTGHS_DIEPCTL11_EPDIS_S)
#define USB_OTGHS_DIEPCTL11_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL11_EPDIS_S  30
/** USB_OTGHS_DIEPCTL11_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL11_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL11_EPENA_M  (USB_OTGHS_DIEPCTL11_EPENA_V << USB_OTGHS_DIEPCTL11_EPENA_S)
#define USB_OTGHS_DIEPCTL11_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL11_EPENA_S  31

/** USB_OTGHS_DIEPINT11_REG register
 *  This register contains the interrupts for the IN Endpoint 11 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT11_REG (DR_REG_USB_OTGHS_BASE + 0xa68)
/** USB_OTGHS_DIEPINT11_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT11_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT11_XFERCOMPL_M  (USB_OTGHS_DIEPINT11_XFERCOMPL_V << USB_OTGHS_DIEPINT11_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT11_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT11_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT11_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT11_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT11_EPDISBLD_M  (USB_OTGHS_DIEPINT11_EPDISBLD_V << USB_OTGHS_DIEPINT11_EPDISBLD_S)
#define USB_OTGHS_DIEPINT11_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT11_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT11_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT11_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT11_AHBERR_M  (USB_OTGHS_DIEPINT11_AHBERR_V << USB_OTGHS_DIEPINT11_AHBERR_S)
#define USB_OTGHS_DIEPINT11_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT11_AHBERR_S  2
/** USB_OTGHS_DIEPINT11_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT11_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT11_TIMEOUT_M  (USB_OTGHS_DIEPINT11_TIMEOUT_V << USB_OTGHS_DIEPINT11_TIMEOUT_S)
#define USB_OTGHS_DIEPINT11_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT11_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT11_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT11_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT11_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT11_INTKNTXFEMP_V << USB_OTGHS_DIEPINT11_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT11_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT11_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT11_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT11_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT11_INTKNEPMIS_M  (USB_OTGHS_DIEPINT11_INTKNEPMIS_V << USB_OTGHS_DIEPINT11_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT11_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT11_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT11_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT11_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT11_INEPNAKEFF_M  (USB_OTGHS_DIEPINT11_INEPNAKEFF_V << USB_OTGHS_DIEPINT11_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT11_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT11_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT11_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT11_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT11_TXFEMP_M  (USB_OTGHS_DIEPINT11_TXFEMP_V << USB_OTGHS_DIEPINT11_TXFEMP_S)
#define USB_OTGHS_DIEPINT11_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT11_TXFEMP_S  7
/** USB_OTGHS_DIEPINT11_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT11_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT11_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT11_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT11_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT11_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT11_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT11_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT11_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT11_BNAINTR_M  (USB_OTGHS_DIEPINT11_BNAINTR_V << USB_OTGHS_DIEPINT11_BNAINTR_S)
#define USB_OTGHS_DIEPINT11_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT11_BNAINTR_S  9
/** USB_OTGHS_DIEPINT11_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT11_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT11_PKTDRPSTS_M  (USB_OTGHS_DIEPINT11_PKTDRPSTS_V << USB_OTGHS_DIEPINT11_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT11_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT11_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT11_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT11_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT11_BBLEERR_M  (USB_OTGHS_DIEPINT11_BBLEERR_V << USB_OTGHS_DIEPINT11_BBLEERR_S)
#define USB_OTGHS_DIEPINT11_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT11_BBLEERR_S  12
/** USB_OTGHS_DIEPINT11_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT11_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT11_NAKINTRPT_M  (USB_OTGHS_DIEPINT11_NAKINTRPT_V << USB_OTGHS_DIEPINT11_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT11_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT11_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT11_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT11_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT11_NYETINTRPT_M  (USB_OTGHS_DIEPINT11_NYETINTRPT_V << USB_OTGHS_DIEPINT11_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT11_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT11_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ11_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 11 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ11_REG (DR_REG_USB_OTGHS_BASE + 0xa70)
/** USB_OTGHS_DIEPTSIZ11_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ11_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ11_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ11_XFERSIZE_V << USB_OTGHS_DIEPTSIZ11_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ11_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ11_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ11_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ11_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ11_PKTCNT_M  (USB_OTGHS_DIEPTSIZ11_PKTCNT_V << USB_OTGHS_DIEPTSIZ11_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ11_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ11_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ11_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ11_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ11_MC_M  (USB_OTGHS_DIEPTSIZ11_MC_V << USB_OTGHS_DIEPTSIZ11_MC_S)
#define USB_OTGHS_DIEPTSIZ11_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ11_MC_S  29

/** USB_OTGHS_DIEPDMA11_REG register
 *  This register contains the DMA Address for the IN Endpoint 11 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA11_REG (DR_REG_USB_OTGHS_BASE + 0xa74)
/** USB_OTGHS_DIEPDMA11_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA11_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA11_DMAADDR_M  (USB_OTGHS_DIEPDMA11_DMAADDR_V << USB_OTGHS_DIEPDMA11_DMAADDR_S)
#define USB_OTGHS_DIEPDMA11_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA11_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS11_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  11 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS11_REG (DR_REG_USB_OTGHS_BASE + 0xa78)
/** USB_OTGHS_DTXFSTS11_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS11_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS11_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS11_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS11_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS11_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS11_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB11_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 11 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB11_REG (DR_REG_USB_OTGHS_BASE + 0xa7c)
/** USB_OTGHS_DIEPDMAB11_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB11_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB11_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB11_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB11_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB11_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB11_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL12_REG register
 *  This register is used to control the characteristics of Endpoint 12.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL12_REG (DR_REG_USB_OTGHS_BASE + 0xa80)
/** USB_OTGHS_DIEPCTL12_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL12_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL12_MPS_M  (USB_OTGHS_DIEPCTL12_MPS_V << USB_OTGHS_DIEPCTL12_MPS_S)
#define USB_OTGHS_DIEPCTL12_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL12_MPS_S  0
/** USB_OTGHS_DIEPCTL12_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL12_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL12_USBACTEP_M  (USB_OTGHS_DIEPCTL12_USBACTEP_V << USB_OTGHS_DIEPCTL12_USBACTEP_S)
#define USB_OTGHS_DIEPCTL12_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL12_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL12_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL12_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL12_DPID_M  (USB_OTGHS_DIEPCTL12_DPID_V << USB_OTGHS_DIEPCTL12_DPID_S)
#define USB_OTGHS_DIEPCTL12_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL12_DPID_S  16
/** USB_OTGHS_DIEPCTL12_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL12_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL12_NAKSTS_M  (USB_OTGHS_DIEPCTL12_NAKSTS_V << USB_OTGHS_DIEPCTL12_NAKSTS_S)
#define USB_OTGHS_DIEPCTL12_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL12_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL12_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL12_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL12_EPTYPE_M  (USB_OTGHS_DIEPCTL12_EPTYPE_V << USB_OTGHS_DIEPCTL12_EPTYPE_S)
#define USB_OTGHS_DIEPCTL12_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL12_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL12_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL12_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL12_STALL_M  (USB_OTGHS_DIEPCTL12_STALL_V << USB_OTGHS_DIEPCTL12_STALL_S)
#define USB_OTGHS_DIEPCTL12_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL12_STALL_S  21
/** USB_OTGHS_DIEPCTL12_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL12_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL12_TXFNUM_M  (USB_OTGHS_DIEPCTL12_TXFNUM_V << USB_OTGHS_DIEPCTL12_TXFNUM_S)
#define USB_OTGHS_DIEPCTL12_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL12_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL12_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL12_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL12_CNAK_M  (USB_OTGHS_DIEPCTL12_CNAK_V << USB_OTGHS_DIEPCTL12_CNAK_S)
#define USB_OTGHS_DIEPCTL12_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL12_CNAK_S  26
/** USB_OTGHS_DIEPCTL12_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL12_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL12_SNAK_M  (USB_OTGHS_DIEPCTL12_SNAK_V << USB_OTGHS_DIEPCTL12_SNAK_S)
#define USB_OTGHS_DIEPCTL12_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL12_SNAK_S  27
/** USB_OTGHS_DIEPCTL12_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL12_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL12_SETD0PID_M  (USB_OTGHS_DIEPCTL12_SETD0PID_V << USB_OTGHS_DIEPCTL12_SETD0PID_S)
#define USB_OTGHS_DIEPCTL12_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL12_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL12_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL12_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL12_SETD1PID_M  (USB_OTGHS_DIEPCTL12_SETD1PID_V << USB_OTGHS_DIEPCTL12_SETD1PID_S)
#define USB_OTGHS_DIEPCTL12_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL12_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL12_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL12_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL12_EPDIS_M  (USB_OTGHS_DIEPCTL12_EPDIS_V << USB_OTGHS_DIEPCTL12_EPDIS_S)
#define USB_OTGHS_DIEPCTL12_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL12_EPDIS_S  30
/** USB_OTGHS_DIEPCTL12_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL12_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL12_EPENA_M  (USB_OTGHS_DIEPCTL12_EPENA_V << USB_OTGHS_DIEPCTL12_EPENA_S)
#define USB_OTGHS_DIEPCTL12_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL12_EPENA_S  31

/** USB_OTGHS_DIEPINT12_REG register
 *  This register contains the interrupts for the IN Endpoint 12 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT12_REG (DR_REG_USB_OTGHS_BASE + 0xa88)
/** USB_OTGHS_DIEPINT12_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT12_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT12_XFERCOMPL_M  (USB_OTGHS_DIEPINT12_XFERCOMPL_V << USB_OTGHS_DIEPINT12_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT12_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT12_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT12_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT12_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT12_EPDISBLD_M  (USB_OTGHS_DIEPINT12_EPDISBLD_V << USB_OTGHS_DIEPINT12_EPDISBLD_S)
#define USB_OTGHS_DIEPINT12_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT12_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT12_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT12_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT12_AHBERR_M  (USB_OTGHS_DIEPINT12_AHBERR_V << USB_OTGHS_DIEPINT12_AHBERR_S)
#define USB_OTGHS_DIEPINT12_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT12_AHBERR_S  2
/** USB_OTGHS_DIEPINT12_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT12_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT12_TIMEOUT_M  (USB_OTGHS_DIEPINT12_TIMEOUT_V << USB_OTGHS_DIEPINT12_TIMEOUT_S)
#define USB_OTGHS_DIEPINT12_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT12_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT12_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT12_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT12_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT12_INTKNTXFEMP_V << USB_OTGHS_DIEPINT12_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT12_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT12_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT12_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT12_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT12_INTKNEPMIS_M  (USB_OTGHS_DIEPINT12_INTKNEPMIS_V << USB_OTGHS_DIEPINT12_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT12_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT12_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT12_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT12_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT12_INEPNAKEFF_M  (USB_OTGHS_DIEPINT12_INEPNAKEFF_V << USB_OTGHS_DIEPINT12_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT12_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT12_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT12_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT12_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT12_TXFEMP_M  (USB_OTGHS_DIEPINT12_TXFEMP_V << USB_OTGHS_DIEPINT12_TXFEMP_S)
#define USB_OTGHS_DIEPINT12_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT12_TXFEMP_S  7
/** USB_OTGHS_DIEPINT12_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT12_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT12_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT12_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT12_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT12_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT12_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT12_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT12_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT12_BNAINTR_M  (USB_OTGHS_DIEPINT12_BNAINTR_V << USB_OTGHS_DIEPINT12_BNAINTR_S)
#define USB_OTGHS_DIEPINT12_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT12_BNAINTR_S  9
/** USB_OTGHS_DIEPINT12_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT12_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT12_PKTDRPSTS_M  (USB_OTGHS_DIEPINT12_PKTDRPSTS_V << USB_OTGHS_DIEPINT12_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT12_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT12_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT12_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT12_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT12_BBLEERR_M  (USB_OTGHS_DIEPINT12_BBLEERR_V << USB_OTGHS_DIEPINT12_BBLEERR_S)
#define USB_OTGHS_DIEPINT12_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT12_BBLEERR_S  12
/** USB_OTGHS_DIEPINT12_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT12_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT12_NAKINTRPT_M  (USB_OTGHS_DIEPINT12_NAKINTRPT_V << USB_OTGHS_DIEPINT12_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT12_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT12_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT12_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT12_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT12_NYETINTRPT_M  (USB_OTGHS_DIEPINT12_NYETINTRPT_V << USB_OTGHS_DIEPINT12_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT12_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT12_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ12_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 12 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ12_REG (DR_REG_USB_OTGHS_BASE + 0xa90)
/** USB_OTGHS_DIEPTSIZ12_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ12_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ12_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ12_XFERSIZE_V << USB_OTGHS_DIEPTSIZ12_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ12_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ12_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ12_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ12_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ12_PKTCNT_M  (USB_OTGHS_DIEPTSIZ12_PKTCNT_V << USB_OTGHS_DIEPTSIZ12_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ12_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ12_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ12_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ12_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ12_MC_M  (USB_OTGHS_DIEPTSIZ12_MC_V << USB_OTGHS_DIEPTSIZ12_MC_S)
#define USB_OTGHS_DIEPTSIZ12_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ12_MC_S  29

/** USB_OTGHS_DIEPDMA12_REG register
 *  This register contains the DMA Address for the IN Endpoint 12 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA12_REG (DR_REG_USB_OTGHS_BASE + 0xa94)
/** USB_OTGHS_DIEPDMA12_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA12_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA12_DMAADDR_M  (USB_OTGHS_DIEPDMA12_DMAADDR_V << USB_OTGHS_DIEPDMA12_DMAADDR_S)
#define USB_OTGHS_DIEPDMA12_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA12_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS12_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  12 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS12_REG (DR_REG_USB_OTGHS_BASE + 0xa98)
/** USB_OTGHS_DTXFSTS12_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS12_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS12_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS12_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS12_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS12_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS12_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB12_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 12 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB12_REG (DR_REG_USB_OTGHS_BASE + 0xa9c)
/** USB_OTGHS_DIEPDMAB12_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB12_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB12_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB12_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB12_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB12_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB12_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL13_REG register
 *  This register is used to control the characteristics of Endpoint 13.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL13_REG (DR_REG_USB_OTGHS_BASE + 0xaa0)
/** USB_OTGHS_DIEPCTL13_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL13_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL13_MPS_M  (USB_OTGHS_DIEPCTL13_MPS_V << USB_OTGHS_DIEPCTL13_MPS_S)
#define USB_OTGHS_DIEPCTL13_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL13_MPS_S  0
/** USB_OTGHS_DIEPCTL13_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL13_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL13_USBACTEP_M  (USB_OTGHS_DIEPCTL13_USBACTEP_V << USB_OTGHS_DIEPCTL13_USBACTEP_S)
#define USB_OTGHS_DIEPCTL13_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL13_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL13_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL13_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL13_DPID_M  (USB_OTGHS_DIEPCTL13_DPID_V << USB_OTGHS_DIEPCTL13_DPID_S)
#define USB_OTGHS_DIEPCTL13_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL13_DPID_S  16
/** USB_OTGHS_DIEPCTL13_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL13_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL13_NAKSTS_M  (USB_OTGHS_DIEPCTL13_NAKSTS_V << USB_OTGHS_DIEPCTL13_NAKSTS_S)
#define USB_OTGHS_DIEPCTL13_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL13_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL13_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL13_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL13_EPTYPE_M  (USB_OTGHS_DIEPCTL13_EPTYPE_V << USB_OTGHS_DIEPCTL13_EPTYPE_S)
#define USB_OTGHS_DIEPCTL13_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL13_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL13_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL13_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL13_STALL_M  (USB_OTGHS_DIEPCTL13_STALL_V << USB_OTGHS_DIEPCTL13_STALL_S)
#define USB_OTGHS_DIEPCTL13_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL13_STALL_S  21
/** USB_OTGHS_DIEPCTL13_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL13_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL13_TXFNUM_M  (USB_OTGHS_DIEPCTL13_TXFNUM_V << USB_OTGHS_DIEPCTL13_TXFNUM_S)
#define USB_OTGHS_DIEPCTL13_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL13_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL13_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL13_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL13_CNAK_M  (USB_OTGHS_DIEPCTL13_CNAK_V << USB_OTGHS_DIEPCTL13_CNAK_S)
#define USB_OTGHS_DIEPCTL13_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL13_CNAK_S  26
/** USB_OTGHS_DIEPCTL13_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL13_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL13_SNAK_M  (USB_OTGHS_DIEPCTL13_SNAK_V << USB_OTGHS_DIEPCTL13_SNAK_S)
#define USB_OTGHS_DIEPCTL13_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL13_SNAK_S  27
/** USB_OTGHS_DIEPCTL13_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL13_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL13_SETD0PID_M  (USB_OTGHS_DIEPCTL13_SETD0PID_V << USB_OTGHS_DIEPCTL13_SETD0PID_S)
#define USB_OTGHS_DIEPCTL13_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL13_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL13_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL13_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL13_SETD1PID_M  (USB_OTGHS_DIEPCTL13_SETD1PID_V << USB_OTGHS_DIEPCTL13_SETD1PID_S)
#define USB_OTGHS_DIEPCTL13_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL13_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL13_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL13_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL13_EPDIS_M  (USB_OTGHS_DIEPCTL13_EPDIS_V << USB_OTGHS_DIEPCTL13_EPDIS_S)
#define USB_OTGHS_DIEPCTL13_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL13_EPDIS_S  30
/** USB_OTGHS_DIEPCTL13_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL13_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL13_EPENA_M  (USB_OTGHS_DIEPCTL13_EPENA_V << USB_OTGHS_DIEPCTL13_EPENA_S)
#define USB_OTGHS_DIEPCTL13_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL13_EPENA_S  31

/** USB_OTGHS_DIEPINT13_REG register
 *  This register contains the interrupts for the IN Endpoint 13 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT13_REG (DR_REG_USB_OTGHS_BASE + 0xaa8)
/** USB_OTGHS_DIEPINT13_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT13_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT13_XFERCOMPL_M  (USB_OTGHS_DIEPINT13_XFERCOMPL_V << USB_OTGHS_DIEPINT13_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT13_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT13_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT13_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT13_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT13_EPDISBLD_M  (USB_OTGHS_DIEPINT13_EPDISBLD_V << USB_OTGHS_DIEPINT13_EPDISBLD_S)
#define USB_OTGHS_DIEPINT13_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT13_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT13_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT13_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT13_AHBERR_M  (USB_OTGHS_DIEPINT13_AHBERR_V << USB_OTGHS_DIEPINT13_AHBERR_S)
#define USB_OTGHS_DIEPINT13_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT13_AHBERR_S  2
/** USB_OTGHS_DIEPINT13_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT13_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT13_TIMEOUT_M  (USB_OTGHS_DIEPINT13_TIMEOUT_V << USB_OTGHS_DIEPINT13_TIMEOUT_S)
#define USB_OTGHS_DIEPINT13_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT13_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT13_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT13_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT13_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT13_INTKNTXFEMP_V << USB_OTGHS_DIEPINT13_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT13_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT13_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT13_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT13_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT13_INTKNEPMIS_M  (USB_OTGHS_DIEPINT13_INTKNEPMIS_V << USB_OTGHS_DIEPINT13_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT13_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT13_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT13_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT13_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT13_INEPNAKEFF_M  (USB_OTGHS_DIEPINT13_INEPNAKEFF_V << USB_OTGHS_DIEPINT13_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT13_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT13_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT13_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT13_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT13_TXFEMP_M  (USB_OTGHS_DIEPINT13_TXFEMP_V << USB_OTGHS_DIEPINT13_TXFEMP_S)
#define USB_OTGHS_DIEPINT13_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT13_TXFEMP_S  7
/** USB_OTGHS_DIEPINT13_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT13_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT13_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT13_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT13_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT13_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT13_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT13_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT13_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT13_BNAINTR_M  (USB_OTGHS_DIEPINT13_BNAINTR_V << USB_OTGHS_DIEPINT13_BNAINTR_S)
#define USB_OTGHS_DIEPINT13_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT13_BNAINTR_S  9
/** USB_OTGHS_DIEPINT13_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT13_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT13_PKTDRPSTS_M  (USB_OTGHS_DIEPINT13_PKTDRPSTS_V << USB_OTGHS_DIEPINT13_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT13_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT13_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT13_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT13_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT13_BBLEERR_M  (USB_OTGHS_DIEPINT13_BBLEERR_V << USB_OTGHS_DIEPINT13_BBLEERR_S)
#define USB_OTGHS_DIEPINT13_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT13_BBLEERR_S  12
/** USB_OTGHS_DIEPINT13_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT13_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT13_NAKINTRPT_M  (USB_OTGHS_DIEPINT13_NAKINTRPT_V << USB_OTGHS_DIEPINT13_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT13_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT13_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT13_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT13_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT13_NYETINTRPT_M  (USB_OTGHS_DIEPINT13_NYETINTRPT_V << USB_OTGHS_DIEPINT13_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT13_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT13_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ13_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 13 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ13_REG (DR_REG_USB_OTGHS_BASE + 0xab0)
/** USB_OTGHS_DIEPTSIZ13_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ13_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ13_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ13_XFERSIZE_V << USB_OTGHS_DIEPTSIZ13_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ13_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ13_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ13_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ13_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ13_PKTCNT_M  (USB_OTGHS_DIEPTSIZ13_PKTCNT_V << USB_OTGHS_DIEPTSIZ13_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ13_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ13_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ13_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ13_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ13_MC_M  (USB_OTGHS_DIEPTSIZ13_MC_V << USB_OTGHS_DIEPTSIZ13_MC_S)
#define USB_OTGHS_DIEPTSIZ13_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ13_MC_S  29

/** USB_OTGHS_DIEPDMA13_REG register
 *  This register contains the DMA Address for the IN Endpoint 13 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA13_REG (DR_REG_USB_OTGHS_BASE + 0xab4)
/** USB_OTGHS_DIEPDMA13_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA13_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA13_DMAADDR_M  (USB_OTGHS_DIEPDMA13_DMAADDR_V << USB_OTGHS_DIEPDMA13_DMAADDR_S)
#define USB_OTGHS_DIEPDMA13_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA13_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS13_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  13 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS13_REG (DR_REG_USB_OTGHS_BASE + 0xab8)
/** USB_OTGHS_DTXFSTS13_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS13_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS13_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS13_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS13_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS13_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS13_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB13_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 13 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB13_REG (DR_REG_USB_OTGHS_BASE + 0xabc)
/** USB_OTGHS_DIEPDMAB13_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB13_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB13_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB13_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB13_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB13_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB13_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL14_REG register
 *  This register is used to control the characteristics of Endpoint 14.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL14_REG (DR_REG_USB_OTGHS_BASE + 0xac0)
/** USB_OTGHS_DIEPCTL14_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL14_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL14_MPS_M  (USB_OTGHS_DIEPCTL14_MPS_V << USB_OTGHS_DIEPCTL14_MPS_S)
#define USB_OTGHS_DIEPCTL14_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL14_MPS_S  0
/** USB_OTGHS_DIEPCTL14_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL14_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL14_USBACTEP_M  (USB_OTGHS_DIEPCTL14_USBACTEP_V << USB_OTGHS_DIEPCTL14_USBACTEP_S)
#define USB_OTGHS_DIEPCTL14_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL14_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL14_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL14_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL14_DPID_M  (USB_OTGHS_DIEPCTL14_DPID_V << USB_OTGHS_DIEPCTL14_DPID_S)
#define USB_OTGHS_DIEPCTL14_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL14_DPID_S  16
/** USB_OTGHS_DIEPCTL14_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL14_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL14_NAKSTS_M  (USB_OTGHS_DIEPCTL14_NAKSTS_V << USB_OTGHS_DIEPCTL14_NAKSTS_S)
#define USB_OTGHS_DIEPCTL14_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL14_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL14_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL14_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL14_EPTYPE_M  (USB_OTGHS_DIEPCTL14_EPTYPE_V << USB_OTGHS_DIEPCTL14_EPTYPE_S)
#define USB_OTGHS_DIEPCTL14_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL14_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL14_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL14_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL14_STALL_M  (USB_OTGHS_DIEPCTL14_STALL_V << USB_OTGHS_DIEPCTL14_STALL_S)
#define USB_OTGHS_DIEPCTL14_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL14_STALL_S  21
/** USB_OTGHS_DIEPCTL14_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL14_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL14_TXFNUM_M  (USB_OTGHS_DIEPCTL14_TXFNUM_V << USB_OTGHS_DIEPCTL14_TXFNUM_S)
#define USB_OTGHS_DIEPCTL14_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL14_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL14_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL14_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL14_CNAK_M  (USB_OTGHS_DIEPCTL14_CNAK_V << USB_OTGHS_DIEPCTL14_CNAK_S)
#define USB_OTGHS_DIEPCTL14_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL14_CNAK_S  26
/** USB_OTGHS_DIEPCTL14_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL14_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL14_SNAK_M  (USB_OTGHS_DIEPCTL14_SNAK_V << USB_OTGHS_DIEPCTL14_SNAK_S)
#define USB_OTGHS_DIEPCTL14_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL14_SNAK_S  27
/** USB_OTGHS_DIEPCTL14_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL14_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL14_SETD0PID_M  (USB_OTGHS_DIEPCTL14_SETD0PID_V << USB_OTGHS_DIEPCTL14_SETD0PID_S)
#define USB_OTGHS_DIEPCTL14_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL14_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL14_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL14_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL14_SETD1PID_M  (USB_OTGHS_DIEPCTL14_SETD1PID_V << USB_OTGHS_DIEPCTL14_SETD1PID_S)
#define USB_OTGHS_DIEPCTL14_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL14_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL14_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL14_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL14_EPDIS_M  (USB_OTGHS_DIEPCTL14_EPDIS_V << USB_OTGHS_DIEPCTL14_EPDIS_S)
#define USB_OTGHS_DIEPCTL14_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL14_EPDIS_S  30
/** USB_OTGHS_DIEPCTL14_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL14_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL14_EPENA_M  (USB_OTGHS_DIEPCTL14_EPENA_V << USB_OTGHS_DIEPCTL14_EPENA_S)
#define USB_OTGHS_DIEPCTL14_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL14_EPENA_S  31

/** USB_OTGHS_DIEPINT14_REG register
 *  This register contains the interrupts for the IN Endpoint 14 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT14_REG (DR_REG_USB_OTGHS_BASE + 0xac8)
/** USB_OTGHS_DIEPINT14_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT14_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT14_XFERCOMPL_M  (USB_OTGHS_DIEPINT14_XFERCOMPL_V << USB_OTGHS_DIEPINT14_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT14_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT14_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT14_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT14_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT14_EPDISBLD_M  (USB_OTGHS_DIEPINT14_EPDISBLD_V << USB_OTGHS_DIEPINT14_EPDISBLD_S)
#define USB_OTGHS_DIEPINT14_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT14_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT14_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT14_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT14_AHBERR_M  (USB_OTGHS_DIEPINT14_AHBERR_V << USB_OTGHS_DIEPINT14_AHBERR_S)
#define USB_OTGHS_DIEPINT14_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT14_AHBERR_S  2
/** USB_OTGHS_DIEPINT14_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT14_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT14_TIMEOUT_M  (USB_OTGHS_DIEPINT14_TIMEOUT_V << USB_OTGHS_DIEPINT14_TIMEOUT_S)
#define USB_OTGHS_DIEPINT14_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT14_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT14_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT14_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT14_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT14_INTKNTXFEMP_V << USB_OTGHS_DIEPINT14_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT14_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT14_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT14_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT14_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT14_INTKNEPMIS_M  (USB_OTGHS_DIEPINT14_INTKNEPMIS_V << USB_OTGHS_DIEPINT14_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT14_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT14_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT14_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT14_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT14_INEPNAKEFF_M  (USB_OTGHS_DIEPINT14_INEPNAKEFF_V << USB_OTGHS_DIEPINT14_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT14_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT14_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT14_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT14_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT14_TXFEMP_M  (USB_OTGHS_DIEPINT14_TXFEMP_V << USB_OTGHS_DIEPINT14_TXFEMP_S)
#define USB_OTGHS_DIEPINT14_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT14_TXFEMP_S  7
/** USB_OTGHS_DIEPINT14_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT14_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT14_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT14_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT14_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT14_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT14_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT14_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT14_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT14_BNAINTR_M  (USB_OTGHS_DIEPINT14_BNAINTR_V << USB_OTGHS_DIEPINT14_BNAINTR_S)
#define USB_OTGHS_DIEPINT14_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT14_BNAINTR_S  9
/** USB_OTGHS_DIEPINT14_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT14_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT14_PKTDRPSTS_M  (USB_OTGHS_DIEPINT14_PKTDRPSTS_V << USB_OTGHS_DIEPINT14_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT14_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT14_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT14_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT14_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT14_BBLEERR_M  (USB_OTGHS_DIEPINT14_BBLEERR_V << USB_OTGHS_DIEPINT14_BBLEERR_S)
#define USB_OTGHS_DIEPINT14_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT14_BBLEERR_S  12
/** USB_OTGHS_DIEPINT14_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT14_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT14_NAKINTRPT_M  (USB_OTGHS_DIEPINT14_NAKINTRPT_V << USB_OTGHS_DIEPINT14_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT14_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT14_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT14_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT14_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT14_NYETINTRPT_M  (USB_OTGHS_DIEPINT14_NYETINTRPT_V << USB_OTGHS_DIEPINT14_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT14_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT14_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ14_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 14 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ14_REG (DR_REG_USB_OTGHS_BASE + 0xad0)
/** USB_OTGHS_DIEPTSIZ14_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ14_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ14_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ14_XFERSIZE_V << USB_OTGHS_DIEPTSIZ14_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ14_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ14_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ14_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ14_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ14_PKTCNT_M  (USB_OTGHS_DIEPTSIZ14_PKTCNT_V << USB_OTGHS_DIEPTSIZ14_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ14_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ14_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ14_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ14_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ14_MC_M  (USB_OTGHS_DIEPTSIZ14_MC_V << USB_OTGHS_DIEPTSIZ14_MC_S)
#define USB_OTGHS_DIEPTSIZ14_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ14_MC_S  29

/** USB_OTGHS_DIEPDMA14_REG register
 *  This register contains the DMA Address for the IN Endpoint 14 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA14_REG (DR_REG_USB_OTGHS_BASE + 0xad4)
/** USB_OTGHS_DIEPDMA14_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA14_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA14_DMAADDR_M  (USB_OTGHS_DIEPDMA14_DMAADDR_V << USB_OTGHS_DIEPDMA14_DMAADDR_S)
#define USB_OTGHS_DIEPDMA14_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA14_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS14_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  14 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS14_REG (DR_REG_USB_OTGHS_BASE + 0xad8)
/** USB_OTGHS_DTXFSTS14_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS14_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS14_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS14_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS14_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS14_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS14_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB14_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 14 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB14_REG (DR_REG_USB_OTGHS_BASE + 0xadc)
/** USB_OTGHS_DIEPDMAB14_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB14_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB14_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB14_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB14_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB14_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB14_DMABUFFERADDR_S  0

/** USB_OTGHS_DIEPCTL15_REG register
 *  This register is used to control the characteristics of Endpoint 15.  Note: This
 *  register exists for an endpoint i if the OTG_EP_DIR_i parameter is 0 or 1 for that
 *  endpoint.
 */
#define USB_OTGHS_DIEPCTL15_REG (DR_REG_USB_OTGHS_BASE + 0xae0)
/** USB_OTGHS_DIEPCTL15_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the
 *  current logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DIEPCTL15_MPS    0x000007FFU
#define USB_OTGHS_DIEPCTL15_MPS_M  (USB_OTGHS_DIEPCTL15_MPS_V << USB_OTGHS_DIEPCTL15_MPS_S)
#define USB_OTGHS_DIEPCTL15_MPS_V  0x000007FFU
#define USB_OTGHS_DIEPCTL15_MPS_S  0
/** USB_OTGHS_DIEPCTL15_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DIEPCTL15_USBACTEP    (BIT(15))
#define USB_OTGHS_DIEPCTL15_USBACTEP_M  (USB_OTGHS_DIEPCTL15_USBACTEP_V << USB_OTGHS_DIEPCTL15_USBACTEP_S)
#define USB_OTGHS_DIEPCTL15_USBACTEP_V  0x00000001U
#define USB_OTGHS_DIEPCTL15_USBACTEP_S  15
/** USB_OTGHS_DIEPCTL15_DPID : RO; bitpos: [16]; default: 0;
 *
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *
 *  Applies to isochronous IN and OUT endpoints only.
 *
 *  Indicates the (micro)frame number in which the core transmits/receives isochronous
 *  data for this endpoint. The application must program the even/odd (micro)frame
 *  number in which it intends to transmit/receive isochronous data for this endpoint
 *  using
 *  the SetEvnFr and SetOddFr fields in this register.
 *  - 1'b0: Even (micro)frame
 *  - 1'b1: Odd (micro)frame
 *  When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame in
 *  which data is received is updated in receive descriptor structure.
 */
#define USB_OTGHS_DIEPCTL15_DPID    (BIT(16))
#define USB_OTGHS_DIEPCTL15_DPID_M  (USB_OTGHS_DIEPCTL15_DPID_V << USB_OTGHS_DIEPCTL15_DPID_S)
#define USB_OTGHS_DIEPCTL15_DPID_V  0x00000001U
#define USB_OTGHS_DIEPCTL15_DPID_S  16
/** USB_OTGHS_DIEPCTL15_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL15_NAKSTS    (BIT(17))
#define USB_OTGHS_DIEPCTL15_NAKSTS_M  (USB_OTGHS_DIEPCTL15_NAKSTS_V << USB_OTGHS_DIEPCTL15_NAKSTS_S)
#define USB_OTGHS_DIEPCTL15_NAKSTS_V  0x00000001U
#define USB_OTGHS_DIEPCTL15_NAKSTS_S  17
/** USB_OTGHS_DIEPCTL15_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DIEPCTL15_EPTYPE    0x00000003U
#define USB_OTGHS_DIEPCTL15_EPTYPE_M  (USB_OTGHS_DIEPCTL15_EPTYPE_V << USB_OTGHS_DIEPCTL15_EPTYPE_S)
#define USB_OTGHS_DIEPCTL15_EPTYPE_V  0x00000003U
#define USB_OTGHS_DIEPCTL15_EPTYPE_S  18
/** USB_OTGHS_DIEPCTL15_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DIEPCTL15_STALL    (BIT(21))
#define USB_OTGHS_DIEPCTL15_STALL_M  (USB_OTGHS_DIEPCTL15_STALL_V << USB_OTGHS_DIEPCTL15_STALL_S)
#define USB_OTGHS_DIEPCTL15_STALL_V  0x00000001U
#define USB_OTGHS_DIEPCTL15_STALL_S  21
/** USB_OTGHS_DIEPCTL15_TXFNUM : R/W; bitpos: [25:22]; default: 0;
 *  TxFIFO Number (TxFNum)
 *
 *  Shared FIFO Operation non-periodic endpoints must set this bit to zero. Periodic
 *  endpoints must map this to the corresponding Periodic TxFIFO number.
 *  - 4'h0: Non-Periodic TxFIFO
 *  - Others: Specified Periodic TxFIFO.number
 *  Note: An interrupt IN endpoint can be configured as a non-periodic endpoint for
 *  applications such as mass storage. The core treats an IN endpoint as a non-periodic
 *  endpoint if the TxFNum field is set to 0. Otherwise, a separate periodic FIFO must
 *  be
 *  allocated for an interrupt IN endpoint, and the number of this
 *  FIFO must be programmed into the TxFNum field. Configuring an interrupt IN
 *  endpoint as a non-periodic endpoint saves the extra periodic FIFO area.
 *
 *  Dedicated FIFO Operation: These bits specify the FIFO number associated with this
 *  endpoint. Each active IN endpoint must be programmed to a separate FIFO number.
 *  This field is valid only for IN endpoints.
 */
#define USB_OTGHS_DIEPCTL15_TXFNUM    0x0000000FU
#define USB_OTGHS_DIEPCTL15_TXFNUM_M  (USB_OTGHS_DIEPCTL15_TXFNUM_V << USB_OTGHS_DIEPCTL15_TXFNUM_S)
#define USB_OTGHS_DIEPCTL15_TXFNUM_V  0x0000000FU
#define USB_OTGHS_DIEPCTL15_TXFNUM_S  22
/** USB_OTGHS_DIEPCTL15_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DIEPCTL15_CNAK    (BIT(26))
#define USB_OTGHS_DIEPCTL15_CNAK_M  (USB_OTGHS_DIEPCTL15_CNAK_V << USB_OTGHS_DIEPCTL15_CNAK_S)
#define USB_OTGHS_DIEPCTL15_CNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL15_CNAK_S  26
/** USB_OTGHS_DIEPCTL15_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is
 *  received on that endpoint.
 */
#define USB_OTGHS_DIEPCTL15_SNAK    (BIT(27))
#define USB_OTGHS_DIEPCTL15_SNAK_M  (USB_OTGHS_DIEPCTL15_SNAK_V << USB_OTGHS_DIEPCTL15_SNAK_S)
#define USB_OTGHS_DIEPCTL15_SNAK_V  0x00000001U
#define USB_OTGHS_DIEPCTL15_SNAK_S  27
/** USB_OTGHS_DIEPCTL15_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL15_SETD0PID    (BIT(28))
#define USB_OTGHS_DIEPCTL15_SETD0PID_M  (USB_OTGHS_DIEPCTL15_SETD0PID_V << USB_OTGHS_DIEPCTL15_SETD0PID_S)
#define USB_OTGHS_DIEPCTL15_SETD0PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL15_SETD0PID_S  28
/** USB_OTGHS_DIEPCTL15_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DIEPCTL15_SETD1PID    (BIT(29))
#define USB_OTGHS_DIEPCTL15_SETD1PID_M  (USB_OTGHS_DIEPCTL15_SETD1PID_V << USB_OTGHS_DIEPCTL15_SETD1PID_S)
#define USB_OTGHS_DIEPCTL15_SETD1PID_V  0x00000001U
#define USB_OTGHS_DIEPCTL15_SETD1PID_S  29
/** USB_OTGHS_DIEPCTL15_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DIEPCTL15_EPDIS    (BIT(30))
#define USB_OTGHS_DIEPCTL15_EPDIS_M  (USB_OTGHS_DIEPCTL15_EPDIS_V << USB_OTGHS_DIEPCTL15_EPDIS_S)
#define USB_OTGHS_DIEPCTL15_EPDIS_V  0x00000001U
#define USB_OTGHS_DIEPCTL15_EPDIS_S  30
/** USB_OTGHS_DIEPCTL15_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled,
 *  -- For IN endpoints this bit indicates that the descriptor structure and data
 *  buffer with data ready to transmit is setup.
 *  -- For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  - When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  -- For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  -- For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set to be able to
 *  transfer SETUP data packets in memory.
 */
#define USB_OTGHS_DIEPCTL15_EPENA    (BIT(31))
#define USB_OTGHS_DIEPCTL15_EPENA_M  (USB_OTGHS_DIEPCTL15_EPENA_V << USB_OTGHS_DIEPCTL15_EPENA_S)
#define USB_OTGHS_DIEPCTL15_EPENA_V  0x00000001U
#define USB_OTGHS_DIEPCTL15_EPENA_S  31

/** USB_OTGHS_DIEPINT15_REG register
 *  This register contains the interrupts for the IN Endpoint 15 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPINT15_REG (DR_REG_USB_OTGHS_BASE + 0xae8)
/** USB_OTGHS_DIEPINT15_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DIEPINT15_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DIEPINT15_XFERCOMPL_M  (USB_OTGHS_DIEPINT15_XFERCOMPL_V << USB_OTGHS_DIEPINT15_XFERCOMPL_S)
#define USB_OTGHS_DIEPINT15_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DIEPINT15_XFERCOMPL_S  0
/** USB_OTGHS_DIEPINT15_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DIEPINT15_EPDISBLD    (BIT(1))
#define USB_OTGHS_DIEPINT15_EPDISBLD_M  (USB_OTGHS_DIEPINT15_EPDISBLD_V << USB_OTGHS_DIEPINT15_EPDISBLD_S)
#define USB_OTGHS_DIEPINT15_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DIEPINT15_EPDISBLD_S  1
/** USB_OTGHS_DIEPINT15_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling in the
 *  Programming Guide.
 */
#define USB_OTGHS_DIEPINT15_AHBERR    (BIT(2))
#define USB_OTGHS_DIEPINT15_AHBERR_M  (USB_OTGHS_DIEPINT15_AHBERR_V << USB_OTGHS_DIEPINT15_AHBERR_S)
#define USB_OTGHS_DIEPINT15_AHBERR_V  0x00000001U
#define USB_OTGHS_DIEPINT15_AHBERR_S  2
/** USB_OTGHS_DIEPINT15_TIMEOUT : R/W; bitpos: [3]; default: 0;
 *  Timeout Condition (TimeOUT)
 *  - In shared TX FIFO mode, applies to non-isochronous IN endpoints only.
 *  - In dedicated FIFO mode, applies only to Control IN endpoints.
 *  - In Scatter/Gather DMA mode, the TimeOUT interrupt is not asserted.
 *  Indicates that the core has detected a timeout condition on the USB for the last IN
 *  token on this endpoint.
 */
#define USB_OTGHS_DIEPINT15_TIMEOUT    (BIT(3))
#define USB_OTGHS_DIEPINT15_TIMEOUT_M  (USB_OTGHS_DIEPINT15_TIMEOUT_V << USB_OTGHS_DIEPINT15_TIMEOUT_S)
#define USB_OTGHS_DIEPINT15_TIMEOUT_V  0x00000001U
#define USB_OTGHS_DIEPINT15_TIMEOUT_S  3
/** USB_OTGHS_DIEPINT15_INTKNTXFEMP : R/W; bitpos: [4]; default: 0;
 *  IN Token Received When TxFIFO is Empty (INTknTXFEmp)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that an IN token was received when the associated TxFIFO
 *  (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for
 *  which the IN token was received.
 */
#define USB_OTGHS_DIEPINT15_INTKNTXFEMP    (BIT(4))
#define USB_OTGHS_DIEPINT15_INTKNTXFEMP_M  (USB_OTGHS_DIEPINT15_INTKNTXFEMP_V << USB_OTGHS_DIEPINT15_INTKNTXFEMP_S)
#define USB_OTGHS_DIEPINT15_INTKNTXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT15_INTKNTXFEMP_S  4
/** USB_OTGHS_DIEPINT15_INTKNEPMIS : R/W; bitpos: [5]; default: 0;
 *  IN Token Received with EP Mismatch (INTknEPMis)
 *
 *  Applies to non-periodic IN endpoints only.
 *
 *  Indicates that the data in the top of the non-periodic TxFIFO belongs to an
 *  endpoint other than the one for which the IN token was received. This interrupt is
 *  asserted on the endpoint for which the IN token was received.
 */
#define USB_OTGHS_DIEPINT15_INTKNEPMIS    (BIT(5))
#define USB_OTGHS_DIEPINT15_INTKNEPMIS_M  (USB_OTGHS_DIEPINT15_INTKNEPMIS_V << USB_OTGHS_DIEPINT15_INTKNEPMIS_S)
#define USB_OTGHS_DIEPINT15_INTKNEPMIS_V  0x00000001U
#define USB_OTGHS_DIEPINT15_INTKNEPMIS_S  5
/** USB_OTGHS_DIEPINT15_INEPNAKEFF : R/W; bitpos: [6]; default: 0;
 *  IN Endpoint NAK Effective (INEPNakEff)
 *
 *  Applies to periodic IN endpoints only.
 *
 *  This bit can be cleared when the application clears the IN endpoint NAK by writing
 *  to DIEPCTLn.CNAK.
 *
 *  This interrupt indicates that the core has sampled the NAK bit
 *
 *  Set (either by the application or by the core). The interrupt indicates that the IN
 *  endpoint NAK bit Set by the application has taken effect in the core.
 *
 *  This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL
 *  bit takes priority over a NAK bit.
 */
#define USB_OTGHS_DIEPINT15_INEPNAKEFF    (BIT(6))
#define USB_OTGHS_DIEPINT15_INEPNAKEFF_M  (USB_OTGHS_DIEPINT15_INEPNAKEFF_V << USB_OTGHS_DIEPINT15_INEPNAKEFF_S)
#define USB_OTGHS_DIEPINT15_INEPNAKEFF_V  0x00000001U
#define USB_OTGHS_DIEPINT15_INEPNAKEFF_S  6
/** USB_OTGHS_DIEPINT15_TXFEMP : RO; bitpos: [7]; default: 1;
 *  Transmit FIFO Empty (TxFEmp)
 *
 *  This bit is valid only for IN endpoints
 *
 *  This interrupt is asserted when the TxFIFO for this endpoint is
 *  either half or completely empty. The half or completely empty
 *  status is determined by the TxFIFO Empty Level bit in the Core
 *  AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).
 */
#define USB_OTGHS_DIEPINT15_TXFEMP    (BIT(7))
#define USB_OTGHS_DIEPINT15_TXFEMP_M  (USB_OTGHS_DIEPINT15_TXFEMP_V << USB_OTGHS_DIEPINT15_TXFEMP_S)
#define USB_OTGHS_DIEPINT15_TXFEMP_V  0x00000001U
#define USB_OTGHS_DIEPINT15_TXFEMP_S  7
/** USB_OTGHS_DIEPINT15_TXFIFOUNDRN : R/W; bitpos: [8]; default: 0;
 *  Fifo Underrun (TxfifoUndrn)
 *
 *  Applies to IN endpoints Only
 *
 *  This bit is valid only If thresholding is enabled. The core generates this
 *  interrupt when
 *  it detects a transmit FIFO underrun condition for this endpoint.
 */
#define USB_OTGHS_DIEPINT15_TXFIFOUNDRN    (BIT(8))
#define USB_OTGHS_DIEPINT15_TXFIFOUNDRN_M  (USB_OTGHS_DIEPINT15_TXFIFOUNDRN_V << USB_OTGHS_DIEPINT15_TXFIFOUNDRN_S)
#define USB_OTGHS_DIEPINT15_TXFIFOUNDRN_V  0x00000001U
#define USB_OTGHS_DIEPINT15_TXFIFOUNDRN_S  8
/** USB_OTGHS_DIEPINT15_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed is not ready for the
 *  Core to process, such as Host busy or DMA done.
 */
#define USB_OTGHS_DIEPINT15_BNAINTR    (BIT(9))
#define USB_OTGHS_DIEPINT15_BNAINTR_M  (USB_OTGHS_DIEPINT15_BNAINTR_V << USB_OTGHS_DIEPINT15_BNAINTR_S)
#define USB_OTGHS_DIEPINT15_BNAINTR_V  0x00000001U
#define USB_OTGHS_DIEPINT15_BNAINTR_S  9
/** USB_OTGHS_DIEPINT15_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DIEPINT15_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DIEPINT15_PKTDRPSTS_M  (USB_OTGHS_DIEPINT15_PKTDRPSTS_V << USB_OTGHS_DIEPINT15_PKTDRPSTS_S)
#define USB_OTGHS_DIEPINT15_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DIEPINT15_PKTDRPSTS_S  11
/** USB_OTGHS_DIEPINT15_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DIEPINT15_BBLEERR    (BIT(12))
#define USB_OTGHS_DIEPINT15_BBLEERR_M  (USB_OTGHS_DIEPINT15_BBLEERR_V << USB_OTGHS_DIEPINT15_BBLEERR_S)
#define USB_OTGHS_DIEPINT15_BBLEERR_V  0x00000001U
#define USB_OTGHS_DIEPINT15_BBLEERR_S  12
/** USB_OTGHS_DIEPINT15_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DIEPINT15_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DIEPINT15_NAKINTRPT_M  (USB_OTGHS_DIEPINT15_NAKINTRPT_V << USB_OTGHS_DIEPINT15_NAKINTRPT_S)
#define USB_OTGHS_DIEPINT15_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT15_NAKINTRPT_S  13
/** USB_OTGHS_DIEPINT15_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DIEPINT15_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DIEPINT15_NYETINTRPT_M  (USB_OTGHS_DIEPINT15_NYETINTRPT_V << USB_OTGHS_DIEPINT15_NYETINTRPT_S)
#define USB_OTGHS_DIEPINT15_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DIEPINT15_NYETINTRPT_S  14

/** USB_OTGHS_DIEPTSIZ15_REG register
 *  This register reflects the Transfer Size of the IN Endpoint 15 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPTSIZ15_REG (DR_REG_USB_OTGHS_BASE + 0xaf0)
/** USB_OTGHS_DIEPTSIZ15_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet from the
 *  external memory is written to the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ15_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ15_XFERSIZE_M  (USB_OTGHS_DIEPTSIZ15_XFERSIZE_V << USB_OTGHS_DIEPTSIZ15_XFERSIZE_S)
#define USB_OTGHS_DIEPTSIZ15_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DIEPTSIZ15_XFERSIZE_S  0
/** USB_OTGHS_DIEPTSIZ15_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  Indicates the total number of USB packets that constitute the Transfer Size amount
 *  of data for endpoint 0.
 *
 *  This field is decremented every time a packet (maximum size or short packet) is
 *  read from the TxFIFO.
 */
#define USB_OTGHS_DIEPTSIZ15_PKTCNT    0x000003FFU
#define USB_OTGHS_DIEPTSIZ15_PKTCNT_M  (USB_OTGHS_DIEPTSIZ15_PKTCNT_V << USB_OTGHS_DIEPTSIZ15_PKTCNT_S)
#define USB_OTGHS_DIEPTSIZ15_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DIEPTSIZ15_PKTCNT_S  19
/** USB_OTGHS_DIEPTSIZ15_MC : R/W; bitpos: [30:29]; default: 0;
 *  MC
 *
 *  Applies to IN endpoints only.
 *
 *  For periodic IN endpoints, this field indicates the number of packets that must be
 *  transmitted per microframe on the USB. The core uses this field to calculate the
 *  data PID for isochronous IN endpoints.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 *  For non-periodic IN endpoints, this field is valid only in Internal DMA mode. It
 *  specifies the number of packets the core must fetchfor an IN endpoint before it
 *  switches to the endpoint pointed to by the Next Endpoint field of the Device
 *  Endpoint-n Control register (DIEPCTLn.NextEp)
 */
#define USB_OTGHS_DIEPTSIZ15_MC    0x00000003U
#define USB_OTGHS_DIEPTSIZ15_MC_M  (USB_OTGHS_DIEPTSIZ15_MC_V << USB_OTGHS_DIEPTSIZ15_MC_S)
#define USB_OTGHS_DIEPTSIZ15_MC_V  0x00000003U
#define USB_OTGHS_DIEPTSIZ15_MC_S  29

/** USB_OTGHS_DIEPDMA15_REG register
 *  This register contains the DMA Address for the IN Endpoint 15 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMA15_REG (DR_REG_USB_OTGHS_BASE + 0xaf4)
/** USB_OTGHS_DIEPDMA15_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DIEPDMA15_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA15_DMAADDR_M  (USB_OTGHS_DIEPDMA15_DMAADDR_V << USB_OTGHS_DIEPDMA15_DMAADDR_S)
#define USB_OTGHS_DIEPDMA15_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMA15_DMAADDR_S  0

/** USB_OTGHS_DTXFSTS15_REG register
 *  This register reflects the status of the IN Endpoint Transmit FIFO Status Register
 *  15 of the Device controller.  Note: This register exists for an endpoint i if the
 *  OTG_EP_DIR_i parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DTXFSTS15_REG (DR_REG_USB_OTGHS_BASE + 0xaf8)
/** USB_OTGHS_DTXFSTS15_INEPTXFSPCAVAIL : RO; bitpos: [15:0]; default: 1024;
 *  IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
 *
 *  Indicates the amount of free space available in the Endpoint TxFIFO.
 *
 *  Values are in terms of 32-bit words.
 *  - 16'h0: Endpoint TxFIFO is full
 *  - 16'h1: 1 word available
 *  - 16'h2: 2 words available
 *  - 16'hn: n words available (where 0  n  32,768)
 *  - 16'h8000: 32,768 words available
 *  - Others: Reserved
 *  In DRD configurations (OTG_MODE = 0, 1, or 2) with dynamic fifo sizing feature
 *  enabled (OTG_DFIFO_DYNAMIC=1), the value of this field is,
 *  - the maximum value of (OTG_TX_HNPERIO_DFIFO_DEPTH, OTG_TX_DINEP_DFIFO_DEPTH_0)
 *  during reset, and
 *  - OTG_TX_DINEP_DFIFO_DEPTH_0, immediately after reset deassertion
 */
#define USB_OTGHS_DTXFSTS15_INEPTXFSPCAVAIL    0x0000FFFFU
#define USB_OTGHS_DTXFSTS15_INEPTXFSPCAVAIL_M  (USB_OTGHS_DTXFSTS15_INEPTXFSPCAVAIL_V << USB_OTGHS_DTXFSTS15_INEPTXFSPCAVAIL_S)
#define USB_OTGHS_DTXFSTS15_INEPTXFSPCAVAIL_V  0x0000FFFFU
#define USB_OTGHS_DTXFSTS15_INEPTXFSPCAVAIL_S  0

/** USB_OTGHS_DIEPDMAB15_REG register
 *  This register contains the DMA Buffer Address of the IN Endpoint 15 of the Device
 *  controller.  Note: This register exists for an endpoint i if the OTG_EP_DIR_i
 *  parameter is 0 or 1 for that endpoint.
 */
#define USB_OTGHS_DIEPDMAB15_REG (DR_REG_USB_OTGHS_BASE + 0xafc)
/** USB_OTGHS_DIEPDMAB15_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DIEPDMAB15_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB15_DMABUFFERADDR_M  (USB_OTGHS_DIEPDMAB15_DMABUFFERADDR_V << USB_OTGHS_DIEPDMAB15_DMABUFFERADDR_S)
#define USB_OTGHS_DIEPDMAB15_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DIEPDMAB15_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL0_REG register
 *  This register is used to control the characteristics of the OUT Endpoint 0 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL0_REG (DR_REG_USB_OTGHS_BASE + 0xb00)
/** USB_OTGHS_DOEPCTL0_MPS : RO; bitpos: [1:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The maximum packet size for control OUT endpoint 0 is the same as what is
 *  programmed in control IN Endpoint 0.
 *  - 2'b00: 64 bytes
 *  - 2'b01: 32 bytes
 *  - 2'b10: 16 bytes
 *  - 2'b11: 8 bytes
 */
#define USB_OTGHS_DOEPCTL0_MPS    0x00000003U
#define USB_OTGHS_DOEPCTL0_MPS_M  (USB_OTGHS_DOEPCTL0_MPS_V << USB_OTGHS_DOEPCTL0_MPS_S)
#define USB_OTGHS_DOEPCTL0_MPS_V  0x00000003U
#define USB_OTGHS_DOEPCTL0_MPS_S  0
/** USB_OTGHS_DOEPCTL0_USBACTEP : RO; bitpos: [15]; default: 1;
 *  USB Active Endpoint (USBActEP)
 *
 *  This bit is always set to 1, indicating that a control endpoint 0 is always active
 *  in all configurations and interfaces.
 */
#define USB_OTGHS_DOEPCTL0_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL0_USBACTEP_M  (USB_OTGHS_DOEPCTL0_USBACTEP_V << USB_OTGHS_DOEPCTL0_USBACTEP_S)
#define USB_OTGHS_DOEPCTL0_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL0_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL0_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit, the core
 *  stops receiving data, even If there is space in the RxFIFO to
 *  accommodate the incoming packet. Irrespective of this bit's
 *  setting, the core always responds to SETUP data packets with
 *  an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL0_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL0_NAKSTS_M  (USB_OTGHS_DOEPCTL0_NAKSTS_V << USB_OTGHS_DOEPCTL0_NAKSTS_S)
#define USB_OTGHS_DOEPCTL0_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL0_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL0_EPTYPE : RO; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  Hardcoded to 2'b00 for control.
 */
#define USB_OTGHS_DOEPCTL0_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL0_EPTYPE_M  (USB_OTGHS_DOEPCTL0_EPTYPE_V << USB_OTGHS_DOEPCTL0_EPTYPE_S)
#define USB_OTGHS_DOEPCTL0_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL0_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL0_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL0_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL0_SNP_M  (USB_OTGHS_DOEPCTL0_SNP_V << USB_OTGHS_DOEPCTL0_SNP_S)
#define USB_OTGHS_DOEPCTL0_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL0_SNP_S  20
/** USB_OTGHS_DOEPCTL0_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  The application can only set this bit, and the core clears it, when
 *  a SETUP token is received for this endpoint. If a NAK bit or
 *  Global OUT NAK is Set along with this bit, the STALL bit takes
 *  priority. Irrespective of this bit's setting, the core always
 *  responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL0_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL0_STALL_M  (USB_OTGHS_DOEPCTL0_STALL_V << USB_OTGHS_DOEPCTL0_STALL_S)
#define USB_OTGHS_DOEPCTL0_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL0_STALL_S  21
/** USB_OTGHS_DOEPCTL0_CNAK : R/W; bitpos: [26]; default: 0;
 *  Clear NAK (CNAK)
 *
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL0_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL0_CNAK_M  (USB_OTGHS_DOEPCTL0_CNAK_V << USB_OTGHS_DOEPCTL0_CNAK_S)
#define USB_OTGHS_DOEPCTL0_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL0_CNAK_S  26
/** USB_OTGHS_DOEPCTL0_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *  Using this bit, the application can control the transmission of NAK handshakes on
 *  an endpoint.
 *  The core can also set bit on a Transfer Completed interrupt, or after a SETUP is
 *  received on the endpoint.
 */
#define USB_OTGHS_DOEPCTL0_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL0_SNAK_M  (USB_OTGHS_DOEPCTL0_SNAK_V << USB_OTGHS_DOEPCTL0_SNAK_S)
#define USB_OTGHS_DOEPCTL0_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL0_SNAK_S  27
/** USB_OTGHS_DOEPCTL0_EPDIS : RO; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  The application cannot disable control OUT endpoint 0.
 */
#define USB_OTGHS_DOEPCTL0_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL0_EPDIS_M  (USB_OTGHS_DOEPCTL0_EPDIS_V << USB_OTGHS_DOEPCTL0_EPDIS_S)
#define USB_OTGHS_DOEPCTL0_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL0_EPDIS_S  30
/** USB_OTGHS_DOEPCTL0_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *  - When Scatter/Gather DMA mode is enabled, for OUT endpoints this bit indicates
 *  that the descriptor structure and data buffer to receive data is setup.
 *  - When Scatter/Gather DMA mode is disabled (such as for buffer-pointer based DMA
 *  mode)this bit indicates that the application has allocated the memory to start
 *  receiving data from the USB.
 *  - The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  -- SETUP Phase Done
 *  -- Endpoint Disabled
 *  -- Transfer Completed
 *  Note: In DMA mode, this bit must be set for the core to transfer SETUP data packets
 *  into memory and it is not cleared on Transfer Completed interrupt of SETUP packet.
 */
#define USB_OTGHS_DOEPCTL0_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL0_EPENA_M  (USB_OTGHS_DOEPCTL0_EPENA_V << USB_OTGHS_DOEPCTL0_EPENA_S)
#define USB_OTGHS_DOEPCTL0_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL0_EPENA_S  31

/** USB_OTGHS_DOEPINT0_REG register
 *  This register contains the interrupts for the OUT Endpoint 0 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT0_REG (DR_REG_USB_OTGHS_BASE + 0xb08)
/** USB_OTGHS_DOEPINT0_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled
 *  - For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  - For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  Note: In DMA mode, this bit must be set for the core to transfer SETUP data packets
 *  into memory. When Scatter/Gather DMA mode is disabled, this field indicates that
 *  the programmed transfer is complete on the AHB as well as on the USB, for this
 *  endpoint.
 */
#define USB_OTGHS_DOEPINT0_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT0_XFERCOMPL_M  (USB_OTGHS_DOEPINT0_XFERCOMPL_V << USB_OTGHS_DOEPINT0_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT0_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT0_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT0_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT0_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT0_EPDISBLD_M  (USB_OTGHS_DOEPINT0_EPDISBLD_V << USB_OTGHS_DOEPINT0_EPDISBLD_S)
#define USB_OTGHS_DOEPINT0_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT0_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT0_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT0_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT0_AHBERR_M  (USB_OTGHS_DOEPINT0_AHBERR_V << USB_OTGHS_DOEPINT0_AHBERR_S)
#define USB_OTGHS_DOEPINT0_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT0_AHBERR_S  2
/** USB_OTGHS_DOEPINT0_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT0_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT0_SETUP_M  (USB_OTGHS_DOEPINT0_SETUP_V << USB_OTGHS_DOEPINT0_SETUP_S)
#define USB_OTGHS_DOEPINT0_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT0_SETUP_S  3
/** USB_OTGHS_DOEPINT0_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint
 *  was not yet enabled. This interrupt is asserted on the endpoint for which the OUT
 *  token was received.
 */
#define USB_OTGHS_DOEPINT0_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT0_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT0_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT0_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT0_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT0_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT0_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT0_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT0_STSPHSERCVD_M  (USB_OTGHS_DOEPINT0_STSPHSERCVD_V << USB_OTGHS_DOEPINT0_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT0_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT0_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT0_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT0_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT0_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT0_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT0_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT0_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT0_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT0_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled.
 *
 *  This interrupt is asserted when the core detects an overflow or a CRC error for
 *  non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT0_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT0_OUTPKTERR_M  (USB_OTGHS_DOEPINT0_OUTPKTERR_V << USB_OTGHS_DOEPINT0_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT0_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT0_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT0_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the core to process, such as Host busy or DMA
 *  done.
 */
#define USB_OTGHS_DOEPINT0_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT0_BNAINTR_M  (USB_OTGHS_DOEPINT0_BNAINTR_V << USB_OTGHS_DOEPINT0_BNAINTR_S)
#define USB_OTGHS_DOEPINT0_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT0_BNAINTR_S  9
/** USB_OTGHS_DOEPINT0_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT0_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT0_PKTDRPSTS_M  (USB_OTGHS_DOEPINT0_PKTDRPSTS_V << USB_OTGHS_DOEPINT0_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT0_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT0_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT0_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT0_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT0_BBLEERR_M  (USB_OTGHS_DOEPINT0_BBLEERR_V << USB_OTGHS_DOEPINT0_BBLEERR_S)
#define USB_OTGHS_DOEPINT0_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT0_BBLEERR_S  12
/** USB_OTGHS_DOEPINT0_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT0_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT0_NAKINTRPT_M  (USB_OTGHS_DOEPINT0_NAKINTRPT_V << USB_OTGHS_DOEPINT0_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT0_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT0_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT0_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT0_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT0_NYETINTRPT_M  (USB_OTGHS_DOEPINT0_NYETINTRPT_V << USB_OTGHS_DOEPINT0_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT0_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT0_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT0_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT0_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT0_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT0_STUPPKTRCVD_V << USB_OTGHS_DOEPINT0_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT0_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT0_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ0_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 0 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ0_REG (DR_REG_USB_OTGHS_BASE + 0xb10)
/** USB_OTGHS_DOEPTSIZ0_XFERSIZE : R/W; bitpos: [6:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for endpoint 0. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ0_XFERSIZE    0x0000007FU
#define USB_OTGHS_DOEPTSIZ0_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ0_XFERSIZE_V << USB_OTGHS_DOEPTSIZ0_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ0_XFERSIZE_V  0x0000007FU
#define USB_OTGHS_DOEPTSIZ0_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ0_PKTCNT : R/W; bitpos: [19]; default: 0;
 *  Packet Count (PktCnt)
 *
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ0_PKTCNT    (BIT(19))
#define USB_OTGHS_DOEPTSIZ0_PKTCNT_M  (USB_OTGHS_DOEPTSIZ0_PKTCNT_V << USB_OTGHS_DOEPTSIZ0_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ0_PKTCNT_V  0x00000001U
#define USB_OTGHS_DOEPTSIZ0_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ0_SUPCNT : R/W; bitpos: [30:29]; default: 0;
 *  SETUP Packet Count (SUPCnt)
 *
 *  This field specifies the number of back-to-back SETUP data packets the endpoint can
 *  receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ0_SUPCNT    0x00000003U
#define USB_OTGHS_DOEPTSIZ0_SUPCNT_M  (USB_OTGHS_DOEPTSIZ0_SUPCNT_V << USB_OTGHS_DOEPTSIZ0_SUPCNT_S)
#define USB_OTGHS_DOEPTSIZ0_SUPCNT_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ0_SUPCNT_S  29

/** USB_OTGHS_DOEPDMA0_REG register
 *  This register contains the DMA Address for the OUT Endpoint 0 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA0_REG (DR_REG_USB_OTGHS_BASE + 0xb14)
/** USB_OTGHS_DOEPDMA0_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA0_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA0_DMAADDR_M  (USB_OTGHS_DOEPDMA0_DMAADDR_V << USB_OTGHS_DOEPDMA0_DMAADDR_S)
#define USB_OTGHS_DOEPDMA0_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA0_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB0_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 0 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB0_REG (DR_REG_USB_OTGHS_BASE + 0xb1c)
/** USB_OTGHS_DOEPDMAB0_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB0_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB0_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB0_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB0_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB0_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB0_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL1_REG register
 *  This register is used to control the characteristics of OUT Endpoint 1 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL1_REG (DR_REG_USB_OTGHS_BASE + 0xb20)
/** USB_OTGHS_DOEPCTL1_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL1_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL1_MPS_M  (USB_OTGHS_DOEPCTL1_MPS_V << USB_OTGHS_DOEPCTL1_MPS_S)
#define USB_OTGHS_DOEPCTL1_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL1_MPS_S  0
/** USB_OTGHS_DOEPCTL1_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL1_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL1_USBACTEP_M  (USB_OTGHS_DOEPCTL1_USBACTEP_V << USB_OTGHS_DOEPCTL1_USBACTEP_S)
#define USB_OTGHS_DOEPCTL1_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL1_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL1_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL1_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL1_DPID_M  (USB_OTGHS_DOEPCTL1_DPID_V << USB_OTGHS_DOEPCTL1_DPID_S)
#define USB_OTGHS_DOEPCTL1_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL1_DPID_S  16
/** USB_OTGHS_DOEPCTL1_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL1_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL1_NAKSTS_M  (USB_OTGHS_DOEPCTL1_NAKSTS_V << USB_OTGHS_DOEPCTL1_NAKSTS_S)
#define USB_OTGHS_DOEPCTL1_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL1_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL1_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL1_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL1_EPTYPE_M  (USB_OTGHS_DOEPCTL1_EPTYPE_V << USB_OTGHS_DOEPCTL1_EPTYPE_S)
#define USB_OTGHS_DOEPCTL1_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL1_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL1_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL1_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL1_SNP_M  (USB_OTGHS_DOEPCTL1_SNP_V << USB_OTGHS_DOEPCTL1_SNP_S)
#define USB_OTGHS_DOEPCTL1_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL1_SNP_S  20
/** USB_OTGHS_DOEPCTL1_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL1_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL1_STALL_M  (USB_OTGHS_DOEPCTL1_STALL_V << USB_OTGHS_DOEPCTL1_STALL_S)
#define USB_OTGHS_DOEPCTL1_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL1_STALL_S  21
/** USB_OTGHS_DOEPCTL1_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL1_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL1_CNAK_M  (USB_OTGHS_DOEPCTL1_CNAK_V << USB_OTGHS_DOEPCTL1_CNAK_S)
#define USB_OTGHS_DOEPCTL1_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL1_CNAK_S  26
/** USB_OTGHS_DOEPCTL1_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL1_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL1_SNAK_M  (USB_OTGHS_DOEPCTL1_SNAK_V << USB_OTGHS_DOEPCTL1_SNAK_S)
#define USB_OTGHS_DOEPCTL1_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL1_SNAK_S  27
/** USB_OTGHS_DOEPCTL1_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL1_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL1_SETD0PID_M  (USB_OTGHS_DOEPCTL1_SETD0PID_V << USB_OTGHS_DOEPCTL1_SETD0PID_S)
#define USB_OTGHS_DOEPCTL1_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL1_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL1_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL1_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL1_SETD1PID_M  (USB_OTGHS_DOEPCTL1_SETD1PID_V << USB_OTGHS_DOEPCTL1_SETD1PID_S)
#define USB_OTGHS_DOEPCTL1_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL1_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL1_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL1_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL1_EPDIS_M  (USB_OTGHS_DOEPCTL1_EPDIS_V << USB_OTGHS_DOEPCTL1_EPDIS_S)
#define USB_OTGHS_DOEPCTL1_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL1_EPDIS_S  30
/** USB_OTGHS_DOEPCTL1_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL1_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL1_EPENA_M  (USB_OTGHS_DOEPCTL1_EPENA_V << USB_OTGHS_DOEPCTL1_EPENA_S)
#define USB_OTGHS_DOEPCTL1_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL1_EPENA_S  31

/** USB_OTGHS_DOEPINT1_REG register
 *  This register contains the interrupts for the OUT Endpoint 1 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT1_REG (DR_REG_USB_OTGHS_BASE + 0xb28)
/** USB_OTGHS_DOEPINT1_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT1_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT1_XFERCOMPL_M  (USB_OTGHS_DOEPINT1_XFERCOMPL_V << USB_OTGHS_DOEPINT1_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT1_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT1_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT1_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT1_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT1_EPDISBLD_M  (USB_OTGHS_DOEPINT1_EPDISBLD_V << USB_OTGHS_DOEPINT1_EPDISBLD_S)
#define USB_OTGHS_DOEPINT1_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT1_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT1_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT1_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT1_AHBERR_M  (USB_OTGHS_DOEPINT1_AHBERR_V << USB_OTGHS_DOEPINT1_AHBERR_S)
#define USB_OTGHS_DOEPINT1_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT1_AHBERR_S  2
/** USB_OTGHS_DOEPINT1_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT1_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT1_SETUP_M  (USB_OTGHS_DOEPINT1_SETUP_V << USB_OTGHS_DOEPINT1_SETUP_S)
#define USB_OTGHS_DOEPINT1_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT1_SETUP_S  3
/** USB_OTGHS_DOEPINT1_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT1_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT1_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT1_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT1_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT1_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT1_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT1_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT1_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT1_STSPHSERCVD_M  (USB_OTGHS_DOEPINT1_STSPHSERCVD_V << USB_OTGHS_DOEPINT1_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT1_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT1_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT1_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT1_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT1_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT1_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT1_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT1_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT1_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT1_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT1_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT1_OUTPKTERR_M  (USB_OTGHS_DOEPINT1_OUTPKTERR_V << USB_OTGHS_DOEPINT1_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT1_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT1_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT1_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT1_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT1_BNAINTR_M  (USB_OTGHS_DOEPINT1_BNAINTR_V << USB_OTGHS_DOEPINT1_BNAINTR_S)
#define USB_OTGHS_DOEPINT1_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT1_BNAINTR_S  9
/** USB_OTGHS_DOEPINT1_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT1_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT1_PKTDRPSTS_M  (USB_OTGHS_DOEPINT1_PKTDRPSTS_V << USB_OTGHS_DOEPINT1_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT1_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT1_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT1_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT1_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT1_BBLEERR_M  (USB_OTGHS_DOEPINT1_BBLEERR_V << USB_OTGHS_DOEPINT1_BBLEERR_S)
#define USB_OTGHS_DOEPINT1_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT1_BBLEERR_S  12
/** USB_OTGHS_DOEPINT1_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT1_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT1_NAKINTRPT_M  (USB_OTGHS_DOEPINT1_NAKINTRPT_V << USB_OTGHS_DOEPINT1_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT1_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT1_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT1_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT1_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT1_NYETINTRPT_M  (USB_OTGHS_DOEPINT1_NYETINTRPT_V << USB_OTGHS_DOEPINT1_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT1_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT1_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT1_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT1_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT1_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT1_STUPPKTRCVD_V << USB_OTGHS_DOEPINT1_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT1_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT1_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ1_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 1 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ1_REG (DR_REG_USB_OTGHS_BASE + 0xb30)
/** USB_OTGHS_DOEPTSIZ1_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ1_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ1_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ1_XFERSIZE_V << USB_OTGHS_DOEPTSIZ1_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ1_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ1_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ1_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ1_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ1_PKTCNT_M  (USB_OTGHS_DOEPTSIZ1_PKTCNT_V << USB_OTGHS_DOEPTSIZ1_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ1_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ1_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ1_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ1_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ1_RXDPID_M  (USB_OTGHS_DOEPTSIZ1_RXDPID_V << USB_OTGHS_DOEPTSIZ1_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ1_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ1_RXDPID_S  29

/** USB_OTGHS_DOEPDMA1_REG register
 *  This register contains the DMA Address for the OUT Endpoint 1 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA1_REG (DR_REG_USB_OTGHS_BASE + 0xb34)
/** USB_OTGHS_DOEPDMA1_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA1_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA1_DMAADDR_M  (USB_OTGHS_DOEPDMA1_DMAADDR_V << USB_OTGHS_DOEPDMA1_DMAADDR_S)
#define USB_OTGHS_DOEPDMA1_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA1_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB1_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 1 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB1_REG (DR_REG_USB_OTGHS_BASE + 0xb3c)
/** USB_OTGHS_DOEPDMAB1_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB1_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB1_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB1_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB1_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB1_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB1_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL2_REG register
 *  This register is used to control the characteristics of OUT Endpoint 2 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL2_REG (DR_REG_USB_OTGHS_BASE + 0xb40)
/** USB_OTGHS_DOEPCTL2_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL2_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL2_MPS_M  (USB_OTGHS_DOEPCTL2_MPS_V << USB_OTGHS_DOEPCTL2_MPS_S)
#define USB_OTGHS_DOEPCTL2_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL2_MPS_S  0
/** USB_OTGHS_DOEPCTL2_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL2_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL2_USBACTEP_M  (USB_OTGHS_DOEPCTL2_USBACTEP_V << USB_OTGHS_DOEPCTL2_USBACTEP_S)
#define USB_OTGHS_DOEPCTL2_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL2_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL2_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL2_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL2_DPID_M  (USB_OTGHS_DOEPCTL2_DPID_V << USB_OTGHS_DOEPCTL2_DPID_S)
#define USB_OTGHS_DOEPCTL2_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL2_DPID_S  16
/** USB_OTGHS_DOEPCTL2_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL2_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL2_NAKSTS_M  (USB_OTGHS_DOEPCTL2_NAKSTS_V << USB_OTGHS_DOEPCTL2_NAKSTS_S)
#define USB_OTGHS_DOEPCTL2_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL2_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL2_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL2_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL2_EPTYPE_M  (USB_OTGHS_DOEPCTL2_EPTYPE_V << USB_OTGHS_DOEPCTL2_EPTYPE_S)
#define USB_OTGHS_DOEPCTL2_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL2_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL2_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL2_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL2_SNP_M  (USB_OTGHS_DOEPCTL2_SNP_V << USB_OTGHS_DOEPCTL2_SNP_S)
#define USB_OTGHS_DOEPCTL2_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL2_SNP_S  20
/** USB_OTGHS_DOEPCTL2_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL2_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL2_STALL_M  (USB_OTGHS_DOEPCTL2_STALL_V << USB_OTGHS_DOEPCTL2_STALL_S)
#define USB_OTGHS_DOEPCTL2_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL2_STALL_S  21
/** USB_OTGHS_DOEPCTL2_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL2_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL2_CNAK_M  (USB_OTGHS_DOEPCTL2_CNAK_V << USB_OTGHS_DOEPCTL2_CNAK_S)
#define USB_OTGHS_DOEPCTL2_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL2_CNAK_S  26
/** USB_OTGHS_DOEPCTL2_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL2_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL2_SNAK_M  (USB_OTGHS_DOEPCTL2_SNAK_V << USB_OTGHS_DOEPCTL2_SNAK_S)
#define USB_OTGHS_DOEPCTL2_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL2_SNAK_S  27
/** USB_OTGHS_DOEPCTL2_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL2_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL2_SETD0PID_M  (USB_OTGHS_DOEPCTL2_SETD0PID_V << USB_OTGHS_DOEPCTL2_SETD0PID_S)
#define USB_OTGHS_DOEPCTL2_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL2_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL2_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL2_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL2_SETD1PID_M  (USB_OTGHS_DOEPCTL2_SETD1PID_V << USB_OTGHS_DOEPCTL2_SETD1PID_S)
#define USB_OTGHS_DOEPCTL2_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL2_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL2_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL2_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL2_EPDIS_M  (USB_OTGHS_DOEPCTL2_EPDIS_V << USB_OTGHS_DOEPCTL2_EPDIS_S)
#define USB_OTGHS_DOEPCTL2_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL2_EPDIS_S  30
/** USB_OTGHS_DOEPCTL2_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL2_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL2_EPENA_M  (USB_OTGHS_DOEPCTL2_EPENA_V << USB_OTGHS_DOEPCTL2_EPENA_S)
#define USB_OTGHS_DOEPCTL2_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL2_EPENA_S  31

/** USB_OTGHS_DOEPINT2_REG register
 *  This register contains the interrupts for the OUT Endpoint 2 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT2_REG (DR_REG_USB_OTGHS_BASE + 0xb48)
/** USB_OTGHS_DOEPINT2_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT2_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT2_XFERCOMPL_M  (USB_OTGHS_DOEPINT2_XFERCOMPL_V << USB_OTGHS_DOEPINT2_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT2_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT2_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT2_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT2_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT2_EPDISBLD_M  (USB_OTGHS_DOEPINT2_EPDISBLD_V << USB_OTGHS_DOEPINT2_EPDISBLD_S)
#define USB_OTGHS_DOEPINT2_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT2_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT2_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT2_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT2_AHBERR_M  (USB_OTGHS_DOEPINT2_AHBERR_V << USB_OTGHS_DOEPINT2_AHBERR_S)
#define USB_OTGHS_DOEPINT2_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT2_AHBERR_S  2
/** USB_OTGHS_DOEPINT2_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT2_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT2_SETUP_M  (USB_OTGHS_DOEPINT2_SETUP_V << USB_OTGHS_DOEPINT2_SETUP_S)
#define USB_OTGHS_DOEPINT2_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT2_SETUP_S  3
/** USB_OTGHS_DOEPINT2_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT2_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT2_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT2_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT2_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT2_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT2_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT2_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT2_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT2_STSPHSERCVD_M  (USB_OTGHS_DOEPINT2_STSPHSERCVD_V << USB_OTGHS_DOEPINT2_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT2_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT2_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT2_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT2_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT2_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT2_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT2_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT2_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT2_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT2_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT2_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT2_OUTPKTERR_M  (USB_OTGHS_DOEPINT2_OUTPKTERR_V << USB_OTGHS_DOEPINT2_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT2_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT2_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT2_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT2_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT2_BNAINTR_M  (USB_OTGHS_DOEPINT2_BNAINTR_V << USB_OTGHS_DOEPINT2_BNAINTR_S)
#define USB_OTGHS_DOEPINT2_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT2_BNAINTR_S  9
/** USB_OTGHS_DOEPINT2_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT2_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT2_PKTDRPSTS_M  (USB_OTGHS_DOEPINT2_PKTDRPSTS_V << USB_OTGHS_DOEPINT2_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT2_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT2_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT2_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT2_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT2_BBLEERR_M  (USB_OTGHS_DOEPINT2_BBLEERR_V << USB_OTGHS_DOEPINT2_BBLEERR_S)
#define USB_OTGHS_DOEPINT2_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT2_BBLEERR_S  12
/** USB_OTGHS_DOEPINT2_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT2_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT2_NAKINTRPT_M  (USB_OTGHS_DOEPINT2_NAKINTRPT_V << USB_OTGHS_DOEPINT2_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT2_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT2_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT2_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT2_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT2_NYETINTRPT_M  (USB_OTGHS_DOEPINT2_NYETINTRPT_V << USB_OTGHS_DOEPINT2_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT2_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT2_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT2_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT2_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT2_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT2_STUPPKTRCVD_V << USB_OTGHS_DOEPINT2_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT2_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT2_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ2_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 2 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ2_REG (DR_REG_USB_OTGHS_BASE + 0xb50)
/** USB_OTGHS_DOEPTSIZ2_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ2_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ2_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ2_XFERSIZE_V << USB_OTGHS_DOEPTSIZ2_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ2_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ2_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ2_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ2_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ2_PKTCNT_M  (USB_OTGHS_DOEPTSIZ2_PKTCNT_V << USB_OTGHS_DOEPTSIZ2_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ2_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ2_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ2_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ2_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ2_RXDPID_M  (USB_OTGHS_DOEPTSIZ2_RXDPID_V << USB_OTGHS_DOEPTSIZ2_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ2_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ2_RXDPID_S  29

/** USB_OTGHS_DOEPDMA2_REG register
 *  This register contains the DMA Address for the OUT Endpoint 2 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA2_REG (DR_REG_USB_OTGHS_BASE + 0xb54)
/** USB_OTGHS_DOEPDMA2_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA2_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA2_DMAADDR_M  (USB_OTGHS_DOEPDMA2_DMAADDR_V << USB_OTGHS_DOEPDMA2_DMAADDR_S)
#define USB_OTGHS_DOEPDMA2_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA2_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB2_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 2 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB2_REG (DR_REG_USB_OTGHS_BASE + 0xb5c)
/** USB_OTGHS_DOEPDMAB2_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB2_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB2_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB2_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB2_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB2_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB2_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL3_REG register
 *  This register is used to control the characteristics of OUT Endpoint 3 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL3_REG (DR_REG_USB_OTGHS_BASE + 0xb60)
/** USB_OTGHS_DOEPCTL3_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL3_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL3_MPS_M  (USB_OTGHS_DOEPCTL3_MPS_V << USB_OTGHS_DOEPCTL3_MPS_S)
#define USB_OTGHS_DOEPCTL3_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL3_MPS_S  0
/** USB_OTGHS_DOEPCTL3_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL3_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL3_USBACTEP_M  (USB_OTGHS_DOEPCTL3_USBACTEP_V << USB_OTGHS_DOEPCTL3_USBACTEP_S)
#define USB_OTGHS_DOEPCTL3_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL3_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL3_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL3_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL3_DPID_M  (USB_OTGHS_DOEPCTL3_DPID_V << USB_OTGHS_DOEPCTL3_DPID_S)
#define USB_OTGHS_DOEPCTL3_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL3_DPID_S  16
/** USB_OTGHS_DOEPCTL3_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL3_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL3_NAKSTS_M  (USB_OTGHS_DOEPCTL3_NAKSTS_V << USB_OTGHS_DOEPCTL3_NAKSTS_S)
#define USB_OTGHS_DOEPCTL3_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL3_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL3_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL3_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL3_EPTYPE_M  (USB_OTGHS_DOEPCTL3_EPTYPE_V << USB_OTGHS_DOEPCTL3_EPTYPE_S)
#define USB_OTGHS_DOEPCTL3_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL3_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL3_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL3_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL3_SNP_M  (USB_OTGHS_DOEPCTL3_SNP_V << USB_OTGHS_DOEPCTL3_SNP_S)
#define USB_OTGHS_DOEPCTL3_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL3_SNP_S  20
/** USB_OTGHS_DOEPCTL3_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL3_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL3_STALL_M  (USB_OTGHS_DOEPCTL3_STALL_V << USB_OTGHS_DOEPCTL3_STALL_S)
#define USB_OTGHS_DOEPCTL3_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL3_STALL_S  21
/** USB_OTGHS_DOEPCTL3_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL3_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL3_CNAK_M  (USB_OTGHS_DOEPCTL3_CNAK_V << USB_OTGHS_DOEPCTL3_CNAK_S)
#define USB_OTGHS_DOEPCTL3_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL3_CNAK_S  26
/** USB_OTGHS_DOEPCTL3_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL3_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL3_SNAK_M  (USB_OTGHS_DOEPCTL3_SNAK_V << USB_OTGHS_DOEPCTL3_SNAK_S)
#define USB_OTGHS_DOEPCTL3_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL3_SNAK_S  27
/** USB_OTGHS_DOEPCTL3_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL3_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL3_SETD0PID_M  (USB_OTGHS_DOEPCTL3_SETD0PID_V << USB_OTGHS_DOEPCTL3_SETD0PID_S)
#define USB_OTGHS_DOEPCTL3_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL3_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL3_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL3_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL3_SETD1PID_M  (USB_OTGHS_DOEPCTL3_SETD1PID_V << USB_OTGHS_DOEPCTL3_SETD1PID_S)
#define USB_OTGHS_DOEPCTL3_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL3_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL3_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL3_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL3_EPDIS_M  (USB_OTGHS_DOEPCTL3_EPDIS_V << USB_OTGHS_DOEPCTL3_EPDIS_S)
#define USB_OTGHS_DOEPCTL3_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL3_EPDIS_S  30
/** USB_OTGHS_DOEPCTL3_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL3_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL3_EPENA_M  (USB_OTGHS_DOEPCTL3_EPENA_V << USB_OTGHS_DOEPCTL3_EPENA_S)
#define USB_OTGHS_DOEPCTL3_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL3_EPENA_S  31

/** USB_OTGHS_DOEPINT3_REG register
 *  This register contains the interrupts for the OUT Endpoint 3 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT3_REG (DR_REG_USB_OTGHS_BASE + 0xb68)
/** USB_OTGHS_DOEPINT3_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT3_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT3_XFERCOMPL_M  (USB_OTGHS_DOEPINT3_XFERCOMPL_V << USB_OTGHS_DOEPINT3_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT3_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT3_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT3_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT3_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT3_EPDISBLD_M  (USB_OTGHS_DOEPINT3_EPDISBLD_V << USB_OTGHS_DOEPINT3_EPDISBLD_S)
#define USB_OTGHS_DOEPINT3_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT3_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT3_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT3_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT3_AHBERR_M  (USB_OTGHS_DOEPINT3_AHBERR_V << USB_OTGHS_DOEPINT3_AHBERR_S)
#define USB_OTGHS_DOEPINT3_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT3_AHBERR_S  2
/** USB_OTGHS_DOEPINT3_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT3_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT3_SETUP_M  (USB_OTGHS_DOEPINT3_SETUP_V << USB_OTGHS_DOEPINT3_SETUP_S)
#define USB_OTGHS_DOEPINT3_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT3_SETUP_S  3
/** USB_OTGHS_DOEPINT3_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT3_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT3_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT3_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT3_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT3_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT3_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT3_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT3_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT3_STSPHSERCVD_M  (USB_OTGHS_DOEPINT3_STSPHSERCVD_V << USB_OTGHS_DOEPINT3_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT3_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT3_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT3_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT3_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT3_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT3_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT3_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT3_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT3_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT3_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT3_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT3_OUTPKTERR_M  (USB_OTGHS_DOEPINT3_OUTPKTERR_V << USB_OTGHS_DOEPINT3_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT3_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT3_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT3_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT3_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT3_BNAINTR_M  (USB_OTGHS_DOEPINT3_BNAINTR_V << USB_OTGHS_DOEPINT3_BNAINTR_S)
#define USB_OTGHS_DOEPINT3_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT3_BNAINTR_S  9
/** USB_OTGHS_DOEPINT3_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT3_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT3_PKTDRPSTS_M  (USB_OTGHS_DOEPINT3_PKTDRPSTS_V << USB_OTGHS_DOEPINT3_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT3_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT3_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT3_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT3_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT3_BBLEERR_M  (USB_OTGHS_DOEPINT3_BBLEERR_V << USB_OTGHS_DOEPINT3_BBLEERR_S)
#define USB_OTGHS_DOEPINT3_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT3_BBLEERR_S  12
/** USB_OTGHS_DOEPINT3_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT3_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT3_NAKINTRPT_M  (USB_OTGHS_DOEPINT3_NAKINTRPT_V << USB_OTGHS_DOEPINT3_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT3_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT3_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT3_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT3_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT3_NYETINTRPT_M  (USB_OTGHS_DOEPINT3_NYETINTRPT_V << USB_OTGHS_DOEPINT3_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT3_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT3_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT3_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT3_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT3_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT3_STUPPKTRCVD_V << USB_OTGHS_DOEPINT3_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT3_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT3_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ3_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 3 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ3_REG (DR_REG_USB_OTGHS_BASE + 0xb70)
/** USB_OTGHS_DOEPTSIZ3_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ3_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ3_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ3_XFERSIZE_V << USB_OTGHS_DOEPTSIZ3_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ3_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ3_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ3_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ3_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ3_PKTCNT_M  (USB_OTGHS_DOEPTSIZ3_PKTCNT_V << USB_OTGHS_DOEPTSIZ3_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ3_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ3_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ3_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ3_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ3_RXDPID_M  (USB_OTGHS_DOEPTSIZ3_RXDPID_V << USB_OTGHS_DOEPTSIZ3_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ3_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ3_RXDPID_S  29

/** USB_OTGHS_DOEPDMA3_REG register
 *  This register contains the DMA Address for the OUT Endpoint 3 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA3_REG (DR_REG_USB_OTGHS_BASE + 0xb74)
/** USB_OTGHS_DOEPDMA3_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA3_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA3_DMAADDR_M  (USB_OTGHS_DOEPDMA3_DMAADDR_V << USB_OTGHS_DOEPDMA3_DMAADDR_S)
#define USB_OTGHS_DOEPDMA3_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA3_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB3_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 3 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB3_REG (DR_REG_USB_OTGHS_BASE + 0xb7c)
/** USB_OTGHS_DOEPDMAB3_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB3_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB3_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB3_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB3_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB3_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB3_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL4_REG register
 *  This register is used to control the characteristics of OUT Endpoint 4 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL4_REG (DR_REG_USB_OTGHS_BASE + 0xb80)
/** USB_OTGHS_DOEPCTL4_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL4_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL4_MPS_M  (USB_OTGHS_DOEPCTL4_MPS_V << USB_OTGHS_DOEPCTL4_MPS_S)
#define USB_OTGHS_DOEPCTL4_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL4_MPS_S  0
/** USB_OTGHS_DOEPCTL4_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL4_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL4_USBACTEP_M  (USB_OTGHS_DOEPCTL4_USBACTEP_V << USB_OTGHS_DOEPCTL4_USBACTEP_S)
#define USB_OTGHS_DOEPCTL4_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL4_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL4_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL4_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL4_DPID_M  (USB_OTGHS_DOEPCTL4_DPID_V << USB_OTGHS_DOEPCTL4_DPID_S)
#define USB_OTGHS_DOEPCTL4_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL4_DPID_S  16
/** USB_OTGHS_DOEPCTL4_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL4_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL4_NAKSTS_M  (USB_OTGHS_DOEPCTL4_NAKSTS_V << USB_OTGHS_DOEPCTL4_NAKSTS_S)
#define USB_OTGHS_DOEPCTL4_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL4_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL4_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL4_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL4_EPTYPE_M  (USB_OTGHS_DOEPCTL4_EPTYPE_V << USB_OTGHS_DOEPCTL4_EPTYPE_S)
#define USB_OTGHS_DOEPCTL4_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL4_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL4_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL4_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL4_SNP_M  (USB_OTGHS_DOEPCTL4_SNP_V << USB_OTGHS_DOEPCTL4_SNP_S)
#define USB_OTGHS_DOEPCTL4_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL4_SNP_S  20
/** USB_OTGHS_DOEPCTL4_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL4_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL4_STALL_M  (USB_OTGHS_DOEPCTL4_STALL_V << USB_OTGHS_DOEPCTL4_STALL_S)
#define USB_OTGHS_DOEPCTL4_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL4_STALL_S  21
/** USB_OTGHS_DOEPCTL4_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL4_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL4_CNAK_M  (USB_OTGHS_DOEPCTL4_CNAK_V << USB_OTGHS_DOEPCTL4_CNAK_S)
#define USB_OTGHS_DOEPCTL4_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL4_CNAK_S  26
/** USB_OTGHS_DOEPCTL4_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL4_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL4_SNAK_M  (USB_OTGHS_DOEPCTL4_SNAK_V << USB_OTGHS_DOEPCTL4_SNAK_S)
#define USB_OTGHS_DOEPCTL4_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL4_SNAK_S  27
/** USB_OTGHS_DOEPCTL4_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL4_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL4_SETD0PID_M  (USB_OTGHS_DOEPCTL4_SETD0PID_V << USB_OTGHS_DOEPCTL4_SETD0PID_S)
#define USB_OTGHS_DOEPCTL4_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL4_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL4_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL4_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL4_SETD1PID_M  (USB_OTGHS_DOEPCTL4_SETD1PID_V << USB_OTGHS_DOEPCTL4_SETD1PID_S)
#define USB_OTGHS_DOEPCTL4_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL4_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL4_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL4_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL4_EPDIS_M  (USB_OTGHS_DOEPCTL4_EPDIS_V << USB_OTGHS_DOEPCTL4_EPDIS_S)
#define USB_OTGHS_DOEPCTL4_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL4_EPDIS_S  30
/** USB_OTGHS_DOEPCTL4_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL4_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL4_EPENA_M  (USB_OTGHS_DOEPCTL4_EPENA_V << USB_OTGHS_DOEPCTL4_EPENA_S)
#define USB_OTGHS_DOEPCTL4_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL4_EPENA_S  31

/** USB_OTGHS_DOEPINT4_REG register
 *  This register contains the interrupts for the OUT Endpoint 4 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT4_REG (DR_REG_USB_OTGHS_BASE + 0xb88)
/** USB_OTGHS_DOEPINT4_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT4_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT4_XFERCOMPL_M  (USB_OTGHS_DOEPINT4_XFERCOMPL_V << USB_OTGHS_DOEPINT4_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT4_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT4_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT4_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT4_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT4_EPDISBLD_M  (USB_OTGHS_DOEPINT4_EPDISBLD_V << USB_OTGHS_DOEPINT4_EPDISBLD_S)
#define USB_OTGHS_DOEPINT4_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT4_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT4_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT4_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT4_AHBERR_M  (USB_OTGHS_DOEPINT4_AHBERR_V << USB_OTGHS_DOEPINT4_AHBERR_S)
#define USB_OTGHS_DOEPINT4_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT4_AHBERR_S  2
/** USB_OTGHS_DOEPINT4_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT4_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT4_SETUP_M  (USB_OTGHS_DOEPINT4_SETUP_V << USB_OTGHS_DOEPINT4_SETUP_S)
#define USB_OTGHS_DOEPINT4_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT4_SETUP_S  3
/** USB_OTGHS_DOEPINT4_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT4_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT4_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT4_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT4_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT4_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT4_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT4_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT4_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT4_STSPHSERCVD_M  (USB_OTGHS_DOEPINT4_STSPHSERCVD_V << USB_OTGHS_DOEPINT4_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT4_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT4_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT4_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT4_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT4_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT4_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT4_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT4_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT4_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT4_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT4_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT4_OUTPKTERR_M  (USB_OTGHS_DOEPINT4_OUTPKTERR_V << USB_OTGHS_DOEPINT4_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT4_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT4_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT4_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT4_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT4_BNAINTR_M  (USB_OTGHS_DOEPINT4_BNAINTR_V << USB_OTGHS_DOEPINT4_BNAINTR_S)
#define USB_OTGHS_DOEPINT4_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT4_BNAINTR_S  9
/** USB_OTGHS_DOEPINT4_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT4_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT4_PKTDRPSTS_M  (USB_OTGHS_DOEPINT4_PKTDRPSTS_V << USB_OTGHS_DOEPINT4_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT4_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT4_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT4_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT4_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT4_BBLEERR_M  (USB_OTGHS_DOEPINT4_BBLEERR_V << USB_OTGHS_DOEPINT4_BBLEERR_S)
#define USB_OTGHS_DOEPINT4_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT4_BBLEERR_S  12
/** USB_OTGHS_DOEPINT4_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT4_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT4_NAKINTRPT_M  (USB_OTGHS_DOEPINT4_NAKINTRPT_V << USB_OTGHS_DOEPINT4_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT4_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT4_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT4_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT4_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT4_NYETINTRPT_M  (USB_OTGHS_DOEPINT4_NYETINTRPT_V << USB_OTGHS_DOEPINT4_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT4_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT4_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT4_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT4_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT4_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT4_STUPPKTRCVD_V << USB_OTGHS_DOEPINT4_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT4_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT4_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ4_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 4 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ4_REG (DR_REG_USB_OTGHS_BASE + 0xb90)
/** USB_OTGHS_DOEPTSIZ4_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ4_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ4_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ4_XFERSIZE_V << USB_OTGHS_DOEPTSIZ4_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ4_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ4_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ4_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ4_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ4_PKTCNT_M  (USB_OTGHS_DOEPTSIZ4_PKTCNT_V << USB_OTGHS_DOEPTSIZ4_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ4_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ4_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ4_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ4_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ4_RXDPID_M  (USB_OTGHS_DOEPTSIZ4_RXDPID_V << USB_OTGHS_DOEPTSIZ4_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ4_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ4_RXDPID_S  29

/** USB_OTGHS_DOEPDMA4_REG register
 *  This register contains the DMA Address for the OUT Endpoint 4 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA4_REG (DR_REG_USB_OTGHS_BASE + 0xb94)
/** USB_OTGHS_DOEPDMA4_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA4_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA4_DMAADDR_M  (USB_OTGHS_DOEPDMA4_DMAADDR_V << USB_OTGHS_DOEPDMA4_DMAADDR_S)
#define USB_OTGHS_DOEPDMA4_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA4_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB4_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 4 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB4_REG (DR_REG_USB_OTGHS_BASE + 0xb9c)
/** USB_OTGHS_DOEPDMAB4_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB4_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB4_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB4_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB4_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB4_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB4_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL5_REG register
 *  This register is used to control the characteristics of OUT Endpoint 5 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL5_REG (DR_REG_USB_OTGHS_BASE + 0xba0)
/** USB_OTGHS_DOEPCTL5_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL5_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL5_MPS_M  (USB_OTGHS_DOEPCTL5_MPS_V << USB_OTGHS_DOEPCTL5_MPS_S)
#define USB_OTGHS_DOEPCTL5_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL5_MPS_S  0
/** USB_OTGHS_DOEPCTL5_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL5_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL5_USBACTEP_M  (USB_OTGHS_DOEPCTL5_USBACTEP_V << USB_OTGHS_DOEPCTL5_USBACTEP_S)
#define USB_OTGHS_DOEPCTL5_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL5_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL5_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL5_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL5_DPID_M  (USB_OTGHS_DOEPCTL5_DPID_V << USB_OTGHS_DOEPCTL5_DPID_S)
#define USB_OTGHS_DOEPCTL5_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL5_DPID_S  16
/** USB_OTGHS_DOEPCTL5_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL5_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL5_NAKSTS_M  (USB_OTGHS_DOEPCTL5_NAKSTS_V << USB_OTGHS_DOEPCTL5_NAKSTS_S)
#define USB_OTGHS_DOEPCTL5_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL5_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL5_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL5_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL5_EPTYPE_M  (USB_OTGHS_DOEPCTL5_EPTYPE_V << USB_OTGHS_DOEPCTL5_EPTYPE_S)
#define USB_OTGHS_DOEPCTL5_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL5_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL5_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL5_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL5_SNP_M  (USB_OTGHS_DOEPCTL5_SNP_V << USB_OTGHS_DOEPCTL5_SNP_S)
#define USB_OTGHS_DOEPCTL5_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL5_SNP_S  20
/** USB_OTGHS_DOEPCTL5_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL5_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL5_STALL_M  (USB_OTGHS_DOEPCTL5_STALL_V << USB_OTGHS_DOEPCTL5_STALL_S)
#define USB_OTGHS_DOEPCTL5_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL5_STALL_S  21
/** USB_OTGHS_DOEPCTL5_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL5_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL5_CNAK_M  (USB_OTGHS_DOEPCTL5_CNAK_V << USB_OTGHS_DOEPCTL5_CNAK_S)
#define USB_OTGHS_DOEPCTL5_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL5_CNAK_S  26
/** USB_OTGHS_DOEPCTL5_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL5_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL5_SNAK_M  (USB_OTGHS_DOEPCTL5_SNAK_V << USB_OTGHS_DOEPCTL5_SNAK_S)
#define USB_OTGHS_DOEPCTL5_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL5_SNAK_S  27
/** USB_OTGHS_DOEPCTL5_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL5_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL5_SETD0PID_M  (USB_OTGHS_DOEPCTL5_SETD0PID_V << USB_OTGHS_DOEPCTL5_SETD0PID_S)
#define USB_OTGHS_DOEPCTL5_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL5_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL5_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL5_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL5_SETD1PID_M  (USB_OTGHS_DOEPCTL5_SETD1PID_V << USB_OTGHS_DOEPCTL5_SETD1PID_S)
#define USB_OTGHS_DOEPCTL5_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL5_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL5_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL5_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL5_EPDIS_M  (USB_OTGHS_DOEPCTL5_EPDIS_V << USB_OTGHS_DOEPCTL5_EPDIS_S)
#define USB_OTGHS_DOEPCTL5_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL5_EPDIS_S  30
/** USB_OTGHS_DOEPCTL5_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL5_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL5_EPENA_M  (USB_OTGHS_DOEPCTL5_EPENA_V << USB_OTGHS_DOEPCTL5_EPENA_S)
#define USB_OTGHS_DOEPCTL5_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL5_EPENA_S  31

/** USB_OTGHS_DOEPINT5_REG register
 *  This register contains the interrupts for the OUT Endpoint 5 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT5_REG (DR_REG_USB_OTGHS_BASE + 0xba8)
/** USB_OTGHS_DOEPINT5_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT5_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT5_XFERCOMPL_M  (USB_OTGHS_DOEPINT5_XFERCOMPL_V << USB_OTGHS_DOEPINT5_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT5_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT5_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT5_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT5_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT5_EPDISBLD_M  (USB_OTGHS_DOEPINT5_EPDISBLD_V << USB_OTGHS_DOEPINT5_EPDISBLD_S)
#define USB_OTGHS_DOEPINT5_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT5_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT5_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT5_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT5_AHBERR_M  (USB_OTGHS_DOEPINT5_AHBERR_V << USB_OTGHS_DOEPINT5_AHBERR_S)
#define USB_OTGHS_DOEPINT5_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT5_AHBERR_S  2
/** USB_OTGHS_DOEPINT5_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT5_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT5_SETUP_M  (USB_OTGHS_DOEPINT5_SETUP_V << USB_OTGHS_DOEPINT5_SETUP_S)
#define USB_OTGHS_DOEPINT5_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT5_SETUP_S  3
/** USB_OTGHS_DOEPINT5_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT5_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT5_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT5_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT5_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT5_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT5_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT5_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT5_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT5_STSPHSERCVD_M  (USB_OTGHS_DOEPINT5_STSPHSERCVD_V << USB_OTGHS_DOEPINT5_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT5_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT5_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT5_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT5_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT5_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT5_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT5_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT5_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT5_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT5_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT5_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT5_OUTPKTERR_M  (USB_OTGHS_DOEPINT5_OUTPKTERR_V << USB_OTGHS_DOEPINT5_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT5_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT5_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT5_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT5_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT5_BNAINTR_M  (USB_OTGHS_DOEPINT5_BNAINTR_V << USB_OTGHS_DOEPINT5_BNAINTR_S)
#define USB_OTGHS_DOEPINT5_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT5_BNAINTR_S  9
/** USB_OTGHS_DOEPINT5_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT5_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT5_PKTDRPSTS_M  (USB_OTGHS_DOEPINT5_PKTDRPSTS_V << USB_OTGHS_DOEPINT5_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT5_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT5_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT5_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT5_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT5_BBLEERR_M  (USB_OTGHS_DOEPINT5_BBLEERR_V << USB_OTGHS_DOEPINT5_BBLEERR_S)
#define USB_OTGHS_DOEPINT5_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT5_BBLEERR_S  12
/** USB_OTGHS_DOEPINT5_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT5_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT5_NAKINTRPT_M  (USB_OTGHS_DOEPINT5_NAKINTRPT_V << USB_OTGHS_DOEPINT5_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT5_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT5_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT5_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT5_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT5_NYETINTRPT_M  (USB_OTGHS_DOEPINT5_NYETINTRPT_V << USB_OTGHS_DOEPINT5_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT5_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT5_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT5_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT5_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT5_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT5_STUPPKTRCVD_V << USB_OTGHS_DOEPINT5_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT5_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT5_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ5_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 5 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ5_REG (DR_REG_USB_OTGHS_BASE + 0xbb0)
/** USB_OTGHS_DOEPTSIZ5_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ5_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ5_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ5_XFERSIZE_V << USB_OTGHS_DOEPTSIZ5_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ5_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ5_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ5_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ5_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ5_PKTCNT_M  (USB_OTGHS_DOEPTSIZ5_PKTCNT_V << USB_OTGHS_DOEPTSIZ5_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ5_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ5_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ5_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ5_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ5_RXDPID_M  (USB_OTGHS_DOEPTSIZ5_RXDPID_V << USB_OTGHS_DOEPTSIZ5_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ5_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ5_RXDPID_S  29

/** USB_OTGHS_DOEPDMA5_REG register
 *  This register contains the DMA Address for the OUT Endpoint 5 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA5_REG (DR_REG_USB_OTGHS_BASE + 0xbb4)
/** USB_OTGHS_DOEPDMA5_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA5_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA5_DMAADDR_M  (USB_OTGHS_DOEPDMA5_DMAADDR_V << USB_OTGHS_DOEPDMA5_DMAADDR_S)
#define USB_OTGHS_DOEPDMA5_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA5_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB5_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 5 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB5_REG (DR_REG_USB_OTGHS_BASE + 0xbbc)
/** USB_OTGHS_DOEPDMAB5_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB5_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB5_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB5_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB5_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB5_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB5_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL6_REG register
 *  This register is used to control the characteristics of OUT Endpoint 6 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL6_REG (DR_REG_USB_OTGHS_BASE + 0xbc0)
/** USB_OTGHS_DOEPCTL6_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL6_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL6_MPS_M  (USB_OTGHS_DOEPCTL6_MPS_V << USB_OTGHS_DOEPCTL6_MPS_S)
#define USB_OTGHS_DOEPCTL6_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL6_MPS_S  0
/** USB_OTGHS_DOEPCTL6_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL6_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL6_USBACTEP_M  (USB_OTGHS_DOEPCTL6_USBACTEP_V << USB_OTGHS_DOEPCTL6_USBACTEP_S)
#define USB_OTGHS_DOEPCTL6_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL6_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL6_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL6_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL6_DPID_M  (USB_OTGHS_DOEPCTL6_DPID_V << USB_OTGHS_DOEPCTL6_DPID_S)
#define USB_OTGHS_DOEPCTL6_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL6_DPID_S  16
/** USB_OTGHS_DOEPCTL6_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL6_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL6_NAKSTS_M  (USB_OTGHS_DOEPCTL6_NAKSTS_V << USB_OTGHS_DOEPCTL6_NAKSTS_S)
#define USB_OTGHS_DOEPCTL6_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL6_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL6_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL6_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL6_EPTYPE_M  (USB_OTGHS_DOEPCTL6_EPTYPE_V << USB_OTGHS_DOEPCTL6_EPTYPE_S)
#define USB_OTGHS_DOEPCTL6_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL6_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL6_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL6_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL6_SNP_M  (USB_OTGHS_DOEPCTL6_SNP_V << USB_OTGHS_DOEPCTL6_SNP_S)
#define USB_OTGHS_DOEPCTL6_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL6_SNP_S  20
/** USB_OTGHS_DOEPCTL6_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL6_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL6_STALL_M  (USB_OTGHS_DOEPCTL6_STALL_V << USB_OTGHS_DOEPCTL6_STALL_S)
#define USB_OTGHS_DOEPCTL6_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL6_STALL_S  21
/** USB_OTGHS_DOEPCTL6_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL6_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL6_CNAK_M  (USB_OTGHS_DOEPCTL6_CNAK_V << USB_OTGHS_DOEPCTL6_CNAK_S)
#define USB_OTGHS_DOEPCTL6_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL6_CNAK_S  26
/** USB_OTGHS_DOEPCTL6_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL6_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL6_SNAK_M  (USB_OTGHS_DOEPCTL6_SNAK_V << USB_OTGHS_DOEPCTL6_SNAK_S)
#define USB_OTGHS_DOEPCTL6_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL6_SNAK_S  27
/** USB_OTGHS_DOEPCTL6_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL6_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL6_SETD0PID_M  (USB_OTGHS_DOEPCTL6_SETD0PID_V << USB_OTGHS_DOEPCTL6_SETD0PID_S)
#define USB_OTGHS_DOEPCTL6_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL6_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL6_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL6_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL6_SETD1PID_M  (USB_OTGHS_DOEPCTL6_SETD1PID_V << USB_OTGHS_DOEPCTL6_SETD1PID_S)
#define USB_OTGHS_DOEPCTL6_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL6_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL6_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL6_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL6_EPDIS_M  (USB_OTGHS_DOEPCTL6_EPDIS_V << USB_OTGHS_DOEPCTL6_EPDIS_S)
#define USB_OTGHS_DOEPCTL6_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL6_EPDIS_S  30
/** USB_OTGHS_DOEPCTL6_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL6_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL6_EPENA_M  (USB_OTGHS_DOEPCTL6_EPENA_V << USB_OTGHS_DOEPCTL6_EPENA_S)
#define USB_OTGHS_DOEPCTL6_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL6_EPENA_S  31

/** USB_OTGHS_DOEPINT6_REG register
 *  This register contains the interrupts for the OUT Endpoint 6 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT6_REG (DR_REG_USB_OTGHS_BASE + 0xbc8)
/** USB_OTGHS_DOEPINT6_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT6_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT6_XFERCOMPL_M  (USB_OTGHS_DOEPINT6_XFERCOMPL_V << USB_OTGHS_DOEPINT6_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT6_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT6_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT6_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT6_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT6_EPDISBLD_M  (USB_OTGHS_DOEPINT6_EPDISBLD_V << USB_OTGHS_DOEPINT6_EPDISBLD_S)
#define USB_OTGHS_DOEPINT6_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT6_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT6_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT6_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT6_AHBERR_M  (USB_OTGHS_DOEPINT6_AHBERR_V << USB_OTGHS_DOEPINT6_AHBERR_S)
#define USB_OTGHS_DOEPINT6_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT6_AHBERR_S  2
/** USB_OTGHS_DOEPINT6_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT6_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT6_SETUP_M  (USB_OTGHS_DOEPINT6_SETUP_V << USB_OTGHS_DOEPINT6_SETUP_S)
#define USB_OTGHS_DOEPINT6_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT6_SETUP_S  3
/** USB_OTGHS_DOEPINT6_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT6_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT6_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT6_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT6_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT6_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT6_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT6_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT6_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT6_STSPHSERCVD_M  (USB_OTGHS_DOEPINT6_STSPHSERCVD_V << USB_OTGHS_DOEPINT6_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT6_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT6_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT6_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT6_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT6_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT6_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT6_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT6_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT6_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT6_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT6_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT6_OUTPKTERR_M  (USB_OTGHS_DOEPINT6_OUTPKTERR_V << USB_OTGHS_DOEPINT6_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT6_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT6_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT6_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT6_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT6_BNAINTR_M  (USB_OTGHS_DOEPINT6_BNAINTR_V << USB_OTGHS_DOEPINT6_BNAINTR_S)
#define USB_OTGHS_DOEPINT6_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT6_BNAINTR_S  9
/** USB_OTGHS_DOEPINT6_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT6_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT6_PKTDRPSTS_M  (USB_OTGHS_DOEPINT6_PKTDRPSTS_V << USB_OTGHS_DOEPINT6_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT6_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT6_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT6_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT6_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT6_BBLEERR_M  (USB_OTGHS_DOEPINT6_BBLEERR_V << USB_OTGHS_DOEPINT6_BBLEERR_S)
#define USB_OTGHS_DOEPINT6_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT6_BBLEERR_S  12
/** USB_OTGHS_DOEPINT6_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT6_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT6_NAKINTRPT_M  (USB_OTGHS_DOEPINT6_NAKINTRPT_V << USB_OTGHS_DOEPINT6_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT6_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT6_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT6_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT6_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT6_NYETINTRPT_M  (USB_OTGHS_DOEPINT6_NYETINTRPT_V << USB_OTGHS_DOEPINT6_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT6_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT6_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT6_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT6_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT6_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT6_STUPPKTRCVD_V << USB_OTGHS_DOEPINT6_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT6_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT6_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ6_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 6 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ6_REG (DR_REG_USB_OTGHS_BASE + 0xbd0)
/** USB_OTGHS_DOEPTSIZ6_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ6_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ6_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ6_XFERSIZE_V << USB_OTGHS_DOEPTSIZ6_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ6_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ6_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ6_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ6_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ6_PKTCNT_M  (USB_OTGHS_DOEPTSIZ6_PKTCNT_V << USB_OTGHS_DOEPTSIZ6_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ6_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ6_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ6_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ6_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ6_RXDPID_M  (USB_OTGHS_DOEPTSIZ6_RXDPID_V << USB_OTGHS_DOEPTSIZ6_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ6_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ6_RXDPID_S  29

/** USB_OTGHS_DOEPDMA6_REG register
 *  This register contains the DMA Address for the OUT Endpoint 6 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA6_REG (DR_REG_USB_OTGHS_BASE + 0xbd4)
/** USB_OTGHS_DOEPDMA6_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA6_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA6_DMAADDR_M  (USB_OTGHS_DOEPDMA6_DMAADDR_V << USB_OTGHS_DOEPDMA6_DMAADDR_S)
#define USB_OTGHS_DOEPDMA6_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA6_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB6_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 6 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB6_REG (DR_REG_USB_OTGHS_BASE + 0xbdc)
/** USB_OTGHS_DOEPDMAB6_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB6_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB6_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB6_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB6_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB6_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB6_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL7_REG register
 *  This register is used to control the characteristics of OUT Endpoint 7 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL7_REG (DR_REG_USB_OTGHS_BASE + 0xbe0)
/** USB_OTGHS_DOEPCTL7_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL7_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL7_MPS_M  (USB_OTGHS_DOEPCTL7_MPS_V << USB_OTGHS_DOEPCTL7_MPS_S)
#define USB_OTGHS_DOEPCTL7_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL7_MPS_S  0
/** USB_OTGHS_DOEPCTL7_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL7_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL7_USBACTEP_M  (USB_OTGHS_DOEPCTL7_USBACTEP_V << USB_OTGHS_DOEPCTL7_USBACTEP_S)
#define USB_OTGHS_DOEPCTL7_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL7_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL7_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL7_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL7_DPID_M  (USB_OTGHS_DOEPCTL7_DPID_V << USB_OTGHS_DOEPCTL7_DPID_S)
#define USB_OTGHS_DOEPCTL7_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL7_DPID_S  16
/** USB_OTGHS_DOEPCTL7_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL7_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL7_NAKSTS_M  (USB_OTGHS_DOEPCTL7_NAKSTS_V << USB_OTGHS_DOEPCTL7_NAKSTS_S)
#define USB_OTGHS_DOEPCTL7_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL7_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL7_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL7_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL7_EPTYPE_M  (USB_OTGHS_DOEPCTL7_EPTYPE_V << USB_OTGHS_DOEPCTL7_EPTYPE_S)
#define USB_OTGHS_DOEPCTL7_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL7_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL7_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL7_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL7_SNP_M  (USB_OTGHS_DOEPCTL7_SNP_V << USB_OTGHS_DOEPCTL7_SNP_S)
#define USB_OTGHS_DOEPCTL7_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL7_SNP_S  20
/** USB_OTGHS_DOEPCTL7_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL7_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL7_STALL_M  (USB_OTGHS_DOEPCTL7_STALL_V << USB_OTGHS_DOEPCTL7_STALL_S)
#define USB_OTGHS_DOEPCTL7_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL7_STALL_S  21
/** USB_OTGHS_DOEPCTL7_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL7_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL7_CNAK_M  (USB_OTGHS_DOEPCTL7_CNAK_V << USB_OTGHS_DOEPCTL7_CNAK_S)
#define USB_OTGHS_DOEPCTL7_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL7_CNAK_S  26
/** USB_OTGHS_DOEPCTL7_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL7_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL7_SNAK_M  (USB_OTGHS_DOEPCTL7_SNAK_V << USB_OTGHS_DOEPCTL7_SNAK_S)
#define USB_OTGHS_DOEPCTL7_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL7_SNAK_S  27
/** USB_OTGHS_DOEPCTL7_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL7_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL7_SETD0PID_M  (USB_OTGHS_DOEPCTL7_SETD0PID_V << USB_OTGHS_DOEPCTL7_SETD0PID_S)
#define USB_OTGHS_DOEPCTL7_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL7_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL7_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL7_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL7_SETD1PID_M  (USB_OTGHS_DOEPCTL7_SETD1PID_V << USB_OTGHS_DOEPCTL7_SETD1PID_S)
#define USB_OTGHS_DOEPCTL7_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL7_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL7_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL7_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL7_EPDIS_M  (USB_OTGHS_DOEPCTL7_EPDIS_V << USB_OTGHS_DOEPCTL7_EPDIS_S)
#define USB_OTGHS_DOEPCTL7_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL7_EPDIS_S  30
/** USB_OTGHS_DOEPCTL7_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL7_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL7_EPENA_M  (USB_OTGHS_DOEPCTL7_EPENA_V << USB_OTGHS_DOEPCTL7_EPENA_S)
#define USB_OTGHS_DOEPCTL7_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL7_EPENA_S  31

/** USB_OTGHS_DOEPINT7_REG register
 *  This register contains the interrupts for the OUT Endpoint 7 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT7_REG (DR_REG_USB_OTGHS_BASE + 0xbe8)
/** USB_OTGHS_DOEPINT7_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT7_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT7_XFERCOMPL_M  (USB_OTGHS_DOEPINT7_XFERCOMPL_V << USB_OTGHS_DOEPINT7_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT7_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT7_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT7_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT7_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT7_EPDISBLD_M  (USB_OTGHS_DOEPINT7_EPDISBLD_V << USB_OTGHS_DOEPINT7_EPDISBLD_S)
#define USB_OTGHS_DOEPINT7_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT7_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT7_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT7_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT7_AHBERR_M  (USB_OTGHS_DOEPINT7_AHBERR_V << USB_OTGHS_DOEPINT7_AHBERR_S)
#define USB_OTGHS_DOEPINT7_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT7_AHBERR_S  2
/** USB_OTGHS_DOEPINT7_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT7_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT7_SETUP_M  (USB_OTGHS_DOEPINT7_SETUP_V << USB_OTGHS_DOEPINT7_SETUP_S)
#define USB_OTGHS_DOEPINT7_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT7_SETUP_S  3
/** USB_OTGHS_DOEPINT7_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT7_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT7_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT7_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT7_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT7_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT7_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT7_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT7_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT7_STSPHSERCVD_M  (USB_OTGHS_DOEPINT7_STSPHSERCVD_V << USB_OTGHS_DOEPINT7_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT7_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT7_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT7_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT7_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT7_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT7_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT7_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT7_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT7_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT7_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT7_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT7_OUTPKTERR_M  (USB_OTGHS_DOEPINT7_OUTPKTERR_V << USB_OTGHS_DOEPINT7_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT7_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT7_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT7_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT7_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT7_BNAINTR_M  (USB_OTGHS_DOEPINT7_BNAINTR_V << USB_OTGHS_DOEPINT7_BNAINTR_S)
#define USB_OTGHS_DOEPINT7_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT7_BNAINTR_S  9
/** USB_OTGHS_DOEPINT7_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT7_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT7_PKTDRPSTS_M  (USB_OTGHS_DOEPINT7_PKTDRPSTS_V << USB_OTGHS_DOEPINT7_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT7_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT7_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT7_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT7_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT7_BBLEERR_M  (USB_OTGHS_DOEPINT7_BBLEERR_V << USB_OTGHS_DOEPINT7_BBLEERR_S)
#define USB_OTGHS_DOEPINT7_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT7_BBLEERR_S  12
/** USB_OTGHS_DOEPINT7_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT7_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT7_NAKINTRPT_M  (USB_OTGHS_DOEPINT7_NAKINTRPT_V << USB_OTGHS_DOEPINT7_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT7_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT7_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT7_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT7_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT7_NYETINTRPT_M  (USB_OTGHS_DOEPINT7_NYETINTRPT_V << USB_OTGHS_DOEPINT7_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT7_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT7_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT7_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT7_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT7_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT7_STUPPKTRCVD_V << USB_OTGHS_DOEPINT7_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT7_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT7_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ7_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 7 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ7_REG (DR_REG_USB_OTGHS_BASE + 0xbf0)
/** USB_OTGHS_DOEPTSIZ7_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ7_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ7_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ7_XFERSIZE_V << USB_OTGHS_DOEPTSIZ7_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ7_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ7_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ7_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ7_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ7_PKTCNT_M  (USB_OTGHS_DOEPTSIZ7_PKTCNT_V << USB_OTGHS_DOEPTSIZ7_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ7_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ7_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ7_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ7_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ7_RXDPID_M  (USB_OTGHS_DOEPTSIZ7_RXDPID_V << USB_OTGHS_DOEPTSIZ7_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ7_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ7_RXDPID_S  29

/** USB_OTGHS_DOEPDMA7_REG register
 *  This register contains the DMA Address for the OUT Endpoint 7 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA7_REG (DR_REG_USB_OTGHS_BASE + 0xbf4)
/** USB_OTGHS_DOEPDMA7_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA7_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA7_DMAADDR_M  (USB_OTGHS_DOEPDMA7_DMAADDR_V << USB_OTGHS_DOEPDMA7_DMAADDR_S)
#define USB_OTGHS_DOEPDMA7_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA7_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB7_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 7 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB7_REG (DR_REG_USB_OTGHS_BASE + 0xbfc)
/** USB_OTGHS_DOEPDMAB7_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB7_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB7_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB7_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB7_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB7_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB7_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL8_REG register
 *  This register is used to control the characteristics of OUT Endpoint 8 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL8_REG (DR_REG_USB_OTGHS_BASE + 0xc00)
/** USB_OTGHS_DOEPCTL8_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL8_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL8_MPS_M  (USB_OTGHS_DOEPCTL8_MPS_V << USB_OTGHS_DOEPCTL8_MPS_S)
#define USB_OTGHS_DOEPCTL8_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL8_MPS_S  0
/** USB_OTGHS_DOEPCTL8_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL8_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL8_USBACTEP_M  (USB_OTGHS_DOEPCTL8_USBACTEP_V << USB_OTGHS_DOEPCTL8_USBACTEP_S)
#define USB_OTGHS_DOEPCTL8_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL8_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL8_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL8_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL8_DPID_M  (USB_OTGHS_DOEPCTL8_DPID_V << USB_OTGHS_DOEPCTL8_DPID_S)
#define USB_OTGHS_DOEPCTL8_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL8_DPID_S  16
/** USB_OTGHS_DOEPCTL8_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL8_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL8_NAKSTS_M  (USB_OTGHS_DOEPCTL8_NAKSTS_V << USB_OTGHS_DOEPCTL8_NAKSTS_S)
#define USB_OTGHS_DOEPCTL8_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL8_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL8_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL8_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL8_EPTYPE_M  (USB_OTGHS_DOEPCTL8_EPTYPE_V << USB_OTGHS_DOEPCTL8_EPTYPE_S)
#define USB_OTGHS_DOEPCTL8_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL8_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL8_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL8_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL8_SNP_M  (USB_OTGHS_DOEPCTL8_SNP_V << USB_OTGHS_DOEPCTL8_SNP_S)
#define USB_OTGHS_DOEPCTL8_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL8_SNP_S  20
/** USB_OTGHS_DOEPCTL8_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL8_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL8_STALL_M  (USB_OTGHS_DOEPCTL8_STALL_V << USB_OTGHS_DOEPCTL8_STALL_S)
#define USB_OTGHS_DOEPCTL8_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL8_STALL_S  21
/** USB_OTGHS_DOEPCTL8_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL8_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL8_CNAK_M  (USB_OTGHS_DOEPCTL8_CNAK_V << USB_OTGHS_DOEPCTL8_CNAK_S)
#define USB_OTGHS_DOEPCTL8_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL8_CNAK_S  26
/** USB_OTGHS_DOEPCTL8_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL8_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL8_SNAK_M  (USB_OTGHS_DOEPCTL8_SNAK_V << USB_OTGHS_DOEPCTL8_SNAK_S)
#define USB_OTGHS_DOEPCTL8_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL8_SNAK_S  27
/** USB_OTGHS_DOEPCTL8_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL8_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL8_SETD0PID_M  (USB_OTGHS_DOEPCTL8_SETD0PID_V << USB_OTGHS_DOEPCTL8_SETD0PID_S)
#define USB_OTGHS_DOEPCTL8_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL8_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL8_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL8_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL8_SETD1PID_M  (USB_OTGHS_DOEPCTL8_SETD1PID_V << USB_OTGHS_DOEPCTL8_SETD1PID_S)
#define USB_OTGHS_DOEPCTL8_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL8_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL8_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL8_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL8_EPDIS_M  (USB_OTGHS_DOEPCTL8_EPDIS_V << USB_OTGHS_DOEPCTL8_EPDIS_S)
#define USB_OTGHS_DOEPCTL8_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL8_EPDIS_S  30
/** USB_OTGHS_DOEPCTL8_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL8_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL8_EPENA_M  (USB_OTGHS_DOEPCTL8_EPENA_V << USB_OTGHS_DOEPCTL8_EPENA_S)
#define USB_OTGHS_DOEPCTL8_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL8_EPENA_S  31

/** USB_OTGHS_DOEPINT8_REG register
 *  This register contains the interrupts for the OUT Endpoint 8 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT8_REG (DR_REG_USB_OTGHS_BASE + 0xc08)
/** USB_OTGHS_DOEPINT8_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT8_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT8_XFERCOMPL_M  (USB_OTGHS_DOEPINT8_XFERCOMPL_V << USB_OTGHS_DOEPINT8_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT8_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT8_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT8_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT8_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT8_EPDISBLD_M  (USB_OTGHS_DOEPINT8_EPDISBLD_V << USB_OTGHS_DOEPINT8_EPDISBLD_S)
#define USB_OTGHS_DOEPINT8_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT8_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT8_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT8_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT8_AHBERR_M  (USB_OTGHS_DOEPINT8_AHBERR_V << USB_OTGHS_DOEPINT8_AHBERR_S)
#define USB_OTGHS_DOEPINT8_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT8_AHBERR_S  2
/** USB_OTGHS_DOEPINT8_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT8_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT8_SETUP_M  (USB_OTGHS_DOEPINT8_SETUP_V << USB_OTGHS_DOEPINT8_SETUP_S)
#define USB_OTGHS_DOEPINT8_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT8_SETUP_S  3
/** USB_OTGHS_DOEPINT8_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT8_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT8_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT8_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT8_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT8_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT8_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT8_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT8_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT8_STSPHSERCVD_M  (USB_OTGHS_DOEPINT8_STSPHSERCVD_V << USB_OTGHS_DOEPINT8_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT8_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT8_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT8_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT8_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT8_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT8_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT8_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT8_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT8_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT8_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT8_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT8_OUTPKTERR_M  (USB_OTGHS_DOEPINT8_OUTPKTERR_V << USB_OTGHS_DOEPINT8_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT8_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT8_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT8_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT8_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT8_BNAINTR_M  (USB_OTGHS_DOEPINT8_BNAINTR_V << USB_OTGHS_DOEPINT8_BNAINTR_S)
#define USB_OTGHS_DOEPINT8_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT8_BNAINTR_S  9
/** USB_OTGHS_DOEPINT8_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT8_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT8_PKTDRPSTS_M  (USB_OTGHS_DOEPINT8_PKTDRPSTS_V << USB_OTGHS_DOEPINT8_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT8_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT8_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT8_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT8_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT8_BBLEERR_M  (USB_OTGHS_DOEPINT8_BBLEERR_V << USB_OTGHS_DOEPINT8_BBLEERR_S)
#define USB_OTGHS_DOEPINT8_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT8_BBLEERR_S  12
/** USB_OTGHS_DOEPINT8_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT8_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT8_NAKINTRPT_M  (USB_OTGHS_DOEPINT8_NAKINTRPT_V << USB_OTGHS_DOEPINT8_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT8_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT8_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT8_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT8_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT8_NYETINTRPT_M  (USB_OTGHS_DOEPINT8_NYETINTRPT_V << USB_OTGHS_DOEPINT8_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT8_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT8_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT8_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT8_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT8_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT8_STUPPKTRCVD_V << USB_OTGHS_DOEPINT8_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT8_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT8_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ8_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 8 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ8_REG (DR_REG_USB_OTGHS_BASE + 0xc10)
/** USB_OTGHS_DOEPTSIZ8_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ8_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ8_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ8_XFERSIZE_V << USB_OTGHS_DOEPTSIZ8_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ8_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ8_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ8_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ8_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ8_PKTCNT_M  (USB_OTGHS_DOEPTSIZ8_PKTCNT_V << USB_OTGHS_DOEPTSIZ8_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ8_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ8_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ8_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ8_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ8_RXDPID_M  (USB_OTGHS_DOEPTSIZ8_RXDPID_V << USB_OTGHS_DOEPTSIZ8_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ8_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ8_RXDPID_S  29

/** USB_OTGHS_DOEPDMA8_REG register
 *  This register contains the DMA Address for the OUT Endpoint 8 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA8_REG (DR_REG_USB_OTGHS_BASE + 0xc14)
/** USB_OTGHS_DOEPDMA8_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA8_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA8_DMAADDR_M  (USB_OTGHS_DOEPDMA8_DMAADDR_V << USB_OTGHS_DOEPDMA8_DMAADDR_S)
#define USB_OTGHS_DOEPDMA8_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA8_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB8_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 8 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB8_REG (DR_REG_USB_OTGHS_BASE + 0xc1c)
/** USB_OTGHS_DOEPDMAB8_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB8_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB8_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB8_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB8_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB8_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB8_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL9_REG register
 *  This register is used to control the characteristics of OUT Endpoint 9 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL9_REG (DR_REG_USB_OTGHS_BASE + 0xc20)
/** USB_OTGHS_DOEPCTL9_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL9_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL9_MPS_M  (USB_OTGHS_DOEPCTL9_MPS_V << USB_OTGHS_DOEPCTL9_MPS_S)
#define USB_OTGHS_DOEPCTL9_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL9_MPS_S  0
/** USB_OTGHS_DOEPCTL9_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL9_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL9_USBACTEP_M  (USB_OTGHS_DOEPCTL9_USBACTEP_V << USB_OTGHS_DOEPCTL9_USBACTEP_S)
#define USB_OTGHS_DOEPCTL9_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL9_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL9_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL9_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL9_DPID_M  (USB_OTGHS_DOEPCTL9_DPID_V << USB_OTGHS_DOEPCTL9_DPID_S)
#define USB_OTGHS_DOEPCTL9_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL9_DPID_S  16
/** USB_OTGHS_DOEPCTL9_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL9_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL9_NAKSTS_M  (USB_OTGHS_DOEPCTL9_NAKSTS_V << USB_OTGHS_DOEPCTL9_NAKSTS_S)
#define USB_OTGHS_DOEPCTL9_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL9_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL9_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL9_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL9_EPTYPE_M  (USB_OTGHS_DOEPCTL9_EPTYPE_V << USB_OTGHS_DOEPCTL9_EPTYPE_S)
#define USB_OTGHS_DOEPCTL9_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL9_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL9_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL9_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL9_SNP_M  (USB_OTGHS_DOEPCTL9_SNP_V << USB_OTGHS_DOEPCTL9_SNP_S)
#define USB_OTGHS_DOEPCTL9_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL9_SNP_S  20
/** USB_OTGHS_DOEPCTL9_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL9_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL9_STALL_M  (USB_OTGHS_DOEPCTL9_STALL_V << USB_OTGHS_DOEPCTL9_STALL_S)
#define USB_OTGHS_DOEPCTL9_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL9_STALL_S  21
/** USB_OTGHS_DOEPCTL9_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL9_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL9_CNAK_M  (USB_OTGHS_DOEPCTL9_CNAK_V << USB_OTGHS_DOEPCTL9_CNAK_S)
#define USB_OTGHS_DOEPCTL9_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL9_CNAK_S  26
/** USB_OTGHS_DOEPCTL9_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL9_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL9_SNAK_M  (USB_OTGHS_DOEPCTL9_SNAK_V << USB_OTGHS_DOEPCTL9_SNAK_S)
#define USB_OTGHS_DOEPCTL9_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL9_SNAK_S  27
/** USB_OTGHS_DOEPCTL9_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL9_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL9_SETD0PID_M  (USB_OTGHS_DOEPCTL9_SETD0PID_V << USB_OTGHS_DOEPCTL9_SETD0PID_S)
#define USB_OTGHS_DOEPCTL9_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL9_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL9_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL9_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL9_SETD1PID_M  (USB_OTGHS_DOEPCTL9_SETD1PID_V << USB_OTGHS_DOEPCTL9_SETD1PID_S)
#define USB_OTGHS_DOEPCTL9_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL9_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL9_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL9_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL9_EPDIS_M  (USB_OTGHS_DOEPCTL9_EPDIS_V << USB_OTGHS_DOEPCTL9_EPDIS_S)
#define USB_OTGHS_DOEPCTL9_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL9_EPDIS_S  30
/** USB_OTGHS_DOEPCTL9_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL9_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL9_EPENA_M  (USB_OTGHS_DOEPCTL9_EPENA_V << USB_OTGHS_DOEPCTL9_EPENA_S)
#define USB_OTGHS_DOEPCTL9_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL9_EPENA_S  31

/** USB_OTGHS_DOEPINT9_REG register
 *  This register contains the interrupts for the OUT Endpoint 9 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT9_REG (DR_REG_USB_OTGHS_BASE + 0xc28)
/** USB_OTGHS_DOEPINT9_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT9_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT9_XFERCOMPL_M  (USB_OTGHS_DOEPINT9_XFERCOMPL_V << USB_OTGHS_DOEPINT9_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT9_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT9_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT9_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT9_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT9_EPDISBLD_M  (USB_OTGHS_DOEPINT9_EPDISBLD_V << USB_OTGHS_DOEPINT9_EPDISBLD_S)
#define USB_OTGHS_DOEPINT9_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT9_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT9_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT9_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT9_AHBERR_M  (USB_OTGHS_DOEPINT9_AHBERR_V << USB_OTGHS_DOEPINT9_AHBERR_S)
#define USB_OTGHS_DOEPINT9_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT9_AHBERR_S  2
/** USB_OTGHS_DOEPINT9_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT9_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT9_SETUP_M  (USB_OTGHS_DOEPINT9_SETUP_V << USB_OTGHS_DOEPINT9_SETUP_S)
#define USB_OTGHS_DOEPINT9_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT9_SETUP_S  3
/** USB_OTGHS_DOEPINT9_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT9_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT9_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT9_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT9_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT9_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT9_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT9_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT9_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT9_STSPHSERCVD_M  (USB_OTGHS_DOEPINT9_STSPHSERCVD_V << USB_OTGHS_DOEPINT9_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT9_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT9_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT9_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT9_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT9_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT9_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT9_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT9_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT9_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT9_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT9_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT9_OUTPKTERR_M  (USB_OTGHS_DOEPINT9_OUTPKTERR_V << USB_OTGHS_DOEPINT9_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT9_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT9_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT9_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT9_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT9_BNAINTR_M  (USB_OTGHS_DOEPINT9_BNAINTR_V << USB_OTGHS_DOEPINT9_BNAINTR_S)
#define USB_OTGHS_DOEPINT9_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT9_BNAINTR_S  9
/** USB_OTGHS_DOEPINT9_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT9_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT9_PKTDRPSTS_M  (USB_OTGHS_DOEPINT9_PKTDRPSTS_V << USB_OTGHS_DOEPINT9_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT9_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT9_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT9_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT9_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT9_BBLEERR_M  (USB_OTGHS_DOEPINT9_BBLEERR_V << USB_OTGHS_DOEPINT9_BBLEERR_S)
#define USB_OTGHS_DOEPINT9_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT9_BBLEERR_S  12
/** USB_OTGHS_DOEPINT9_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT9_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT9_NAKINTRPT_M  (USB_OTGHS_DOEPINT9_NAKINTRPT_V << USB_OTGHS_DOEPINT9_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT9_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT9_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT9_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT9_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT9_NYETINTRPT_M  (USB_OTGHS_DOEPINT9_NYETINTRPT_V << USB_OTGHS_DOEPINT9_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT9_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT9_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT9_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT9_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT9_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT9_STUPPKTRCVD_V << USB_OTGHS_DOEPINT9_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT9_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT9_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ9_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 9 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ9_REG (DR_REG_USB_OTGHS_BASE + 0xc30)
/** USB_OTGHS_DOEPTSIZ9_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ9_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ9_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ9_XFERSIZE_V << USB_OTGHS_DOEPTSIZ9_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ9_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ9_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ9_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ9_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ9_PKTCNT_M  (USB_OTGHS_DOEPTSIZ9_PKTCNT_V << USB_OTGHS_DOEPTSIZ9_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ9_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ9_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ9_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ9_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ9_RXDPID_M  (USB_OTGHS_DOEPTSIZ9_RXDPID_V << USB_OTGHS_DOEPTSIZ9_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ9_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ9_RXDPID_S  29

/** USB_OTGHS_DOEPDMA9_REG register
 *  This register contains the DMA Address for the OUT Endpoint 9 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA9_REG (DR_REG_USB_OTGHS_BASE + 0xc34)
/** USB_OTGHS_DOEPDMA9_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA9_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA9_DMAADDR_M  (USB_OTGHS_DOEPDMA9_DMAADDR_V << USB_OTGHS_DOEPDMA9_DMAADDR_S)
#define USB_OTGHS_DOEPDMA9_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA9_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB9_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 9 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB9_REG (DR_REG_USB_OTGHS_BASE + 0xc3c)
/** USB_OTGHS_DOEPDMAB9_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB9_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB9_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB9_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB9_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB9_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB9_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL10_REG register
 *  This register is used to control the characteristics of OUT Endpoint 10 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL10_REG (DR_REG_USB_OTGHS_BASE + 0xc40)
/** USB_OTGHS_DOEPCTL10_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL10_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL10_MPS_M  (USB_OTGHS_DOEPCTL10_MPS_V << USB_OTGHS_DOEPCTL10_MPS_S)
#define USB_OTGHS_DOEPCTL10_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL10_MPS_S  0
/** USB_OTGHS_DOEPCTL10_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL10_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL10_USBACTEP_M  (USB_OTGHS_DOEPCTL10_USBACTEP_V << USB_OTGHS_DOEPCTL10_USBACTEP_S)
#define USB_OTGHS_DOEPCTL10_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL10_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL10_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL10_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL10_DPID_M  (USB_OTGHS_DOEPCTL10_DPID_V << USB_OTGHS_DOEPCTL10_DPID_S)
#define USB_OTGHS_DOEPCTL10_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL10_DPID_S  16
/** USB_OTGHS_DOEPCTL10_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL10_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL10_NAKSTS_M  (USB_OTGHS_DOEPCTL10_NAKSTS_V << USB_OTGHS_DOEPCTL10_NAKSTS_S)
#define USB_OTGHS_DOEPCTL10_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL10_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL10_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL10_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL10_EPTYPE_M  (USB_OTGHS_DOEPCTL10_EPTYPE_V << USB_OTGHS_DOEPCTL10_EPTYPE_S)
#define USB_OTGHS_DOEPCTL10_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL10_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL10_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL10_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL10_SNP_M  (USB_OTGHS_DOEPCTL10_SNP_V << USB_OTGHS_DOEPCTL10_SNP_S)
#define USB_OTGHS_DOEPCTL10_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL10_SNP_S  20
/** USB_OTGHS_DOEPCTL10_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL10_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL10_STALL_M  (USB_OTGHS_DOEPCTL10_STALL_V << USB_OTGHS_DOEPCTL10_STALL_S)
#define USB_OTGHS_DOEPCTL10_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL10_STALL_S  21
/** USB_OTGHS_DOEPCTL10_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL10_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL10_CNAK_M  (USB_OTGHS_DOEPCTL10_CNAK_V << USB_OTGHS_DOEPCTL10_CNAK_S)
#define USB_OTGHS_DOEPCTL10_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL10_CNAK_S  26
/** USB_OTGHS_DOEPCTL10_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL10_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL10_SNAK_M  (USB_OTGHS_DOEPCTL10_SNAK_V << USB_OTGHS_DOEPCTL10_SNAK_S)
#define USB_OTGHS_DOEPCTL10_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL10_SNAK_S  27
/** USB_OTGHS_DOEPCTL10_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL10_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL10_SETD0PID_M  (USB_OTGHS_DOEPCTL10_SETD0PID_V << USB_OTGHS_DOEPCTL10_SETD0PID_S)
#define USB_OTGHS_DOEPCTL10_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL10_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL10_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL10_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL10_SETD1PID_M  (USB_OTGHS_DOEPCTL10_SETD1PID_V << USB_OTGHS_DOEPCTL10_SETD1PID_S)
#define USB_OTGHS_DOEPCTL10_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL10_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL10_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL10_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL10_EPDIS_M  (USB_OTGHS_DOEPCTL10_EPDIS_V << USB_OTGHS_DOEPCTL10_EPDIS_S)
#define USB_OTGHS_DOEPCTL10_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL10_EPDIS_S  30
/** USB_OTGHS_DOEPCTL10_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL10_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL10_EPENA_M  (USB_OTGHS_DOEPCTL10_EPENA_V << USB_OTGHS_DOEPCTL10_EPENA_S)
#define USB_OTGHS_DOEPCTL10_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL10_EPENA_S  31

/** USB_OTGHS_DOEPINT10_REG register
 *  This register contains the interrupts for the OUT Endpoint 10 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT10_REG (DR_REG_USB_OTGHS_BASE + 0xc48)
/** USB_OTGHS_DOEPINT10_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT10_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT10_XFERCOMPL_M  (USB_OTGHS_DOEPINT10_XFERCOMPL_V << USB_OTGHS_DOEPINT10_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT10_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT10_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT10_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT10_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT10_EPDISBLD_M  (USB_OTGHS_DOEPINT10_EPDISBLD_V << USB_OTGHS_DOEPINT10_EPDISBLD_S)
#define USB_OTGHS_DOEPINT10_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT10_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT10_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT10_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT10_AHBERR_M  (USB_OTGHS_DOEPINT10_AHBERR_V << USB_OTGHS_DOEPINT10_AHBERR_S)
#define USB_OTGHS_DOEPINT10_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT10_AHBERR_S  2
/** USB_OTGHS_DOEPINT10_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT10_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT10_SETUP_M  (USB_OTGHS_DOEPINT10_SETUP_V << USB_OTGHS_DOEPINT10_SETUP_S)
#define USB_OTGHS_DOEPINT10_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT10_SETUP_S  3
/** USB_OTGHS_DOEPINT10_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT10_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT10_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT10_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT10_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT10_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT10_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT10_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT10_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT10_STSPHSERCVD_M  (USB_OTGHS_DOEPINT10_STSPHSERCVD_V << USB_OTGHS_DOEPINT10_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT10_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT10_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT10_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT10_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT10_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT10_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT10_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT10_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT10_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT10_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT10_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT10_OUTPKTERR_M  (USB_OTGHS_DOEPINT10_OUTPKTERR_V << USB_OTGHS_DOEPINT10_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT10_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT10_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT10_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT10_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT10_BNAINTR_M  (USB_OTGHS_DOEPINT10_BNAINTR_V << USB_OTGHS_DOEPINT10_BNAINTR_S)
#define USB_OTGHS_DOEPINT10_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT10_BNAINTR_S  9
/** USB_OTGHS_DOEPINT10_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT10_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT10_PKTDRPSTS_M  (USB_OTGHS_DOEPINT10_PKTDRPSTS_V << USB_OTGHS_DOEPINT10_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT10_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT10_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT10_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT10_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT10_BBLEERR_M  (USB_OTGHS_DOEPINT10_BBLEERR_V << USB_OTGHS_DOEPINT10_BBLEERR_S)
#define USB_OTGHS_DOEPINT10_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT10_BBLEERR_S  12
/** USB_OTGHS_DOEPINT10_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT10_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT10_NAKINTRPT_M  (USB_OTGHS_DOEPINT10_NAKINTRPT_V << USB_OTGHS_DOEPINT10_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT10_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT10_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT10_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT10_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT10_NYETINTRPT_M  (USB_OTGHS_DOEPINT10_NYETINTRPT_V << USB_OTGHS_DOEPINT10_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT10_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT10_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT10_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT10_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT10_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT10_STUPPKTRCVD_V << USB_OTGHS_DOEPINT10_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT10_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT10_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ10_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 10 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ10_REG (DR_REG_USB_OTGHS_BASE + 0xc50)
/** USB_OTGHS_DOEPTSIZ10_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ10_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ10_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ10_XFERSIZE_V << USB_OTGHS_DOEPTSIZ10_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ10_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ10_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ10_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ10_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ10_PKTCNT_M  (USB_OTGHS_DOEPTSIZ10_PKTCNT_V << USB_OTGHS_DOEPTSIZ10_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ10_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ10_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ10_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ10_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ10_RXDPID_M  (USB_OTGHS_DOEPTSIZ10_RXDPID_V << USB_OTGHS_DOEPTSIZ10_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ10_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ10_RXDPID_S  29

/** USB_OTGHS_DOEPDMA10_REG register
 *  This register contains the DMA Address for the OUT Endpoint 10 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA10_REG (DR_REG_USB_OTGHS_BASE + 0xc54)
/** USB_OTGHS_DOEPDMA10_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA10_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA10_DMAADDR_M  (USB_OTGHS_DOEPDMA10_DMAADDR_V << USB_OTGHS_DOEPDMA10_DMAADDR_S)
#define USB_OTGHS_DOEPDMA10_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA10_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB10_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 10 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB10_REG (DR_REG_USB_OTGHS_BASE + 0xc5c)
/** USB_OTGHS_DOEPDMAB10_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB10_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB10_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB10_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB10_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB10_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB10_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL11_REG register
 *  This register is used to control the characteristics of OUT Endpoint 11 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL11_REG (DR_REG_USB_OTGHS_BASE + 0xc60)
/** USB_OTGHS_DOEPCTL11_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL11_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL11_MPS_M  (USB_OTGHS_DOEPCTL11_MPS_V << USB_OTGHS_DOEPCTL11_MPS_S)
#define USB_OTGHS_DOEPCTL11_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL11_MPS_S  0
/** USB_OTGHS_DOEPCTL11_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL11_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL11_USBACTEP_M  (USB_OTGHS_DOEPCTL11_USBACTEP_V << USB_OTGHS_DOEPCTL11_USBACTEP_S)
#define USB_OTGHS_DOEPCTL11_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL11_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL11_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL11_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL11_DPID_M  (USB_OTGHS_DOEPCTL11_DPID_V << USB_OTGHS_DOEPCTL11_DPID_S)
#define USB_OTGHS_DOEPCTL11_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL11_DPID_S  16
/** USB_OTGHS_DOEPCTL11_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL11_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL11_NAKSTS_M  (USB_OTGHS_DOEPCTL11_NAKSTS_V << USB_OTGHS_DOEPCTL11_NAKSTS_S)
#define USB_OTGHS_DOEPCTL11_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL11_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL11_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL11_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL11_EPTYPE_M  (USB_OTGHS_DOEPCTL11_EPTYPE_V << USB_OTGHS_DOEPCTL11_EPTYPE_S)
#define USB_OTGHS_DOEPCTL11_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL11_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL11_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL11_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL11_SNP_M  (USB_OTGHS_DOEPCTL11_SNP_V << USB_OTGHS_DOEPCTL11_SNP_S)
#define USB_OTGHS_DOEPCTL11_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL11_SNP_S  20
/** USB_OTGHS_DOEPCTL11_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL11_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL11_STALL_M  (USB_OTGHS_DOEPCTL11_STALL_V << USB_OTGHS_DOEPCTL11_STALL_S)
#define USB_OTGHS_DOEPCTL11_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL11_STALL_S  21
/** USB_OTGHS_DOEPCTL11_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL11_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL11_CNAK_M  (USB_OTGHS_DOEPCTL11_CNAK_V << USB_OTGHS_DOEPCTL11_CNAK_S)
#define USB_OTGHS_DOEPCTL11_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL11_CNAK_S  26
/** USB_OTGHS_DOEPCTL11_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL11_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL11_SNAK_M  (USB_OTGHS_DOEPCTL11_SNAK_V << USB_OTGHS_DOEPCTL11_SNAK_S)
#define USB_OTGHS_DOEPCTL11_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL11_SNAK_S  27
/** USB_OTGHS_DOEPCTL11_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL11_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL11_SETD0PID_M  (USB_OTGHS_DOEPCTL11_SETD0PID_V << USB_OTGHS_DOEPCTL11_SETD0PID_S)
#define USB_OTGHS_DOEPCTL11_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL11_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL11_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL11_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL11_SETD1PID_M  (USB_OTGHS_DOEPCTL11_SETD1PID_V << USB_OTGHS_DOEPCTL11_SETD1PID_S)
#define USB_OTGHS_DOEPCTL11_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL11_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL11_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL11_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL11_EPDIS_M  (USB_OTGHS_DOEPCTL11_EPDIS_V << USB_OTGHS_DOEPCTL11_EPDIS_S)
#define USB_OTGHS_DOEPCTL11_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL11_EPDIS_S  30
/** USB_OTGHS_DOEPCTL11_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL11_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL11_EPENA_M  (USB_OTGHS_DOEPCTL11_EPENA_V << USB_OTGHS_DOEPCTL11_EPENA_S)
#define USB_OTGHS_DOEPCTL11_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL11_EPENA_S  31

/** USB_OTGHS_DOEPINT11_REG register
 *  This register contains the interrupts for the OUT Endpoint 11 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT11_REG (DR_REG_USB_OTGHS_BASE + 0xc68)
/** USB_OTGHS_DOEPINT11_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT11_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT11_XFERCOMPL_M  (USB_OTGHS_DOEPINT11_XFERCOMPL_V << USB_OTGHS_DOEPINT11_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT11_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT11_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT11_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT11_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT11_EPDISBLD_M  (USB_OTGHS_DOEPINT11_EPDISBLD_V << USB_OTGHS_DOEPINT11_EPDISBLD_S)
#define USB_OTGHS_DOEPINT11_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT11_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT11_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT11_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT11_AHBERR_M  (USB_OTGHS_DOEPINT11_AHBERR_V << USB_OTGHS_DOEPINT11_AHBERR_S)
#define USB_OTGHS_DOEPINT11_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT11_AHBERR_S  2
/** USB_OTGHS_DOEPINT11_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT11_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT11_SETUP_M  (USB_OTGHS_DOEPINT11_SETUP_V << USB_OTGHS_DOEPINT11_SETUP_S)
#define USB_OTGHS_DOEPINT11_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT11_SETUP_S  3
/** USB_OTGHS_DOEPINT11_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT11_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT11_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT11_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT11_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT11_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT11_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT11_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT11_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT11_STSPHSERCVD_M  (USB_OTGHS_DOEPINT11_STSPHSERCVD_V << USB_OTGHS_DOEPINT11_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT11_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT11_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT11_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT11_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT11_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT11_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT11_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT11_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT11_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT11_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT11_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT11_OUTPKTERR_M  (USB_OTGHS_DOEPINT11_OUTPKTERR_V << USB_OTGHS_DOEPINT11_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT11_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT11_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT11_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT11_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT11_BNAINTR_M  (USB_OTGHS_DOEPINT11_BNAINTR_V << USB_OTGHS_DOEPINT11_BNAINTR_S)
#define USB_OTGHS_DOEPINT11_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT11_BNAINTR_S  9
/** USB_OTGHS_DOEPINT11_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT11_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT11_PKTDRPSTS_M  (USB_OTGHS_DOEPINT11_PKTDRPSTS_V << USB_OTGHS_DOEPINT11_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT11_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT11_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT11_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT11_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT11_BBLEERR_M  (USB_OTGHS_DOEPINT11_BBLEERR_V << USB_OTGHS_DOEPINT11_BBLEERR_S)
#define USB_OTGHS_DOEPINT11_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT11_BBLEERR_S  12
/** USB_OTGHS_DOEPINT11_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT11_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT11_NAKINTRPT_M  (USB_OTGHS_DOEPINT11_NAKINTRPT_V << USB_OTGHS_DOEPINT11_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT11_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT11_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT11_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT11_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT11_NYETINTRPT_M  (USB_OTGHS_DOEPINT11_NYETINTRPT_V << USB_OTGHS_DOEPINT11_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT11_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT11_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT11_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT11_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT11_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT11_STUPPKTRCVD_V << USB_OTGHS_DOEPINT11_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT11_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT11_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ11_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 11 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ11_REG (DR_REG_USB_OTGHS_BASE + 0xc70)
/** USB_OTGHS_DOEPTSIZ11_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ11_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ11_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ11_XFERSIZE_V << USB_OTGHS_DOEPTSIZ11_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ11_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ11_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ11_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ11_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ11_PKTCNT_M  (USB_OTGHS_DOEPTSIZ11_PKTCNT_V << USB_OTGHS_DOEPTSIZ11_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ11_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ11_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ11_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ11_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ11_RXDPID_M  (USB_OTGHS_DOEPTSIZ11_RXDPID_V << USB_OTGHS_DOEPTSIZ11_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ11_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ11_RXDPID_S  29

/** USB_OTGHS_DOEPDMA11_REG register
 *  This register contains the DMA Address for the OUT Endpoint 11 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA11_REG (DR_REG_USB_OTGHS_BASE + 0xc74)
/** USB_OTGHS_DOEPDMA11_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA11_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA11_DMAADDR_M  (USB_OTGHS_DOEPDMA11_DMAADDR_V << USB_OTGHS_DOEPDMA11_DMAADDR_S)
#define USB_OTGHS_DOEPDMA11_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA11_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB11_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 11 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB11_REG (DR_REG_USB_OTGHS_BASE + 0xc7c)
/** USB_OTGHS_DOEPDMAB11_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB11_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB11_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB11_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB11_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB11_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB11_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL12_REG register
 *  This register is used to control the characteristics of OUT Endpoint 12 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL12_REG (DR_REG_USB_OTGHS_BASE + 0xc80)
/** USB_OTGHS_DOEPCTL12_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL12_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL12_MPS_M  (USB_OTGHS_DOEPCTL12_MPS_V << USB_OTGHS_DOEPCTL12_MPS_S)
#define USB_OTGHS_DOEPCTL12_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL12_MPS_S  0
/** USB_OTGHS_DOEPCTL12_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL12_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL12_USBACTEP_M  (USB_OTGHS_DOEPCTL12_USBACTEP_V << USB_OTGHS_DOEPCTL12_USBACTEP_S)
#define USB_OTGHS_DOEPCTL12_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL12_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL12_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL12_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL12_DPID_M  (USB_OTGHS_DOEPCTL12_DPID_V << USB_OTGHS_DOEPCTL12_DPID_S)
#define USB_OTGHS_DOEPCTL12_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL12_DPID_S  16
/** USB_OTGHS_DOEPCTL12_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL12_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL12_NAKSTS_M  (USB_OTGHS_DOEPCTL12_NAKSTS_V << USB_OTGHS_DOEPCTL12_NAKSTS_S)
#define USB_OTGHS_DOEPCTL12_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL12_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL12_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL12_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL12_EPTYPE_M  (USB_OTGHS_DOEPCTL12_EPTYPE_V << USB_OTGHS_DOEPCTL12_EPTYPE_S)
#define USB_OTGHS_DOEPCTL12_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL12_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL12_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL12_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL12_SNP_M  (USB_OTGHS_DOEPCTL12_SNP_V << USB_OTGHS_DOEPCTL12_SNP_S)
#define USB_OTGHS_DOEPCTL12_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL12_SNP_S  20
/** USB_OTGHS_DOEPCTL12_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL12_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL12_STALL_M  (USB_OTGHS_DOEPCTL12_STALL_V << USB_OTGHS_DOEPCTL12_STALL_S)
#define USB_OTGHS_DOEPCTL12_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL12_STALL_S  21
/** USB_OTGHS_DOEPCTL12_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL12_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL12_CNAK_M  (USB_OTGHS_DOEPCTL12_CNAK_V << USB_OTGHS_DOEPCTL12_CNAK_S)
#define USB_OTGHS_DOEPCTL12_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL12_CNAK_S  26
/** USB_OTGHS_DOEPCTL12_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL12_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL12_SNAK_M  (USB_OTGHS_DOEPCTL12_SNAK_V << USB_OTGHS_DOEPCTL12_SNAK_S)
#define USB_OTGHS_DOEPCTL12_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL12_SNAK_S  27
/** USB_OTGHS_DOEPCTL12_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL12_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL12_SETD0PID_M  (USB_OTGHS_DOEPCTL12_SETD0PID_V << USB_OTGHS_DOEPCTL12_SETD0PID_S)
#define USB_OTGHS_DOEPCTL12_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL12_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL12_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL12_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL12_SETD1PID_M  (USB_OTGHS_DOEPCTL12_SETD1PID_V << USB_OTGHS_DOEPCTL12_SETD1PID_S)
#define USB_OTGHS_DOEPCTL12_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL12_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL12_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL12_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL12_EPDIS_M  (USB_OTGHS_DOEPCTL12_EPDIS_V << USB_OTGHS_DOEPCTL12_EPDIS_S)
#define USB_OTGHS_DOEPCTL12_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL12_EPDIS_S  30
/** USB_OTGHS_DOEPCTL12_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL12_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL12_EPENA_M  (USB_OTGHS_DOEPCTL12_EPENA_V << USB_OTGHS_DOEPCTL12_EPENA_S)
#define USB_OTGHS_DOEPCTL12_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL12_EPENA_S  31

/** USB_OTGHS_DOEPINT12_REG register
 *  This register contains the interrupts for the OUT Endpoint 12 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT12_REG (DR_REG_USB_OTGHS_BASE + 0xc88)
/** USB_OTGHS_DOEPINT12_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT12_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT12_XFERCOMPL_M  (USB_OTGHS_DOEPINT12_XFERCOMPL_V << USB_OTGHS_DOEPINT12_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT12_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT12_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT12_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT12_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT12_EPDISBLD_M  (USB_OTGHS_DOEPINT12_EPDISBLD_V << USB_OTGHS_DOEPINT12_EPDISBLD_S)
#define USB_OTGHS_DOEPINT12_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT12_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT12_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT12_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT12_AHBERR_M  (USB_OTGHS_DOEPINT12_AHBERR_V << USB_OTGHS_DOEPINT12_AHBERR_S)
#define USB_OTGHS_DOEPINT12_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT12_AHBERR_S  2
/** USB_OTGHS_DOEPINT12_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT12_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT12_SETUP_M  (USB_OTGHS_DOEPINT12_SETUP_V << USB_OTGHS_DOEPINT12_SETUP_S)
#define USB_OTGHS_DOEPINT12_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT12_SETUP_S  3
/** USB_OTGHS_DOEPINT12_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT12_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT12_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT12_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT12_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT12_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT12_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT12_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT12_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT12_STSPHSERCVD_M  (USB_OTGHS_DOEPINT12_STSPHSERCVD_V << USB_OTGHS_DOEPINT12_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT12_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT12_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT12_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT12_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT12_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT12_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT12_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT12_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT12_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT12_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT12_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT12_OUTPKTERR_M  (USB_OTGHS_DOEPINT12_OUTPKTERR_V << USB_OTGHS_DOEPINT12_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT12_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT12_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT12_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT12_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT12_BNAINTR_M  (USB_OTGHS_DOEPINT12_BNAINTR_V << USB_OTGHS_DOEPINT12_BNAINTR_S)
#define USB_OTGHS_DOEPINT12_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT12_BNAINTR_S  9
/** USB_OTGHS_DOEPINT12_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT12_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT12_PKTDRPSTS_M  (USB_OTGHS_DOEPINT12_PKTDRPSTS_V << USB_OTGHS_DOEPINT12_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT12_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT12_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT12_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT12_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT12_BBLEERR_M  (USB_OTGHS_DOEPINT12_BBLEERR_V << USB_OTGHS_DOEPINT12_BBLEERR_S)
#define USB_OTGHS_DOEPINT12_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT12_BBLEERR_S  12
/** USB_OTGHS_DOEPINT12_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT12_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT12_NAKINTRPT_M  (USB_OTGHS_DOEPINT12_NAKINTRPT_V << USB_OTGHS_DOEPINT12_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT12_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT12_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT12_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT12_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT12_NYETINTRPT_M  (USB_OTGHS_DOEPINT12_NYETINTRPT_V << USB_OTGHS_DOEPINT12_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT12_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT12_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT12_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT12_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT12_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT12_STUPPKTRCVD_V << USB_OTGHS_DOEPINT12_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT12_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT12_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ12_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 12 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ12_REG (DR_REG_USB_OTGHS_BASE + 0xc90)
/** USB_OTGHS_DOEPTSIZ12_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ12_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ12_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ12_XFERSIZE_V << USB_OTGHS_DOEPTSIZ12_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ12_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ12_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ12_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ12_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ12_PKTCNT_M  (USB_OTGHS_DOEPTSIZ12_PKTCNT_V << USB_OTGHS_DOEPTSIZ12_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ12_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ12_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ12_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ12_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ12_RXDPID_M  (USB_OTGHS_DOEPTSIZ12_RXDPID_V << USB_OTGHS_DOEPTSIZ12_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ12_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ12_RXDPID_S  29

/** USB_OTGHS_DOEPDMA12_REG register
 *  This register contains the DMA Address for the OUT Endpoint 12 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA12_REG (DR_REG_USB_OTGHS_BASE + 0xc94)
/** USB_OTGHS_DOEPDMA12_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA12_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA12_DMAADDR_M  (USB_OTGHS_DOEPDMA12_DMAADDR_V << USB_OTGHS_DOEPDMA12_DMAADDR_S)
#define USB_OTGHS_DOEPDMA12_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA12_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB12_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 12 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB12_REG (DR_REG_USB_OTGHS_BASE + 0xc9c)
/** USB_OTGHS_DOEPDMAB12_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB12_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB12_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB12_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB12_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB12_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB12_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL13_REG register
 *  This register is used to control the characteristics of OUT Endpoint 13 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL13_REG (DR_REG_USB_OTGHS_BASE + 0xca0)
/** USB_OTGHS_DOEPCTL13_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL13_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL13_MPS_M  (USB_OTGHS_DOEPCTL13_MPS_V << USB_OTGHS_DOEPCTL13_MPS_S)
#define USB_OTGHS_DOEPCTL13_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL13_MPS_S  0
/** USB_OTGHS_DOEPCTL13_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL13_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL13_USBACTEP_M  (USB_OTGHS_DOEPCTL13_USBACTEP_V << USB_OTGHS_DOEPCTL13_USBACTEP_S)
#define USB_OTGHS_DOEPCTL13_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL13_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL13_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL13_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL13_DPID_M  (USB_OTGHS_DOEPCTL13_DPID_V << USB_OTGHS_DOEPCTL13_DPID_S)
#define USB_OTGHS_DOEPCTL13_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL13_DPID_S  16
/** USB_OTGHS_DOEPCTL13_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL13_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL13_NAKSTS_M  (USB_OTGHS_DOEPCTL13_NAKSTS_V << USB_OTGHS_DOEPCTL13_NAKSTS_S)
#define USB_OTGHS_DOEPCTL13_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL13_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL13_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL13_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL13_EPTYPE_M  (USB_OTGHS_DOEPCTL13_EPTYPE_V << USB_OTGHS_DOEPCTL13_EPTYPE_S)
#define USB_OTGHS_DOEPCTL13_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL13_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL13_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL13_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL13_SNP_M  (USB_OTGHS_DOEPCTL13_SNP_V << USB_OTGHS_DOEPCTL13_SNP_S)
#define USB_OTGHS_DOEPCTL13_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL13_SNP_S  20
/** USB_OTGHS_DOEPCTL13_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL13_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL13_STALL_M  (USB_OTGHS_DOEPCTL13_STALL_V << USB_OTGHS_DOEPCTL13_STALL_S)
#define USB_OTGHS_DOEPCTL13_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL13_STALL_S  21
/** USB_OTGHS_DOEPCTL13_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL13_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL13_CNAK_M  (USB_OTGHS_DOEPCTL13_CNAK_V << USB_OTGHS_DOEPCTL13_CNAK_S)
#define USB_OTGHS_DOEPCTL13_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL13_CNAK_S  26
/** USB_OTGHS_DOEPCTL13_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL13_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL13_SNAK_M  (USB_OTGHS_DOEPCTL13_SNAK_V << USB_OTGHS_DOEPCTL13_SNAK_S)
#define USB_OTGHS_DOEPCTL13_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL13_SNAK_S  27
/** USB_OTGHS_DOEPCTL13_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL13_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL13_SETD0PID_M  (USB_OTGHS_DOEPCTL13_SETD0PID_V << USB_OTGHS_DOEPCTL13_SETD0PID_S)
#define USB_OTGHS_DOEPCTL13_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL13_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL13_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL13_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL13_SETD1PID_M  (USB_OTGHS_DOEPCTL13_SETD1PID_V << USB_OTGHS_DOEPCTL13_SETD1PID_S)
#define USB_OTGHS_DOEPCTL13_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL13_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL13_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL13_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL13_EPDIS_M  (USB_OTGHS_DOEPCTL13_EPDIS_V << USB_OTGHS_DOEPCTL13_EPDIS_S)
#define USB_OTGHS_DOEPCTL13_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL13_EPDIS_S  30
/** USB_OTGHS_DOEPCTL13_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL13_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL13_EPENA_M  (USB_OTGHS_DOEPCTL13_EPENA_V << USB_OTGHS_DOEPCTL13_EPENA_S)
#define USB_OTGHS_DOEPCTL13_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL13_EPENA_S  31

/** USB_OTGHS_DOEPINT13_REG register
 *  This register contains the interrupts for the OUT Endpoint 13 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT13_REG (DR_REG_USB_OTGHS_BASE + 0xca8)
/** USB_OTGHS_DOEPINT13_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT13_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT13_XFERCOMPL_M  (USB_OTGHS_DOEPINT13_XFERCOMPL_V << USB_OTGHS_DOEPINT13_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT13_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT13_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT13_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT13_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT13_EPDISBLD_M  (USB_OTGHS_DOEPINT13_EPDISBLD_V << USB_OTGHS_DOEPINT13_EPDISBLD_S)
#define USB_OTGHS_DOEPINT13_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT13_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT13_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT13_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT13_AHBERR_M  (USB_OTGHS_DOEPINT13_AHBERR_V << USB_OTGHS_DOEPINT13_AHBERR_S)
#define USB_OTGHS_DOEPINT13_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT13_AHBERR_S  2
/** USB_OTGHS_DOEPINT13_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT13_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT13_SETUP_M  (USB_OTGHS_DOEPINT13_SETUP_V << USB_OTGHS_DOEPINT13_SETUP_S)
#define USB_OTGHS_DOEPINT13_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT13_SETUP_S  3
/** USB_OTGHS_DOEPINT13_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT13_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT13_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT13_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT13_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT13_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT13_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT13_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT13_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT13_STSPHSERCVD_M  (USB_OTGHS_DOEPINT13_STSPHSERCVD_V << USB_OTGHS_DOEPINT13_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT13_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT13_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT13_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT13_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT13_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT13_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT13_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT13_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT13_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT13_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT13_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT13_OUTPKTERR_M  (USB_OTGHS_DOEPINT13_OUTPKTERR_V << USB_OTGHS_DOEPINT13_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT13_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT13_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT13_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT13_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT13_BNAINTR_M  (USB_OTGHS_DOEPINT13_BNAINTR_V << USB_OTGHS_DOEPINT13_BNAINTR_S)
#define USB_OTGHS_DOEPINT13_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT13_BNAINTR_S  9
/** USB_OTGHS_DOEPINT13_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT13_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT13_PKTDRPSTS_M  (USB_OTGHS_DOEPINT13_PKTDRPSTS_V << USB_OTGHS_DOEPINT13_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT13_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT13_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT13_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT13_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT13_BBLEERR_M  (USB_OTGHS_DOEPINT13_BBLEERR_V << USB_OTGHS_DOEPINT13_BBLEERR_S)
#define USB_OTGHS_DOEPINT13_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT13_BBLEERR_S  12
/** USB_OTGHS_DOEPINT13_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT13_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT13_NAKINTRPT_M  (USB_OTGHS_DOEPINT13_NAKINTRPT_V << USB_OTGHS_DOEPINT13_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT13_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT13_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT13_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT13_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT13_NYETINTRPT_M  (USB_OTGHS_DOEPINT13_NYETINTRPT_V << USB_OTGHS_DOEPINT13_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT13_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT13_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT13_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT13_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT13_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT13_STUPPKTRCVD_V << USB_OTGHS_DOEPINT13_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT13_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT13_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ13_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 13 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ13_REG (DR_REG_USB_OTGHS_BASE + 0xcb0)
/** USB_OTGHS_DOEPTSIZ13_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ13_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ13_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ13_XFERSIZE_V << USB_OTGHS_DOEPTSIZ13_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ13_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ13_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ13_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ13_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ13_PKTCNT_M  (USB_OTGHS_DOEPTSIZ13_PKTCNT_V << USB_OTGHS_DOEPTSIZ13_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ13_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ13_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ13_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ13_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ13_RXDPID_M  (USB_OTGHS_DOEPTSIZ13_RXDPID_V << USB_OTGHS_DOEPTSIZ13_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ13_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ13_RXDPID_S  29

/** USB_OTGHS_DOEPDMA13_REG register
 *  This register contains the DMA Address for the OUT Endpoint 13 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA13_REG (DR_REG_USB_OTGHS_BASE + 0xcb4)
/** USB_OTGHS_DOEPDMA13_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA13_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA13_DMAADDR_M  (USB_OTGHS_DOEPDMA13_DMAADDR_V << USB_OTGHS_DOEPDMA13_DMAADDR_S)
#define USB_OTGHS_DOEPDMA13_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA13_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB13_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 13 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB13_REG (DR_REG_USB_OTGHS_BASE + 0xcbc)
/** USB_OTGHS_DOEPDMAB13_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB13_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB13_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB13_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB13_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB13_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB13_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL14_REG register
 *  This register is used to control the characteristics of OUT Endpoint 14 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL14_REG (DR_REG_USB_OTGHS_BASE + 0xcc0)
/** USB_OTGHS_DOEPCTL14_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL14_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL14_MPS_M  (USB_OTGHS_DOEPCTL14_MPS_V << USB_OTGHS_DOEPCTL14_MPS_S)
#define USB_OTGHS_DOEPCTL14_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL14_MPS_S  0
/** USB_OTGHS_DOEPCTL14_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL14_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL14_USBACTEP_M  (USB_OTGHS_DOEPCTL14_USBACTEP_V << USB_OTGHS_DOEPCTL14_USBACTEP_S)
#define USB_OTGHS_DOEPCTL14_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL14_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL14_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL14_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL14_DPID_M  (USB_OTGHS_DOEPCTL14_DPID_V << USB_OTGHS_DOEPCTL14_DPID_S)
#define USB_OTGHS_DOEPCTL14_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL14_DPID_S  16
/** USB_OTGHS_DOEPCTL14_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL14_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL14_NAKSTS_M  (USB_OTGHS_DOEPCTL14_NAKSTS_V << USB_OTGHS_DOEPCTL14_NAKSTS_S)
#define USB_OTGHS_DOEPCTL14_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL14_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL14_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL14_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL14_EPTYPE_M  (USB_OTGHS_DOEPCTL14_EPTYPE_V << USB_OTGHS_DOEPCTL14_EPTYPE_S)
#define USB_OTGHS_DOEPCTL14_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL14_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL14_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL14_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL14_SNP_M  (USB_OTGHS_DOEPCTL14_SNP_V << USB_OTGHS_DOEPCTL14_SNP_S)
#define USB_OTGHS_DOEPCTL14_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL14_SNP_S  20
/** USB_OTGHS_DOEPCTL14_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL14_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL14_STALL_M  (USB_OTGHS_DOEPCTL14_STALL_V << USB_OTGHS_DOEPCTL14_STALL_S)
#define USB_OTGHS_DOEPCTL14_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL14_STALL_S  21
/** USB_OTGHS_DOEPCTL14_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL14_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL14_CNAK_M  (USB_OTGHS_DOEPCTL14_CNAK_V << USB_OTGHS_DOEPCTL14_CNAK_S)
#define USB_OTGHS_DOEPCTL14_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL14_CNAK_S  26
/** USB_OTGHS_DOEPCTL14_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL14_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL14_SNAK_M  (USB_OTGHS_DOEPCTL14_SNAK_V << USB_OTGHS_DOEPCTL14_SNAK_S)
#define USB_OTGHS_DOEPCTL14_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL14_SNAK_S  27
/** USB_OTGHS_DOEPCTL14_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL14_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL14_SETD0PID_M  (USB_OTGHS_DOEPCTL14_SETD0PID_V << USB_OTGHS_DOEPCTL14_SETD0PID_S)
#define USB_OTGHS_DOEPCTL14_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL14_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL14_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL14_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL14_SETD1PID_M  (USB_OTGHS_DOEPCTL14_SETD1PID_V << USB_OTGHS_DOEPCTL14_SETD1PID_S)
#define USB_OTGHS_DOEPCTL14_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL14_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL14_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL14_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL14_EPDIS_M  (USB_OTGHS_DOEPCTL14_EPDIS_V << USB_OTGHS_DOEPCTL14_EPDIS_S)
#define USB_OTGHS_DOEPCTL14_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL14_EPDIS_S  30
/** USB_OTGHS_DOEPCTL14_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL14_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL14_EPENA_M  (USB_OTGHS_DOEPCTL14_EPENA_V << USB_OTGHS_DOEPCTL14_EPENA_S)
#define USB_OTGHS_DOEPCTL14_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL14_EPENA_S  31

/** USB_OTGHS_DOEPINT14_REG register
 *  This register contains the interrupts for the OUT Endpoint 14 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT14_REG (DR_REG_USB_OTGHS_BASE + 0xcc8)
/** USB_OTGHS_DOEPINT14_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT14_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT14_XFERCOMPL_M  (USB_OTGHS_DOEPINT14_XFERCOMPL_V << USB_OTGHS_DOEPINT14_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT14_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT14_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT14_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT14_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT14_EPDISBLD_M  (USB_OTGHS_DOEPINT14_EPDISBLD_V << USB_OTGHS_DOEPINT14_EPDISBLD_S)
#define USB_OTGHS_DOEPINT14_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT14_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT14_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT14_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT14_AHBERR_M  (USB_OTGHS_DOEPINT14_AHBERR_V << USB_OTGHS_DOEPINT14_AHBERR_S)
#define USB_OTGHS_DOEPINT14_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT14_AHBERR_S  2
/** USB_OTGHS_DOEPINT14_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT14_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT14_SETUP_M  (USB_OTGHS_DOEPINT14_SETUP_V << USB_OTGHS_DOEPINT14_SETUP_S)
#define USB_OTGHS_DOEPINT14_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT14_SETUP_S  3
/** USB_OTGHS_DOEPINT14_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT14_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT14_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT14_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT14_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT14_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT14_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT14_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT14_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT14_STSPHSERCVD_M  (USB_OTGHS_DOEPINT14_STSPHSERCVD_V << USB_OTGHS_DOEPINT14_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT14_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT14_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT14_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT14_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT14_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT14_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT14_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT14_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT14_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT14_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT14_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT14_OUTPKTERR_M  (USB_OTGHS_DOEPINT14_OUTPKTERR_V << USB_OTGHS_DOEPINT14_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT14_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT14_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT14_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT14_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT14_BNAINTR_M  (USB_OTGHS_DOEPINT14_BNAINTR_V << USB_OTGHS_DOEPINT14_BNAINTR_S)
#define USB_OTGHS_DOEPINT14_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT14_BNAINTR_S  9
/** USB_OTGHS_DOEPINT14_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT14_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT14_PKTDRPSTS_M  (USB_OTGHS_DOEPINT14_PKTDRPSTS_V << USB_OTGHS_DOEPINT14_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT14_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT14_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT14_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT14_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT14_BBLEERR_M  (USB_OTGHS_DOEPINT14_BBLEERR_V << USB_OTGHS_DOEPINT14_BBLEERR_S)
#define USB_OTGHS_DOEPINT14_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT14_BBLEERR_S  12
/** USB_OTGHS_DOEPINT14_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT14_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT14_NAKINTRPT_M  (USB_OTGHS_DOEPINT14_NAKINTRPT_V << USB_OTGHS_DOEPINT14_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT14_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT14_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT14_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT14_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT14_NYETINTRPT_M  (USB_OTGHS_DOEPINT14_NYETINTRPT_V << USB_OTGHS_DOEPINT14_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT14_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT14_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT14_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT14_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT14_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT14_STUPPKTRCVD_V << USB_OTGHS_DOEPINT14_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT14_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT14_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ14_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 14 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ14_REG (DR_REG_USB_OTGHS_BASE + 0xcd0)
/** USB_OTGHS_DOEPTSIZ14_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ14_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ14_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ14_XFERSIZE_V << USB_OTGHS_DOEPTSIZ14_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ14_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ14_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ14_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ14_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ14_PKTCNT_M  (USB_OTGHS_DOEPTSIZ14_PKTCNT_V << USB_OTGHS_DOEPTSIZ14_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ14_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ14_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ14_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ14_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ14_RXDPID_M  (USB_OTGHS_DOEPTSIZ14_RXDPID_V << USB_OTGHS_DOEPTSIZ14_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ14_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ14_RXDPID_S  29

/** USB_OTGHS_DOEPDMA14_REG register
 *  This register contains the DMA Address for the OUT Endpoint 14 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA14_REG (DR_REG_USB_OTGHS_BASE + 0xcd4)
/** USB_OTGHS_DOEPDMA14_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA14_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA14_DMAADDR_M  (USB_OTGHS_DOEPDMA14_DMAADDR_V << USB_OTGHS_DOEPDMA14_DMAADDR_S)
#define USB_OTGHS_DOEPDMA14_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA14_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB14_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 14 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB14_REG (DR_REG_USB_OTGHS_BASE + 0xcdc)
/** USB_OTGHS_DOEPDMAB14_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB14_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB14_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB14_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB14_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB14_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB14_DMABUFFERADDR_S  0

/** USB_OTGHS_DOEPCTL15_REG register
 *  This register is used to control the characteristics of OUT Endpoint 15 of the
 *  Device controller.
 */
#define USB_OTGHS_DOEPCTL15_REG (DR_REG_USB_OTGHS_BASE + 0xce0)
/** USB_OTGHS_DOEPCTL15_MPS : R/W; bitpos: [10:0]; default: 0;
 *  Maximum Packet Size (MPS)
 *
 *  The application must program this field with the maximum packet size for the current
 *  logical endpoint. This value is in bytes.
 */
#define USB_OTGHS_DOEPCTL15_MPS    0x000007FFU
#define USB_OTGHS_DOEPCTL15_MPS_M  (USB_OTGHS_DOEPCTL15_MPS_V << USB_OTGHS_DOEPCTL15_MPS_S)
#define USB_OTGHS_DOEPCTL15_MPS_V  0x000007FFU
#define USB_OTGHS_DOEPCTL15_MPS_S  0
/** USB_OTGHS_DOEPCTL15_USBACTEP : R/W; bitpos: [15]; default: 0;
 *  USB Active Endpoint (USBActEP)
 *
 *  Indicates whether this endpoint is active in the current configuration and
 *  interface. The
 *  core clears this bit for all endpoints (other than EP 0) after detecting a USB
 *  reset. After
 *  receiving the SetConfiguration and SetInterface commands, the application must
 *  program endpoint registers accordingly and set this bit.
 */
#define USB_OTGHS_DOEPCTL15_USBACTEP    (BIT(15))
#define USB_OTGHS_DOEPCTL15_USBACTEP_M  (USB_OTGHS_DOEPCTL15_USBACTEP_V << USB_OTGHS_DOEPCTL15_USBACTEP_S)
#define USB_OTGHS_DOEPCTL15_USBACTEP_V  0x00000001U
#define USB_OTGHS_DOEPCTL15_USBACTEP_S  15
/** USB_OTGHS_DOEPCTL15_DPID : RO; bitpos: [16]; default: 0;
 *  Endpoint Data PID (DPID)
 *
 *  Applies to interrupt/bulk IN and OUT endpoints only.
 *
 *  Contains the PID of the packet to be received or transmitted on this endpoint. The
 *  application must program the PID of the first packet to be received or transmitted
 *  on
 *  this endpoint, after the endpoint is activated. The applications use the SetD1PID
 *  and
 *  SetD0PID fields of this register to program either DATA0 or DATA1 PID.
 *  - 1'b0: DATA0
 *  - 1'b1: DATA1
 *  This field is applicable for both Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *
 *  Reset: 1'b0
 *
 *  Even/Odd (Micro)Frame (EO_FrNum)
 *
 *  In non-Scatter/Gather DMA mode:
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Indicates the (micro)frame number in which the core transmits/receives
 *  isochronous data for this endpoint. The application must program the even/odd
 *  (micro)frame number in which it intends to transmit/receive isochronous data for
 *  this endpoint using the SetEvnFr and SetOddFr fields in this register.
 *  -- 1'b0: Even (micro)frame
 *  -- 1'b1: Odd (micro)frame
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is provided in the transmit descriptor structure. The frame
 *  in which data is received is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL15_DPID    (BIT(16))
#define USB_OTGHS_DOEPCTL15_DPID_M  (USB_OTGHS_DOEPCTL15_DPID_V << USB_OTGHS_DOEPCTL15_DPID_S)
#define USB_OTGHS_DOEPCTL15_DPID_V  0x00000001U
#define USB_OTGHS_DOEPCTL15_DPID_S  16
/** USB_OTGHS_DOEPCTL15_NAKSTS : RO; bitpos: [17]; default: 0;
 *  NAK Status (NAKSts)
 *
 *  Indicates the following:
 *  - 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
 *  - 1'b1: The core is transmitting NAK handshakes on this endpoint.
 *  When either the application or the core sets this bit:
 *  - The core stops receiving any data on an OUT endpoint, even if there is space in
 *  the RxFIFO to accommodate the incoming packet.
 *  - For non-isochronous IN endpoints: The core stops transmitting any data on an IN
 *  endpoint, even if there data is available in the TxFIFO.
 *  - For isochronous IN endpoints: The core sends out a zero-length data packet, even
 *  if there data is available in the TxFIFO.
 *  Irrespective of this bit's setting, the core always responds to SETUP data packets
 *  with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL15_NAKSTS    (BIT(17))
#define USB_OTGHS_DOEPCTL15_NAKSTS_M  (USB_OTGHS_DOEPCTL15_NAKSTS_V << USB_OTGHS_DOEPCTL15_NAKSTS_S)
#define USB_OTGHS_DOEPCTL15_NAKSTS_V  0x00000001U
#define USB_OTGHS_DOEPCTL15_NAKSTS_S  17
/** USB_OTGHS_DOEPCTL15_EPTYPE : R/W; bitpos: [19:18]; default: 0;
 *  Endpoint Type (EPType)
 *
 *  This is the transfer type supported by this logical endpoint.
 *  - 2'b00: Control
 *  - 2'b01: Isochronous
 *  - 2'b10: Bulk
 *  - 2'b11: Interrupt
 */
#define USB_OTGHS_DOEPCTL15_EPTYPE    0x00000003U
#define USB_OTGHS_DOEPCTL15_EPTYPE_M  (USB_OTGHS_DOEPCTL15_EPTYPE_V << USB_OTGHS_DOEPCTL15_EPTYPE_S)
#define USB_OTGHS_DOEPCTL15_EPTYPE_V  0x00000003U
#define USB_OTGHS_DOEPCTL15_EPTYPE_S  18
/** USB_OTGHS_DOEPCTL15_SNP : R/W; bitpos: [20]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_DOEPCTL15_SNP    (BIT(20))
#define USB_OTGHS_DOEPCTL15_SNP_M  (USB_OTGHS_DOEPCTL15_SNP_V << USB_OTGHS_DOEPCTL15_SNP_S)
#define USB_OTGHS_DOEPCTL15_SNP_V  0x00000001U
#define USB_OTGHS_DOEPCTL15_SNP_S  20
/** USB_OTGHS_DOEPCTL15_STALL : R/W; bitpos: [21]; default: 0;
 *  STALL Handshake (Stall)
 *
 *  Applies to non-control, non-isochronous IN and OUT endpoints only.
 *
 *  The application sets this bit to stall all tokens from the USB host to this
 *  endpoint. If a
 *  NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
 *  the
 *  STALL bit takes priority. Only the application can clear this bit, never the core.
 *
 *  Applies to control endpoints only.
 *
 *  The application can only set this bit, and the core clears it, when a SETUP token is
 *  received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT
 *  NAK is set along with this bit, the STALL bit takes priority. Irrespective of this
 *  bit's
 *  setting, the core always responds to SETUP data packets with an ACK handshake.
 */
#define USB_OTGHS_DOEPCTL15_STALL    (BIT(21))
#define USB_OTGHS_DOEPCTL15_STALL_M  (USB_OTGHS_DOEPCTL15_STALL_V << USB_OTGHS_DOEPCTL15_STALL_S)
#define USB_OTGHS_DOEPCTL15_STALL_V  0x00000001U
#define USB_OTGHS_DOEPCTL15_STALL_S  21
/** USB_OTGHS_DOEPCTL15_CNAK : R/W; bitpos: [26]; default: 0;
 *
 *  Clear NAK (CNAK)
 *  A write to this bit clears the NAK bit for the endpoint.
 */
#define USB_OTGHS_DOEPCTL15_CNAK    (BIT(26))
#define USB_OTGHS_DOEPCTL15_CNAK_M  (USB_OTGHS_DOEPCTL15_CNAK_V << USB_OTGHS_DOEPCTL15_CNAK_S)
#define USB_OTGHS_DOEPCTL15_CNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL15_CNAK_S  26
/** USB_OTGHS_DOEPCTL15_SNAK : R/W; bitpos: [27]; default: 0;
 *  Set NAK (SNAK)
 *
 *  A write to this bit sets the NAK bit for the endpoint.
 *
 *  Using this bit, the application can control the transmission of NAK
 *  handshakes on an endpoint. The core can also set this bit for an
 *  endpoint after a SETUP packet is received on that endpoint.
 */
#define USB_OTGHS_DOEPCTL15_SNAK    (BIT(27))
#define USB_OTGHS_DOEPCTL15_SNAK_M  (USB_OTGHS_DOEPCTL15_SNAK_V << USB_OTGHS_DOEPCTL15_SNAK_S)
#define USB_OTGHS_DOEPCTL15_SNAK_V  0x00000001U
#define USB_OTGHS_DOEPCTL15_SNAK_S  27
/** USB_OTGHS_DOEPCTL15_SETD0PID : R/W; bitpos: [28]; default: 0;
 *  Set DATA0 PID (SetD0PID)
 *  - Applies to interrupt/bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA0.
 *  - This field is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  In non-Scatter/Gather DMA mode: Set Even (micro)frame (SetEvenFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the Even/Odd (micro)frame (EO_FrNum) field to even
 *  (micro)frame.
 *  - When Scatter/Gather DMA mode is enabled, this field is reserved. The frame number
 *  in which to send data is in the transmit descriptor structure. The frame in which
 *  to receive data is updated in receive descriptor structure.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL15_SETD0PID    (BIT(28))
#define USB_OTGHS_DOEPCTL15_SETD0PID_M  (USB_OTGHS_DOEPCTL15_SETD0PID_V << USB_OTGHS_DOEPCTL15_SETD0PID_S)
#define USB_OTGHS_DOEPCTL15_SETD0PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL15_SETD0PID_S  28
/** USB_OTGHS_DOEPCTL15_SETD1PID : R/W; bitpos: [29]; default: 0;
 *  Set DATA1 PID (SetD1PID)
 *  - Applies to interrupt and bulk IN and OUT endpoints only.
 *  - Writing to this field sets the Endpoint Data PID (DPID) field in this register to
 *  DATA1.
 *  - This field is applicable both for scatter-gather DMA mode and non scatter-gather
 *  DMA mode.
 *  Reset: 1'b0
 *
 *  Set Odd (micro)frame (SetOddFr)
 *  - Applies to isochronous IN and OUT endpoints only.
 *  - Writing to this field sets the even and odd (micro)frame (EO_FrNum) field to odd
 *  (micro)frame.
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPCTL15_SETD1PID    (BIT(29))
#define USB_OTGHS_DOEPCTL15_SETD1PID_M  (USB_OTGHS_DOEPCTL15_SETD1PID_V << USB_OTGHS_DOEPCTL15_SETD1PID_S)
#define USB_OTGHS_DOEPCTL15_SETD1PID_V  0x00000001U
#define USB_OTGHS_DOEPCTL15_SETD1PID_S  29
/** USB_OTGHS_DOEPCTL15_EPDIS : R/W; bitpos: [30]; default: 0;
 *  Endpoint Disable (EPDis)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  The application sets this bit to stop transmitting/receiving data on an endpoint,
 *  even
 *  before the transfer for that endpoint is complete. The application must wait for the
 *  Endpoint Disabled interrupt before treating the endpoint as disabled. The core
 *  clears
 *  this bit before setting the Endpoint Disabled interrupt. The application must set
 *  this bit
 *  only if Endpoint Enable is already set for this endpoint.
 */
#define USB_OTGHS_DOEPCTL15_EPDIS    (BIT(30))
#define USB_OTGHS_DOEPCTL15_EPDIS_M  (USB_OTGHS_DOEPCTL15_EPDIS_V << USB_OTGHS_DOEPCTL15_EPDIS_S)
#define USB_OTGHS_DOEPCTL15_EPDIS_V  0x00000001U
#define USB_OTGHS_DOEPCTL15_EPDIS_S  30
/** USB_OTGHS_DOEPCTL15_EPENA : R/W; bitpos: [31]; default: 0;
 *  Endpoint Enable (EPEna)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  When Scatter/Gather DMA mode is enabled,
 *  - For IN endpoints this bit indicates that the descriptor structure and data buffer
 *  with data ready to transmit is setup.
 *  - For OUT endpoint it indicates that the descriptor structure and data buffer to
 *  receive data is setup.
 *  When Scatter/Gather DMA mode is enabled such as for buffer-pointer based DMA mode:
 *  - For IN endpoints, this bit indicates that data is ready to be transmitted on the
 *  endpoint.
 *  - For OUT endpoints, this bit indicates that the application has allocated the
 *  memory to start receiving data from the USB.
 *  The core clears this bit before setting any of the following interrupts on this
 *  endpoint:
 *  - SETUP Phase Done
 *  - Endpoint Disabled
 *  - Transfer Completed
 *  Note: For control endpoints in DMA mode, this bit must be set for the controller to
 *  transfer SETUP data packets to the memory. This bit is not cleared on Transfer
 *  Completed interrupt of the SETUP packet.
 */
#define USB_OTGHS_DOEPCTL15_EPENA    (BIT(31))
#define USB_OTGHS_DOEPCTL15_EPENA_M  (USB_OTGHS_DOEPCTL15_EPENA_V << USB_OTGHS_DOEPCTL15_EPENA_S)
#define USB_OTGHS_DOEPCTL15_EPENA_V  0x00000001U
#define USB_OTGHS_DOEPCTL15_EPENA_S  31

/** USB_OTGHS_DOEPINT15_REG register
 *  This register contains the interrupts for the OUT Endpoint 15 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPINT15_REG (DR_REG_USB_OTGHS_BASE + 0xce8)
/** USB_OTGHS_DOEPINT15_XFERCOMPL : R/W; bitpos: [0]; default: 0;
 *  Transfer Completed Interrupt (XferCompl)
 *
 *  Applies to IN and OUT endpoints.
 *  - When Scatter/Gather DMA mode is enabled
 *  -- For IN endpoint this field indicates that the requested data from the descriptor
 *  is moved from external system memory to internal FIFO.
 *  -- For OUT endpoint this field indicates that the requested data from the internal
 *  FIFO is moved to external system memory. This interrupt is generated only when the
 *  corresponding endpoint descriptor is closed, and the IOC bit for the corresponding
 *  descriptor is Set.
 *  - When Scatter/Gather DMA mode is disabled, this field indicates that the
 *  programmed transfer is complete on the AHB as well as on the USB, for this endpoint.
 */
#define USB_OTGHS_DOEPINT15_XFERCOMPL    (BIT(0))
#define USB_OTGHS_DOEPINT15_XFERCOMPL_M  (USB_OTGHS_DOEPINT15_XFERCOMPL_V << USB_OTGHS_DOEPINT15_XFERCOMPL_S)
#define USB_OTGHS_DOEPINT15_XFERCOMPL_V  0x00000001U
#define USB_OTGHS_DOEPINT15_XFERCOMPL_S  0
/** USB_OTGHS_DOEPINT15_EPDISBLD : R/W; bitpos: [1]; default: 0;
 *  Endpoint Disabled Interrupt (EPDisbld)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This bit indicates that the endpoint is disabled per the application's request.
 */
#define USB_OTGHS_DOEPINT15_EPDISBLD    (BIT(1))
#define USB_OTGHS_DOEPINT15_EPDISBLD_M  (USB_OTGHS_DOEPINT15_EPDISBLD_V << USB_OTGHS_DOEPINT15_EPDISBLD_S)
#define USB_OTGHS_DOEPINT15_EPDISBLD_V  0x00000001U
#define USB_OTGHS_DOEPINT15_EPDISBLD_S  1
/** USB_OTGHS_DOEPINT15_AHBERR : R/W; bitpos: [2]; default: 0;
 *  AHB Error (AHBErr)
 *
 *  Applies to IN and OUT endpoints.
 *
 *  This is generated only in Internal DMA mode when there is an AHB error during an
 *  AHB read/write. The application can read the corresponding endpoint DMA address
 *  register to get the error address. For details, see AHB Error Handling section in
 *  the Programming Guide.
 */
#define USB_OTGHS_DOEPINT15_AHBERR    (BIT(2))
#define USB_OTGHS_DOEPINT15_AHBERR_M  (USB_OTGHS_DOEPINT15_AHBERR_V << USB_OTGHS_DOEPINT15_AHBERR_S)
#define USB_OTGHS_DOEPINT15_AHBERR_V  0x00000001U
#define USB_OTGHS_DOEPINT15_AHBERR_S  2
/** USB_OTGHS_DOEPINT15_SETUP : R/W; bitpos: [3]; default: 0;
 *  SETUP Phase Done (SetUp)
 *
 *  Applies to control OUT endpoints only.
 *
 *  Indicates that the SETUP phase for the control endpoint is
 *  complete and no more back-to-back SETUP packets were
 *  received for the current control transfer. On this interrupt, the
 *  application can decode the received SETUP data packet.
 */
#define USB_OTGHS_DOEPINT15_SETUP    (BIT(3))
#define USB_OTGHS_DOEPINT15_SETUP_M  (USB_OTGHS_DOEPINT15_SETUP_V << USB_OTGHS_DOEPINT15_SETUP_S)
#define USB_OTGHS_DOEPINT15_SETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT15_SETUP_S  3
/** USB_OTGHS_DOEPINT15_OUTTKNEPDIS : R/W; bitpos: [4]; default: 0;
 *  OUT Token Received When Endpoint Disabled (OUTTknEPdis)
 *
 *  Applies only to control OUT endpoints.
 *
 *  Indicates that an OUT token was received when the endpoint was not yet enabled.
 *  This interrupt is asserted on the endpoint for which the OUT token was received.
 */
#define USB_OTGHS_DOEPINT15_OUTTKNEPDIS    (BIT(4))
#define USB_OTGHS_DOEPINT15_OUTTKNEPDIS_M  (USB_OTGHS_DOEPINT15_OUTTKNEPDIS_V << USB_OTGHS_DOEPINT15_OUTTKNEPDIS_S)
#define USB_OTGHS_DOEPINT15_OUTTKNEPDIS_V  0x00000001U
#define USB_OTGHS_DOEPINT15_OUTTKNEPDIS_S  4
/** USB_OTGHS_DOEPINT15_STSPHSERCVD : R/W; bitpos: [5]; default: 0;
 *  Status Phase Received for Control Write (StsPhseRcvd)
 *
 *  This interrupt is valid only for Control OUT endpoints.
 *
 *  This interrupt is generated only after the core has transferred all
 *  the data that the host has sent during the data phase of a control
 *  write transfer, to the system memory buffer.
 *
 *  The interrupt indicates to the application that the host has
 *  switched from data phase to the status phase of a Control Write
 *  transfer. The application can use this interrupt to ACK or STALL
 *  the Status phase, after it has decoded the data phase.
 */
#define USB_OTGHS_DOEPINT15_STSPHSERCVD    (BIT(5))
#define USB_OTGHS_DOEPINT15_STSPHSERCVD_M  (USB_OTGHS_DOEPINT15_STSPHSERCVD_V << USB_OTGHS_DOEPINT15_STSPHSERCVD_S)
#define USB_OTGHS_DOEPINT15_STSPHSERCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT15_STSPHSERCVD_S  5
/** USB_OTGHS_DOEPINT15_BACK2BACKSETUP : R/W; bitpos: [6]; default: 0;
 *  Back-to-Back SETUP Packets Received (Back2BackSETup)
 *
 *  Applies to Control OUT endpoints only.
 *
 *  This bit indicates that the core has received more than three
 *  back-to-back SETUP packets for this particular endpoint. For
 *  information about handling this interrupt,
 */
#define USB_OTGHS_DOEPINT15_BACK2BACKSETUP    (BIT(6))
#define USB_OTGHS_DOEPINT15_BACK2BACKSETUP_M  (USB_OTGHS_DOEPINT15_BACK2BACKSETUP_V << USB_OTGHS_DOEPINT15_BACK2BACKSETUP_S)
#define USB_OTGHS_DOEPINT15_BACK2BACKSETUP_V  0x00000001U
#define USB_OTGHS_DOEPINT15_BACK2BACKSETUP_S  6
/** USB_OTGHS_DOEPINT15_OUTPKTERR : R/W; bitpos: [8]; default: 0;
 *  OUT Packet Error (OutPktErr)
 *
 *  Applies to OUT endpoints Only
 *
 *  This interrupt is valid only when thresholding is enabled. This interrupt is
 *  asserted when the
 *  core detects an overflow or a CRC error for non-Isochronous OUT packet.
 */
#define USB_OTGHS_DOEPINT15_OUTPKTERR    (BIT(8))
#define USB_OTGHS_DOEPINT15_OUTPKTERR_M  (USB_OTGHS_DOEPINT15_OUTPKTERR_V << USB_OTGHS_DOEPINT15_OUTPKTERR_S)
#define USB_OTGHS_DOEPINT15_OUTPKTERR_V  0x00000001U
#define USB_OTGHS_DOEPINT15_OUTPKTERR_S  8
/** USB_OTGHS_DOEPINT15_BNAINTR : R/W; bitpos: [9]; default: 0;
 *  BNA (Buffer Not Available) Interrupt (BNAIntr)
 *
 *  This bit is valid only when Scatter/Gather DMA mode is enabled.
 *
 *  The core generates this interrupt when the descriptor accessed
 *  is not ready for the Core to process, such as Host busy or DMA
 *  done
 */
#define USB_OTGHS_DOEPINT15_BNAINTR    (BIT(9))
#define USB_OTGHS_DOEPINT15_BNAINTR_M  (USB_OTGHS_DOEPINT15_BNAINTR_V << USB_OTGHS_DOEPINT15_BNAINTR_S)
#define USB_OTGHS_DOEPINT15_BNAINTR_V  0x00000001U
#define USB_OTGHS_DOEPINT15_BNAINTR_S  9
/** USB_OTGHS_DOEPINT15_PKTDRPSTS : R/W; bitpos: [11]; default: 0;
 *  Packet Drop Status (PktDrpSts)
 *
 *  This bit indicates to the application that an ISOC OUT packet has been dropped. This
 *  bit does not have an associated mask bit and does not generate an interrupt.
 *
 *  Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer
 *  interrupt feature is selected.
 */
#define USB_OTGHS_DOEPINT15_PKTDRPSTS    (BIT(11))
#define USB_OTGHS_DOEPINT15_PKTDRPSTS_M  (USB_OTGHS_DOEPINT15_PKTDRPSTS_V << USB_OTGHS_DOEPINT15_PKTDRPSTS_S)
#define USB_OTGHS_DOEPINT15_PKTDRPSTS_V  0x00000001U
#define USB_OTGHS_DOEPINT15_PKTDRPSTS_S  11
/** USB_OTGHS_DOEPINT15_BBLEERR : R/W; bitpos: [12]; default: 0;
 *  NAK Interrupt (BbleErr)
 *
 *  The core generates this interrupt when babble is received for the endpoint.
 */
#define USB_OTGHS_DOEPINT15_BBLEERR    (BIT(12))
#define USB_OTGHS_DOEPINT15_BBLEERR_M  (USB_OTGHS_DOEPINT15_BBLEERR_V << USB_OTGHS_DOEPINT15_BBLEERR_S)
#define USB_OTGHS_DOEPINT15_BBLEERR_V  0x00000001U
#define USB_OTGHS_DOEPINT15_BBLEERR_S  12
/** USB_OTGHS_DOEPINT15_NAKINTRPT : R/W; bitpos: [13]; default: 0;
 *  NAK Interrupt (NAKInterrupt)
 *
 *  The core generates this interrupt when a NAK is transmitted or received by the
 *  device.
 *
 *  In case of isochronous IN endpoints the interrupt gets generated when a zero length
 *  packet is transmitted due to un-availability of data in the TXFifo.
 */
#define USB_OTGHS_DOEPINT15_NAKINTRPT    (BIT(13))
#define USB_OTGHS_DOEPINT15_NAKINTRPT_M  (USB_OTGHS_DOEPINT15_NAKINTRPT_V << USB_OTGHS_DOEPINT15_NAKINTRPT_S)
#define USB_OTGHS_DOEPINT15_NAKINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT15_NAKINTRPT_S  13
/** USB_OTGHS_DOEPINT15_NYETINTRPT : R/W; bitpos: [14]; default: 0;
 *  NYET Interrupt (NYETIntrpt)
 *
 *  The core generates this interrupt when a NYET response is transmitted for a non
 *  isochronous OUT endpoint.
 */
#define USB_OTGHS_DOEPINT15_NYETINTRPT    (BIT(14))
#define USB_OTGHS_DOEPINT15_NYETINTRPT_M  (USB_OTGHS_DOEPINT15_NYETINTRPT_V << USB_OTGHS_DOEPINT15_NYETINTRPT_S)
#define USB_OTGHS_DOEPINT15_NYETINTRPT_V  0x00000001U
#define USB_OTGHS_DOEPINT15_NYETINTRPT_S  14
/** USB_OTGHS_DOEPINT15_STUPPKTRCVD : R/W; bitpos: [15]; default: 0;
 *  Setup Packet Received
 *
 *  Applicable for Control OUT Endpoints in only in the Buffer DMA Mode
 *
 *  Set by the controller, this bit indicates that this buffer holds 8 bytes of
 *  setup data. There is only one Setup packet per buffer. On receiving a
 *  Setup packet, the controller closes the buffer and disables the
 *  corresponding endpoint. The application has to re-enable the endpoint to
 *  receive any OUT data for the Control Transfer and reprogram the buffer
 *  start address.
 *
 *  Note: Because of the above behavior, the controller can receive any
 *  number of back to back setup packets and one buffer for every setup
 *  packet is used.
 *  - 1'b0: No Setup packet received
 *  - 1'b1: Setup packet received
 *  Reset: 1'b0
 */
#define USB_OTGHS_DOEPINT15_STUPPKTRCVD    (BIT(15))
#define USB_OTGHS_DOEPINT15_STUPPKTRCVD_M  (USB_OTGHS_DOEPINT15_STUPPKTRCVD_V << USB_OTGHS_DOEPINT15_STUPPKTRCVD_S)
#define USB_OTGHS_DOEPINT15_STUPPKTRCVD_V  0x00000001U
#define USB_OTGHS_DOEPINT15_STUPPKTRCVD_S  15

/** USB_OTGHS_DOEPTSIZ15_REG register
 *  This register contains the Transfer Size for the OUT Endpoint 15 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPTSIZ15_REG (DR_REG_USB_OTGHS_BASE + 0xcf0)
/** USB_OTGHS_DOEPTSIZ15_XFERSIZE : R/W; bitpos: [18:0]; default: 0;
 *  Transfer Size (XferSize)
 *
 *  Indicates the transfer size in bytes for the endpoint. The core
 *  interrupts the application only after it has exhausted the transfer
 *  size amount of data. The transfer size can be Set to the
 *  maximum packet size of the endpoint, to be interrupted at the
 *  end of each packet.
 *
 *  The core decrements this field every time a packet is read from
 *  the RxFIFO and written to the external memory.
 */
#define USB_OTGHS_DOEPTSIZ15_XFERSIZE    0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ15_XFERSIZE_M  (USB_OTGHS_DOEPTSIZ15_XFERSIZE_V << USB_OTGHS_DOEPTSIZ15_XFERSIZE_S)
#define USB_OTGHS_DOEPTSIZ15_XFERSIZE_V  0x0007FFFFU
#define USB_OTGHS_DOEPTSIZ15_XFERSIZE_S  0
/** USB_OTGHS_DOEPTSIZ15_PKTCNT : R/W; bitpos: [28:19]; default: 0;
 *  Packet Count (PktCnt)
 *  This field is decremented to zero after a packet is written into the RxFIFO.
 */
#define USB_OTGHS_DOEPTSIZ15_PKTCNT    0x000003FFU
#define USB_OTGHS_DOEPTSIZ15_PKTCNT_M  (USB_OTGHS_DOEPTSIZ15_PKTCNT_V << USB_OTGHS_DOEPTSIZ15_PKTCNT_S)
#define USB_OTGHS_DOEPTSIZ15_PKTCNT_V  0x000003FFU
#define USB_OTGHS_DOEPTSIZ15_PKTCNT_S  19
/** USB_OTGHS_DOEPTSIZ15_RXDPID : RO; bitpos: [30:29]; default: 0;
 *  RxDPID
 *
 *  Applies to isochronous OUT endpoints only.
 *
 *  This is the data PID received in the last packet for this endpoint.
 *  - 2'b00: DATA0
 *  - 2'b01: DATA2
 *  - 2'b10: DATA1
 *  - 2'b11: MDATA
 *  SETUP Packet Count (SUPCnt)
 *
 *  Applies to control OUT Endpoints only.
 *
 *  This field specifies the number of back-to-back SETUP data
 *  packets the endpoint can receive.
 *  - 2'b01: 1 packet
 *  - 2'b10: 2 packets
 *  - 2'b11: 3 packets
 */
#define USB_OTGHS_DOEPTSIZ15_RXDPID    0x00000003U
#define USB_OTGHS_DOEPTSIZ15_RXDPID_M  (USB_OTGHS_DOEPTSIZ15_RXDPID_V << USB_OTGHS_DOEPTSIZ15_RXDPID_S)
#define USB_OTGHS_DOEPTSIZ15_RXDPID_V  0x00000003U
#define USB_OTGHS_DOEPTSIZ15_RXDPID_S  29

/** USB_OTGHS_DOEPDMA15_REG register
 *  This register contains the DMA Address for the OUT Endpoint 15 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMA15_REG (DR_REG_USB_OTGHS_BASE + 0xcf4)
/** USB_OTGHS_DOEPDMA15_DMAADDR : R/W; bitpos: [31:0]; default: 0;
 *  Holds the start address of the external memory for storing or fetching endpoint
 *  data.
 *
 *  Note: For control endpoints, this field stores control OUT data packets as well as
 *  SETUP transaction data packets. When more than three SETUP packets are
 *  received back-to-back, the SETUP data packet in the memory is overwritten.
 *
 *  This register is incremented on every AHB transaction. The application can give
 *  only a DWORD-aligned address.
 *  - When Scatter/Gather DMA mode is not enabled, the application programs the start
 *  address value in this field.
 *  - When Scatter/Gather DMA mode is enabled, this field indicates the base pointer
 *  for the descriptor list.
 */
#define USB_OTGHS_DOEPDMA15_DMAADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA15_DMAADDR_M  (USB_OTGHS_DOEPDMA15_DMAADDR_V << USB_OTGHS_DOEPDMA15_DMAADDR_S)
#define USB_OTGHS_DOEPDMA15_DMAADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMA15_DMAADDR_S  0

/** USB_OTGHS_DOEPDMAB15_REG register
 *  This register contains the DMA Buffer Address for the OUT Endpoint 15 of the Device
 *  controller.
 */
#define USB_OTGHS_DOEPDMAB15_REG (DR_REG_USB_OTGHS_BASE + 0xcfc)
/** USB_OTGHS_DOEPDMAB15_DMABUFFERADDR : RO; bitpos: [31:0]; default: 0;
 *  Holds the current buffer address.This register is updated as and when the data
 *  transfer for the corresponding end point is in progress.
 *
 *  This register is present only in Scatter/Gather DMA mode. Otherwise this field is
 *  reserved.
 */
#define USB_OTGHS_DOEPDMAB15_DMABUFFERADDR    0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB15_DMABUFFERADDR_M  (USB_OTGHS_DOEPDMAB15_DMABUFFERADDR_V << USB_OTGHS_DOEPDMAB15_DMABUFFERADDR_S)
#define USB_OTGHS_DOEPDMAB15_DMABUFFERADDR_V  0xFFFFFFFFU
#define USB_OTGHS_DOEPDMAB15_DMABUFFERADDR_S  0

/** USB_OTGHS_PCGCCTL_REG register
 *  This register is used to control the Power and Clock Gating characteristics of the
 *  controller.
 */
#define USB_OTGHS_PCGCCTL_REG (DR_REG_USB_OTGHS_BASE + 0xe00)
/** USB_OTGHS_PCGCCTL_STOPPCLK : R/W; bitpos: [0]; default: 0;
 *  Stop Pclk (StopPclk)
 *  - The application sets this bit to stop the PHY clock (phy_clk) when the USB is
 *  suspended, the session is not valid, or the device is disconnected.
 *  - The application clears this bit when the USB is resumed or a new session starts.
 */
#define USB_OTGHS_PCGCCTL_STOPPCLK    (BIT(0))
#define USB_OTGHS_PCGCCTL_STOPPCLK_M  (USB_OTGHS_PCGCCTL_STOPPCLK_V << USB_OTGHS_PCGCCTL_STOPPCLK_S)
#define USB_OTGHS_PCGCCTL_STOPPCLK_V  0x00000001U
#define USB_OTGHS_PCGCCTL_STOPPCLK_S  0
/** USB_OTGHS_PCGCCTL_GATEHCLK : R/W; bitpos: [1]; default: 0;
 *  Gate Hclk (GateHclk)
 *  - The application sets this bit to gate hclk to modules other than the AHB Slave
 *  and Master and wakeup logic when the USB is suspended or the session is not valid.
 *  - The application clears this bit when the USB is resumed or a new session starts.
 */
#define USB_OTGHS_PCGCCTL_GATEHCLK    (BIT(1))
#define USB_OTGHS_PCGCCTL_GATEHCLK_M  (USB_OTGHS_PCGCCTL_GATEHCLK_V << USB_OTGHS_PCGCCTL_GATEHCLK_S)
#define USB_OTGHS_PCGCCTL_GATEHCLK_V  0x00000001U
#define USB_OTGHS_PCGCCTL_GATEHCLK_S  1
/** USB_OTGHS_PCGCCTL_PWRCLMP : R/W; bitpos: [2]; default: 0;
 *  Power Clamp (PwrClmp)
 *
 *  This bit is valid only in Partial Power-Down mode
 *  - The application sets this bit before the power is turned off to clamp the signals
 *  between the power-on modules and the power-off modules.
 *  - The application clears the bit to disable the clamping before the power is turned
 *  on.
 */
#define USB_OTGHS_PCGCCTL_PWRCLMP    (BIT(2))
#define USB_OTGHS_PCGCCTL_PWRCLMP_M  (USB_OTGHS_PCGCCTL_PWRCLMP_V << USB_OTGHS_PCGCCTL_PWRCLMP_S)
#define USB_OTGHS_PCGCCTL_PWRCLMP_V  0x00000001U
#define USB_OTGHS_PCGCCTL_PWRCLMP_S  2
/** USB_OTGHS_PCGCCTL_RSTPDWNMODULE : R/W; bitpos: [3]; default: 0;
 *  Reset Power-Down Modules (RstPdwnModule)
 *
 *  This bit is valid only in Partial Power-Down mode.
 *  - The application sets this bit when the power is turned off.
 *  - The application clears this bit after the power is turned on and the PHY clock is
 *  up.
 *
 *  Note: The R/W of all core registers are possible only when this bit is set to 1b0.
 */
#define USB_OTGHS_PCGCCTL_RSTPDWNMODULE    (BIT(3))
#define USB_OTGHS_PCGCCTL_RSTPDWNMODULE_M  (USB_OTGHS_PCGCCTL_RSTPDWNMODULE_V << USB_OTGHS_PCGCCTL_RSTPDWNMODULE_S)
#define USB_OTGHS_PCGCCTL_RSTPDWNMODULE_V  0x00000001U
#define USB_OTGHS_PCGCCTL_RSTPDWNMODULE_S  3
/** USB_OTGHS_PCGCCTL_PHYSLEEP : RO; bitpos: [6]; default: 0;
 *  PHY In Sleep
 *
 *  Indicates that the PHY is in Sleep State.
 */
#define USB_OTGHS_PCGCCTL_PHYSLEEP    (BIT(6))
#define USB_OTGHS_PCGCCTL_PHYSLEEP_M  (USB_OTGHS_PCGCCTL_PHYSLEEP_V << USB_OTGHS_PCGCCTL_PHYSLEEP_S)
#define USB_OTGHS_PCGCCTL_PHYSLEEP_V  0x00000001U
#define USB_OTGHS_PCGCCTL_PHYSLEEP_S  6
/** USB_OTGHS_PCGCCTL_L1SUSPENDED : RO; bitpos: [7]; default: 0;
 *  L1 Deep Sleep
 *
 *  Indicates that the PHY is in deep sleep when in L1 state.
 */
#define USB_OTGHS_PCGCCTL_L1SUSPENDED    (BIT(7))
#define USB_OTGHS_PCGCCTL_L1SUSPENDED_M  (USB_OTGHS_PCGCCTL_L1SUSPENDED_V << USB_OTGHS_PCGCCTL_L1SUSPENDED_S)
#define USB_OTGHS_PCGCCTL_L1SUSPENDED_V  0x00000001U
#define USB_OTGHS_PCGCCTL_L1SUSPENDED_S  7
/** USB_OTGHS_PCGCCTL_RESETAFTERSUSP : R/W; bitpos: [8]; default: 0;
 *  Reset after suspend
 *
 *  Applicable in Partial power-down mode
 *
 *  In partial power-down mode of operation, this bit needs to be set in host mode
 *  before
 *  clamp is removed if the host needs to issue reset after suspend. If this bit is not
 *  set,
 *  then the host issues resume after suspend.
 *
 *  This bit is not applicable in device mode and non-partial power-down mode.
 *  In Hibernation mode, this bit needs to be set at RESTORE_POINT before
 *  PCGCCTL.EssRegRestored is set. In this case, PCGCCTL.restore_mode needs to
 *  be set to wait_restore.
 */
#define USB_OTGHS_PCGCCTL_RESETAFTERSUSP    (BIT(8))
#define USB_OTGHS_PCGCCTL_RESETAFTERSUSP_M  (USB_OTGHS_PCGCCTL_RESETAFTERSUSP_V << USB_OTGHS_PCGCCTL_RESETAFTERSUSP_S)
#define USB_OTGHS_PCGCCTL_RESETAFTERSUSP_V  0x00000001U
#define USB_OTGHS_PCGCCTL_RESETAFTERSUSP_S  8

/** USB_OTGHS_GSTARFXDIS_REG register
 *  This register is used to disable STAR fixes added in the controller. The
 *  application can set the register fields to operate with the functionality before
 *  the fix was done.
 */
#define USB_OTGHS_GSTARFXDIS_REG (DR_REG_USB_OTGHS_BASE + 0xf00)
/** USB_OTGHS_GSTARFXDIS_HOST_IGNORES_RMTWKUP_DIS : R/W; bitpos: [0]; default: 0;
 *  Disable the STAR fix added for Device controller to go back to low power mode when
 *  Host ignores Remote wakeup
 *  The application programs Host_Ignores_RmtWkup_dis=1 to disable the device
 *  controller from going back to low power mode (SUSPENDED state) when the host
 *  ignores the remote wakeup signalling from the device and does not respond back with
 *  resume. This bit must be programmed during the initial configuration of the
 *  controller and must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_HOST_IGNORES_RMTWKUP_DIS    (BIT(0))
#define USB_OTGHS_GSTARFXDIS_HOST_IGNORES_RMTWKUP_DIS_M  (USB_OTGHS_GSTARFXDIS_HOST_IGNORES_RMTWKUP_DIS_V << USB_OTGHS_GSTARFXDIS_HOST_IGNORES_RMTWKUP_DIS_S)
#define USB_OTGHS_GSTARFXDIS_HOST_IGNORES_RMTWKUP_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_HOST_IGNORES_RMTWKUP_DIS_S  0
/** USB_OTGHS_GSTARFXDIS_RESUME_FRM_CHK_BUS_DIS : R/W; bitpos: [1]; default: 0;
 *  Disable the STAR fix added for Device controller to detect lineK and move to
 *  RESUMING state after the 50us pull-up delay ends
 *  The application programs Resume_frm_CHK_BUS_dis=1 to disable the device controller
 *  from detecting line K and transitioning to RESUMING state in the scenario where
 *  Host resume starts immediately after the 50us pull-up delay timer expires. This bit
 *  must be programmed during the initial configuration of the controller and must not
 *  be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_RESUME_FRM_CHK_BUS_DIS    (BIT(1))
#define USB_OTGHS_GSTARFXDIS_RESUME_FRM_CHK_BUS_DIS_M  (USB_OTGHS_GSTARFXDIS_RESUME_FRM_CHK_BUS_DIS_V << USB_OTGHS_GSTARFXDIS_RESUME_FRM_CHK_BUS_DIS_S)
#define USB_OTGHS_GSTARFXDIS_RESUME_FRM_CHK_BUS_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_RESUME_FRM_CHK_BUS_DIS_S  1
/** USB_OTGHS_GSTARFXDIS_IGNORE_CTLOUT_DATA0_DIS : R/W; bitpos: [2]; default: 0;
 *  Disable the STAR fix added for Device controller to reject DATA0 for the first
 *  Control OUT Data Phase and Control Status OUT Phase
 *  The application programs Ignore_CtlOUT_DATA0_dis=1 to disable the device controller
 *  from reporting transaction error when DATA0 PID is received from host for the first
 *  Control OUT Data Phase and Control Status OUT phase. This bit must be programmed
 *  during the initial configuration of the controller and must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_IGNORE_CTLOUT_DATA0_DIS    (BIT(2))
#define USB_OTGHS_GSTARFXDIS_IGNORE_CTLOUT_DATA0_DIS_M  (USB_OTGHS_GSTARFXDIS_IGNORE_CTLOUT_DATA0_DIS_V << USB_OTGHS_GSTARFXDIS_IGNORE_CTLOUT_DATA0_DIS_S)
#define USB_OTGHS_GSTARFXDIS_IGNORE_CTLOUT_DATA0_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_IGNORE_CTLOUT_DATA0_DIS_S  2
/** USB_OTGHS_GSTARFXDIS_SSPLIT_STALLNYET_ERR_DIS : R/W; bitpos: [3]; default: 0;
 *  Disable the STAR fix added for Host controller to flag error for SSPLIT STALL/NYET
 *  The application programs SSPLIT_STALLNYET_Err_dis=1 to disable the host controller
 *  from reporting transaction error for STALL/NYET received from device for SSPLIT
 *  transfer. This bit must be programmed during the initial configuration of the
 *  controller and must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_SSPLIT_STALLNYET_ERR_DIS    (BIT(3))
#define USB_OTGHS_GSTARFXDIS_SSPLIT_STALLNYET_ERR_DIS_M  (USB_OTGHS_GSTARFXDIS_SSPLIT_STALLNYET_ERR_DIS_V << USB_OTGHS_GSTARFXDIS_SSPLIT_STALLNYET_ERR_DIS_S)
#define USB_OTGHS_GSTARFXDIS_SSPLIT_STALLNYET_ERR_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_SSPLIT_STALLNYET_ERR_DIS_S  3
/** USB_OTGHS_GSTARFXDIS_ACCEPT_ISOC_SPLIT_DATA1_DIS : R/W; bitpos: [4]; default: 0;
 *  Disable the STAR fix added for Host controller to accept DATA1 PID from device for
 *  ISOC Split transfers
 *  The application programs Accept_Isoc_split_DATA1_dis=1 to disable the host
 *  controller from accepting DATA1 PID from device for ISOC Split transfers. This bit
 *  must be programmed during the initial configuration of the controller and must not
 *  be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_ACCEPT_ISOC_SPLIT_DATA1_DIS    (BIT(4))
#define USB_OTGHS_GSTARFXDIS_ACCEPT_ISOC_SPLIT_DATA1_DIS_M  (USB_OTGHS_GSTARFXDIS_ACCEPT_ISOC_SPLIT_DATA1_DIS_V << USB_OTGHS_GSTARFXDIS_ACCEPT_ISOC_SPLIT_DATA1_DIS_S)
#define USB_OTGHS_GSTARFXDIS_ACCEPT_ISOC_SPLIT_DATA1_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_ACCEPT_ISOC_SPLIT_DATA1_DIS_S  4
/** USB_OTGHS_GSTARFXDIS_HANDLEFAULTYCABLE_DIS : R/W; bitpos: [5]; default: 0;
 *  Disable the STAR fix added for Host controller to handle Faulty cable scenarios
 *  The application programs HandleFaultyCable_dis=1 to disable the host controller
 *  from reporting Port Babble error when the linestate is stuck at 1 (in FS mode) or 2
 *  (in LS mode) due to a Faulty cable. This bit must be programmed during the initial
 *  configuration of the controller and must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_HANDLEFAULTYCABLE_DIS    (BIT(5))
#define USB_OTGHS_GSTARFXDIS_HANDLEFAULTYCABLE_DIS_M  (USB_OTGHS_GSTARFXDIS_HANDLEFAULTYCABLE_DIS_V << USB_OTGHS_GSTARFXDIS_HANDLEFAULTYCABLE_DIS_S)
#define USB_OTGHS_GSTARFXDIS_HANDLEFAULTYCABLE_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_HANDLEFAULTYCABLE_DIS_S  5
/** USB_OTGHS_GSTARFXDIS_LS_IPG_INCR_DIS : R/W; bitpos: [6]; default: 0;
 *  Disable the STAR fix added for Host controller LS mode IPG increment from 2 LS bit
 *  times to 3 LS bit times
 *  The application programs LS_IPG_incr_dis=1 to disable the IPG increment from 2 to 3
 *  LS bit times when host controller is operating in LS mode. This bit must be
 *  programmed during the initial configuration of the controller and must not be
 *  modified later.
 */
#define USB_OTGHS_GSTARFXDIS_LS_IPG_INCR_DIS    (BIT(6))
#define USB_OTGHS_GSTARFXDIS_LS_IPG_INCR_DIS_M  (USB_OTGHS_GSTARFXDIS_LS_IPG_INCR_DIS_V << USB_OTGHS_GSTARFXDIS_LS_IPG_INCR_DIS_S)
#define USB_OTGHS_GSTARFXDIS_LS_IPG_INCR_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_LS_IPG_INCR_DIS_S  6
/** USB_OTGHS_GSTARFXDIS_FSDISC_IDLE_DIS : R/W; bitpos: [7]; default: 0;
 *  Disable the STAR fix added for Device controller to transition to IDLE state during
 *  FS device disconnect
 *  The application programs FSDisc_Idle_dis=1 to disable the Transmit/Receive state
 *  machine from moving to IDLE state when FS device disconnect happens. This bit must
 *  be programmed during the initial configuration of the controller and must not be
 *  modified later.
 */
#define USB_OTGHS_GSTARFXDIS_FSDISC_IDLE_DIS    (BIT(7))
#define USB_OTGHS_GSTARFXDIS_FSDISC_IDLE_DIS_M  (USB_OTGHS_GSTARFXDIS_FSDISC_IDLE_DIS_V << USB_OTGHS_GSTARFXDIS_FSDISC_IDLE_DIS_S)
#define USB_OTGHS_GSTARFXDIS_FSDISC_IDLE_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_FSDISC_IDLE_DIS_S  7
/** USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_DIS : R/W; bitpos: [8]; default:
 *  0;
 *  Disable the STAR fix added for Device controller to not start Remote Wakeup
 *  signalling when USB resume has already started
 *  The application programs Concurrent_Rmtwkup_USBResume_dis=1 to allow the controller
 *  to do remote wakeup signalling when USB resume has already started from the Host.
 *  This bit must be programmed during the initial configuration of the controller and
 *  must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_DIS    (BIT(8))
#define USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_DIS_M  (USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_DIS_V << USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_DIS_S)
#define USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_DIS_S  8
/** USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_HIB_DIS : R/W; bitpos: [9];
 *  default: 1;
 *  Disable the STAR fix added for Device controller to not hang when Remote Wakeup
 *  signalling clashes with Host resume
 *  The application can program Concurrent_Rmtwkup_USBResume_Hib_dis=1 to disable the
 *  fix.
 *  Note: With Concurrent_Rmtwkup_USBResume_Hib_dis=0, the STAR fix is enabled and the
 *  device controller does not hang when the remote wakeup clashes with host resume.
 *  After the remote wakeup programming is done, if there was no utmi_txready received
 *  from the PHY while the utmi_txvalid was asserted, then the controller detects the
 *  line K as the host resume and directly moves to the RESUMING state, along with
 *  de-asserting utmi_txvalid. This prevents the controller from hanging but also
 *  violates the UTMI spec requirement which states that utmi_txvalid must be
 *  de-asserted only after getting utmi_txready. Hence, if any misbehaviour is observed
 *  with this fix enabled, it is recommended to keep the fix disabled.
 *  This bit must be programmed during the initial configuration of the controller and
 *  must not be modified later. The fix is applicable only for Hibernation case.
 */
#define USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_HIB_DIS    (BIT(9))
#define USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_HIB_DIS_M  (USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_HIB_DIS_V << USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_HIB_DIS_S)
#define USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_HIB_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_CONCURRENT_RMTWKUP_USBRESUME_HIB_DIS_S  9
/** USB_OTGHS_GSTARFXDIS_LS_IPG_CHK_AFTER_NAK_STALL_FOR_IN_DIS : R/W; bitpos: [10];
 *  default: 0;
 *  Disable the STAR fix added for Host controller to wait for IPG duration to send
 *  next token after receiving NAK/STALL for previous IN token with FS/LS device
 *  The application programs LS_IPG_chk_after_NAK_STALL_for_IN_dis=1 to allow the
 *  controller to send the next token without waiting for the interpacket gap duration
 *  after receiving a NAK/STALL from device for the previous IN token. This bit must be
 *  programmed during the initial configuration of the controller and must not be
 *  modified later.
 */
#define USB_OTGHS_GSTARFXDIS_LS_IPG_CHK_AFTER_NAK_STALL_FOR_IN_DIS    (BIT(10))
#define USB_OTGHS_GSTARFXDIS_LS_IPG_CHK_AFTER_NAK_STALL_FOR_IN_DIS_M  (USB_OTGHS_GSTARFXDIS_LS_IPG_CHK_AFTER_NAK_STALL_FOR_IN_DIS_V << USB_OTGHS_GSTARFXDIS_LS_IPG_CHK_AFTER_NAK_STALL_FOR_IN_DIS_S)
#define USB_OTGHS_GSTARFXDIS_LS_IPG_CHK_AFTER_NAK_STALL_FOR_IN_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_LS_IPG_CHK_AFTER_NAK_STALL_FOR_IN_DIS_S  10
/** USB_OTGHS_GSTARFXDIS_PHY_IOP_XCVRSEL_TXVLD_CORR_DIS : R/W; bitpos: [11]; default: 0;
 *  Disable the STAR fix added for Host controller to increase the gap between
 *  utmi_xcvrselect switching and utmi_txvalid assertion in LS/FS mode
 *  The application programs PHY_IOp_xcvrsel_txvld_corr_dis=1 to allow the controller
 *  to assert utmi_txvalid 1 cycle after the utmi_xcvrselect switching. This can cause
 *  interop issues with SNPS PHY which requires at least 2 cycles of gap between the
 *  utmi_xcvrselect switch and the utmi_txvalid assertion. Hence it is recommended to
 *  program PHY_IOp_xcvrsel_txvld_corr_dis=0.
 *  This bit must be programmed during the initial configuration of the controller and
 *  must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_PHY_IOP_XCVRSEL_TXVLD_CORR_DIS    (BIT(11))
#define USB_OTGHS_GSTARFXDIS_PHY_IOP_XCVRSEL_TXVLD_CORR_DIS_M  (USB_OTGHS_GSTARFXDIS_PHY_IOP_XCVRSEL_TXVLD_CORR_DIS_V << USB_OTGHS_GSTARFXDIS_PHY_IOP_XCVRSEL_TXVLD_CORR_DIS_S)
#define USB_OTGHS_GSTARFXDIS_PHY_IOP_XCVRSEL_TXVLD_CORR_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_PHY_IOP_XCVRSEL_TXVLD_CORR_DIS_S  11
/** USB_OTGHS_GSTARFXDIS_ULPI_XCVRSEL_SWITCH_CORR_DIS : R/W; bitpos: [12]; default: 0;
 *  Disable the STAR fix added for Host controller to increase the preamble transceiver
 *  select switch delay to accommodate time taken for ULPI function control write
 *  The application programs ULPI_xcvrsel_switch_corr_dis=1 to allow the controller to
 *  do back to back transceiver select switching within the duration required for a
 *  single ULPI function control write (around 5-6 ulpi_clk cycles). This can cause a
 *  corrupted packet to go on the bus since the ULPI wrapper may not be able to do the
 *  second ULPI functional update (register write) correctly. Hence it is recommended
 *  to program ULPI_xcvrsel_switch_corr_dis=0.
 *  With ULPI_xcvrsel_switch_corr_dis=0, the delay between transceiver select switch
 *  and txvalid assertion has also been increased for FS/LS mode to resolve PHY interop
 *  issues.
 *  This bit must be programmed during the initial configuration of the controller and
 *  must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_ULPI_XCVRSEL_SWITCH_CORR_DIS    (BIT(12))
#define USB_OTGHS_GSTARFXDIS_ULPI_XCVRSEL_SWITCH_CORR_DIS_M  (USB_OTGHS_GSTARFXDIS_ULPI_XCVRSEL_SWITCH_CORR_DIS_V << USB_OTGHS_GSTARFXDIS_ULPI_XCVRSEL_SWITCH_CORR_DIS_S)
#define USB_OTGHS_GSTARFXDIS_ULPI_XCVRSEL_SWITCH_CORR_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_ULPI_XCVRSEL_SWITCH_CORR_DIS_S  12
/** USB_OTGHS_GSTARFXDIS_XACTERR_DATA0_CTRL_STS_IN_DIS : R/W; bitpos: [13]; default: 1;
 *  Disable the STAR fix added for Host controller to report transaction error when
 *  DATA0 PID is received for CTRL STATUS IN transfer in DMA mode
 *  The application programs XactErr_DATA0_CTRL_STS_IN_dis=1 to allow the controller to
 *  respond with ACK for the incorrect DATA0 PID and then retry the control STATUS IN
 *  transfer until DATA1 PID is received. With XactErr_DATA0_CTRL_STS_IN_dis=0, the
 *  controller generates Transaction Error interrupt when the incorrect PID is
 *  received. This STAR fix is applicable only for Buffer DMA and Descriptor DMA modes.
 *  This bit must be programmed during the initial configuration of the controller and
 *  must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_XACTERR_DATA0_CTRL_STS_IN_DIS    (BIT(13))
#define USB_OTGHS_GSTARFXDIS_XACTERR_DATA0_CTRL_STS_IN_DIS_M  (USB_OTGHS_GSTARFXDIS_XACTERR_DATA0_CTRL_STS_IN_DIS_V << USB_OTGHS_GSTARFXDIS_XACTERR_DATA0_CTRL_STS_IN_DIS_S)
#define USB_OTGHS_GSTARFXDIS_XACTERR_DATA0_CTRL_STS_IN_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_XACTERR_DATA0_CTRL_STS_IN_DIS_S  13
/** USB_OTGHS_GSTARFXDIS_HOST_XCVRSEL_RESETAFTRSUSP_CORR_DIS : R/W; bitpos: [15];
 *  default: 0;
 *  Disable the STAR fix added for correcting XcvrSel on UTMI Interface in host mode.
 *  When host controller drives reset in power down suspend state, the behavior of
 *  XcvrSel has been corrected to drive the valid combination of XcvrSel (HS_XCVR) and
 *  TermSel (HS_TERM) on the UTMI interface.
 *  The application can set this register bit to 1'b1 to fall back to the original
 *  behavior of the Host controller driving XcvrSel (FS_XCVR) and TermSel (HS_TERM)
 *  when reset is driven to exit from power down state.
 *  This bit must be programmed during the initial configuration of the controller and
 *  must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_HOST_XCVRSEL_RESETAFTRSUSP_CORR_DIS    (BIT(15))
#define USB_OTGHS_GSTARFXDIS_HOST_XCVRSEL_RESETAFTRSUSP_CORR_DIS_M  (USB_OTGHS_GSTARFXDIS_HOST_XCVRSEL_RESETAFTRSUSP_CORR_DIS_V << USB_OTGHS_GSTARFXDIS_HOST_XCVRSEL_RESETAFTRSUSP_CORR_DIS_S)
#define USB_OTGHS_GSTARFXDIS_HOST_XCVRSEL_RESETAFTRSUSP_CORR_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_HOST_XCVRSEL_RESETAFTRSUSP_CORR_DIS_S  15
/** USB_OTGHS_GSTARFXDIS_HOST_UTMI_TXVLD_CORR_DIS : R/W; bitpos: [16]; default: 0;
 *  Disable the correction to OpMode/XcvrSel/TermSel on UTMI Interface in Host mode.
 *  When HPRT.PrtRst is set by the application, the Host controller can change the
 *  Opmode, XcvrSel and TermSel while TxValid is still high (1'b1) during SOF
 *  transmission in 8-bit UTMI mode. This behavior of the controller has been corrected
 *  to handle port reset during SOF transmission. With the fix, the controller waits
 *  for Txvalid to go low (1'b0) and then changes the OpMode, XcvrSel and TermSel.
 *  The application can set this register bit to 1'b1 to fall back to the original
 *  behavior of the controller.
 *  This bit must be programmed during the initial configuration of the controller and
 *  must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_HOST_UTMI_TXVLD_CORR_DIS    (BIT(16))
#define USB_OTGHS_GSTARFXDIS_HOST_UTMI_TXVLD_CORR_DIS_M  (USB_OTGHS_GSTARFXDIS_HOST_UTMI_TXVLD_CORR_DIS_V << USB_OTGHS_GSTARFXDIS_HOST_UTMI_TXVLD_CORR_DIS_S)
#define USB_OTGHS_GSTARFXDIS_HOST_UTMI_TXVLD_CORR_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_HOST_UTMI_TXVLD_CORR_DIS_S  16
/** USB_OTGHS_GSTARFXDIS_OPMODE_XCVRSEL_CHIRPEN_CORR_DIS : R/W; bitpos: [17]; default:
 *  0;
 *  Disable the STAR fix added for correcting Opmode and XcvrSel on UTMI Interface when
 *  reset is detected in suspend state.
 *  In configurations with Battery charger support enabled (and GOTGCTL.ChirpEn
 *  programmed to 1), the RTL has been updated to wait for 1ms and then change the
 *  opmode and xcvrselect when reset is detected in the suspend state.
 *  The application can set this register bit to 1'b1 to fall back to the original
 *  behavior of the controller and change Opmode and XcvrSel without waiting for 1ms
 *  after reset detection.
 *  This bit must be programmed during the initial configuration of the controller and
 *  must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_OPMODE_XCVRSEL_CHIRPEN_CORR_DIS    (BIT(17))
#define USB_OTGHS_GSTARFXDIS_OPMODE_XCVRSEL_CHIRPEN_CORR_DIS_M  (USB_OTGHS_GSTARFXDIS_OPMODE_XCVRSEL_CHIRPEN_CORR_DIS_V << USB_OTGHS_GSTARFXDIS_OPMODE_XCVRSEL_CHIRPEN_CORR_DIS_S)
#define USB_OTGHS_GSTARFXDIS_OPMODE_XCVRSEL_CHIRPEN_CORR_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_OPMODE_XCVRSEL_CHIRPEN_CORR_DIS_S  17
/** USB_OTGHS_GSTARFXDIS_TXVALID_DEASSERTION_CORR_DIS : R/W; bitpos: [18]; default: 0;
 *  Disable the STAR fix added for correcting Txvalid deassertion on UTMI Interface
 *  when soft disconnect is done.
 *  The RTL has been updated to wait for utmi_txready and then de-assert the
 *  utmi_txvalid being driven by MAC DSSR when soft disconnect is done.
 *  The application can set this register bit to 1'b1 to fall back to the original
 *  behavior of the controller and change Txvalid without waiting for Txready.
 *  This bit must be programmed during the initial configuration of the controller and
 *  must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_TXVALID_DEASSERTION_CORR_DIS    (BIT(18))
#define USB_OTGHS_GSTARFXDIS_TXVALID_DEASSERTION_CORR_DIS_M  (USB_OTGHS_GSTARFXDIS_TXVALID_DEASSERTION_CORR_DIS_V << USB_OTGHS_GSTARFXDIS_TXVALID_DEASSERTION_CORR_DIS_S)
#define USB_OTGHS_GSTARFXDIS_TXVALID_DEASSERTION_CORR_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_TXVALID_DEASSERTION_CORR_DIS_S  18
/** USB_OTGHS_GSTARFXDIS_HOST_NO_XFER_AFTER_PRTDIS_FIX_DIS : R/W; bitpos: [19];
 *  default: 0;
 *  Disable the STAR fix added for correcting Host behavior when port is disabled.
 *  The RTL has been updated to not assert utmi_txvalid when the port is disabled.
 *  The application can set this register bit to 1'b1 to fall back to the original
 *  behavior of the controller.
 *  This bit must be programmed during the initial configuration of the controller and
 *  must not be modified later.
 */
#define USB_OTGHS_GSTARFXDIS_HOST_NO_XFER_AFTER_PRTDIS_FIX_DIS    (BIT(19))
#define USB_OTGHS_GSTARFXDIS_HOST_NO_XFER_AFTER_PRTDIS_FIX_DIS_M  (USB_OTGHS_GSTARFXDIS_HOST_NO_XFER_AFTER_PRTDIS_FIX_DIS_V << USB_OTGHS_GSTARFXDIS_HOST_NO_XFER_AFTER_PRTDIS_FIX_DIS_S)
#define USB_OTGHS_GSTARFXDIS_HOST_NO_XFER_AFTER_PRTDIS_FIX_DIS_V  0x00000001U
#define USB_OTGHS_GSTARFXDIS_HOST_NO_XFER_AFTER_PRTDIS_FIX_DIS_S  19
/** USB_OTGHS_GSTARFXDIS_RESERVED : RO; bitpos: [31:21]; default: 0;
 *  RESERVED
 */
#define USB_OTGHS_GSTARFXDIS_RESERVED    0x000007FFU
#define USB_OTGHS_GSTARFXDIS_RESERVED_M  (USB_OTGHS_GSTARFXDIS_RESERVED_V << USB_OTGHS_GSTARFXDIS_RESERVED_S)
#define USB_OTGHS_GSTARFXDIS_RESERVED_V  0x000007FFU
#define USB_OTGHS_GSTARFXDIS_RESERVED_S  21

#ifdef __cplusplus
}
#endif
