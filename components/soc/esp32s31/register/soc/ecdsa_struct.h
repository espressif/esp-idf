/**
 * SPDX-FileCopyrightText: 2025 Espressif Systems (Shanghai) CO LTD
 *
 *  SPDX-License-Identifier: Apache-2.0 OR MIT
 */
#pragma once

#include <stdint.h>
#ifdef __cplusplus
extern "C" {
#endif

/** Group: Data Memory */

/** Group: Configuration registers */
/** Type of conf register
 *  ECDSA configure register
 */
typedef union {
    struct {
        /** work_mode : R/W; bitpos: [1:0]; default: 0;
         *  The work mode bits of ECDSA Accelerator. 0: Signature Verify Mode. 1: Signature
         *  Generate Mode. 2: Export Public Key Mode. 3: invalid.
         */
        uint32_t work_mode:2;
        /** ecc_curve : R/W; bitpos: [3:2]; default: 0;
         *  The ecc curve select bit of ECDSA Accelerator.  0: P-192. 1: P-256. 2: P-384 3: SM2.
         */
        uint32_t ecc_curve:2;
        /** software_set_k : R/W; bitpos: [4]; default: 0;
         *  The source of k select bit. 0: k is automatically generated by hardware. 1: k is
         *  written by software.
         */
        uint32_t software_set_k:1;
        /** software_set_z : R/W; bitpos: [5]; default: 0;
         *  The source of z select bit. 0: z is generated from SHA result. 1: z is written by
         *  software.
         */
        uint32_t software_set_z:1;
        /** deterministic_k : R/W; bitpos: [6]; default: 0;
         *  The source of hardware generated k. 0: k is generated by TRNG. 1: k is generated by
         *  deterministic derivation algorithm.
         */
        uint32_t deterministic_k:1;
        /** use_hardware_key : R/W; bitpos: [7]; default: 0;
         *  Configures the ECDSA use software key or hardware key.
         *  0: Software key.
         *  1: Hardware key.
         */
        uint32_t use_hardware_key:1;
        uint32_t reserved_8:24;
    };
    uint32_t val;
} ecdsa_conf_reg_t;

/** Type of start register
 *  ECDSA start register
 */
typedef union {
    struct {
        /** start : WT; bitpos: [0]; default: 0;
         *  Write 1 to start calculation of ECDSA Accelerator. This bit will be self-cleared
         *  after configuration.
         */
        uint32_t start:1;
        /** load_done : WT; bitpos: [1]; default: 0;
         *  Write 1 to input load done signal of ECDSA Accelerator. This bit will be
         *  self-cleared after configuration.
         */
        uint32_t load_done:1;
        /** get_done : WT; bitpos: [2]; default: 0;
         *  Write 1 to input get done signal of ECDSA Accelerator. This bit will be
         *  self-cleared after configuration.
         */
        uint32_t get_done:1;
        uint32_t reserved_3:29;
    };
    uint32_t val;
} ecdsa_start_reg_t;

/** Type of timeout_limit register
 *  ECDSA timeout limit configure register
 */
typedef union {
    struct {
        /** timeout_limit : R/W; bitpos: [31:0]; default: 4294967295;
         *  The timeout limitation for waiting sub-IP.
         */
        uint32_t timeout_limit:32;
    };
    uint32_t val;
} ecdsa_timeout_limit_reg_t;


/** Group: Clock and reset registers */
/** Type of clk register
 *  ECDSA clock gate register
 */
typedef union {
    struct {
        /** clk_gate_force_on : R/W; bitpos: [0]; default: 0;
         *  Write 1 to force on register clock gate.
         */
        uint32_t clk_gate_force_on:1;
        uint32_t reserved_1:31;
    };
    uint32_t val;
} ecdsa_clk_reg_t;


/** Group: Interrupt registers */
/** Type of int_raw register
 *  ECDSA interrupt raw register, valid in level.
 */
typedef union {
    struct {
        /** prep_done_int_raw : RO/WTC/SS; bitpos: [0]; default: 0;
         *  The raw interrupt status bit  for the ecdsa_prep_done_int interrupt
         */
        uint32_t prep_done_int_raw:1;
        /** proc_done_int_raw : RO/WTC/SS; bitpos: [1]; default: 0;
         *  The raw interrupt status bit  for the ecdsa_proc_done_int interrupt
         */
        uint32_t proc_done_int_raw:1;
        /** post_done_int_raw : RO/WTC/SS; bitpos: [2]; default: 0;
         *  The raw interrupt status bit  for the ecdsa_post_done_int interrupt
         */
        uint32_t post_done_int_raw:1;
        /** sha_release_int_raw : RO/WTC/SS; bitpos: [3]; default: 0;
         *  The raw interrupt status bit  for the ecdsa_sha_release_int interrupt
         */
        uint32_t sha_release_int_raw:1;
        uint32_t reserved_4:28;
    };
    uint32_t val;
} ecdsa_int_raw_reg_t;

/** Type of int_st register
 *  ECDSA interrupt status register.
 */
typedef union {
    struct {
        /** prep_done_int_st : RO; bitpos: [0]; default: 0;
         *  The masked interrupt status bit  for the ecdsa_prep_done_int interrupt
         */
        uint32_t prep_done_int_st:1;
        /** proc_done_int_st : RO; bitpos: [1]; default: 0;
         *  The masked interrupt status bit  for the ecdsa_proc_done_int interrupt
         */
        uint32_t proc_done_int_st:1;
        /** post_done_int_st : RO; bitpos: [2]; default: 0;
         *  The masked interrupt status bit  for the ecdsa_post_done_int interrupt
         */
        uint32_t post_done_int_st:1;
        /** sha_release_int_st : RO; bitpos: [3]; default: 0;
         *  The masked interrupt status bit  for the ecdsa_sha_release_int interrupt
         */
        uint32_t sha_release_int_st:1;
        uint32_t reserved_4:28;
    };
    uint32_t val;
} ecdsa_int_st_reg_t;

/** Type of int_ena register
 *  ECDSA interrupt enable register.
 */
typedef union {
    struct {
        /** prep_done_int_ena : R/W; bitpos: [0]; default: 0;
         *  The interrupt enable bit  for the ecdsa_prep_done_int interrupt
         */
        uint32_t prep_done_int_ena:1;
        /** proc_done_int_ena : R/W; bitpos: [1]; default: 0;
         *  The interrupt enable bit  for the ecdsa_proc_done_int interrupt
         */
        uint32_t proc_done_int_ena:1;
        /** post_done_int_ena : R/W; bitpos: [2]; default: 0;
         *  The interrupt enable bit  for the ecdsa_post_done_int interrupt
         */
        uint32_t post_done_int_ena:1;
        /** sha_release_int_ena : R/W; bitpos: [3]; default: 0;
         *  The interrupt enable bit  for the ecdsa_sha_release_int interrupt
         */
        uint32_t sha_release_int_ena:1;
        uint32_t reserved_4:28;
    };
    uint32_t val;
} ecdsa_int_ena_reg_t;

/** Type of int_clr register
 *  ECDSA interrupt clear register.
 */
typedef union {
    struct {
        /** prep_done_int_clr : WT; bitpos: [0]; default: 0;
         *  Set this bit to clear the ecdsa_prep_done_int interrupt
         */
        uint32_t prep_done_int_clr:1;
        /** proc_done_int_clr : WT; bitpos: [1]; default: 0;
         *  Set this bit to clear the ecdsa_proc_done_int interrupt
         */
        uint32_t proc_done_int_clr:1;
        /** post_done_int_clr : WT; bitpos: [2]; default: 0;
         *  Set this bit to clear the ecdsa_post_done_int interrupt
         */
        uint32_t post_done_int_clr:1;
        /** sha_release_int_clr : WT; bitpos: [3]; default: 0;
         *  Set this bit to clear the ecdsa_sha_release_int interrupt
         */
        uint32_t sha_release_int_clr:1;
        uint32_t reserved_4:28;
    };
    uint32_t val;
} ecdsa_int_clr_reg_t;


/** Group: Status registers */
/** Type of state register
 *  ECDSA status register
 */
typedef union {
    struct {
        /** busy : RO; bitpos: [1:0]; default: 0;
         *  The status bits of ECDSA Accelerator. ECDSA is at 0: IDLE, 1: LOAD, 2: GET, 3: BUSY
         *  state.
         */
        uint32_t busy:2;
        uint32_t reserved_2:30;
    };
    uint32_t val;
} ecdsa_state_reg_t;


/** Group: Result registers */
/** Type of result register
 *  ECDSA result register
 */
typedef union {
    struct {
        /** operation_result : RO/SS; bitpos: [0]; default: 0;
         *  The operation result bit of ECDSA Accelerator, only valid when ECDSA calculation is
         *  done.
         */
        uint32_t operation_result:1;
        uint32_t reserved_1:31;
    };
    uint32_t val;
} ecdsa_result_reg_t;


/** Group: Status Register */
/** Type of free register
 *  ECDSA free state
 */
typedef union {
    struct {
        /** free : R/W; bitpos: [0]; default: 1;
         *  Represents if ECDSA Accelerator is free or not.
         *  0: non-free
         *  1: free
         */
        uint32_t free:1;
        uint32_t reserved_1:31;
    };
    uint32_t val;
} ecdsa_free_reg_t;


/** Group: Key Registers */
/** Type of key_0 register
 *  ECDSA key data register 0
 */
typedef union {
    struct {
        /** key_0 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_0 that is a part of key material.
         */
        uint32_t key_0:32;
    };
    uint32_t val;
} ecdsa_key_0_reg_t;

/** Type of key_1 register
 *  ECDSA key data register 1
 */
typedef union {
    struct {
        /** key_1 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_1 that is a part of key material.
         */
        uint32_t key_1:32;
    };
    uint32_t val;
} ecdsa_key_1_reg_t;

/** Type of key_2 register
 *  ECDSA key data register 2
 */
typedef union {
    struct {
        /** key_2 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_2 that is a part of key material.
         */
        uint32_t key_2:32;
    };
    uint32_t val;
} ecdsa_key_2_reg_t;

/** Type of key_3 register
 *  ECDSA key data register 3
 */
typedef union {
    struct {
        /** key_3 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_3 that is a part of key material.
         */
        uint32_t key_3:32;
    };
    uint32_t val;
} ecdsa_key_3_reg_t;

/** Type of key_4 register
 *  ECDSA key data register 4
 */
typedef union {
    struct {
        /** key_4 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_4 that is a part of key material.
         */
        uint32_t key_4:32;
    };
    uint32_t val;
} ecdsa_key_4_reg_t;

/** Type of key_5 register
 *  ECDSA key data register 5
 */
typedef union {
    struct {
        /** key_5 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_5 that is a part of key material.
         */
        uint32_t key_5:32;
    };
    uint32_t val;
} ecdsa_key_5_reg_t;

/** Type of key_6 register
 *  ECDSA key data register 6
 */
typedef union {
    struct {
        /** key_6 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_6 that is a part of key material.
         */
        uint32_t key_6:32;
    };
    uint32_t val;
} ecdsa_key_6_reg_t;

/** Type of key_7 register
 *  ECDSA key data register 7
 */
typedef union {
    struct {
        /** key_7 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_7 that is a part of key material.
         */
        uint32_t key_7:32;
    };
    uint32_t val;
} ecdsa_key_7_reg_t;

/** Type of key_8 register
 *  ECDSA key data register 8
 */
typedef union {
    struct {
        /** key_8 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_8 that is a part of key material.
         */
        uint32_t key_8:32;
    };
    uint32_t val;
} ecdsa_key_8_reg_t;

/** Type of key_9 register
 *  ECDSA key data register 9
 */
typedef union {
    struct {
        /** key_9 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_9 that is a part of key material.
         */
        uint32_t key_9:32;
    };
    uint32_t val;
} ecdsa_key_9_reg_t;

/** Type of key_10 register
 *  ECDSA key data register 10
 */
typedef union {
    struct {
        /** key_10 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_10 that is a part of key material.
         */
        uint32_t key_10:32;
    };
    uint32_t val;
} ecdsa_key_10_reg_t;

/** Type of key_11 register
 *  ECDSA key data register 11
 */
typedef union {
    struct {
        /** key_11 : R/W; bitpos: [31:0]; default: 0;
         *  These bits stores key_11 that is a part of key material.
         */
        uint32_t key_11:32;
    };
    uint32_t val;
} ecdsa_key_11_reg_t;


/** Group: SHA register */
/** Type of sha_mode register
 *  ECDSA control SHA register
 */
typedef union {
    struct {
        /** sha_mode : R/W; bitpos: [3:0]; default: 0;
         *  The work mode bits of SHA Calculator in ECDSA Accelerator. 0: SHA1. 1: SHA-224. 2:
         *  SHA-256. 3: SHA-384 4: SHA-512. 5: SHA-512224. 6: SHA-512256. 14:SM3. Others:
         *  invalid.
         */
        uint32_t sha_mode:4;
        uint32_t reserved_4:28;
    };
    uint32_t val;
} ecdsa_sha_mode_reg_t;

/** Type of sha_start register
 *  ECDSA control SHA register
 */
typedef union {
    struct {
        /** sha_start : WT; bitpos: [0]; default: 0;
         *  Write 1 to start the first calculation of SHA Calculator in ECDSA Accelerator. This
         *  bit will be self-cleared after configuration.
         */
        uint32_t sha_start:1;
        uint32_t reserved_1:31;
    };
    uint32_t val;
} ecdsa_sha_start_reg_t;

/** Type of sha_continue register
 *  ECDSA control SHA register
 */
typedef union {
    struct {
        /** sha_continue : WT; bitpos: [0]; default: 0;
         *  Write 1 to start the latter calculation of SHA Calculator in ECDSA Accelerator. This
         *  bit will be self-cleared after configuration.
         */
        uint32_t sha_continue:1;
        uint32_t reserved_1:31;
    };
    uint32_t val;
} ecdsa_sha_continue_reg_t;

/** Type of sha_busy register
 *  ECDSA status register
 */
typedef union {
    struct {
        /** sha_busy : RO; bitpos: [0]; default: 0;
         *  The busy status bit of SHA Calculator in ECDSA Accelerator. 1:SHA is in
         *  calculation. 0: SHA is idle.
         */
        uint32_t sha_busy:1;
        uint32_t reserved_1:31;
    };
    uint32_t val;
} ecdsa_sha_busy_reg_t;


/** Group: Version register */
/** Type of date register
 *  Version control register
 */
typedef union {
    struct {
        /** date : R/W; bitpos: [27:0]; default: 38830480;
         *  ECDSA version control register
         */
        uint32_t date:28;
        uint32_t reserved_28:4;
    };
    uint32_t val;
} ecdsa_date_reg_t;


typedef struct {
    uint32_t reserved_000;
    volatile ecdsa_conf_reg_t conf;
    volatile ecdsa_clk_reg_t clk;
    volatile ecdsa_int_raw_reg_t int_raw;
    volatile ecdsa_int_st_reg_t int_st;
    volatile ecdsa_int_ena_reg_t int_ena;
    volatile ecdsa_int_clr_reg_t int_clr;
    volatile ecdsa_start_reg_t start;
    volatile ecdsa_state_reg_t state;
    volatile ecdsa_result_reg_t result;
    volatile ecdsa_timeout_limit_reg_t timeout_limit;
    volatile ecdsa_free_reg_t free;
    uint32_t reserved_030[4];
    volatile ecdsa_key_0_reg_t key_0;
    volatile ecdsa_key_1_reg_t key_1;
    volatile ecdsa_key_2_reg_t key_2;
    volatile ecdsa_key_3_reg_t key_3;
    volatile ecdsa_key_4_reg_t key_4;
    volatile ecdsa_key_5_reg_t key_5;
    volatile ecdsa_key_6_reg_t key_6;
    volatile ecdsa_key_7_reg_t key_7;
    volatile ecdsa_key_8_reg_t key_8;
    volatile ecdsa_key_9_reg_t key_9;
    volatile ecdsa_key_10_reg_t key_10;
    volatile ecdsa_key_11_reg_t key_11;
    uint32_t reserved_070[35];
    volatile ecdsa_date_reg_t date;
    uint32_t reserved_100[64];
    volatile ecdsa_sha_mode_reg_t sha_mode;
    uint32_t reserved_204[3];
    volatile ecdsa_sha_start_reg_t sha_start;
    volatile ecdsa_sha_continue_reg_t sha_continue;
    volatile ecdsa_sha_busy_reg_t sha_busy;
    uint32_t reserved_21c[25];
    volatile uint32_t message[16];
    uint32_t reserved_2c0[72];
    volatile uint32_t r[12];
    volatile uint32_t s[12];
    volatile uint32_t z[12];
    volatile uint32_t qax[12];
    volatile uint32_t qay[12];
} ecdsa_dev_t;


#ifndef __cplusplus
_Static_assert(sizeof(ecdsa_dev_t) == 0x4d0, "Invalid size of ecdsa_dev_t structure");
#endif

#ifdef __cplusplus
}
#endif
