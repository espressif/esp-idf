menu "ESP32C3-Specific"
    visible if IDF_TARGET_ESP32C3

    choice ESP32C3_DEFAULT_CPU_FREQ_MHZ
        prompt "CPU frequency"
        default ESP32C3_DEFAULT_CPU_FREQ_40 if IDF_ENV_FPGA
        default ESP32C3_DEFAULT_CPU_FREQ_160 if !IDF_ENV_FPGA
        help
            CPU frequency to be set on application startup.

        config ESP32C3_DEFAULT_CPU_FREQ_40
            bool "40 MHz"
            depends on IDF_ENV_FPGA
        config ESP32C3_DEFAULT_CPU_FREQ_80
            bool "80 MHz"
        config ESP32C3_DEFAULT_CPU_FREQ_160
            bool "160 MHz"
    endchoice

    config ESP32C3_DEFAULT_CPU_FREQ_MHZ
        int
        default 40 if ESP32C3_DEFAULT_CPU_FREQ_40
        default 80 if ESP32C3_DEFAULT_CPU_FREQ_80
        default 160 if ESP32C3_DEFAULT_CPU_FREQ_160

    choice ESP32C3_UNIVERSAL_MAC_ADDRESSES
        bool "Number of universally administered (by IEEE) MAC address"
        default ESP32C3_UNIVERSAL_MAC_ADDRESSES_TWO
        help
            Configure the number of universally administered (by IEEE) MAC addresses.
            During initialization, MAC addresses for each network interface are generated or derived from a
            single base MAC address.
            If the number of universal MAC addresses is Two, all interfaces (WiFi station, WiFi softap) receive a
            universally administered MAC address. They are generated sequentially by adding 0, and 1 (respectively)
            to the final octet of the base MAC address. If the number of universal MAC addresses is one,
            only WiFi station receives a universally administered MAC address.
            It's generated by adding 0 to the base MAC address.
            The WiFi softap receives local MAC addresses. It's derived from the universal WiFi station MAC addresses.
            When using the default (Espressif-assigned) base MAC address, either setting can be used. When using
            a custom universal MAC address range, the correct setting will depend on the allocation of MAC
            addresses in this range (either 1 or 2 per device.)

        config ESP32C3_UNIVERSAL_MAC_ADDRESSES_TWO
            bool "Two"
            select ESP_MAC_ADDR_UNIVERSE_WIFI_STA
            select ESP_MAC_ADDR_UNIVERSE_BT
        config ESP32C3_UNIVERSAL_MAC_ADDRESSES_THREE
            bool "Three"
            select ESP_MAC_ADDR_UNIVERSE_WIFI_STA
            select ESP_MAC_ADDR_UNIVERSE_WIFI_AP
            select ESP_MAC_ADDR_UNIVERSE_BT
    endchoice

    config ESP32C3_UNIVERSAL_MAC_ADDRESSES
        int
        default 2 if ESP32C3_UNIVERSAL_MAC_ADDRESSES_TWO
        default 3 if ESP32C3_UNIVERSAL_MAC_ADDRESSES_THREE

    config ESP_MAC_ADDR_UNIVERSE_BT_OFFSET
        int
        default 2 if ESP32C3_UNIVERSAL_MAC_ADDRESSES_THREE
        default 1 if ESP32C3_UNIVERSAL_MAC_ADDRESSES_TWO

    config ESP32C3_DEBUG_OCDAWARE
        bool "Make exception and panic handlers JTAG/OCD aware"
        default y
        select FREERTOS_DEBUG_OCDAWARE
        help
            The FreeRTOS panic and unhandled exception handers can detect a JTAG OCD debugger and
            instead of panicking, have the debugger stop on the offending instruction.

    config ESP32C3_DEBUG_STUBS_ENABLE
        bool "OpenOCD debug stubs"
        default COMPILER_OPTIMIZATION_LEVEL_DEBUG
        depends on !ESP32C3_TRAX
        help
            Debug stubs are used by OpenOCD to execute pre-compiled onboard code which does some useful debugging,
            e.g. GCOV data dump.

    config ESP32C3_BROWNOUT_DET
        # TODO ESP32-C3 IDF-2397
        bool
        default n
        help
            The ESP32-S3 has a built-in brownout detector which can detect if the voltage is lower than
            a specific value. If this happens, it will reset the chip in order to prevent unintended
            behaviour.

    choice ESP32C3_BROWNOUT_DET_LVL_SEL
        prompt "Brownout voltage level"
        depends on ESP32C3_BROWNOUT_DET
        default ESP32C3_BROWNOUT_DET_LVL_SEL_7
        help
            The brownout detector will reset the chip when the supply voltage is approximately
            below this level. Note that there may be some variation of brownout voltage level
            between each ESP3-S3 chip.

            #The voltage levels here are estimates, more work needs to be done to figure out the exact voltages
            #of the brownout threshold levels.
        config ESP32C3_BROWNOUT_DET_LVL_SEL_7
            bool "2.44V"
        config ESP32C3_BROWNOUT_DET_LVL_SEL_6
            bool "2.56V"
        config ESP32C3_BROWNOUT_DET_LVL_SEL_5
            bool "2.67V"
        config ESP32C3_BROWNOUT_DET_LVL_SEL_4
            bool "2.84V"
        config ESP32C3_BROWNOUT_DET_LVL_SEL_3
            bool "2.98V"
        config ESP32C3_BROWNOUT_DET_LVL_SEL_2
            bool "3.19V"
        config ESP32C3_BROWNOUT_DET_LVL_SEL_1
            bool "3.30V"
    endchoice

    config ESP32C3_BROWNOUT_DET_LVL
        int
        default 1 if ESP32C3_BROWNOUT_DET_LVL_SEL_1
        default 2 if ESP32C3_BROWNOUT_DET_LVL_SEL_2
        default 3 if ESP32C3_BROWNOUT_DET_LVL_SEL_3
        default 4 if ESP32C3_BROWNOUT_DET_LVL_SEL_4
        default 5 if ESP32C3_BROWNOUT_DET_LVL_SEL_5
        default 6 if ESP32C3_BROWNOUT_DET_LVL_SEL_6
        default 7 if ESP32C3_BROWNOUT_DET_LVL_SEL_7

    choice ESP32C3_TIME_SYSCALL
        prompt "Timers used for gettimeofday function"
        default ESP32C3_TIME_SYSCALL_USE_RTC_SYSTIMER
        help
            This setting defines which hardware timers are used to
            implement 'gettimeofday' and 'time' functions in C library.

            - If both high-resolution (systimer) and RTC timers are used, timekeeping will
              continue in deep sleep. Time will be reported at 1 microsecond
              resolution. This is the default, and the recommended option.
            - If only high-resolution timer (systimer) is used, gettimeofday will
              provide time at microsecond resolution.
              Time will not be preserved when going into deep sleep mode.
            - If only RTC timer is used, timekeeping will continue in
              deep sleep, but time will be measured at 6.(6) microsecond
              resolution. Also the gettimeofday function itself may take
              longer to run.
            - If no timers are used, gettimeofday and time functions
              return -1 and set errno to ENOSYS.
            - When RTC is used for timekeeping, two RTC_STORE registers are
              used to keep time in deep sleep mode.

        config ESP32C3_TIME_SYSCALL_USE_RTC_SYSTIMER
            bool "RTC and high-resolution timer"
            select ESP_TIME_FUNCS_USE_RTC_TIMER
            select ESP_TIME_FUNCS_USE_ESP_TIMER
        config ESP32C3_TIME_SYSCALL_USE_RTC
            bool "RTC"
            select ESP_TIME_FUNCS_USE_RTC_TIMER
        config ESP32C3_TIME_SYSCALL_USE_SYSTIMER
            bool "High-resolution timer"
            select ESP_TIME_FUNCS_USE_ESP_TIMER
        config ESP32C3_TIME_SYSCALL_USE_NONE
            bool "None"
            select ESP_TIME_FUNCS_USE_NONE
    endchoice

    choice ESP32C3_RTC_CLK_SRC
        prompt "RTC clock source"
        default ESP32C3_RTC_CLK_SRC_INT_RC
        help
            Choose which clock is used as RTC clock source.

        config ESP32C3_RTC_CLK_SRC_INT_RC
            bool "Internal 150kHz RC oscillator"
        config ESP32C3_RTC_CLK_SRC_EXT_CRYS
            bool "External 32kHz crystal"
            select ESP_SYSTEM_RTC_EXT_XTAL
        config ESP32C3_RTC_CLK_SRC_EXT_OSC
            bool "External 32kHz oscillator at 32K_XP pin"
        config ESP32C3_RTC_CLK_SRC_INT_8MD256
            bool "Internal 8MHz oscillator, divided by 256 (~32kHz)"
    endchoice

    config ESP32C3_RTC_CLK_CAL_CYCLES
        int "Number of cycles for RTC_SLOW_CLK calibration"
        default 3000 if ESP32C3_RTC_CLK_SRC_EXT_CRYS || ESP32C3_RTC_CLK_SRC_EXT_OSC || ESP32C3_RTC_CLK_SRC_INT_8MD256
        default 1024 if ESP32C3_RTC_CLK_SRC_INT_RC
        range 0 125000
        help
            When the startup code initializes RTC_SLOW_CLK, it can perform
            calibration by comparing the RTC_SLOW_CLK frequency with main XTAL
            frequency. This option sets the number of RTC_SLOW_CLK cycles measured
            by the calibration routine. Higher numbers increase calibration
            precision, which may be important for applications which spend a lot of
            time in deep sleep. Lower numbers reduce startup time.

            When this option is set to 0, clock calibration will not be performed at
            startup, and approximate clock frequencies will be assumed:

            - 150000 Hz if internal RC oscillator is used as clock source. For this use value 1024.
            - 32768 Hz if the 32k crystal oscillator is used. For this use value 3000 or more.
              In case more value will help improve the definition of the launch of the crystal.
              If the crystal could not start, it will be switched to internal RC.

    config ESP32C3_NO_BLOBS
        bool "No Binary Blobs"
        depends on !BT_ENABLED
        default n
        help
            If enabled, this disables the linking of binary libraries in the application build. Note
            that after enabling this Wi-Fi/Bluetooth will not work.

    config ESP32C3_ALLOW_RTC_FAST_MEM_AS_HEAP
        bool "Enable RTC fast memory for dynamic allocations"
        depends on !ESP32C3_MEMPROT_FEATURE
        default y
        help
            This config option allows to add RTC fast memory region to system heap with capability
            similar to that of DRAM region but without DMA. This memory will be consumed first per
            heap initialization order by early startup services and scheduler related code. Speed
            wise RTC fast memory operates on APB clock and hence does not have much performance impact.

endmenu  # ESP32C3-Specific
